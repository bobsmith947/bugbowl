{"version":3,"sources":["webpack://orgabowl/webpack/universalModuleDefinition","webpack://orgabowl/../node_modules/source-map-loader/dist/node_modules/@js-joda/core/dist/js-joda.esm.js","webpack://orgabowl/../core/common/src/DateTimePeriod.kt","webpack://orgabowl/./kotlin-dce/text/StringBuilder.kt","webpack://orgabowl/./kotlin-dce/kotlin/text/char.kt","webpack://orgabowl/../core/common/src/DateTimeUnit.kt","webpack://orgabowl/../core/common/src/Instant.kt","webpack://orgabowl/../core/common/src/math.kt","webpack://orgabowl/../core/commonMain/src/kotlinx/serialization/encoding/Decoding.kt","webpack://orgabowl/../core/commonMain/src/kotlinx/serialization/descriptors/SerialDescriptors.kt","webpack://orgabowl/../core/commonMain/src/kotlinx/serialization/Serializers.kt","webpack://orgabowl/../core/commonMain/src/kotlinx/serialization/internal/Platform.common.kt","webpack://orgabowl/../core/js/src/DayOfWeek.kt","webpack://orgabowl/../core/js/src/Month.kt","webpack://orgabowl/./kotlin-dce/kotlin/math.kt","webpack://orgabowl/./kotlin-dce/generated/_Strings.kt","webpack://orgabowl/../core/common/src/DayOfWeek.kt","webpack://orgabowl/../core/common/src/Month.kt","webpack://orgabowl/./kotlin-dce/wrapper.js","webpack://orgabowl/./kotlin-dce/arrayUtils.js","webpack://orgabowl/./kotlin-dce/callableReferenceUtils.js","webpack://orgabowl/./kotlin-dce/conversions.js","webpack://orgabowl/./kotlin-dce/core.js","webpack://orgabowl/./kotlin-dce/misc.js","webpack://orgabowl/./kotlin-dce/polyfills.js","webpack://orgabowl/./kotlin-dce/markerFunctions.js","webpack://orgabowl/./kotlin-dce/rtti.js","webpack://orgabowl/./kotlin-dce/long.js","webpack://orgabowl/./kotlin-dce/runtime/arrayUtils.kt","webpack://orgabowl/./kotlin-dce/runtime/Enum.kt","webpack://orgabowl/./kotlin-dce/primitiveCompanionObjects.kt","webpack://orgabowl/./kotlin-dce/generated/_Arrays.kt","webpack://orgabowl/./kotlin-dce/generated/_Ranges.kt","webpack://orgabowl/./kotlin-dce/kotlin/UByte.kt","webpack://orgabowl/./kotlin-dce/kotlin/UInt.kt","webpack://orgabowl/./kotlin-dce/kotlin/UShort.kt","webpack://orgabowl/./kotlin-dce/Ranges.kt","webpack://orgabowl/./kotlin-dce/collections/Collections.kt","webpack://orgabowl/./kotlin-dce/collections/Maps.kt","webpack://orgabowl/./kotlin-dce/collections/Sets.kt","webpack://orgabowl/./kotlin-dce/text/StringNumberConversions.kt","webpack://orgabowl/./kotlin-dce/time/Duration.kt","webpack://orgabowl/./kotlin-dce/kotlin/UnsignedUtils.kt","webpack://orgabowl/./kotlin-dce/collections/Sequences.kt","webpack://orgabowl/./kotlin-dce/generated/_Collections.kt","webpack://orgabowl/./kotlin-dce/generated/_Sequences.kt","webpack://orgabowl/./kotlin-dce/util/Preconditions.kt","webpack://orgabowl/./kotlin-dce/kotlin/text/string.kt","webpack://orgabowl/./kotlin-dce/Iterators.kt","webpack://orgabowl/./kotlin-dce/ProgressionIterators.kt","webpack://orgabowl/./kotlin-dce/CharCode.kt","webpack://orgabowl/./kotlin-dce/Progressions.kt","webpack://orgabowl/./kotlin-dce/Collections.kt","webpack://orgabowl/./kotlin-dce/Range.kt","webpack://orgabowl/./kotlin-dce/Unit.kt","webpack://orgabowl/./kotlin-dce/internal/progressionUtil.kt","webpack://orgabowl/./kotlin-dce/kotlin/builtins.kt","webpack://orgabowl/./kotlin-dce/kotlin/coroutines/CoroutineImpl.kt","webpack://orgabowl/./kotlin-dce/util/Standard.kt","webpack://orgabowl/./kotlin-dce/util/Result.kt","webpack://orgabowl/./kotlin-dce/coroutines/Continuation.kt","webpack://orgabowl/./kotlin-dce/kotlin/exceptions.kt","webpack://orgabowl/./kotlin-dce/kotlin/kotlin.kt","webpack://orgabowl/./kotlin-dce/kotlin/text/numberConversions_js-v1.kt","webpack://orgabowl/./kotlin-dce/generated/_ArraysJs.kt","webpack://orgabowl/./kotlin-dce/generated/_WhitespaceChars.kt","webpack://orgabowl/./kotlin-dce/kotlin/collections.kt","webpack://orgabowl/./kotlin-dce/kotlin/collections/AbstractMutableCollection.kt","webpack://orgabowl/./kotlin-dce/kotlin/collections/AbstractMutableList.kt","webpack://orgabowl/./kotlin-dce/kotlin/collections/AbstractMutableMap.kt","webpack://orgabowl/./kotlin-dce/kotlin/collections/AbstractMutableSet.kt","webpack://orgabowl/./kotlin-dce/kotlin/collections/ArrayList.kt","webpack://orgabowl/./kotlin-dce/kotlin/collections/EqualityComparator.kt","webpack://orgabowl/./kotlin-dce/kotlin/Comparator.kt","webpack://orgabowl/./kotlin-dce/kotlin/collections/HashMap.kt","webpack://orgabowl/./kotlin-dce/kotlin/collections/HashSet.kt","webpack://orgabowl/./kotlin-dce/kotlin/collections/InternalHashCodeMap.kt","webpack://orgabowl/./kotlin-dce/kotlin/collections/InternalStringMap.kt","webpack://orgabowl/./kotlin-dce/kotlin/collections/LinkedHashMap.kt","webpack://orgabowl/./kotlin-dce/kotlin/collections/LinkedHashSet.kt","webpack://orgabowl/./kotlin-dce/kotlin/console.kt","webpack://orgabowl/./kotlin-dce/kotlin/coroutines/SafeContinuationJs.kt","webpack://orgabowl/./kotlin-dce/kotlin/dom/ItemArrayLike.kt","webpack://orgabowl/./kotlin-dce/kotlin/exceptionUtils.kt","webpack://orgabowl/./kotlin-dce/kotlin/numbers.kt","webpack://orgabowl/./kotlin-dce/kotlin/reflect/KClassImpl.kt","webpack://orgabowl/./kotlin-dce/kotlin/collections/InternalMap.kt","webpack://orgabowl/./kotlin-dce/kotlin/jsOperators.kt","webpack://orgabowl/./kotlin-dce/kotlin/reflect/KTypeImpl.kt","webpack://orgabowl/./kotlin-dce/kotlin/reflect/primitives.kt","webpack://orgabowl/./kotlin-dce/kotlin/reflect/reflection.kt","webpack://orgabowl/./kotlin-dce/kotlin/regexp.kt","webpack://orgabowl/./kotlin-dce/kotlin/text/StringBuilderJs.kt","webpack://orgabowl/./kotlin-dce/kotlin/text/numberConversions.kt","webpack://orgabowl/./kotlin-dce/kotlin/text/regex.kt","webpack://orgabowl/./kotlin-dce/text/Strings.kt","webpack://orgabowl/./kotlin-dce/generated/_ComparisonsJs.kt","webpack://orgabowl/./kotlin-dce/kotlin/text/stringsCode.kt","webpack://orgabowl/./kotlin-dce/collections/AbstractCollection.kt","webpack://orgabowl/./kotlin-dce/collections/AbstractList.kt","webpack://orgabowl/./kotlin-dce/collections/AbstractMap.kt","webpack://orgabowl/./kotlin-dce/collections/AbstractSet.kt","webpack://orgabowl/./kotlin-dce/collections/IndexedValue.kt","webpack://orgabowl/./kotlin-dce/collections/Iterables.kt","webpack://orgabowl/./kotlin-dce/collections/Iterators.kt","webpack://orgabowl/./kotlin-dce/collections/MapWithDefault.kt","webpack://orgabowl/./kotlin-dce/collections/MutableCollections.kt","webpack://orgabowl/./kotlin-dce/coroutines/ContinuationInterceptor.kt","webpack://orgabowl/./kotlin-dce/coroutines/CoroutineContext.kt","webpack://orgabowl/./kotlin-dce/coroutines/CoroutineContextImpl.kt","webpack://orgabowl/./kotlin-dce/coroutines/intrinsics/Intrinsics.kt","webpack://orgabowl/./kotlin-dce/ranges/Ranges.kt","webpack://orgabowl/./kotlin-dce/reflect/KTypeProjection.kt","webpack://orgabowl/./kotlin-dce/reflect/KVariance.kt","webpack://orgabowl/./kotlin-dce/text/Appendable.kt","webpack://orgabowl/./kotlin-dce/text/Char.kt","webpack://orgabowl/./kotlin-dce/text/Indent.kt","webpack://orgabowl/./kotlin-dce/text/regex/MatchResult.kt","webpack://orgabowl/./kotlin-dce/util/Lazy.kt","webpack://orgabowl/./kotlin-dce/util/Tuples.kt","webpack://orgabowl/./kotlin-dce/kotlin/ULong.kt","webpack://orgabowl/./kotlin-dce/experimental/bitwiseOperations.kt","webpack://orgabowl/./kotlin-dce/kotlin/UIntRange.kt","webpack://orgabowl/./kotlin-dce/kotlin/UIterators.kt","webpack://orgabowl/./kotlin-dce/kotlin/ULongRange.kt","webpack://orgabowl/./kotlin-dce/kotlin/UProgressionUtil.kt","webpack://orgabowl/./kotlin-dce/kotlin/UStrings.kt","webpack://orgabowl/./kotlin-dce/generated/_Sets.kt","webpack://orgabowl/./kotlin-dce/kotlin/coroutines/intrinsics/IntrinsicsJs.kt","webpack://orgabowl/./kotlin-dce/kotlin/reflection_js-v1.kt","webpack://orgabowl/./kotlin-dce/kotlinx/dom/Mutations.kt","webpack://orgabowl/./kotlin-dce/kotlin/reflect/JsClass.kt","webpack://orgabowl/./kotlin-dce/kotlin/reflect/KTypeHelpers.kt","webpack://orgabowl/./kotlin-dce/kotlin/coroutines/js/internal/EmptyContinuation.kt","webpack://orgabowl/./kotlin-dce/kotlin/random/PlatformRandom.kt","webpack://orgabowl/./kotlin-dce/kotlin/text/utf8Encoding.kt","webpack://orgabowl/./kotlin-dce/util/DeepRecursive.kt","webpack://orgabowl/./kotlin-dce/text/regex/RegexExtensions.kt","webpack://orgabowl/../src/commonMain/kotlin/api.kt","webpack://orgabowl/../src/commonMain/kotlin/attributes.kt","webpack://orgabowl/../src/commonMain/kotlin/delegating-map.kt","webpack://orgabowl/../src/commonMain/kotlin/finalize-consumer.kt","webpack://orgabowl/../src/commonMain/kotlin/generated/gen-enums.kt","webpack://orgabowl/../src/commonMain/kotlin/generated/gen-tags-b.kt","webpack://orgabowl/../src/commonMain/kotlin/generated/gen-tags-i.kt","webpack://orgabowl/../src/commonMain/kotlin/generated/gen-tags-o.kt","webpack://orgabowl/../src/commonMain/kotlin/generated/gen-tags-t.kt","webpack://orgabowl/../src/commonMain/kotlin/htmltag.kt","webpack://orgabowl/../src/commonMain/kotlin/stream.kt","webpack://orgabowl/../src/jsMain/kotlin/dom-js.kt","webpack://orgabowl/../src/jsMain/kotlin/visit-js.kt","webpack://orgabowl/./kotlin-dce/generated/_Maps.kt","webpack://orgabowl/../src/commonMain/kotlin/generated/gen-attr-traits.kt","webpack://orgabowl/../src/jsMain/kotlin/generated/gen-event-attrs-js.kt","webpack://orgabowl/../src/commonMain/kotlin/generated/gen-attributes.kt","webpack://orgabowl/./kotlin-dce/kotlin/reflect/AssociatedObjects.kt","webpack://orgabowl/../core/commonMain/src/kotlinx/serialization/builtins/BuiltinSerializers.kt","webpack://orgabowl/../core/commonMain/src/kotlinx/serialization/descriptors/ContextAware.kt","webpack://orgabowl/../core/commonMain/src/kotlinx/serialization/descriptors/SerialDescriptor.kt","webpack://orgabowl/../core/commonMain/src/kotlinx/serialization/descriptors/SerialKinds.kt","webpack://orgabowl/../core/commonMain/src/kotlinx/serialization/internal/PluginGeneratedSerialDescriptor.kt","webpack://orgabowl/../core/commonMain/src/kotlinx/serialization/encoding/AbstractDecoder.kt","webpack://orgabowl/../core/commonMain/src/kotlinx/serialization/encoding/AbstractEncoder.kt","webpack://orgabowl/../core/commonMain/src/kotlinx/serialization/internal/AbstractPolymorphicSerializer.kt","webpack://orgabowl/../core/commonMain/src/kotlinx/serialization/internal/CollectionDescriptors.kt","webpack://orgabowl/../core/commonMain/src/kotlinx/serialization/internal/CollectionSerializers.kt","webpack://orgabowl/../core/commonMain/src/kotlinx/serialization/internal/InlineClassDescriptor.kt","webpack://orgabowl/../core/commonMain/src/kotlinx/serialization/internal/InlineClasses.kt","webpack://orgabowl/../core/commonMain/src/kotlinx/serialization/encoding/Encoding.kt","webpack://orgabowl/../core/commonMain/src/kotlinx/serialization/internal/NoOpEncoder.kt","webpack://orgabowl/../core/commonMain/src/kotlinx/serialization/internal/NullableSerializer.kt","webpack://orgabowl/../core/commonMain/src/kotlinx/serialization/internal/ObjectSerializer.kt","webpack://orgabowl/./kotlin-dce/util/HashCode.kt","webpack://orgabowl/../core/commonMain/src/kotlinx/serialization/internal/PrimitiveArraysSerializers.kt","webpack://orgabowl/../core/commonMain/src/kotlinx/serialization/internal/PluginHelperInterfaces.kt","webpack://orgabowl/../core/commonMain/src/kotlinx/serialization/internal/Primitives.kt","webpack://orgabowl/../core/commonMain/src/kotlinx/serialization/internal/Tagged.kt","webpack://orgabowl/../core/commonMain/src/kotlinx/serialization/internal/Tuples.kt","webpack://orgabowl/../core/commonMain/src/kotlinx/serialization/modules/SerializersModule.kt","webpack://orgabowl/../core/commonMain/src/kotlinx/serialization/PolymorphicSerializer.kt","webpack://orgabowl/../core/commonMain/src/kotlinx/serialization/SealedSerializer.kt","webpack://orgabowl/./kotlin-dce/collections/Grouping.kt","webpack://orgabowl/../core/commonMain/src/kotlinx/serialization/SerializationException.kt","webpack://orgabowl/../core/jsMain/src/kotlinx/serialization/internal/Platform.kt","webpack://orgabowl/../core/jsMain/src/kotlinx/serialization/Serializers.kt","webpack://orgabowl/../core/commonMain/src/kotlinx/serialization/internal/JsonInternalDependencies.kt","webpack://orgabowl/../formats/json/commonMain/src/kotlinx/serialization/json/internal/JsonLexer.kt","webpack://orgabowl/../formats/json/jsMain/src/kotlinx/serialization/json/internal/DynamicDecoders.kt","webpack://orgabowl/../formats/json/commonMain/src/kotlinx/serialization/json/internal/Composers.kt","webpack://orgabowl/../formats/json/commonMain/src/kotlinx/serialization/json/internal/JsonExceptions.kt","webpack://orgabowl/../formats/json/commonMain/src/kotlinx/serialization/json/internal/JsonNamesMap.kt","webpack://orgabowl/../formats/json/commonMain/src/kotlinx/serialization/json/internal/JsonTreeReader.kt","webpack://orgabowl/../formats/json/commonMain/src/kotlinx/serialization/json/internal/Polymorphic.kt","webpack://orgabowl/../formats/json/commonMain/src/kotlinx/serialization/json/internal/TreeJsonEncoder.kt","webpack://orgabowl/../formats/json/commonMain/src/kotlinx/serialization/json/internal/SchemaCache.kt","webpack://orgabowl/../formats/json/commonMain/src/kotlinx/serialization/json/internal/StreamingJsonDecoder.kt","webpack://orgabowl/../formats/json/commonMain/src/kotlinx/serialization/json/internal/StreamingJsonEncoder.kt","webpack://orgabowl/../formats/json/commonMain/src/kotlinx/serialization/json/internal/StringOps.kt","webpack://orgabowl/../formats/json/commonMain/src/kotlinx/serialization/json/internal/TreeJsonDecoder.kt","webpack://orgabowl/../formats/json/commonMain/src/kotlinx/serialization/json/internal/WriteMode.kt","webpack://orgabowl/../formats/json/commonMain/src/kotlinx/serialization/json/Json.kt","webpack://orgabowl/../formats/json/commonMain/src/kotlinx/serialization/json/JsonConfiguration.kt","webpack://orgabowl/../formats/json/commonMain/src/kotlinx/serialization/json/JsonElement.kt","webpack://orgabowl/../formats/json/commonMain/src/kotlinx/serialization/json/JsonElementSerializers.kt","webpack://orgabowl/../formats/json/commonMain/src/kotlinx/serialization/json/JsonNames.kt","webpack://orgabowl/../formats/json/jsMain/src/kotlinx/serialization/json/internal/createMapForCache.kt","webpack://orgabowl/../formats/json/jsMain/src/kotlinx/serialization/json/internal/JsonStringBuilder.kt","webpack://orgabowl/./kotlin/collections/Collections.kt","webpack://orgabowl/./kotlin/collections/Maps.kt","webpack://orgabowl/./kotlin/generated/_Maps.kt","webpack://orgabowl/../src/commonMain/kotlin/generated/gen-consumer-tags.kt","webpack://orgabowl/./kotlin/text/Strings.kt","webpack://orgabowl/../src/commonMain/kotlin/generated/gen-tag-unions.kt","webpack://orgabowl/../src/jsMain/edu/mines/csci341/hackathon/js/App.kt","webpack://orgabowl/./kotlin/generated/_Collections.kt","webpack://orgabowl/../core/commonMain/src/kotlinx/serialization/SerialFormat.kt","webpack://orgabowl/./kotlin/util/Standard.kt","webpack://orgabowl/./kotlin/org.w3c/org.w3c.dom.kt","webpack://orgabowl/./kotlin/kotlin/text/string.kt","webpack://orgabowl/webpack/bootstrap","webpack://orgabowl/webpack/runtime/define property getters","webpack://orgabowl/webpack/runtime/hasOwnProperty shorthand","webpack://orgabowl/webpack/runtime/make namespace object","webpack://orgabowl/webpack/startup"],"names":["root","factory","exports","module","define","amd","this","createErrorType","name","init","superErrorClass","JsJodaException","message","Error","captureStackTrace","constructor","stack","apply","arguments","toString","prototype","Object","create","DateTimeException","cause","msg","DateTimeParseException","text","index","parsedString","errorIndex","UnsupportedTemporalTypeException","ArithmeticException","IllegalArgumentException","IllegalStateException","NullPointerException","_inheritsLoose","subClass","superClass","__proto__","_assertThisInitialized","self","ReferenceError","assert","assertion","error","requireNonNull","value","parameterName","requireInstance","_class","abstractMethodFail","methodName","TypeError","assert$1","freeze","MAX_SAFE_INTEGER","MIN_SAFE_INTEGER","MathUtil","intDiv","x","y","r","roundDown","safeZero","intMod","Math","ceil","floor","floorDiv","floorMod","safeAdd","verifyInt","safeToInt","safeSubtract","safeMultiply","parseInt","_parseInt","_x","isNaN","compareNumbers","a","b","smi","int","hash","number","Infinity","result","hashCode","_len","length","numbers","Array","_key","_i","_numbers","n","Enum","_name","_proto","equals","other","toJSON","TemporalAmount","get","unit","units","addTo","temporal","subtractFrom","TemporalUnit","duration","isDurationEstimated","isDateBased","isTimeBased","isSupportedBy","dateTime","periodToAdd","between","temporal1","temporal2","Duration","_TemporalAmount","seconds","nanos","_this","call","_seconds","_nanos","ofDays","days","_create","LocalTime","SECONDS_PER_DAY","ofHours","hours","SECONDS_PER_HOUR","ofMinutes","minutes","SECONDS_PER_MINUTE","ofSeconds","nanoAdjustment","secs","NANOS_PER_SECOND","nos","ofMillis","millis","mos","ofNanos","of","amount","ZERO","plus","from","forEach","startInclusive","endExclusive","until","ChronoUnit","SECONDS","isSupported","ChronoField","NANO_OF_SECOND","startNos","getLong","adjustedEnd","with","e","parse","matches","RegExp","exec","negate","dayMatch","hourMatch","minuteMatch","secondMatch","fractionMatch","daysAsSecs","_parseNumber","hoursAsSecs","minsAsSecs","negativeSecs","charAt","_parseFraction","ex","parsed","multiplier","errorText","substring","parseFloat","_createSecondsNanos","_createNegateDaysHoursMinutesSecondsNanos","negated","NANOS","isZero","isNegative","nano","withSeconds","withNanos","nanoOfSecond","checkValidIntValue","plusDuration","durationOrNumber","unitOrNumber","plusAmountUnit","plusSecondsNanos","amountToAdd","DAYS","plusNanos","MICROS","MILLIS","plusMillis","plusSeconds","multipliedBy","plusDays","daysToAdd","plusHours","hoursToAdd","plusMinutes","minutesToAdd","secondsToAdd","millisToAdd","nanosToAdd","epochSec","minus","minusDuration","minusAmountUnit","secsToSubtract","nanosToSubtract","amountToSubtract","minusDays","daysToSubtract","minusHours","hoursToSubtract","minusMinutes","minutesToSubtract","minusSeconds","secondsToSubtract","minusMillis","millisToSubtract","minusNanos","multiplicand","dividedBy","divisor","secsMod","abs","toDays","toHours","toMinutes","toMillis","round","toNanos","totalNanos","compareTo","otherDuration","cmp","nanoString","rval","slice","YearConstants","_TemporalUnit","estimatedDuration","_duration","FOREVER","e2","TemporalField","baseUnit","rangeUnit","range","rangeRefinedBy","getFrom","adjustInto","newValue","displayName","ValueRange","minSmallest","minLargest","maxSmallest","maxLargest","_minSmallest","_minLargest","_maxLargest","_maxSmallest","isFixed","minimum","largestMinimum","maximum","smallestMaximum","isValidValue","checkValidValue","field","isValidIntValue","isIntValue","str","_TemporalField","_baseUnit","_rangeUnit","_range","byName","fieldName","prop","DAY_OF_WEEK","ALIGNED_DAY_OF_WEEK_IN_MONTH","ALIGNED_DAY_OF_WEEK_IN_YEAR","DAY_OF_MONTH","DAY_OF_YEAR","EPOCH_DAY","ALIGNED_WEEK_OF_MONTH","ALIGNED_WEEK_OF_YEAR","MONTH_OF_YEAR","YEAR_OF_ERA","YEAR","ERA","NANO_OF_DAY","MICRO_OF_SECOND","MICRO_OF_DAY","MILLI_OF_SECOND","MILLI_OF_DAY","SECOND_OF_MINUTE","SECOND_OF_DAY","MINUTE_OF_HOUR","MINUTE_OF_DAY","HOUR_OF_AMPM","CLOCK_HOUR_OF_AMPM","HOUR_OF_DAY","CLOCK_HOUR_OF_DAY","AMPM_OF_DAY","TemporalQueries","zoneId","ZONE_ID","chronology","CHRONO","precision","PRECISION","zone","ZONE","offset","OFFSET","localDate","LOCAL_DATE","localTime","LOCAL_TIME","TemporalAccessor","query","_query","queryFrom","TemporalQuery","_Enum","createTemporalQuery","queryFromFunction","ExtendedTemporalQuery","_TemporalQuery","ENUMS","MONTHS","DayOfWeek","_TemporalAccessor","ordinal","_ordinal","values","valueOf","dayOfWeek","style","locale","Month","_value","months","newMonthVal","leapYear","FEBRUARY","APRIL","JUNE","SEPTEMBER","NOVEMBER","minLength","maxLength","firstDayOfYear","leap","JANUARY","MARCH","MAY","JULY","AUGUST","OCTOBER","DECEMBER","firstMonthOfQuarter","IsoChronology","INSTANCE","month","PATTERN","Period","years","_years","_months","_days","ofYears","ofMonths","ofWeeks","weeks","i","unitAmount","YEARS","startDate","endDate","LocalDate","_parse","yearMatch","monthMatch","weekMatch","val","withYears","withMonths","withDays","plusYears","yearsToAdd","plusMonths","monthsToAdd","minusYears","yearsToSubtract","minusMonths","monthsToSubtract","scalar","normalized","totalMonths","toTotalMonths","splitYears","splitMonths","obj","buf","ParsePosition","_index","_errorIndex","getIndex","setIndex","getErrorIndex","setErrorIndex","EnumMap","_map","putAll","otherMap","key","containsKey","hasOwnProperty","undefined","put","set","retainAll","keyList","map","remove","keyName","keySet","clear","ResolverStyle","STRICT","SMART","LENIENT","TemporalAdjuster","Temporal","p1","p2","minusAmount","plusAmount","endTemporal","withAdjuster","withFieldValue","adjuster","DefaultInterfaceTemporal","_Temporal","ChronoLocalDate","_DefaultInterfaceTemp","fieldOrUnit","ofEpochDay","toEpochDay","format","formatter","DateTimeFormatter","StringUtil","startsWith","pattern","indexOf","len","charCodeAt","ZoneId","systemDefault","getAvailableZoneIds","ofOffset","prefix","id","rules","isFixedOffset","Instant","EPOCH","ZoneRules","Fixed","instantOrLocalDateTime","offsetOfInstant","offsetOfLocalDateTime","instant","offsetOfEpochMilli","epochMilli","localDateTime","validOffsets","transition","standardOffset","daylightSavings","isDaylightSavings","isValidOffset","nextTransition","previousTransition","transitions","transitionRules","_ZoneRules","_offset","_proto2","SECONDS_CACHE","ID_CACHE","ZoneOffset","_ZoneId","totalSeconds","_validateTotalSeconds","_totalSeconds","_rules","_id","_buildId","absTotalSeconds","absHours","absMinutes","MINUTES_PER_HOUR","absSeconds","MAX_SECONDS","_validate","offsetId","first","ofHoursMinutesSeconds","pos","precededByColon","ch1","ch2","ofHoursMinutes","ofTotalSeconds","ofTotalMinutes","totalMinutes","totalSecs","OFFSET_SECONDS","DateTimeBuilder","fieldValues","chrono","date","time","leapSecond","excessDays","dtb","_addFieldValue","getFieldValue0","old","_putFieldValue0","resolve","resolverStyle","resolverFields","_mergeDate","_mergeTime","_resolveTimeInferZeroes","_resolveInstant","_checkDate","resolveDate","_addObject","val1","val2","ch","_ch","ap","hap","nod","cod","lod","sod","mod","los","cos","_nos","_cos","_los","hod","moh","som","hodVal","mohVal","somVal","nosVal","_hodVal","ofNanoOfDay","_excessDays","ofSecondOfDay","_excessDays2","dateOrTime","offsetSecs","atTime","atZone","INSTANT_SECONDS","_instant","build","type","DateTimeParseContext","_constructorSelf","_constructorFormatter","_constructorParam","_caseSensitive","_strict","_parsed","Parsed","symbols","_locale","_symbols","_overrideChronology","decimalStyle","_overrideZone","copy","isStrict","setStrict","strict","setLocale","startOptional","push","currentParsed","endOptional","successful","splice","isCaseSensitive","setCaseSensitive","caseSensitive","subSequenceEquals","cs1","offset1","cs2","offset2","toLowerCase","charEquals","charEqualsIgnoreCase","c1","c2","setParsedField","errorPos","successPos","currentParsedFieldValues","setParsedZone","getParsed","toParsed","setParsedLeapSecond","getEffectiveChronology","dateTimeParseContext","cloned","toBuilder","builder","overrideZone","DateTimePrintContext","localeOrFormatter","_temporal","adjust","_optional","getValueQuery","getValue","setDateTime","IsoFields","QUARTER_DAYS","Field","_isIso","_getWeekRangeByLocalDate","wby","_getWeekBasedYear","_getWeekRangeByYear","THURSDAY","WEDNESDAY","isLeapYear","_getWeek","dow0","doy0","dayOfYear","doyThu0","firstMonDoy0","withDayOfYear","week","year","doy","_dow","DAY_OF_QUARTER_FIELD","_Field","QUARTER_YEARS","qoy","QUARTER_OF_YEAR","moy","curValue","partialTemporal","yearLong","qoyLong","doq","DAY_OF_QUARTER","_qoy","max","QUARTER_OF_YEAR_FIELD","_Field2","_proto3","WEEK_OF_WEEK_BASED_YEAR_FIELD","_Field3","_proto4","WEEKS","WEEK_BASED_YEARS","wbyLong","WEEK_BASED_YEAR","dowLong","wowby","WEEK_OF_WEEK_BASED_YEAR","dow","plusWeeks","_dow2","temp","WEEK_BASED_YEAR_FIELD","_Field4","_proto5","newWby","resolved","Unit","_proto6","added","DecimalStyle","zeroChar","positiveSignChar","negativeSignChar","decimalPointChar","_zeroDigit","_zeroDigitCharCode","_positiveSign","_negativeSign","_decimalSeparator","positiveSign","withPositiveSign","negativeSign","withNegativeSign","zeroDigit","withZeroDigit","decimalSeparator","withDecimalSeparator","convertToDigit","char","convertNumberToI18N","numericText","diff","convertedText","String","fromCharCode","availableLocales","STANDARD","SignStyle","positive","fixedWidth","NORMAL","ALWAYS","EXCEEDS_PAD","NEVER","NOT_NEGATIVE","TextStyle","isStandalone","FULL_STANDALONE","SHORT_STANDALONE","NARROW_STANDALONE","asStandalone","FULL","SHORT","NARROW","asNormal","CharLiteralPrinterParser","literal","_literal","print","context","append","position","CompositePrinterParser","printerParsers","optional","_printerParsers","withOptional","setLength","FractionPrinterParser","minWidth","maxWidth","decimalPoint","fraction","convertToFraction","outputScale","min","substr","effectiveMin","effectiveMax","minEndPos","maxEndPos","total","digit","moveLeft","scale","pow","convertFromFraction","_min","decimal","EXCEED_POINTS","NumberPrinterParser","signStyle","subsequentWidth","_field","_minWidth","_maxWidth","_signStyle","_subsequentWidth","withFixedWidth","withSubsequentWidth","_isFixedWidth","contextValue","_getValue","sign","negative","effMinWidth","effMaxWidth","pass","parseLen","_parseLen","_setValue","ReducedPrinterParser","_NumberPrinterParser","width","baseValue","baseDate","_baseValue","_baseDate","absValue","basePart","isFixedWidth","PATTERNS","OffsetIdPrinterParser","noOffsetText","_checkPattern","bufPos","output","appendChar","noOffsetLen","array","arrayIndex","parseText","required","converted","replace","INSTANCE_ID","PadPrinterParserDecorator","printerParser","padWidth","padChar","_printerParser","_padWidth","_padChar","preLen","insert","endPos","resultPos","SettingsParser","SENSITIVE","INSENSITIVE","PARSER","PARSER$1","PARSER$2","StringLiteralPrinterParser","ZoneRulesProvider","getRules","ZoneRegion","ofId","ZoneIdPrinterParser","description","nextChar","newContext","nextNextChar","_parsePrefixedOffset","UTC","availableZoneIds","zoneIdTree","size","ZoneIdTree","createTreeMap","maxParseLength","treeMap","parsedZoneId","parseLength","parsedSubZoneId","isLeaf","prefixPos","toUpperCase","sortedZoneIds","sort","ZoneIdTreeMap","add","_treeMap","idLength","subZoneId","subTreeMap","MAX_WIDTH$1","DateTimeFormatterBuilder","_active","_parent","_padNextWidth","_padNextChar","_valueParserIndex","_of","parent","dtFormatterBuilder","parseCaseSensitive","_appendInternalPrinterParser","parseCaseInsensitive","parseStrict","parseLenient","appendValue","_appendValue1","_appendValue2","_appendValue4","_appendValuePrinterParser","pp","appendValueReduced","_appendValueReducedFieldWidthMaxWidthBaseDate","_appendValueReducedFieldWidthMaxWidthBaseValue","activeValueParser","basePP","_appendInternal","appendFraction","appendInstant","fractionalDigits","InstantPrinterParser","appendOffsetId","appendOffset","appendZoneId","appendPattern","_parsePattern","appendZoneText","appendText","appendLocalizedOffset","appendWeekField","FIELD_MAP","cur","start","count","pad","padNext","_parseField","zero","_start","appendLiteral","optionalStart","optionalEnd","BASE_DATE","_padNext1","_padNext2","cpp","_toPrinterParser","toFormatter","SECONDS_PER_10000_YEARS","SECONDS_0000_TO_1970","inSecs","inNanos","inSec","inNano","zeroSecs","hi","lo","ldt","LocalDateTime","ofEpochSecond","second","_zeroSecs","_hi","_lo","_ldt","div","minDigits","maxDigits","ISO_LOCAL_DATE","instantSecs","yearParsed","day","hour","secVal","nanoVal","sec","toEpochSecond","StringBuilder","_str","end","_decimalStyle","_resolverStyle","_resolverFields","_chrono","_zone","parsedExcessDays","PARSED_EXCESS_DAYS","parsedLeapSecond","PARSED_LEAP_SECOND","ofPattern","withChronology","withLocale","withResolverStyle","_formatTo","appendable","parse1","parse2","_parseToBuilder","_createError","abbr","_parseUnresolved0","parseUnresolved","MonthDay","dayOfMonth","_month","_day","now","zoneIdOrClock","now0","nowZoneId","nowClock","Clock","systemDefaultZone","system","clock","monthOrNumber","ofMonthNumber","ofNumberNumber","parseString","parseStringFormatter","FROM","monthValue","isValidYear","Year","isLeap","withMonth","withDayOfMonth","atYear","isAfter","isBefore","YearMonth","_year","ofNumberMonth","isSupportedField","isSupportedUnit","PROLEPTIC_MONTH","DECADES","CENTURIES","MILLENNIA","ERAS","MAX_VALUE","_getProlepticMonth","isValidDay","lengthOfMonth","lengthOfYear","adjusterOrField","f","withYear","newYear","calcMonths","monthsUntil","atDay","atEndOfMonth","isoYear","parseTextFormatter","isValidMonthDay","monthDay","ofYearDay","atMonth","atMonthMonth","atMonthNumber","atMonthDay","yearsUntil","TemporalAdjusters","firstDayOfMonth","Impl","FIRST_DAY_OF_MONTH","lastDayOfMonth","LAST_DAY_OF_MONTH","firstDayOfNextMonth","FIRST_DAY_OF_NEXT_MONTH","FIRST_DAY_OF_YEAR","lastDayOfYear","LAST_DAY_OF_YEAR","firstDayOfNextYear","FIRST_DAY_OF_NEXT_YEAR","firstInMonth","DayOfWeekInMonth","lastInMonth","dayOfWeekInMonth","next","RelativeDayOfWeek","nextOrSame","previous","previousOrSame","_TemporalAdjuster","_TemporalAdjuster2","_this2","_dowValue","curDow","dowDiff","_temp","_curDow","daysDiff","_TemporalAdjuster3","relative","_this3","_relative","calDow","_daysDiff","prolepticYear","_updateResolveMap","current","prolepticMonth","yoeLong","era","dom","_y","_y2","_days2","aw","ad","_y3","_weeks","_days3","_aw","_date","OffsetTime","_time","OffsetDateTime","toOffsetTime","clockOrZone","_now","ofInstant","ofTimeAndOffset","ofNumbers","minute","secsOfDay","epochSecond","ISO_OFFSET_TIME","toNanoOfDay","atDate","_toEpochNano","isEqual","_withLocalTimeOffset","toLocalTime","truncatedTo","nanosUntil","MINUTES","NANOS_PER_MINUTE","HOURS","NANOS_PER_HOUR","HALF_DAYS","withHour","withMinute","withSecond","withNano","withOffsetSameInstant","difference","withOffsetSameLocal","compare","ChronoZonedDateTime","toLocalDate","toInstant","toSecondOfDay","toLocalDateTime","thisEpochSec","otherEpochSec","ZonedDateTime","_ChronoZonedDateTime","_dateTime","of2","of3","of8","ofLocal","dt","preferredOffset","trans","offsetAfter","some","validOffset","ofInstant2","ofInstant3","ofStrict","isGap","ofLenient","zdt","_from","__from","ISO_ZONED_DATE_TIME","_resolveLocal","newDateTime","_resolveOffset","withEarlierOffsetAtOverlap","isOverlap","earlierOffset","offsetBefore","withLaterOffsetAtOverlap","laterOffset","withZoneSameLocal","withZoneSameInstant","withFixedOffsetZone","minusWeeks","toOffsetDateTime","_","ofDateTime","ofDateAndTime","ISO_OFFSET_DATE_TIME","atZoneSameInstant","atZoneSimilarLocal","toZonedDateTime","_withDateTimeOffset","DAYS_PER_CYCLE","DAYS_0000_TO_1970","_ChronoLocalDate","epochDay","adjustCycles","doyEst","yearEst","zeroDay","marchDoy0","marchMonth0","_resolvePreviousValid","_get0","_prolepticMonth","m","newMonth","weeksToAdd","mjDay","weeksToSubtract","until1","until2","daysUntil","_monthsUntil","packed1","packed2","calcDate","atTime1","atTime4","_atTimeOffsetTime","atStartOfDay","atStartOfDayWithZone","MIDNIGHT","dateTimeAfter","_compareTo0","otherDate","yearValue","dayValue","ChronoLocalDateTime","_ChronoLocalDateTime","_ofEpochMillis","localSecond","localEpochDay","ISO_LOCAL_DATE_TIME","_withDateTime","newDate","newTime","MICROS_PER_DAY","MILLIS_PER_DAY","_plusWithOverflow","totDays","NANOS_PER_DAY","MINUTES_PER_DAY","HOURS_PER_DAY","totNanos","curNoD","newNoD","timeUntil","endTime","atOffset","_hour","_minute","_second","_nanoOfSecond","_nano","secondOfDay","nanoOfDay","ISO_LOCAL_TIME","ham","unitDur","dur","mofd","newMofd","sofd","newSofd","nofd","newNofd","hourValue","minuteValue","secondValue","nanoValue","NANOS_PER_MILLI","systemUTC","ofEpochMilli","ISO_INSTANT","MIN_SECONDS","nval","_nval","_plus","_nanosUntil","toEpochMilli","_secondsUntil","secsDiff","nanosDiff","otherInstant","SystemClock","fixed","fixedInstant","FixedClock","baseClock","OffsetClock","withZone","_Clock","Date","getTime","_Clock2","_zoneId","_Clock3","_baseClock","ZoneOffsetTransition","_transition","_offsetBefore","_offsetAfter","dateTimeBefore","durationSeconds","d","SystemDefaultZoneRules","offsetInMinutes","getTimezoneOffset","offsetInMinutesBeforePossibleTransition","offsetInMinutesAfterPossibleTransition","_throwNotSupported","SystemDefaultZoneId","ZoneIdFactory","SYSTEM_DEFAULT_ZONE_ID_INSTANCE","isInit","MIN_VALUE","MIN","MAX","NOON","_init$k","isoWeekOfWeekyear","isoWeekyear","MONDAY","TUESDAY","FRIDAY","SATURDAY","SUNDAY","EPOCH_0","SYSTEM","BASIC_ISO_DATE","ISO_OFFSET_DATE","ISO_ORDINAL_DATE","ISO_WEEK_DATE","ToNativeJsConverter","zonedDateTime","toDate","convert","NativeJsTemporal","_epochMilli","nativeJs","jsJoda","used","jsJodaExports","use","fn","Kotlin","isBooleanArray","isArray","Int8Array","$type$","isByteArray","isShortArray","Int16Array","isCharArray","Uint16Array","isIntArray","Int32Array","isFloatArray","Float32Array","isDoubleArray","Float64Array","isLongArray","isArrayish","ArrayBuffer","isView","arrayToString","join","arrayEquals","arrayHashCode","arr","getCallableRef","callableName","toShort","toByte","toChar","toBoxedChar","BoxedChar","unboxChar","obj1","obj2","objType","getObjectHashCode","numberHashCode","Number","getStringHashCode","o","bufFloat64","bufInt32","lowIndex","highIndex","OBJECT_HASH_CODE_PROPERTY_NAME","random","defineProperty","throwMarkerError","imul","isInheritanceFromInterface","ctor","iface","metadata","$metadata$","interfaces","superPrototype","getPrototypeOf","superConstructor","identityHashCode","Long","low_","low","high_","high","IntCache_","fromInt","cachedObj","fromNumber","TWO_PWR_63_DBL_","TWO_PWR_32_DBL_","fromBits","lowBits","highBits","fromString","radix","opt_radix","radixToPower","power","multiply","TWO_PWR_16_DBL_","TWO_PWR_24_DBL_","TWO_PWR_31_DBL_","TWO_PWR_48_DBL_","TWO_PWR_64_DBL_","ONE","NEG_ONE","TWO_PWR_24_","toInt","toNumber","getLowBitsUnsigned","equalsLong","radixLong","rem","subtract","remDiv","digits","getHighBits","getLowBits","getNumBitsAbs","bit","isOdd","notEqualsLong","lessThan","lessThanOrEqual","greaterThan","greaterThanOrEqual","thisNeg","otherNeg","not","a48","a32","a16","a00","b48","b32","b16","c48","c32","c16","c00","b00","approx","shiftRight","shiftLeft","res","log2","log","LN2","delta","approxRes","approxRem","modulo","and","or","xor","numBits","shiftRightUnsigned","compareTo_11rb$","inc","dec","unaryPlus","unaryMinus","inv","rangeTo","kotlin","ranges","LongRange","defineInlineFunction","fun","wrapFunction","suspendCall","coroutineResult","coroutineReceiver","typeA","doubleCompareTo","primitiveCompareTo","ia","imulEmulated","ensureNotNull","throwNPE","searchString","lastIndexOf","endsWith","subjectString","lastIndex","trunc","NaN","taylor_2_bound","sqrt","taylor_n_bound","upper_taylor_2_bound","upper_taylor_n_bound","sinh","exp","y1","isFinite","cosh","tanh","asinh","acosh","atanh","log1p","x2","x3","expm1","hypot","log10","LOG10E","LOG2E","clz32","asUint","fill","O","relativeStart","k","relativeEnd","finalValue","normalizeOffset","typedArraySlice","begin","subarray","arrays","TypedArray","Function","callback","totalOrderComparator","compareFunction","Kind","isType","object","klass","proto","kind","OBJECT","klassMetadata","INTERFACE","isNumber","isChar","isCharSequence","CharSequence","initValue","fillArrayVal","element","NoSuchElementException","IntRange","destination","item","asCollection","emptySet","setOf","toCollection","iterator","hasNext","single","optimizeReadOnlySet","separator","postfix","limit","truncated","transform","buffer","to","last","step","EMPTY","minimumValue","maximumValue","emptySequence","TakeSequence","optimizeReadOnlyList","TransformingSequence","CharIterator","IntIterator","LongIterator","getProgressionLastElement","endInclusive","NotImplementedError","nextByte","nextShort","nextInt","nextLong","nextFloat","nextDouble","nextBoolean","CharProgressionIterator","isEmpty","CharProgression","rangeStart","rangeEnd","IntProgressionIterator","IntProgression","LongProgressionIterator","LongProgression","CharRange","c","differenceModulo","BooleanIterator","ByteIterator","ShortIterator","FloatIterator","DoubleIterator","v","currentResult","isFailure","currentException","exceptionOrNull","doResume","outcome","exception","completion","Result","createFailure","intercepted","Exception","RuntimeException","src","dst","srcLen","dstLen","source","newSize","defaultValue","checkRadix","ArrayList","fromIndex","toIndex","toArray","copyToArrayImpl","collection","pair","startIndex","endIndex","destinationOffset","rangeSize","subrange","throwIndexOverflow","expectedSize","AbstractCollection","AbstractMutableCollection","AbstractMutableList","AbstractMap","AbstractMutableSet","initialCapacity","copyToArray","elements","checkIsMutable","modified","it","changed","times","hasPrevious","oldValue","entries","iter","entry","modCount","concat","pop","arrayCopy","value1","value2","internalMap","equality","InternalHashCodeMap","loadFactor","createJsMap","keys","BaseOutput","BufferedOutput","initialResult","AbstractList","ClassCastException","POSITIVE_INFINITY","NEGATIVE_INFINITY","KClassImpl","jClass","createEntrySet","chainOrEntry","chain","isChain","chainSize","keyIndex","itemIndex","state","lastEntry","_head","_tail","node","newEntry","println","outputStream","write","messageString","s","flush","console","IndexOutOfBoundsException","simpleName","jsClass","PrimitiveKClassImpl","classifier","isMarkedNullable","kClass","variance","prefixString","functionClasses","arity","getKClassM","getKClass1","jClasses","ErrorKClass","stringClass","SimpleKClassImpl","content","uppercase","MIN_HIGH_SURROGATE","MAX_HIGH_SURROGATE","MIN_LOW_SURROGATE","MAX_LOW_SURROGATE","isWhitespaceImpl","options","match","reversed","isLowSurrogate","isHighSurrogate","concatToString","string","toInsert","newLength","dstIndex","stringCsq","reset","input","test","findNext","Regex","replacement","lastStart","sb","foundMatch","collectionSizeOrDefault","nonGlobalOptions","subSequence","ignoreCase","JsMath","n1","n2","s1","s2","regex","regionMatchesImpl","thisOffset","otherOffset","MatchGroup","nextIndex","otherIterator","elem","elemOther","AbstractSet","ourValue","ArrayAsCollection","emptyList","listOf","contains","isVarargs","IndexingIterator","IndexedValue","checkIndexOverflow","pairs","emptyMap","filterInPlace","predicate","predicateResultToRemove","writeIndex","readIndex","removeIndex","GeneratorSequence","seedFunction","nextFunction","FlatteningSequence","itemIterator","nextItemIterator","SubSequence","left","nextItem","nextState","safe","getOrThrow","acc","removed","interceptor","CombinedContext","operation","initial","newLeft","KTypeProjection","accumulator","star","uppercaseChar","thisUpper","otherUpper","newIndent","lines","isBlank","line","isWhitespace","firstChar","limitBeforeMul","limitForMaxRadix","digitOf","NumberFormatException","chars","indices","regionMatches","currentStartIndex","strings","findAnyOf","currentIndex","DelimitedRangesSequence","asList","delimiters","splitToSequence","lineSequence","nextSearchIndex","groupValues","initializer","isInitialized","InitializedLazyImpl","Pair","that","UByte","third","UInt","uintCompare","data","ulongCompare","uintDivide","ulongDivide","uintRemainder","ulongRemainder","UIntProgression","UIntRange","bitCount","uintToDouble","UIntProgressionIterator","UIntIterator","ULong","nextUInt","nextULong","ULongProgression","ulongToDouble","ulongToString","ULongProgressionIterator","ULongIterator","ac","bc","UShort","uradix","beforeAdding","v1","v2","dividend","quotient","base","toMutableList","IndexingIterable","list","collectionSizeOrNull","addAll","fillFrom","arrayCopyResize","booleanArrayIterator","byteArrayIterator","shortArrayIterator","charArrayIterator","intArrayIterator","longArrayIterator","floatArrayIterator","doubleArrayIterator","instance","UnsafeLazyImpl","original","delegate","hasChildNodes","removeChild","firstChild","propertyName","isInfinite","KTypeImpl","intClass","doubleClass","booleanClass","functionClass","booleanArrayClass","charArrayClass","byteArrayClass","shortArrayClass","intArrayClass","longArrayClass","floatArrayClass","doubleArrayClass","arrayClass","anyClass","throwableClass","toIntOrNull","numberFormatError","toLongOrNull","thisLower","otherLower","getOrImplicitDefault","mapOf","optimizeReadOnlyMap","toSet","replaceIndent","indexOfAny","charArrayOf","toUByteOrNull","toUShortOrNull","toUIntOrNull","toULongOrNull","NodeJsOutput","BufferedOutputToConsoleLog","throwOnFailure","Comparator","SingletonStringMap","consumer","entity","attributeName","tag","tagName","thisRef","attributes","encoder","Attribute","trueValue","falseValue","BooleanEncoder","tickerEncode","EnumEncoder","realValue","valuesMap","joinToString","stringSetDecode","initialValues","FinalizeConsumer","partial","HTMLTag","initialAttributes","DelegatingMap","JSDOMBuilder","block","err","downstream","attribute","event","finalize","attributeBooleanTicker","attributeStringString","attributeButtonFormEncTypeEnumButtonFormEncTypeValues","attributeButtonFormMethodEnumButtonFormMethodValues","attributeButtonTypeEnumButtonTypeValues","attributeInputTypeEnumInputTypeValues","attributeBooleanBooleanOnOff","attributeInputFormEncTypeEnumInputFormEncTypeValues","attributeInputFormMethodEnumInputFormMethodValues","attributeTextAreaWrapEnumTextAreaWrapValues","attributeThScopeEnumThScopeValues","immutableEntries","namespace","document","createElement","attributesEntries","setAttribute","appendChild","removeAttribute","createTextNode","innerHTML","childNodes","nodeType","Node","TEXT_NODE","DefaultUnsafe","createComment","visitTag","singletonMapOf","attributeSetStringStringSet","onFinalize","createTree","ownerDocument","StringAttribute","StringSetAttribute","BooleanAttribute","TickerAttribute","EnumAttribute","buttonFormEncTypeValues","buttonFormMethodValues","buttonTypeValues","commandTypeValues","dirValues","draggableValues","formEncTypeValues","formMethodValues","iframeSandboxValues","inputFormEncTypeValues","inputFormMethodValues","inputTypeValues","keyGenKeyTypeValues","runAtValues","textAreaWrapValues","thScopeValues","coerceAtLeast","mapCapacity","mappings","sourceIterator","findAssociatedObject","answer","toDouble","visitTagAndFinalize","attributesMapOf","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","definition","enumerable","Symbol","toStringTag"],"mappings":"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b,ELuIsDqP,GKvI7C9wD,EAAIyhD,GACb,OLqDmEiP,GKrDxDmB,ELqD0EpB,KKrDpEqB,ELqDgFrB,OKrDtF,EL+E6C,IAAAY,GK/EnCQ,EL+E8CpB,KAAK,SK/E9CqB,EL+E0DrB,OAb7B,IAAAY,GAAW,IAaVA,GK/EtBQ,EL+EiCpB,KAAK,SK/EjCqB,EL+E6CrB,OAblBA,KAAK,IKlE3BhP,ELkEsCgP,OK/DtF,mBAmBI,GAAA/Q,EAAO,EADuE,O3FwBZ8Q,G2FvBlD16B,E3FuBmE26B,K2FvB1D53B,E3FuBsE43B,O2FvB/E,EAAc53B,E3FsDwB,IAAA03B,G2FtDf13B,E3FsDyB43B,K2FtDnB,GAAiB53B,EAAK/C,E3FkWhC,IAAAy6B,G2FlWuC7Q,I3FsDO+Q,KAAZ,G2FrDrE,GAAA/Q,EAAO,EAFuE,O3FwBZ8Q,G2FtBlD16B,E3FsBmE26B,K2FtB1D53B,E3FsBsE43B,O2FtB/E,EAAc53B,E3FwCuB,IAAA03B,G2FxCd13B,E3FwCwB43B,K2FxClB,GAAiB36B,EAAO+C,E3FiWlC,IAAA03B,G2FjWwC,GAAC7Q,I3FwCG+Q,KAAX,G2FvC5D,MAAa,GAAyB,iBAGlD,mBAmBI,GAAA/Q,EAAA,WAAO,EAD2E,OLQfgR,GKPnD56B,ELOqE26B,KKP5D53B,ELOwE43B,OKPjF,EAAc53B,ELiC0B,IAAAw4B,GKjCjBx4B,ELiC4B43B,KAAK,SKjC3B,GAAiB53B,EAAK/C,ELyV7B,IAAAu7B,GKzVoC3R,ILiCU+Q,OKhCpF,GAAA/Q,EAAA,WAAO,EAF2E,OLQfgR,GKNnD56B,ELMqE26B,KKN5D53B,ELMwE43B,OKNjF,EAAc53B,ELmByB,IAAAw4B,GKnBhBx4B,ELmB2B43B,KAAK,IKnB1B,GAAiB36B,EAAO+C,ELwV/B,IAAAw4B,GKxVsC3R,EAAD,eLmBO+Q,OKlB1E,MAAa,GAAyB,iB1FlDxB,eAEtB,KAFyD,YAEzD,sBACI,eAGqC,IAAAsB,GAAO,GAE5C,eAGqC,IAAAA,IAAO,GAE5C,gBAGmC,EAEnC,eAGkC,G,0FyF4EtC,WAAkC,uB,uBAElC,WACI,MAAY,YACZ,GAAI,MAAAl0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","file":"index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"orgabowl\"] = factory();\n\telse\n\t\troot[\"orgabowl\"] = factory();\n})(this, function() {\nreturn ","//! @version @js-joda/core - 3.2.0\n//! @copyright (c) 2015-present, Philipp Thürwächter, Pattrick Hüper & js-joda contributors\n//! @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n//! @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n\n/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\nfunction createErrorType(name, init, superErrorClass) {\n  if (superErrorClass === void 0) {\n    superErrorClass = Error;\n  }\n\n  function JsJodaException(message) {\n    if (!Error.captureStackTrace) {\n      this.stack = new Error().stack;\n    } else {\n      Error.captureStackTrace(this, this.constructor);\n    }\n\n    this.message = message;\n    init && init.apply(this, arguments);\n\n    this.toString = function () {\n      return this.name + \": \" + this.message;\n    };\n  }\n\n  JsJodaException.prototype = Object.create(superErrorClass.prototype);\n  JsJodaException.prototype.name = name;\n  JsJodaException.prototype.constructor = JsJodaException;\n  return JsJodaException;\n}\n\nvar DateTimeException = createErrorType('DateTimeException', messageWithCause);\nvar DateTimeParseException = createErrorType('DateTimeParseException', messageForDateTimeParseException);\nvar UnsupportedTemporalTypeException = createErrorType('UnsupportedTemporalTypeException', null, DateTimeException);\nvar ArithmeticException = createErrorType('ArithmeticException');\nvar IllegalArgumentException = createErrorType('IllegalArgumentException');\nvar IllegalStateException = createErrorType('IllegalStateException');\nvar NullPointerException = createErrorType('NullPointerException');\n\nfunction messageWithCause(message, cause) {\n  if (cause === void 0) {\n    cause = null;\n  }\n\n  var msg = message || this.name;\n\n  if (cause !== null && cause instanceof Error) {\n    msg += '\\n-------\\nCaused by: ' + cause.stack + '\\n-------\\n';\n  }\n\n  this.message = msg;\n}\n\nfunction messageForDateTimeParseException(message, text, index, cause) {\n  if (text === void 0) {\n    text = '';\n  }\n\n  if (index === void 0) {\n    index = 0;\n  }\n\n  if (cause === void 0) {\n    cause = null;\n  }\n\n  var msg = message || this.name;\n  msg += ': ' + text + ', at index: ' + index;\n\n  if (cause !== null && cause instanceof Error) {\n    msg += '\\n-------\\nCaused by: ' + cause.stack + '\\n-------\\n';\n  }\n\n  this.message = msg;\n\n  this.parsedString = function () {\n    return text;\n  };\n\n  this.errorIndex = function () {\n    return index;\n  };\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\n/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\nfunction assert(assertion, msg, error) {\n  if (!assertion) {\n    if (error) {\n      throw new error(msg);\n    } else {\n      throw new Error(msg);\n    }\n  }\n}\nfunction requireNonNull(value, parameterName) {\n  if (value == null) {\n    throw new NullPointerException(parameterName + ' must not be null');\n  }\n\n  return value;\n}\nfunction requireInstance(value, _class, parameterName) {\n  if (!(value instanceof _class)) {\n    throw new IllegalArgumentException(parameterName + ' must be an instance of ' + (_class.name ? _class.name : _class) + (value && value.constructor && value.constructor.name ? ', but is ' + value.constructor.name : ''));\n  }\n\n  return value;\n}\nfunction abstractMethodFail(methodName) {\n  throw new TypeError('abstract method \"' + methodName + '\" is not implemented');\n}\n\nvar assert$1 = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    assert: assert,\n    requireNonNull: requireNonNull,\n    requireInstance: requireInstance,\n    abstractMethodFail: abstractMethodFail\n});\n\n/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\nvar MAX_SAFE_INTEGER = 9007199254740991;\nvar MIN_SAFE_INTEGER = -9007199254740991;\nvar MathUtil = function () {\n  function MathUtil() {}\n\n  MathUtil.intDiv = function intDiv(x, y) {\n    var r = x / y;\n    r = MathUtil.roundDown(r);\n    return MathUtil.safeZero(r);\n  };\n\n  MathUtil.intMod = function intMod(x, y) {\n    var r = x - MathUtil.intDiv(x, y) * y;\n    r = MathUtil.roundDown(r);\n    return MathUtil.safeZero(r);\n  };\n\n  MathUtil.roundDown = function roundDown(r) {\n    if (r < 0) {\n      return Math.ceil(r);\n    } else {\n      return Math.floor(r);\n    }\n  };\n\n  MathUtil.floorDiv = function floorDiv(x, y) {\n    var r = Math.floor(x / y);\n    return MathUtil.safeZero(r);\n  };\n\n  MathUtil.floorMod = function floorMod(x, y) {\n    var r = x - MathUtil.floorDiv(x, y) * y;\n    return MathUtil.safeZero(r);\n  };\n\n  MathUtil.safeAdd = function safeAdd(x, y) {\n    MathUtil.verifyInt(x);\n    MathUtil.verifyInt(y);\n\n    if (x === 0) {\n      return MathUtil.safeZero(y);\n    }\n\n    if (y === 0) {\n      return MathUtil.safeZero(x);\n    }\n\n    var r = MathUtil.safeToInt(x + y);\n\n    if (r === x || r === y) {\n      throw new ArithmeticException('Invalid addition beyond MAX_SAFE_INTEGER!');\n    }\n\n    return r;\n  };\n\n  MathUtil.safeSubtract = function safeSubtract(x, y) {\n    MathUtil.verifyInt(x);\n    MathUtil.verifyInt(y);\n\n    if (x === 0 && y === 0) {\n      return 0;\n    } else if (x === 0) {\n      return MathUtil.safeZero(-1 * y);\n    } else if (y === 0) {\n      return MathUtil.safeZero(x);\n    }\n\n    return MathUtil.safeToInt(x - y);\n  };\n\n  MathUtil.safeMultiply = function safeMultiply(x, y) {\n    MathUtil.verifyInt(x);\n    MathUtil.verifyInt(y);\n\n    if (x === 1) {\n      return MathUtil.safeZero(y);\n    }\n\n    if (y === 1) {\n      return MathUtil.safeZero(x);\n    }\n\n    if (x === 0 || y === 0) {\n      return 0;\n    }\n\n    var r = MathUtil.safeToInt(x * y);\n\n    if (r / y !== x || x === MIN_SAFE_INTEGER && y === -1 || y === MIN_SAFE_INTEGER && x === -1) {\n      throw new ArithmeticException('Multiplication overflows: ' + x + ' * ' + y);\n    }\n\n    return r;\n  };\n\n  MathUtil.parseInt = function (_parseInt) {\n    function parseInt(_x) {\n      return _parseInt.apply(this, arguments);\n    }\n\n    parseInt.toString = function () {\n      return _parseInt.toString();\n    };\n\n    return parseInt;\n  }(function (value) {\n    var r = parseInt(value);\n    return MathUtil.safeToInt(r);\n  });\n\n  MathUtil.safeToInt = function safeToInt(value) {\n    MathUtil.verifyInt(value);\n    return MathUtil.safeZero(value);\n  };\n\n  MathUtil.verifyInt = function verifyInt(value) {\n    if (value == null) {\n      throw new ArithmeticException(\"Invalid value: '\" + value + \"', using null or undefined as argument\");\n    }\n\n    if (isNaN(value)) {\n      throw new ArithmeticException('Invalid int value, using NaN as argument');\n    }\n\n    if (value % 1 !== 0) {\n      throw new ArithmeticException(\"Invalid value: '\" + value + \"' is a float\");\n    }\n\n    if (value > MAX_SAFE_INTEGER || value < MIN_SAFE_INTEGER) {\n      throw new ArithmeticException('Calculation overflows an int: ' + value);\n    }\n  };\n\n  MathUtil.safeZero = function safeZero(value) {\n    return value === 0 ? 0 : +value;\n  };\n\n  MathUtil.compareNumbers = function compareNumbers(a, b) {\n    if (a < b) {\n      return -1;\n    }\n\n    if (a > b) {\n      return 1;\n    }\n\n    return 0;\n  };\n\n  MathUtil.smi = function smi(int) {\n    return int >>> 1 & 0x40000000 | int & 0xBFFFFFFF;\n  };\n\n  MathUtil.hash = function hash(number) {\n    if (number !== number || number === Infinity) {\n      return 0;\n    }\n\n    var result = number;\n\n    while (number > 0xFFFFFFFF) {\n      number /= 0xFFFFFFFF;\n      result ^= number;\n    }\n\n    return MathUtil.smi(result);\n  };\n\n  MathUtil.hashCode = function hashCode() {\n    var result = 17;\n\n    for (var _len = arguments.length, numbers = new Array(_len), _key = 0; _key < _len; _key++) {\n      numbers[_key] = arguments[_key];\n    }\n\n    for (var _i = 0, _numbers = numbers; _i < _numbers.length; _i++) {\n      var n = _numbers[_i];\n      result = (result << 5) - result + MathUtil.hash(n);\n    }\n\n    return MathUtil.hash(result);\n  };\n\n  return MathUtil;\n}();\nMathUtil.MAX_SAFE_INTEGER = MAX_SAFE_INTEGER;\nMathUtil.MIN_SAFE_INTEGER = MIN_SAFE_INTEGER;\n\n/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\nvar Enum = function () {\n  function Enum(name) {\n    this._name = name;\n  }\n\n  var _proto = Enum.prototype;\n\n  _proto.equals = function equals(other) {\n    return this === other;\n  };\n\n  _proto.toString = function toString() {\n    return this._name;\n  };\n\n  _proto.toJSON = function toJSON() {\n    return this.toString();\n  };\n\n  return Enum;\n}();\n\n/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\nvar TemporalAmount = function () {\n  function TemporalAmount() {}\n\n  var _proto = TemporalAmount.prototype;\n\n  _proto.get = function get(unit) {\n    abstractMethodFail('get');\n  };\n\n  _proto.units = function units() {\n    abstractMethodFail('units');\n  };\n\n  _proto.addTo = function addTo(temporal) {\n    abstractMethodFail('addTo');\n  };\n\n  _proto.subtractFrom = function subtractFrom(temporal) {\n    abstractMethodFail('subtractFrom');\n  };\n\n  return TemporalAmount;\n}();\n\n/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\nvar TemporalUnit = function () {\n  function TemporalUnit() {}\n\n  var _proto = TemporalUnit.prototype;\n\n  _proto.duration = function duration() {\n    abstractMethodFail('duration');\n  };\n\n  _proto.isDurationEstimated = function isDurationEstimated() {\n    abstractMethodFail('isDurationEstimated');\n  };\n\n  _proto.isDateBased = function isDateBased() {\n    abstractMethodFail('isDateBased');\n  };\n\n  _proto.isTimeBased = function isTimeBased() {\n    abstractMethodFail('isTimeBased');\n  };\n\n  _proto.isSupportedBy = function isSupportedBy(temporal) {\n    abstractMethodFail('isSupportedBy');\n  };\n\n  _proto.addTo = function addTo(dateTime, periodToAdd) {\n    abstractMethodFail('addTo');\n  };\n\n  _proto.between = function between(temporal1, temporal2) {\n    abstractMethodFail('between');\n  };\n\n  return TemporalUnit;\n}();\n\nvar Duration = function (_TemporalAmount) {\n  _inheritsLoose(Duration, _TemporalAmount);\n\n  function Duration(seconds, nanos) {\n    var _this;\n\n    _this = _TemporalAmount.call(this) || this;\n    _this._seconds = MathUtil.safeToInt(seconds);\n    _this._nanos = MathUtil.safeToInt(nanos);\n    return _this;\n  }\n\n  Duration.ofDays = function ofDays(days) {\n    return Duration._create(MathUtil.safeMultiply(days, LocalTime.SECONDS_PER_DAY), 0);\n  };\n\n  Duration.ofHours = function ofHours(hours) {\n    return Duration._create(MathUtil.safeMultiply(hours, LocalTime.SECONDS_PER_HOUR), 0);\n  };\n\n  Duration.ofMinutes = function ofMinutes(minutes) {\n    return Duration._create(MathUtil.safeMultiply(minutes, LocalTime.SECONDS_PER_MINUTE), 0);\n  };\n\n  Duration.ofSeconds = function ofSeconds(seconds, nanoAdjustment) {\n    if (nanoAdjustment === void 0) {\n      nanoAdjustment = 0;\n    }\n\n    var secs = MathUtil.safeAdd(seconds, MathUtil.floorDiv(nanoAdjustment, LocalTime.NANOS_PER_SECOND));\n    var nos = MathUtil.floorMod(nanoAdjustment, LocalTime.NANOS_PER_SECOND);\n    return Duration._create(secs, nos);\n  };\n\n  Duration.ofMillis = function ofMillis(millis) {\n    var secs = MathUtil.intDiv(millis, 1000);\n    var mos = MathUtil.intMod(millis, 1000);\n\n    if (mos < 0) {\n      mos += 1000;\n      secs--;\n    }\n\n    return Duration._create(secs, mos * 1000000);\n  };\n\n  Duration.ofNanos = function ofNanos(nanos) {\n    var secs = MathUtil.intDiv(nanos, LocalTime.NANOS_PER_SECOND);\n    var nos = MathUtil.intMod(nanos, LocalTime.NANOS_PER_SECOND);\n\n    if (nos < 0) {\n      nos += LocalTime.NANOS_PER_SECOND;\n      secs--;\n    }\n\n    return this._create(secs, nos);\n  };\n\n  Duration.of = function of(amount, unit) {\n    return Duration.ZERO.plus(amount, unit);\n  };\n\n  Duration.from = function from(amount) {\n    requireNonNull(amount, 'amount');\n    requireInstance(amount, TemporalAmount);\n    var duration = Duration.ZERO;\n    amount.units().forEach(function (unit) {\n      duration = duration.plus(amount.get(unit), unit);\n    });\n    return duration;\n  };\n\n  Duration.between = function between(startInclusive, endExclusive) {\n    requireNonNull(startInclusive, 'startInclusive');\n    requireNonNull(endExclusive, 'endExclusive');\n    var secs = startInclusive.until(endExclusive, ChronoUnit.SECONDS);\n    var nanos = 0;\n\n    if (startInclusive.isSupported(ChronoField.NANO_OF_SECOND) && endExclusive.isSupported(ChronoField.NANO_OF_SECOND)) {\n      try {\n        var startNos = startInclusive.getLong(ChronoField.NANO_OF_SECOND);\n        nanos = endExclusive.getLong(ChronoField.NANO_OF_SECOND) - startNos;\n\n        if (secs > 0 && nanos < 0) {\n          nanos += LocalTime.NANOS_PER_SECOND;\n        } else if (secs < 0 && nanos > 0) {\n          nanos -= LocalTime.NANOS_PER_SECOND;\n        } else if (secs === 0 && nanos !== 0) {\n          var adjustedEnd = endExclusive.with(ChronoField.NANO_OF_SECOND, startNos);\n          secs = startInclusive.until(adjustedEnd, ChronoUnit.SECONDS);\n        }\n      } catch (e) {}\n    }\n\n    return this.ofSeconds(secs, nanos);\n  };\n\n  Duration.parse = function parse(text) {\n    requireNonNull(text, 'text');\n    var PATTERN = new RegExp('([-+]?)P(?:([-+]?[0-9]+)D)?(T(?:([-+]?[0-9]+)H)?(?:([-+]?[0-9]+)M)?(?:([-+]?[0-9]+)(?:[.,]([0-9]{0,9}))?S)?)?', 'i');\n    var matches = PATTERN.exec(text);\n\n    if (matches !== null) {\n      if ('T' === matches[3] === false) {\n        var negate = '-' === matches[1];\n        var dayMatch = matches[2];\n        var hourMatch = matches[4];\n        var minuteMatch = matches[5];\n        var secondMatch = matches[6];\n        var fractionMatch = matches[7];\n\n        if (dayMatch != null || hourMatch != null || minuteMatch != null || secondMatch != null) {\n          var daysAsSecs = Duration._parseNumber(text, dayMatch, LocalTime.SECONDS_PER_DAY, 'days');\n\n          var hoursAsSecs = Duration._parseNumber(text, hourMatch, LocalTime.SECONDS_PER_HOUR, 'hours');\n\n          var minsAsSecs = Duration._parseNumber(text, minuteMatch, LocalTime.SECONDS_PER_MINUTE, 'minutes');\n\n          var seconds = Duration._parseNumber(text, secondMatch, 1, 'seconds');\n\n          var negativeSecs = secondMatch != null && secondMatch.charAt(0) === '-';\n\n          var nanos = Duration._parseFraction(text, fractionMatch, negativeSecs ? -1 : 1);\n\n          try {\n            return Duration._create(negate, daysAsSecs, hoursAsSecs, minsAsSecs, seconds, nanos);\n          } catch (ex) {\n            throw new DateTimeParseException('Text cannot be parsed to a Duration: overflow', text, 0, ex);\n          }\n        }\n      }\n    }\n\n    throw new DateTimeParseException('Text cannot be parsed to a Duration', text, 0);\n  };\n\n  Duration._parseNumber = function _parseNumber(text, parsed, multiplier, errorText) {\n    if (parsed == null) {\n      return 0;\n    }\n\n    try {\n      if (parsed[0] === '+') {\n        parsed = parsed.substring(1);\n      }\n\n      return MathUtil.safeMultiply(parseFloat(parsed), multiplier);\n    } catch (ex) {\n      throw new DateTimeParseException('Text cannot be parsed to a Duration: ' + errorText, text, 0, ex);\n    }\n  };\n\n  Duration._parseFraction = function _parseFraction(text, parsed, negate) {\n    if (parsed == null || parsed.length === 0) {\n      return 0;\n    }\n\n    parsed = (parsed + '000000000').substring(0, 9);\n    return parseFloat(parsed) * negate;\n  };\n\n  Duration._create = function _create() {\n    if (arguments.length <= 2) {\n      return Duration._createSecondsNanos(arguments[0], arguments[1]);\n    } else {\n      return Duration._createNegateDaysHoursMinutesSecondsNanos(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);\n    }\n  };\n\n  Duration._createNegateDaysHoursMinutesSecondsNanos = function _createNegateDaysHoursMinutesSecondsNanos(negate, daysAsSecs, hoursAsSecs, minsAsSecs, secs, nanos) {\n    var seconds = MathUtil.safeAdd(daysAsSecs, MathUtil.safeAdd(hoursAsSecs, MathUtil.safeAdd(minsAsSecs, secs)));\n\n    if (negate) {\n      return Duration.ofSeconds(seconds, nanos).negated();\n    }\n\n    return Duration.ofSeconds(seconds, nanos);\n  };\n\n  Duration._createSecondsNanos = function _createSecondsNanos(seconds, nanoAdjustment) {\n    if (seconds === void 0) {\n      seconds = 0;\n    }\n\n    if (nanoAdjustment === void 0) {\n      nanoAdjustment = 0;\n    }\n\n    if (seconds === 0 && nanoAdjustment === 0) {\n      return Duration.ZERO;\n    }\n\n    return new Duration(seconds, nanoAdjustment);\n  };\n\n  var _proto = Duration.prototype;\n\n  _proto.get = function get(unit) {\n    if (unit === ChronoUnit.SECONDS) {\n      return this._seconds;\n    } else if (unit === ChronoUnit.NANOS) {\n      return this._nanos;\n    } else {\n      throw new UnsupportedTemporalTypeException('Unsupported unit: ' + unit);\n    }\n  };\n\n  _proto.units = function units() {\n    return [ChronoUnit.SECONDS, ChronoUnit.NANOS];\n  };\n\n  _proto.isZero = function isZero() {\n    return this._seconds === 0 && this._nanos === 0;\n  };\n\n  _proto.isNegative = function isNegative() {\n    return this._seconds < 0;\n  };\n\n  _proto.seconds = function seconds() {\n    return this._seconds;\n  };\n\n  _proto.nano = function nano() {\n    return this._nanos;\n  };\n\n  _proto.withSeconds = function withSeconds(seconds) {\n    return Duration._create(seconds, this._nanos);\n  };\n\n  _proto.withNanos = function withNanos(nanoOfSecond) {\n    ChronoField.NANO_OF_SECOND.checkValidIntValue(nanoOfSecond);\n    return Duration._create(this._seconds, nanoOfSecond);\n  };\n\n  _proto.plusDuration = function plusDuration(duration) {\n    requireNonNull(duration, 'duration');\n    return this.plus(duration.seconds(), duration.nano());\n  };\n\n  _proto.plus = function plus(durationOrNumber, unitOrNumber) {\n    if (arguments.length === 1) {\n      return this.plusDuration(durationOrNumber);\n    } else if (arguments.length === 2 && unitOrNumber instanceof TemporalUnit) {\n      return this.plusAmountUnit(durationOrNumber, unitOrNumber);\n    } else {\n      return this.plusSecondsNanos(durationOrNumber, unitOrNumber);\n    }\n  };\n\n  _proto.plusAmountUnit = function plusAmountUnit(amountToAdd, unit) {\n    requireNonNull(amountToAdd, 'amountToAdd');\n    requireNonNull(unit, 'unit');\n\n    if (unit === ChronoUnit.DAYS) {\n      return this.plusSecondsNanos(MathUtil.safeMultiply(amountToAdd, LocalTime.SECONDS_PER_DAY), 0);\n    }\n\n    if (unit.isDurationEstimated()) {\n      throw new UnsupportedTemporalTypeException('Unit must not have an estimated duration');\n    }\n\n    if (amountToAdd === 0) {\n      return this;\n    }\n\n    if (unit instanceof ChronoUnit) {\n      switch (unit) {\n        case ChronoUnit.NANOS:\n          return this.plusNanos(amountToAdd);\n\n        case ChronoUnit.MICROS:\n          return this.plusSecondsNanos(MathUtil.intDiv(amountToAdd, 1000000 * 1000) * 1000, MathUtil.intMod(amountToAdd, 1000000 * 1000) * 1000);\n\n        case ChronoUnit.MILLIS:\n          return this.plusMillis(amountToAdd);\n\n        case ChronoUnit.SECONDS:\n          return this.plusSeconds(amountToAdd);\n      }\n\n      return this.plusSecondsNanos(MathUtil.safeMultiply(unit.duration().seconds(), amountToAdd), 0);\n    }\n\n    var duration = unit.duration().multipliedBy(amountToAdd);\n    return this.plusSecondsNanos(duration.seconds(), duration.nano());\n  };\n\n  _proto.plusDays = function plusDays(daysToAdd) {\n    return this.plusSecondsNanos(MathUtil.safeMultiply(daysToAdd, LocalTime.SECONDS_PER_DAY), 0);\n  };\n\n  _proto.plusHours = function plusHours(hoursToAdd) {\n    return this.plusSecondsNanos(MathUtil.safeMultiply(hoursToAdd, LocalTime.SECONDS_PER_HOUR), 0);\n  };\n\n  _proto.plusMinutes = function plusMinutes(minutesToAdd) {\n    return this.plusSecondsNanos(MathUtil.safeMultiply(minutesToAdd, LocalTime.SECONDS_PER_MINUTE), 0);\n  };\n\n  _proto.plusSeconds = function plusSeconds(secondsToAdd) {\n    return this.plusSecondsNanos(secondsToAdd, 0);\n  };\n\n  _proto.plusMillis = function plusMillis(millisToAdd) {\n    return this.plusSecondsNanos(MathUtil.intDiv(millisToAdd, 1000), MathUtil.intMod(millisToAdd, 1000) * 1000000);\n  };\n\n  _proto.plusNanos = function plusNanos(nanosToAdd) {\n    return this.plusSecondsNanos(0, nanosToAdd);\n  };\n\n  _proto.plusSecondsNanos = function plusSecondsNanos(secondsToAdd, nanosToAdd) {\n    requireNonNull(secondsToAdd, 'secondsToAdd');\n    requireNonNull(nanosToAdd, 'nanosToAdd');\n\n    if (secondsToAdd === 0 && nanosToAdd === 0) {\n      return this;\n    }\n\n    var epochSec = MathUtil.safeAdd(this._seconds, secondsToAdd);\n    epochSec = MathUtil.safeAdd(epochSec, MathUtil.intDiv(nanosToAdd, LocalTime.NANOS_PER_SECOND));\n    nanosToAdd = MathUtil.intMod(nanosToAdd, LocalTime.NANOS_PER_SECOND);\n    var nanoAdjustment = MathUtil.safeAdd(this._nanos, nanosToAdd);\n    return Duration.ofSeconds(epochSec, nanoAdjustment);\n  };\n\n  _proto.minus = function minus(durationOrNumber, unit) {\n    if (arguments.length === 1) {\n      return this.minusDuration(durationOrNumber);\n    } else {\n      return this.minusAmountUnit(durationOrNumber, unit);\n    }\n  };\n\n  _proto.minusDuration = function minusDuration(duration) {\n    requireNonNull(duration, 'duration');\n    var secsToSubtract = duration.seconds();\n    var nanosToSubtract = duration.nano();\n\n    if (secsToSubtract === MIN_SAFE_INTEGER) {\n      return this.plus(MAX_SAFE_INTEGER, -nanosToSubtract);\n    }\n\n    return this.plus(-secsToSubtract, -nanosToSubtract);\n  };\n\n  _proto.minusAmountUnit = function minusAmountUnit(amountToSubtract, unit) {\n    requireNonNull(amountToSubtract, 'amountToSubtract');\n    requireNonNull(unit, 'unit');\n    return amountToSubtract === MIN_SAFE_INTEGER ? this.plusAmountUnit(MAX_SAFE_INTEGER, unit) : this.plusAmountUnit(-amountToSubtract, unit);\n  };\n\n  _proto.minusDays = function minusDays(daysToSubtract) {\n    return daysToSubtract === MIN_SAFE_INTEGER ? this.plusDays(MAX_SAFE_INTEGER) : this.plusDays(-daysToSubtract);\n  };\n\n  _proto.minusHours = function minusHours(hoursToSubtract) {\n    return hoursToSubtract === MIN_SAFE_INTEGER ? this.plusHours(MAX_SAFE_INTEGER) : this.plusHours(-hoursToSubtract);\n  };\n\n  _proto.minusMinutes = function minusMinutes(minutesToSubtract) {\n    return minutesToSubtract === MIN_SAFE_INTEGER ? this.plusMinutes(MAX_SAFE_INTEGER) : this.plusMinutes(-minutesToSubtract);\n  };\n\n  _proto.minusSeconds = function minusSeconds(secondsToSubtract) {\n    return secondsToSubtract === MIN_SAFE_INTEGER ? this.plusSeconds(MAX_SAFE_INTEGER) : this.plusSeconds(-secondsToSubtract);\n  };\n\n  _proto.minusMillis = function minusMillis(millisToSubtract) {\n    return millisToSubtract === MIN_SAFE_INTEGER ? this.plusMillis(MAX_SAFE_INTEGER) : this.plusMillis(-millisToSubtract);\n  };\n\n  _proto.minusNanos = function minusNanos(nanosToSubtract) {\n    return nanosToSubtract === MIN_SAFE_INTEGER ? this.plusNanos(MAX_SAFE_INTEGER) : this.plusNanos(-nanosToSubtract);\n  };\n\n  _proto.multipliedBy = function multipliedBy(multiplicand) {\n    if (multiplicand === 0) {\n      return Duration.ZERO;\n    }\n\n    if (multiplicand === 1) {\n      return this;\n    }\n\n    var secs = MathUtil.safeMultiply(this._seconds, multiplicand);\n    var nos = MathUtil.safeMultiply(this._nanos, multiplicand);\n    secs = secs + MathUtil.intDiv(nos, LocalTime.NANOS_PER_SECOND);\n    nos = MathUtil.intMod(nos, LocalTime.NANOS_PER_SECOND);\n    return Duration.ofSeconds(secs, nos);\n  };\n\n  _proto.dividedBy = function dividedBy(divisor) {\n    if (divisor === 0) {\n      throw new ArithmeticException('Cannot divide by zero');\n    }\n\n    if (divisor === 1) {\n      return this;\n    }\n\n    var secs = MathUtil.intDiv(this._seconds, divisor);\n    var secsMod = MathUtil.roundDown((this._seconds / divisor - secs) * LocalTime.NANOS_PER_SECOND);\n    var nos = MathUtil.intDiv(this._nanos, divisor);\n    nos = secsMod + nos;\n    return Duration.ofSeconds(secs, nos);\n  };\n\n  _proto.negated = function negated() {\n    return this.multipliedBy(-1);\n  };\n\n  _proto.abs = function abs() {\n    return this.isNegative() ? this.negated() : this;\n  };\n\n  _proto.addTo = function addTo(temporal) {\n    requireNonNull(temporal, 'temporal');\n\n    if (this._seconds !== 0) {\n      temporal = temporal.plus(this._seconds, ChronoUnit.SECONDS);\n    }\n\n    if (this._nanos !== 0) {\n      temporal = temporal.plus(this._nanos, ChronoUnit.NANOS);\n    }\n\n    return temporal;\n  };\n\n  _proto.subtractFrom = function subtractFrom(temporal) {\n    requireNonNull(temporal, 'temporal');\n\n    if (this._seconds !== 0) {\n      temporal = temporal.minus(this._seconds, ChronoUnit.SECONDS);\n    }\n\n    if (this._nanos !== 0) {\n      temporal = temporal.minus(this._nanos, ChronoUnit.NANOS);\n    }\n\n    return temporal;\n  };\n\n  _proto.toDays = function toDays() {\n    return MathUtil.intDiv(this._seconds, LocalTime.SECONDS_PER_DAY);\n  };\n\n  _proto.toHours = function toHours() {\n    return MathUtil.intDiv(this._seconds, LocalTime.SECONDS_PER_HOUR);\n  };\n\n  _proto.toMinutes = function toMinutes() {\n    return MathUtil.intDiv(this._seconds, LocalTime.SECONDS_PER_MINUTE);\n  };\n\n  _proto.toMillis = function toMillis() {\n    var millis = Math.round(MathUtil.safeMultiply(this._seconds, 1000));\n    millis = MathUtil.safeAdd(millis, MathUtil.intDiv(this._nanos, 1000000));\n    return millis;\n  };\n\n  _proto.toNanos = function toNanos() {\n    var totalNanos = MathUtil.safeMultiply(this._seconds, LocalTime.NANOS_PER_SECOND);\n    totalNanos = MathUtil.safeAdd(totalNanos, this._nanos);\n    return totalNanos;\n  };\n\n  _proto.compareTo = function compareTo(otherDuration) {\n    requireNonNull(otherDuration, 'otherDuration');\n    requireInstance(otherDuration, Duration, 'otherDuration');\n    var cmp = MathUtil.compareNumbers(this._seconds, otherDuration.seconds());\n\n    if (cmp !== 0) {\n      return cmp;\n    }\n\n    return this._nanos - otherDuration.nano();\n  };\n\n  _proto.equals = function equals(otherDuration) {\n    if (this === otherDuration) {\n      return true;\n    }\n\n    if (otherDuration instanceof Duration) {\n      return this.seconds() === otherDuration.seconds() && this.nano() === otherDuration.nano();\n    }\n\n    return false;\n  };\n\n  _proto.toString = function toString() {\n    if (this === Duration.ZERO) {\n      return 'PT0S';\n    }\n\n    var hours = MathUtil.intDiv(this._seconds, LocalTime.SECONDS_PER_HOUR);\n    var minutes = MathUtil.intDiv(MathUtil.intMod(this._seconds, LocalTime.SECONDS_PER_HOUR), LocalTime.SECONDS_PER_MINUTE);\n    var secs = MathUtil.intMod(this._seconds, LocalTime.SECONDS_PER_MINUTE);\n    var rval = 'PT';\n\n    if (hours !== 0) {\n      rval += hours + 'H';\n    }\n\n    if (minutes !== 0) {\n      rval += minutes + 'M';\n    }\n\n    if (secs === 0 && this._nanos === 0 && rval.length > 2) {\n      return rval;\n    }\n\n    if (secs < 0 && this._nanos > 0) {\n      if (secs === -1) {\n        rval += '-0';\n      } else {\n        rval += secs + 1;\n      }\n    } else {\n      rval += secs;\n    }\n\n    if (this._nanos > 0) {\n      rval += '.';\n      var nanoString;\n\n      if (secs < 0) {\n        nanoString = '' + (2 * LocalTime.NANOS_PER_SECOND - this._nanos);\n      } else {\n        nanoString = '' + (LocalTime.NANOS_PER_SECOND + this._nanos);\n      }\n\n      nanoString = nanoString.slice(1, nanoString.length);\n      rval += nanoString;\n\n      while (rval.charAt(rval.length - 1) === '0') {\n        rval = rval.slice(0, rval.length - 1);\n      }\n    }\n\n    rval += 'S';\n    return rval;\n  };\n\n  _proto.toJSON = function toJSON() {\n    return this.toString();\n  };\n\n  return Duration;\n}(TemporalAmount);\nfunction _init() {\n  Duration.ZERO = new Duration(0, 0);\n}\n\n/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @license BSD-3-Clause (see LICENSE.md in the root directory of this source tree)\n */\nvar YearConstants = function YearConstants() {};\nfunction _init$1() {\n  YearConstants.MIN_VALUE = -999999;\n  YearConstants.MAX_VALUE = 999999;\n}\n\nvar ChronoUnit = function (_TemporalUnit) {\n  _inheritsLoose(ChronoUnit, _TemporalUnit);\n\n  function ChronoUnit(name, estimatedDuration) {\n    var _this;\n\n    _this = _TemporalUnit.call(this) || this;\n    _this._name = name;\n    _this._duration = estimatedDuration;\n    return _this;\n  }\n\n  var _proto = ChronoUnit.prototype;\n\n  _proto.duration = function duration() {\n    return this._duration;\n  };\n\n  _proto.isDurationEstimated = function isDurationEstimated() {\n    return this.isDateBased() || this === ChronoUnit.FOREVER;\n  };\n\n  _proto.isDateBased = function isDateBased() {\n    return this.compareTo(ChronoUnit.DAYS) >= 0 && this !== ChronoUnit.FOREVER;\n  };\n\n  _proto.isTimeBased = function isTimeBased() {\n    return this.compareTo(ChronoUnit.DAYS) < 0;\n  };\n\n  _proto.isSupportedBy = function isSupportedBy(temporal) {\n    if (this === ChronoUnit.FOREVER) {\n      return false;\n    }\n\n    try {\n      temporal.plus(1, this);\n      return true;\n    } catch (e) {\n      try {\n        temporal.plus(-1, this);\n        return true;\n      } catch (e2) {\n        return false;\n      }\n    }\n  };\n\n  _proto.addTo = function addTo(temporal, amount) {\n    return temporal.plus(amount, this);\n  };\n\n  _proto.between = function between(temporal1, temporal2) {\n    return temporal1.until(temporal2, this);\n  };\n\n  _proto.toString = function toString() {\n    return this._name;\n  };\n\n  _proto.compareTo = function compareTo(other) {\n    return this.duration().compareTo(other.duration());\n  };\n\n  return ChronoUnit;\n}(TemporalUnit);\nfunction _init$2() {\n  ChronoUnit.NANOS = new ChronoUnit('Nanos', Duration.ofNanos(1));\n  ChronoUnit.MICROS = new ChronoUnit('Micros', Duration.ofNanos(1000));\n  ChronoUnit.MILLIS = new ChronoUnit('Millis', Duration.ofNanos(1000000));\n  ChronoUnit.SECONDS = new ChronoUnit('Seconds', Duration.ofSeconds(1));\n  ChronoUnit.MINUTES = new ChronoUnit('Minutes', Duration.ofSeconds(60));\n  ChronoUnit.HOURS = new ChronoUnit('Hours', Duration.ofSeconds(3600));\n  ChronoUnit.HALF_DAYS = new ChronoUnit('HalfDays', Duration.ofSeconds(43200));\n  ChronoUnit.DAYS = new ChronoUnit('Days', Duration.ofSeconds(86400));\n  ChronoUnit.WEEKS = new ChronoUnit('Weeks', Duration.ofSeconds(7 * 86400));\n  ChronoUnit.MONTHS = new ChronoUnit('Months', Duration.ofSeconds(31556952 / 12));\n  ChronoUnit.YEARS = new ChronoUnit('Years', Duration.ofSeconds(31556952));\n  ChronoUnit.DECADES = new ChronoUnit('Decades', Duration.ofSeconds(31556952 * 10));\n  ChronoUnit.CENTURIES = new ChronoUnit('Centuries', Duration.ofSeconds(31556952 * 100));\n  ChronoUnit.MILLENNIA = new ChronoUnit('Millennia', Duration.ofSeconds(31556952 * 1000));\n  ChronoUnit.ERAS = new ChronoUnit('Eras', Duration.ofSeconds(31556952 * (YearConstants.MAX_VALUE + 1)));\n  ChronoUnit.FOREVER = new ChronoUnit('Forever', Duration.ofSeconds(MathUtil.MAX_SAFE_INTEGER, 999999999));\n}\n\n/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nvar TemporalField = function () {\n  function TemporalField() {}\n\n  var _proto = TemporalField.prototype;\n\n  _proto.isDateBased = function isDateBased() {\n    abstractMethodFail('isDateBased');\n  };\n\n  _proto.isTimeBased = function isTimeBased() {\n    abstractMethodFail('isTimeBased');\n  };\n\n  _proto.baseUnit = function baseUnit() {\n    abstractMethodFail('baseUnit');\n  };\n\n  _proto.rangeUnit = function rangeUnit() {\n    abstractMethodFail('rangeUnit');\n  };\n\n  _proto.range = function range() {\n    abstractMethodFail('range');\n  };\n\n  _proto.rangeRefinedBy = function rangeRefinedBy(temporal) {\n    abstractMethodFail('rangeRefinedBy');\n  };\n\n  _proto.getFrom = function getFrom(temporal) {\n    abstractMethodFail('getFrom');\n  };\n\n  _proto.adjustInto = function adjustInto(temporal, newValue) {\n    abstractMethodFail('adjustInto');\n  };\n\n  _proto.isSupportedBy = function isSupportedBy(temporal) {\n    abstractMethodFail('isSupportedBy');\n  };\n\n  _proto.displayName = function displayName() {\n    abstractMethodFail('displayName');\n  };\n\n  _proto.equals = function equals(other) {\n    abstractMethodFail('equals');\n  };\n\n  _proto.name = function name() {\n    abstractMethodFail('name');\n  };\n\n  return TemporalField;\n}();\n\n/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\nvar ValueRange = function () {\n  function ValueRange(minSmallest, minLargest, maxSmallest, maxLargest) {\n    assert(!(minSmallest > minLargest), 'Smallest minimum value \\'' + minSmallest + '\\' must be less than largest minimum value \\'' + minLargest + '\\'', IllegalArgumentException);\n    assert(!(maxSmallest > maxLargest), 'Smallest maximum value \\'' + maxSmallest + '\\' must be less than largest maximum value \\'' + maxLargest + '\\'', IllegalArgumentException);\n    assert(!(minLargest > maxLargest), 'Minimum value \\'' + minLargest + '\\' must be less than maximum value \\'' + maxLargest + '\\'', IllegalArgumentException);\n    this._minSmallest = minSmallest;\n    this._minLargest = minLargest;\n    this._maxLargest = maxLargest;\n    this._maxSmallest = maxSmallest;\n  }\n\n  var _proto = ValueRange.prototype;\n\n  _proto.isFixed = function isFixed() {\n    return this._minSmallest === this._minLargest && this._maxSmallest === this._maxLargest;\n  };\n\n  _proto.minimum = function minimum() {\n    return this._minSmallest;\n  };\n\n  _proto.largestMinimum = function largestMinimum() {\n    return this._minLargest;\n  };\n\n  _proto.maximum = function maximum() {\n    return this._maxLargest;\n  };\n\n  _proto.smallestMaximum = function smallestMaximum() {\n    return this._maxSmallest;\n  };\n\n  _proto.isValidValue = function isValidValue(value) {\n    return this.minimum() <= value && value <= this.maximum();\n  };\n\n  _proto.checkValidValue = function checkValidValue(value, field) {\n    var msg;\n\n    if (!this.isValidValue(value)) {\n      if (field != null) {\n        msg = 'Invalid value for ' + field + ' (valid values ' + this.toString() + '): ' + value;\n      } else {\n        msg = 'Invalid value (valid values ' + this.toString() + '): ' + value;\n      }\n\n      return assert(false, msg, DateTimeException);\n    }\n\n    return value;\n  };\n\n  _proto.checkValidIntValue = function checkValidIntValue(value, field) {\n    if (this.isValidIntValue(value) === false) {\n      throw new DateTimeException('Invalid int value for ' + field + ': ' + value);\n    }\n\n    return value;\n  };\n\n  _proto.isValidIntValue = function isValidIntValue(value) {\n    return this.isIntValue() && this.isValidValue(value);\n  };\n\n  _proto.isIntValue = function isIntValue() {\n    return this.minimum() >= MathUtil.MIN_SAFE_INTEGER && this.maximum() <= MathUtil.MAX_SAFE_INTEGER;\n  };\n\n  _proto.equals = function equals(other) {\n    if (other === this) {\n      return true;\n    }\n\n    if (other instanceof ValueRange) {\n      return this._minSmallest === other._minSmallest && this._minLargest === other._minLargest && this._maxSmallest === other._maxSmallest && this._maxLargest === other._maxLargest;\n    }\n\n    return false;\n  };\n\n  _proto.hashCode = function hashCode() {\n    return MathUtil.hashCode(this._minSmallest, this._minLargest, this._maxSmallest, this._maxLargest);\n  };\n\n  _proto.toString = function toString() {\n    var str = this.minimum() + (this.minimum() !== this.largestMinimum() ? '/' + this.largestMinimum() : '');\n    str += ' - ';\n    str += this.smallestMaximum() + (this.smallestMaximum() !== this.maximum() ? '/' + this.maximum() : '');\n    return str;\n  };\n\n  ValueRange.of = function of() {\n    if (arguments.length === 2) {\n      return new ValueRange(arguments[0], arguments[0], arguments[1], arguments[1]);\n    } else if (arguments.length === 3) {\n      return new ValueRange(arguments[0], arguments[0], arguments[1], arguments[2]);\n    } else if (arguments.length === 4) {\n      return new ValueRange(arguments[0], arguments[1], arguments[2], arguments[3]);\n    } else {\n      return assert(false, 'Invalid number of arguments ' + arguments.length, IllegalArgumentException);\n    }\n  };\n\n  return ValueRange;\n}();\n\nvar ChronoField = function (_TemporalField) {\n  _inheritsLoose(ChronoField, _TemporalField);\n\n  ChronoField.byName = function byName(fieldName) {\n    for (var prop in ChronoField) {\n      if (ChronoField[prop]) {\n        if (ChronoField[prop] instanceof ChronoField && ChronoField[prop].name() === fieldName) {\n          return ChronoField[prop];\n        }\n      }\n    }\n  };\n\n  function ChronoField(name, baseUnit, rangeUnit, range) {\n    var _this;\n\n    _this = _TemporalField.call(this) || this;\n    _this._name = name;\n    _this._baseUnit = baseUnit;\n    _this._rangeUnit = rangeUnit;\n    _this._range = range;\n    return _this;\n  }\n\n  var _proto = ChronoField.prototype;\n\n  _proto.name = function name() {\n    return this._name;\n  };\n\n  _proto.baseUnit = function baseUnit() {\n    return this._baseUnit;\n  };\n\n  _proto.rangeUnit = function rangeUnit() {\n    return this._rangeUnit;\n  };\n\n  _proto.range = function range() {\n    return this._range;\n  };\n\n  _proto.displayName = function displayName() {\n    return this.toString();\n  };\n\n  _proto.checkValidValue = function checkValidValue(value) {\n    return this.range().checkValidValue(value, this);\n  };\n\n  _proto.checkValidIntValue = function checkValidIntValue(value) {\n    return this.range().checkValidIntValue(value, this);\n  };\n\n  _proto.isDateBased = function isDateBased() {\n    var dateBased = this === ChronoField.DAY_OF_WEEK || this === ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH || this === ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR || this === ChronoField.DAY_OF_MONTH || this === ChronoField.DAY_OF_YEAR || this === ChronoField.EPOCH_DAY || this === ChronoField.ALIGNED_WEEK_OF_MONTH || this === ChronoField.ALIGNED_WEEK_OF_YEAR || this === ChronoField.MONTH_OF_YEAR || this === ChronoField.YEAR_OF_ERA || this === ChronoField.YEAR || this === ChronoField.ERA;\n    return dateBased;\n  };\n\n  _proto.isTimeBased = function isTimeBased() {\n    var timeBased = this === ChronoField.NANO_OF_SECOND || this === ChronoField.NANO_OF_DAY || this === ChronoField.MICRO_OF_SECOND || this === ChronoField.MICRO_OF_DAY || this === ChronoField.MILLI_OF_SECOND || this === ChronoField.MILLI_OF_DAY || this === ChronoField.SECOND_OF_MINUTE || this === ChronoField.SECOND_OF_DAY || this === ChronoField.MINUTE_OF_HOUR || this === ChronoField.MINUTE_OF_DAY || this === ChronoField.HOUR_OF_AMPM || this === ChronoField.CLOCK_HOUR_OF_AMPM || this === ChronoField.HOUR_OF_DAY || this === ChronoField.CLOCK_HOUR_OF_DAY || this === ChronoField.AMPM_OF_DAY;\n    return timeBased;\n  };\n\n  _proto.rangeRefinedBy = function rangeRefinedBy(temporal) {\n    return temporal.range(this);\n  };\n\n  _proto.getFrom = function getFrom(temporal) {\n    return temporal.getLong(this);\n  };\n\n  _proto.toString = function toString() {\n    return this.name();\n  };\n\n  _proto.equals = function equals(other) {\n    return this === other;\n  };\n\n  _proto.adjustInto = function adjustInto(temporal, newValue) {\n    return temporal.with(this, newValue);\n  };\n\n  _proto.isSupportedBy = function isSupportedBy(temporal) {\n    return temporal.isSupported(this);\n  };\n\n  return ChronoField;\n}(TemporalField);\nfunction _init$3() {\n  ChronoField.NANO_OF_SECOND = new ChronoField('NanoOfSecond', ChronoUnit.NANOS, ChronoUnit.SECONDS, ValueRange.of(0, 999999999));\n  ChronoField.NANO_OF_DAY = new ChronoField('NanoOfDay', ChronoUnit.NANOS, ChronoUnit.DAYS, ValueRange.of(0, 86400 * 1000000000 - 1));\n  ChronoField.MICRO_OF_SECOND = new ChronoField('MicroOfSecond', ChronoUnit.MICROS, ChronoUnit.SECONDS, ValueRange.of(0, 999999));\n  ChronoField.MICRO_OF_DAY = new ChronoField('MicroOfDay', ChronoUnit.MICROS, ChronoUnit.DAYS, ValueRange.of(0, 86400 * 1000000 - 1));\n  ChronoField.MILLI_OF_SECOND = new ChronoField('MilliOfSecond', ChronoUnit.MILLIS, ChronoUnit.SECONDS, ValueRange.of(0, 999));\n  ChronoField.MILLI_OF_DAY = new ChronoField('MilliOfDay', ChronoUnit.MILLIS, ChronoUnit.DAYS, ValueRange.of(0, 86400 * 1000 - 1));\n  ChronoField.SECOND_OF_MINUTE = new ChronoField('SecondOfMinute', ChronoUnit.SECONDS, ChronoUnit.MINUTES, ValueRange.of(0, 59));\n  ChronoField.SECOND_OF_DAY = new ChronoField('SecondOfDay', ChronoUnit.SECONDS, ChronoUnit.DAYS, ValueRange.of(0, 86400 - 1));\n  ChronoField.MINUTE_OF_HOUR = new ChronoField('MinuteOfHour', ChronoUnit.MINUTES, ChronoUnit.HOURS, ValueRange.of(0, 59));\n  ChronoField.MINUTE_OF_DAY = new ChronoField('MinuteOfDay', ChronoUnit.MINUTES, ChronoUnit.DAYS, ValueRange.of(0, 24 * 60 - 1));\n  ChronoField.HOUR_OF_AMPM = new ChronoField('HourOfAmPm', ChronoUnit.HOURS, ChronoUnit.HALF_DAYS, ValueRange.of(0, 11));\n  ChronoField.CLOCK_HOUR_OF_AMPM = new ChronoField('ClockHourOfAmPm', ChronoUnit.HOURS, ChronoUnit.HALF_DAYS, ValueRange.of(1, 12));\n  ChronoField.HOUR_OF_DAY = new ChronoField('HourOfDay', ChronoUnit.HOURS, ChronoUnit.DAYS, ValueRange.of(0, 23));\n  ChronoField.CLOCK_HOUR_OF_DAY = new ChronoField('ClockHourOfDay', ChronoUnit.HOURS, ChronoUnit.DAYS, ValueRange.of(1, 24));\n  ChronoField.AMPM_OF_DAY = new ChronoField('AmPmOfDay', ChronoUnit.HALF_DAYS, ChronoUnit.DAYS, ValueRange.of(0, 1));\n  ChronoField.DAY_OF_WEEK = new ChronoField('DayOfWeek', ChronoUnit.DAYS, ChronoUnit.WEEKS, ValueRange.of(1, 7));\n  ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH = new ChronoField('AlignedDayOfWeekInMonth', ChronoUnit.DAYS, ChronoUnit.WEEKS, ValueRange.of(1, 7));\n  ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR = new ChronoField('AlignedDayOfWeekInYear', ChronoUnit.DAYS, ChronoUnit.WEEKS, ValueRange.of(1, 7));\n  ChronoField.DAY_OF_MONTH = new ChronoField('DayOfMonth', ChronoUnit.DAYS, ChronoUnit.MONTHS, ValueRange.of(1, 28, 31), 'day');\n  ChronoField.DAY_OF_YEAR = new ChronoField('DayOfYear', ChronoUnit.DAYS, ChronoUnit.YEARS, ValueRange.of(1, 365, 366));\n  ChronoField.EPOCH_DAY = new ChronoField('EpochDay', ChronoUnit.DAYS, ChronoUnit.FOREVER, ValueRange.of(Math.floor(YearConstants.MIN_VALUE * 365.25), Math.floor(YearConstants.MAX_VALUE * 365.25)));\n  ChronoField.ALIGNED_WEEK_OF_MONTH = new ChronoField('AlignedWeekOfMonth', ChronoUnit.WEEKS, ChronoUnit.MONTHS, ValueRange.of(1, 4, 5));\n  ChronoField.ALIGNED_WEEK_OF_YEAR = new ChronoField('AlignedWeekOfYear', ChronoUnit.WEEKS, ChronoUnit.YEARS, ValueRange.of(1, 53));\n  ChronoField.MONTH_OF_YEAR = new ChronoField('MonthOfYear', ChronoUnit.MONTHS, ChronoUnit.YEARS, ValueRange.of(1, 12), 'month');\n  ChronoField.PROLEPTIC_MONTH = new ChronoField('ProlepticMonth', ChronoUnit.MONTHS, ChronoUnit.FOREVER, ValueRange.of(YearConstants.MIN_VALUE * 12, YearConstants.MAX_VALUE * 12 + 11));\n  ChronoField.YEAR_OF_ERA = new ChronoField('YearOfEra', ChronoUnit.YEARS, ChronoUnit.FOREVER, ValueRange.of(1, YearConstants.MAX_VALUE, YearConstants.MAX_VALUE + 1));\n  ChronoField.YEAR = new ChronoField('Year', ChronoUnit.YEARS, ChronoUnit.FOREVER, ValueRange.of(YearConstants.MIN_VALUE, YearConstants.MAX_VALUE), 'year');\n  ChronoField.ERA = new ChronoField('Era', ChronoUnit.ERAS, ChronoUnit.FOREVER, ValueRange.of(0, 1));\n  ChronoField.INSTANT_SECONDS = new ChronoField('InstantSeconds', ChronoUnit.SECONDS, ChronoUnit.FOREVER, ValueRange.of(MIN_SAFE_INTEGER, MAX_SAFE_INTEGER));\n  ChronoField.OFFSET_SECONDS = new ChronoField('OffsetSeconds', ChronoUnit.SECONDS, ChronoUnit.FOREVER, ValueRange.of(-18 * 3600, 18 * 3600));\n}\n\n/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\nvar TemporalQueries = function () {\n  function TemporalQueries() {}\n\n  TemporalQueries.zoneId = function zoneId() {\n    return TemporalQueries.ZONE_ID;\n  };\n\n  TemporalQueries.chronology = function chronology() {\n    return TemporalQueries.CHRONO;\n  };\n\n  TemporalQueries.precision = function precision() {\n    return TemporalQueries.PRECISION;\n  };\n\n  TemporalQueries.zone = function zone() {\n    return TemporalQueries.ZONE;\n  };\n\n  TemporalQueries.offset = function offset() {\n    return TemporalQueries.OFFSET;\n  };\n\n  TemporalQueries.localDate = function localDate() {\n    return TemporalQueries.LOCAL_DATE;\n  };\n\n  TemporalQueries.localTime = function localTime() {\n    return TemporalQueries.LOCAL_TIME;\n  };\n\n  return TemporalQueries;\n}();\n\n/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\nvar TemporalAccessor = function () {\n  function TemporalAccessor() {}\n\n  var _proto = TemporalAccessor.prototype;\n\n  _proto.query = function query(_query) {\n    if (_query === TemporalQueries.zoneId() || _query === TemporalQueries.chronology() || _query === TemporalQueries.precision()) {\n      return null;\n    }\n\n    return _query.queryFrom(this);\n  };\n\n  _proto.get = function get(field) {\n    return this.range(field).checkValidIntValue(this.getLong(field), field);\n  };\n\n  _proto.range = function range(field) {\n    if (field instanceof ChronoField) {\n      if (this.isSupported(field)) {\n        return field.range();\n      }\n\n      throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);\n    }\n\n    return field.rangeRefinedBy(this);\n  };\n\n  return TemporalAccessor;\n}();\n\nvar TemporalQuery = function (_Enum) {\n  _inheritsLoose(TemporalQuery, _Enum);\n\n  function TemporalQuery() {\n    return _Enum.apply(this, arguments) || this;\n  }\n\n  var _proto = TemporalQuery.prototype;\n\n  _proto.queryFrom = function queryFrom(temporal) {\n    abstractMethodFail('queryFrom');\n  };\n\n  return TemporalQuery;\n}(Enum);\nfunction createTemporalQuery(name, queryFromFunction) {\n  var ExtendedTemporalQuery = function (_TemporalQuery) {\n    _inheritsLoose(ExtendedTemporalQuery, _TemporalQuery);\n\n    function ExtendedTemporalQuery() {\n      return _TemporalQuery.apply(this, arguments) || this;\n    }\n\n    return ExtendedTemporalQuery;\n  }(TemporalQuery);\n\n  ExtendedTemporalQuery.prototype.queryFrom = queryFromFunction;\n  return new ExtendedTemporalQuery(name);\n}\n\nvar DayOfWeek = function (_TemporalAccessor) {\n  _inheritsLoose(DayOfWeek, _TemporalAccessor);\n\n  function DayOfWeek(ordinal, name) {\n    var _this;\n\n    _this = _TemporalAccessor.call(this) || this;\n    _this._ordinal = ordinal;\n    _this._name = name;\n    return _this;\n  }\n\n  var _proto = DayOfWeek.prototype;\n\n  _proto.ordinal = function ordinal() {\n    return this._ordinal;\n  };\n\n  _proto.name = function name() {\n    return this._name;\n  };\n\n  DayOfWeek.values = function values() {\n    return ENUMS.slice();\n  };\n\n  DayOfWeek.valueOf = function valueOf(name) {\n    var ordinal = 0;\n\n    for (ordinal; ordinal < ENUMS.length; ordinal++) {\n      if (ENUMS[ordinal].name() === name) {\n        break;\n      }\n    }\n\n    return DayOfWeek.of(ordinal + 1);\n  };\n\n  DayOfWeek.of = function of(dayOfWeek) {\n    if (dayOfWeek < 1 || dayOfWeek > 7) {\n      throw new DateTimeException('Invalid value for DayOfWeek: ' + dayOfWeek);\n    }\n\n    return ENUMS[dayOfWeek - 1];\n  };\n\n  DayOfWeek.from = function from(temporal) {\n    assert(temporal != null, 'temporal', NullPointerException);\n\n    if (temporal instanceof DayOfWeek) {\n      return temporal;\n    }\n\n    try {\n      return DayOfWeek.of(temporal.get(ChronoField.DAY_OF_WEEK));\n    } catch (ex) {\n      if (ex instanceof DateTimeException) {\n        throw new DateTimeException('Unable to obtain DayOfWeek from TemporalAccessor: ' + temporal + ', type ' + (temporal.constructor != null ? temporal.constructor.name : ''), ex);\n      } else {\n        throw ex;\n      }\n    }\n  };\n\n  _proto.value = function value() {\n    return this._ordinal + 1;\n  };\n\n  _proto.displayName = function displayName(style, locale) {\n    throw new IllegalArgumentException('Pattern using (localized) text not implemented yet!');\n  };\n\n  _proto.isSupported = function isSupported(field) {\n    if (field instanceof ChronoField) {\n      return field === ChronoField.DAY_OF_WEEK;\n    }\n\n    return field != null && field.isSupportedBy(this);\n  };\n\n  _proto.range = function range(field) {\n    if (field === ChronoField.DAY_OF_WEEK) {\n      return field.range();\n    } else if (field instanceof ChronoField) {\n      throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);\n    }\n\n    return field.rangeRefinedBy(this);\n  };\n\n  _proto.get = function get(field) {\n    if (field === ChronoField.DAY_OF_WEEK) {\n      return this.value();\n    }\n\n    return this.range(field).checkValidIntValue(this.getLong(field), field);\n  };\n\n  _proto.getLong = function getLong(field) {\n    if (field === ChronoField.DAY_OF_WEEK) {\n      return this.value();\n    } else if (field instanceof ChronoField) {\n      throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);\n    }\n\n    return field.getFrom(this);\n  };\n\n  _proto.plus = function plus(days) {\n    var amount = MathUtil.floorMod(days, 7);\n    return ENUMS[MathUtil.floorMod(this._ordinal + (amount + 7), 7)];\n  };\n\n  _proto.minus = function minus(days) {\n    return this.plus(-1 * MathUtil.floorMod(days, 7));\n  };\n\n  _proto.query = function query(_query) {\n    if (_query === TemporalQueries.precision()) {\n      return ChronoUnit.DAYS;\n    } else if (_query === TemporalQueries.localDate() || _query === TemporalQueries.localTime() || _query === TemporalQueries.chronology() || _query === TemporalQueries.zone() || _query === TemporalQueries.zoneId() || _query === TemporalQueries.offset()) {\n      return null;\n    }\n\n    assert(_query != null, 'query', NullPointerException);\n    return _query.queryFrom(this);\n  };\n\n  _proto.adjustInto = function adjustInto(temporal) {\n    requireNonNull(temporal, 'temporal');\n    return temporal.with(ChronoField.DAY_OF_WEEK, this.value());\n  };\n\n  _proto.equals = function equals(other) {\n    return this === other;\n  };\n\n  _proto.toString = function toString() {\n    return this._name;\n  };\n\n  _proto.compareTo = function compareTo(other) {\n    requireNonNull(other, 'other');\n    requireInstance(other, DayOfWeek, 'other');\n    return this._ordinal - other._ordinal;\n  };\n\n  _proto.toJSON = function toJSON() {\n    return this.toString();\n  };\n\n  return DayOfWeek;\n}(TemporalAccessor);\nvar ENUMS;\nfunction _init$4() {\n  DayOfWeek.MONDAY = new DayOfWeek(0, 'MONDAY');\n  DayOfWeek.TUESDAY = new DayOfWeek(1, 'TUESDAY');\n  DayOfWeek.WEDNESDAY = new DayOfWeek(2, 'WEDNESDAY');\n  DayOfWeek.THURSDAY = new DayOfWeek(3, 'THURSDAY');\n  DayOfWeek.FRIDAY = new DayOfWeek(4, 'FRIDAY');\n  DayOfWeek.SATURDAY = new DayOfWeek(5, 'SATURDAY');\n  DayOfWeek.SUNDAY = new DayOfWeek(6, 'SUNDAY');\n  DayOfWeek.FROM = createTemporalQuery('DayOfWeek.FROM', function (temporal) {\n    return DayOfWeek.from(temporal);\n  });\n  ENUMS = [DayOfWeek.MONDAY, DayOfWeek.TUESDAY, DayOfWeek.WEDNESDAY, DayOfWeek.THURSDAY, DayOfWeek.FRIDAY, DayOfWeek.SATURDAY, DayOfWeek.SUNDAY];\n}\n\nvar Month = function (_TemporalAccessor) {\n  _inheritsLoose(Month, _TemporalAccessor);\n\n  function Month(value, name) {\n    var _this;\n\n    _this = _TemporalAccessor.call(this) || this;\n    _this._value = MathUtil.safeToInt(value);\n    _this._name = name;\n    return _this;\n  }\n\n  var _proto = Month.prototype;\n\n  _proto.value = function value() {\n    return this._value;\n  };\n\n  _proto.ordinal = function ordinal() {\n    return this._value - 1;\n  };\n\n  _proto.name = function name() {\n    return this._name;\n  };\n\n  _proto.displayName = function displayName(style, locale) {\n    throw new IllegalArgumentException('Pattern using (localized) text not implemented yet!');\n  };\n\n  _proto.isSupported = function isSupported(field) {\n    if (null === field) {\n      return false;\n    }\n\n    if (field instanceof ChronoField) {\n      return field === ChronoField.MONTH_OF_YEAR;\n    }\n\n    return field != null && field.isSupportedBy(this);\n  };\n\n  _proto.get = function get(field) {\n    if (field === ChronoField.MONTH_OF_YEAR) {\n      return this.value();\n    }\n\n    return this.range(field).checkValidIntValue(this.getLong(field), field);\n  };\n\n  _proto.getLong = function getLong(field) {\n    if (field === ChronoField.MONTH_OF_YEAR) {\n      return this.value();\n    } else if (field instanceof ChronoField) {\n      throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);\n    }\n\n    return field.getFrom(this);\n  };\n\n  _proto.plus = function plus(months) {\n    var amount = MathUtil.intMod(months, 12) + 12;\n    var newMonthVal = MathUtil.intMod(this.value() + amount, 12);\n    newMonthVal = newMonthVal === 0 ? 12 : newMonthVal;\n    return Month.of(newMonthVal);\n  };\n\n  _proto.minus = function minus(months) {\n    return this.plus(-1 * MathUtil.intMod(months, 12));\n  };\n\n  _proto.length = function length(leapYear) {\n    switch (this) {\n      case Month.FEBRUARY:\n        return leapYear ? 29 : 28;\n\n      case Month.APRIL:\n      case Month.JUNE:\n      case Month.SEPTEMBER:\n      case Month.NOVEMBER:\n        return 30;\n\n      default:\n        return 31;\n    }\n  };\n\n  _proto.minLength = function minLength() {\n    switch (this) {\n      case Month.FEBRUARY:\n        return 28;\n\n      case Month.APRIL:\n      case Month.JUNE:\n      case Month.SEPTEMBER:\n      case Month.NOVEMBER:\n        return 30;\n\n      default:\n        return 31;\n    }\n  };\n\n  _proto.maxLength = function maxLength() {\n    switch (this) {\n      case Month.FEBRUARY:\n        return 29;\n\n      case Month.APRIL:\n      case Month.JUNE:\n      case Month.SEPTEMBER:\n      case Month.NOVEMBER:\n        return 30;\n\n      default:\n        return 31;\n    }\n  };\n\n  _proto.firstDayOfYear = function firstDayOfYear(leapYear) {\n    var leap = leapYear ? 1 : 0;\n\n    switch (this) {\n      case Month.JANUARY:\n        return 1;\n\n      case Month.FEBRUARY:\n        return 32;\n\n      case Month.MARCH:\n        return 60 + leap;\n\n      case Month.APRIL:\n        return 91 + leap;\n\n      case Month.MAY:\n        return 121 + leap;\n\n      case Month.JUNE:\n        return 152 + leap;\n\n      case Month.JULY:\n        return 182 + leap;\n\n      case Month.AUGUST:\n        return 213 + leap;\n\n      case Month.SEPTEMBER:\n        return 244 + leap;\n\n      case Month.OCTOBER:\n        return 274 + leap;\n\n      case Month.NOVEMBER:\n        return 305 + leap;\n\n      case Month.DECEMBER:\n      default:\n        return 335 + leap;\n    }\n  };\n\n  _proto.firstMonthOfQuarter = function firstMonthOfQuarter() {\n    switch (this) {\n      case Month.JANUARY:\n      case Month.FEBRUARY:\n      case Month.MARCH:\n        return Month.JANUARY;\n\n      case Month.APRIL:\n      case Month.MAY:\n      case Month.JUNE:\n        return Month.APRIL;\n\n      case Month.JULY:\n      case Month.AUGUST:\n      case Month.SEPTEMBER:\n        return Month.JULY;\n\n      case Month.OCTOBER:\n      case Month.NOVEMBER:\n      case Month.DECEMBER:\n      default:\n        return Month.OCTOBER;\n    }\n  };\n\n  _proto.query = function query(_query) {\n    assert(_query != null, 'query() parameter must not be null', DateTimeException);\n\n    if (_query === TemporalQueries.chronology()) {\n      return IsoChronology.INSTANCE;\n    } else if (_query === TemporalQueries.precision()) {\n      return ChronoUnit.MONTHS;\n    }\n\n    return _TemporalAccessor.prototype.query.call(this, _query);\n  };\n\n  _proto.toString = function toString() {\n    switch (this) {\n      case Month.JANUARY:\n        return 'JANUARY';\n\n      case Month.FEBRUARY:\n        return 'FEBRUARY';\n\n      case Month.MARCH:\n        return 'MARCH';\n\n      case Month.APRIL:\n        return 'APRIL';\n\n      case Month.MAY:\n        return 'MAY';\n\n      case Month.JUNE:\n        return 'JUNE';\n\n      case Month.JULY:\n        return 'JULY';\n\n      case Month.AUGUST:\n        return 'AUGUST';\n\n      case Month.SEPTEMBER:\n        return 'SEPTEMBER';\n\n      case Month.OCTOBER:\n        return 'OCTOBER';\n\n      case Month.NOVEMBER:\n        return 'NOVEMBER';\n\n      case Month.DECEMBER:\n        return 'DECEMBER';\n\n      default:\n        return 'unknown Month, value: ' + this.value();\n    }\n  };\n\n  _proto.toJSON = function toJSON() {\n    return this.toString();\n  };\n\n  _proto.adjustInto = function adjustInto(temporal) {\n    return temporal.with(ChronoField.MONTH_OF_YEAR, this.value());\n  };\n\n  _proto.compareTo = function compareTo(other) {\n    requireNonNull(other, 'other');\n    requireInstance(other, Month, 'other');\n    return this._value - other._value;\n  };\n\n  _proto.equals = function equals(other) {\n    return this === other;\n  };\n\n  Month.valueOf = function valueOf(name) {\n    var ordinal = 0;\n\n    for (ordinal; ordinal < MONTHS.length; ordinal++) {\n      if (MONTHS[ordinal].name() === name) {\n        break;\n      }\n    }\n\n    return Month.of(ordinal + 1);\n  };\n\n  Month.values = function values() {\n    return MONTHS.slice();\n  };\n\n  Month.of = function of(month) {\n    if (month < 1 || month > 12) {\n      assert(false, 'Invalid value for MonthOfYear: ' + month, DateTimeException);\n    }\n\n    return MONTHS[month - 1];\n  };\n\n  Month.from = function from(temporal) {\n    if (temporal instanceof Month) {\n      return temporal;\n    }\n\n    try {\n      return Month.of(temporal.get(ChronoField.MONTH_OF_YEAR));\n    } catch (ex) {\n      throw new DateTimeException('Unable to obtain Month from TemporalAccessor: ' + temporal + ' of type ' + (temporal && temporal.constructor != null ? temporal.constructor.name : ''), ex);\n    }\n  };\n\n  return Month;\n}(TemporalAccessor);\nvar MONTHS;\nfunction _init$5() {\n  Month.JANUARY = new Month(1, 'JANUARY');\n  Month.FEBRUARY = new Month(2, 'FEBRUARY');\n  Month.MARCH = new Month(3, 'MARCH');\n  Month.APRIL = new Month(4, 'APRIL');\n  Month.MAY = new Month(5, 'MAY');\n  Month.JUNE = new Month(6, 'JUNE');\n  Month.JULY = new Month(7, 'JULY');\n  Month.AUGUST = new Month(8, 'AUGUST');\n  Month.SEPTEMBER = new Month(9, 'SEPTEMBER');\n  Month.OCTOBER = new Month(10, 'OCTOBER');\n  Month.NOVEMBER = new Month(11, 'NOVEMBER');\n  Month.DECEMBER = new Month(12, 'DECEMBER');\n  MONTHS = [Month.JANUARY, Month.FEBRUARY, Month.MARCH, Month.APRIL, Month.MAY, Month.JUNE, Month.JULY, Month.AUGUST, Month.SEPTEMBER, Month.OCTOBER, Month.NOVEMBER, Month.DECEMBER];\n}\n\nvar PATTERN = /([-+]?)P(?:([-+]?[0-9]+)Y)?(?:([-+]?[0-9]+)M)?(?:([-+]?[0-9]+)W)?(?:([-+]?[0-9]+)D)?/;\nvar Period = function (_TemporalAmount) {\n  _inheritsLoose(Period, _TemporalAmount);\n\n  function Period(years, months, days) {\n    var _this;\n\n    _this = _TemporalAmount.call(this) || this;\n\n    var _years = MathUtil.safeToInt(years);\n\n    var _months = MathUtil.safeToInt(months);\n\n    var _days = MathUtil.safeToInt(days);\n\n    if (_years === 0 && _months === 0 && _days === 0) {\n      if (!Period.ZERO) {\n        _this._years = _years;\n        _this._months = _months;\n        _this._days = _days;\n        Period.ZERO = _assertThisInitialized(_this);\n      }\n\n      return Period.ZERO || _assertThisInitialized(_this);\n    }\n\n    _this._years = _years;\n    _this._months = _months;\n    _this._days = _days;\n    return _this;\n  }\n\n  Period.ofYears = function ofYears(years) {\n    return Period.create(years, 0, 0);\n  };\n\n  Period.ofMonths = function ofMonths(months) {\n    return Period.create(0, months, 0);\n  };\n\n  Period.ofWeeks = function ofWeeks(weeks) {\n    return Period.create(0, 0, MathUtil.safeMultiply(weeks, 7));\n  };\n\n  Period.ofDays = function ofDays(days) {\n    return Period.create(0, 0, days);\n  };\n\n  Period.of = function of(years, months, days) {\n    return Period.create(years, months, days);\n  };\n\n  Period.from = function from(amount) {\n    if (amount instanceof Period) {\n      return amount;\n    }\n\n    requireNonNull(amount, 'amount');\n    var years = 0;\n    var months = 0;\n    var days = 0;\n    var units = amount.units();\n\n    for (var i = 0; i < units.length; i++) {\n      var unit = units[i];\n      var unitAmount = amount.get(unit);\n\n      if (unit === ChronoUnit.YEARS) {\n        years = MathUtil.safeToInt(unitAmount);\n      } else if (unit === ChronoUnit.MONTHS) {\n        months = MathUtil.safeToInt(unitAmount);\n      } else if (unit === ChronoUnit.DAYS) {\n        days = MathUtil.safeToInt(unitAmount);\n      } else {\n        throw new DateTimeException('Unit must be Years, Months or Days, but was ' + unit);\n      }\n    }\n\n    return Period.create(years, months, days);\n  };\n\n  Period.between = function between(startDate, endDate) {\n    requireNonNull(startDate, 'startDate');\n    requireNonNull(endDate, 'endDate');\n    requireInstance(startDate, LocalDate, 'startDate');\n    requireInstance(endDate, LocalDate, 'endDate');\n    return startDate.until(endDate);\n  };\n\n  Period.parse = function parse(text) {\n    requireNonNull(text, 'text');\n\n    try {\n      return Period._parse(text);\n    } catch (ex) {\n      if (ex instanceof ArithmeticException) {\n        throw new DateTimeParseException('Text cannot be parsed to a Period', text, 0, ex);\n      } else {\n        throw ex;\n      }\n    }\n  };\n\n  Period._parse = function _parse(text) {\n    var matches = PATTERN.exec(text);\n\n    if (matches != null) {\n      var negate = '-' === matches[1] ? -1 : 1;\n      var yearMatch = matches[2];\n      var monthMatch = matches[3];\n      var weekMatch = matches[4];\n      var dayMatch = matches[5];\n\n      if (yearMatch != null || monthMatch != null || weekMatch != null || dayMatch != null) {\n        var years = Period._parseNumber(text, yearMatch, negate);\n\n        var months = Period._parseNumber(text, monthMatch, negate);\n\n        var weeks = Period._parseNumber(text, weekMatch, negate);\n\n        var days = Period._parseNumber(text, dayMatch, negate);\n\n        days = MathUtil.safeAdd(days, MathUtil.safeMultiply(weeks, 7));\n        return Period.create(years, months, days);\n      }\n    }\n\n    throw new DateTimeParseException('Text cannot be parsed to a Period', text, 0);\n  };\n\n  Period._parseNumber = function _parseNumber(text, str, negate) {\n    if (str == null) {\n      return 0;\n    }\n\n    var val = MathUtil.parseInt(str);\n    return MathUtil.safeMultiply(val, negate);\n  };\n\n  Period.create = function create(years, months, days) {\n    return new Period(years, months, days);\n  };\n\n  var _proto = Period.prototype;\n\n  _proto.units = function units() {\n    return [ChronoUnit.YEARS, ChronoUnit.MONTHS, ChronoUnit.DAYS];\n  };\n\n  _proto.chronology = function chronology() {\n    return IsoChronology.INSTANCE;\n  };\n\n  _proto.get = function get(unit) {\n    if (unit === ChronoUnit.YEARS) {\n      return this._years;\n    }\n\n    if (unit === ChronoUnit.MONTHS) {\n      return this._months;\n    }\n\n    if (unit === ChronoUnit.DAYS) {\n      return this._days;\n    }\n\n    throw new UnsupportedTemporalTypeException('Unsupported unit: ' + unit);\n  };\n\n  _proto.isZero = function isZero() {\n    return this === Period.ZERO;\n  };\n\n  _proto.isNegative = function isNegative() {\n    return this._years < 0 || this._months < 0 || this._days < 0;\n  };\n\n  _proto.years = function years() {\n    return this._years;\n  };\n\n  _proto.months = function months() {\n    return this._months;\n  };\n\n  _proto.days = function days() {\n    return this._days;\n  };\n\n  _proto.withYears = function withYears(years) {\n    if (years === this._years) {\n      return this;\n    }\n\n    return Period.create(years, this._months, this._days);\n  };\n\n  _proto.withMonths = function withMonths(months) {\n    if (months === this._months) {\n      return this;\n    }\n\n    return Period.create(this._years, months, this._days);\n  };\n\n  _proto.withDays = function withDays(days) {\n    if (days === this._days) {\n      return this;\n    }\n\n    return Period.create(this._years, this._months, days);\n  };\n\n  _proto.plus = function plus(amountToAdd) {\n    var amount = Period.from(amountToAdd);\n    return Period.create(MathUtil.safeAdd(this._years, amount._years), MathUtil.safeAdd(this._months, amount._months), MathUtil.safeAdd(this._days, amount._days));\n  };\n\n  _proto.plusYears = function plusYears(yearsToAdd) {\n    if (yearsToAdd === 0) {\n      return this;\n    }\n\n    return Period.create(MathUtil.safeToInt(MathUtil.safeAdd(this._years, yearsToAdd)), this._months, this._days);\n  };\n\n  _proto.plusMonths = function plusMonths(monthsToAdd) {\n    if (monthsToAdd === 0) {\n      return this;\n    }\n\n    return Period.create(this._years, MathUtil.safeToInt(MathUtil.safeAdd(this._months, monthsToAdd)), this._days);\n  };\n\n  _proto.plusDays = function plusDays(daysToAdd) {\n    if (daysToAdd === 0) {\n      return this;\n    }\n\n    return Period.create(this._years, this._months, MathUtil.safeToInt(MathUtil.safeAdd(this._days, daysToAdd)));\n  };\n\n  _proto.minus = function minus(amountToSubtract) {\n    var amount = Period.from(amountToSubtract);\n    return Period.create(MathUtil.safeSubtract(this._years, amount._years), MathUtil.safeSubtract(this._months, amount._months), MathUtil.safeSubtract(this._days, amount._days));\n  };\n\n  _proto.minusYears = function minusYears(yearsToSubtract) {\n    return this.plusYears(-1 * yearsToSubtract);\n  };\n\n  _proto.minusMonths = function minusMonths(monthsToSubtract) {\n    return this.plusMonths(-1 * monthsToSubtract);\n  };\n\n  _proto.minusDays = function minusDays(daysToSubtract) {\n    return this.plusDays(-1 * daysToSubtract);\n  };\n\n  _proto.multipliedBy = function multipliedBy(scalar) {\n    if (this === Period.ZERO || scalar === 1) {\n      return this;\n    }\n\n    return Period.create(MathUtil.safeMultiply(this._years, scalar), MathUtil.safeMultiply(this._months, scalar), MathUtil.safeMultiply(this._days, scalar));\n  };\n\n  _proto.negated = function negated() {\n    return this.multipliedBy(-1);\n  };\n\n  _proto.normalized = function normalized() {\n    var totalMonths = this.toTotalMonths();\n    var splitYears = MathUtil.intDiv(totalMonths, 12);\n    var splitMonths = MathUtil.intMod(totalMonths, 12);\n\n    if (splitYears === this._years && splitMonths === this._months) {\n      return this;\n    }\n\n    return Period.create(MathUtil.safeToInt(splitYears), splitMonths, this._days);\n  };\n\n  _proto.toTotalMonths = function toTotalMonths() {\n    return this._years * 12 + this._months;\n  };\n\n  _proto.addTo = function addTo(temporal) {\n    requireNonNull(temporal, 'temporal');\n\n    if (this._years !== 0) {\n      if (this._months !== 0) {\n        temporal = temporal.plus(this.toTotalMonths(), ChronoUnit.MONTHS);\n      } else {\n        temporal = temporal.plus(this._years, ChronoUnit.YEARS);\n      }\n    } else if (this._months !== 0) {\n      temporal = temporal.plus(this._months, ChronoUnit.MONTHS);\n    }\n\n    if (this._days !== 0) {\n      temporal = temporal.plus(this._days, ChronoUnit.DAYS);\n    }\n\n    return temporal;\n  };\n\n  _proto.subtractFrom = function subtractFrom(temporal) {\n    requireNonNull(temporal, 'temporal');\n\n    if (this._years !== 0) {\n      if (this._months !== 0) {\n        temporal = temporal.minus(this.toTotalMonths(), ChronoUnit.MONTHS);\n      } else {\n        temporal = temporal.minus(this._years, ChronoUnit.YEARS);\n      }\n    } else if (this._months !== 0) {\n      temporal = temporal.minus(this._months, ChronoUnit.MONTHS);\n    }\n\n    if (this._days !== 0) {\n      temporal = temporal.minus(this._days, ChronoUnit.DAYS);\n    }\n\n    return temporal;\n  };\n\n  _proto.equals = function equals(obj) {\n    if (this === obj) {\n      return true;\n    }\n\n    if (obj instanceof Period) {\n      var other = obj;\n      return this._years === other._years && this._months === other._months && this._days === other._days;\n    }\n\n    return false;\n  };\n\n  _proto.hashCode = function hashCode() {\n    return MathUtil.hashCode(this._years, this._months, this._days);\n  };\n\n  _proto.toString = function toString() {\n    if (this === Period.ZERO) {\n      return 'P0D';\n    } else {\n      var buf = 'P';\n\n      if (this._years !== 0) {\n        buf += '' + this._years + 'Y';\n      }\n\n      if (this._months !== 0) {\n        buf += '' + this._months + 'M';\n      }\n\n      if (this._days !== 0) {\n        buf += '' + this._days + 'D';\n      }\n\n      return buf;\n    }\n  };\n\n  _proto.toJSON = function toJSON() {\n    return this.toString();\n  };\n\n  return Period;\n}(TemporalAmount);\nfunction _init$6() {\n  Period.ofDays(0);\n}\n\n/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\nvar ParsePosition = function () {\n  function ParsePosition(index) {\n    this._index = index;\n    this._errorIndex = -1;\n  }\n\n  var _proto = ParsePosition.prototype;\n\n  _proto.getIndex = function getIndex() {\n    return this._index;\n  };\n\n  _proto.setIndex = function setIndex(index) {\n    this._index = index;\n  };\n\n  _proto.getErrorIndex = function getErrorIndex() {\n    return this._errorIndex;\n  };\n\n  _proto.setErrorIndex = function setErrorIndex(errorIndex) {\n    this._errorIndex = errorIndex;\n  };\n\n  return ParsePosition;\n}();\n\n/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\nvar EnumMap = function () {\n  function EnumMap() {\n    this._map = {};\n  }\n\n  var _proto = EnumMap.prototype;\n\n  _proto.putAll = function putAll(otherMap) {\n    for (var key in otherMap._map) {\n      this._map[key] = otherMap._map[key];\n    }\n\n    return this;\n  };\n\n  _proto.containsKey = function containsKey(key) {\n    return this._map.hasOwnProperty(key.name()) && this.get(key) !== undefined;\n  };\n\n  _proto.get = function get(key) {\n    return this._map[key.name()];\n  };\n\n  _proto.put = function put(key, val) {\n    return this.set(key, val);\n  };\n\n  _proto.set = function set(key, val) {\n    this._map[key.name()] = val;\n    return this;\n  };\n\n  _proto.retainAll = function retainAll(keyList) {\n    var map = {};\n\n    for (var i = 0; i < keyList.length; i++) {\n      var key = keyList[i].name();\n      map[key] = this._map[key];\n    }\n\n    this._map = map;\n    return this;\n  };\n\n  _proto.remove = function remove(key) {\n    var keyName = key.name();\n    var val = this._map[keyName];\n    this._map[keyName] = undefined;\n    return val;\n  };\n\n  _proto.keySet = function keySet() {\n    return this._map;\n  };\n\n  _proto.clear = function clear() {\n    this._map = {};\n  };\n\n  return EnumMap;\n}();\n\nvar ResolverStyle = function (_Enum) {\n  _inheritsLoose(ResolverStyle, _Enum);\n\n  function ResolverStyle() {\n    return _Enum.apply(this, arguments) || this;\n  }\n\n  return ResolverStyle;\n}(Enum);\nResolverStyle.STRICT = new ResolverStyle('STRICT');\nResolverStyle.SMART = new ResolverStyle('SMART');\nResolverStyle.LENIENT = new ResolverStyle('LENIENT');\n\n/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\nvar TemporalAdjuster = function () {\n  function TemporalAdjuster() {}\n\n  var _proto = TemporalAdjuster.prototype;\n\n  _proto.adjustInto = function adjustInto(temporal) {\n    abstractMethodFail('adjustInto');\n  };\n\n  return TemporalAdjuster;\n}();\n\nvar Temporal = function (_TemporalAccessor) {\n  _inheritsLoose(Temporal, _TemporalAccessor);\n\n  function Temporal() {\n    return _TemporalAccessor.apply(this, arguments) || this;\n  }\n\n  var _proto = Temporal.prototype;\n\n  _proto.isSupported = function isSupported(unit) {\n    abstractMethodFail('isSupported');\n  };\n\n  _proto.minus = function minus(p1, p2) {\n    if (arguments.length < 2) {\n      return this.minusAmount(p1);\n    } else {\n      return this.minusAmountUnit(p1, p2);\n    }\n  };\n\n  _proto.minusAmount = function minusAmount(amount) {\n    abstractMethodFail('minusAmount');\n  };\n\n  _proto.minusAmountUnit = function minusAmountUnit(amountToSubtract, unit) {\n    abstractMethodFail('minusAmountUnit');\n  };\n\n  _proto.plus = function plus(p1, p2) {\n    if (arguments.length < 2) {\n      return this.plusAmount(p1);\n    } else {\n      return this.plusAmountUnit(p1, p2);\n    }\n  };\n\n  _proto.plusAmount = function plusAmount(amount) {\n    abstractMethodFail('plusAmount');\n  };\n\n  _proto.plusAmountUnit = function plusAmountUnit(amountToAdd, unit) {\n    abstractMethodFail('plusAmountUnit');\n  };\n\n  _proto.until = function until(endTemporal, unit) {\n    abstractMethodFail('until');\n  };\n\n  _proto.with = function _with(p1, p2) {\n    if (arguments.length < 2) {\n      return this.withAdjuster(p1);\n    } else {\n      return this.withFieldValue(p1, p2);\n    }\n  };\n\n  _proto.withAdjuster = function withAdjuster(adjuster) {\n    abstractMethodFail('withAdjuster');\n  };\n\n  _proto.withFieldValue = function withFieldValue(field, newValue) {\n    abstractMethodFail('withFieldValue');\n  };\n\n  return Temporal;\n}(TemporalAccessor);\n\nvar DefaultInterfaceTemporal = function (_Temporal) {\n  _inheritsLoose(DefaultInterfaceTemporal, _Temporal);\n\n  function DefaultInterfaceTemporal() {\n    return _Temporal.apply(this, arguments) || this;\n  }\n\n  var _proto = DefaultInterfaceTemporal.prototype;\n\n  _proto.withAdjuster = function withAdjuster(adjuster) {\n    requireNonNull(adjuster, 'adjuster');\n    requireInstance(adjuster, TemporalAdjuster, 'adjuster');\n    return adjuster.adjustInto(this);\n  };\n\n  _proto.plusAmount = function plusAmount(amount) {\n    requireNonNull(amount, 'amount');\n    requireInstance(amount, TemporalAmount, 'amount');\n    return amount.addTo(this);\n  };\n\n  _proto.minusAmount = function minusAmount(amount) {\n    requireNonNull(amount, 'amount');\n    requireInstance(amount, TemporalAmount, 'amount');\n    return amount.subtractFrom(this);\n  };\n\n  _proto.minusAmountUnit = function minusAmountUnit(amountToSubtract, unit) {\n    requireNonNull(amountToSubtract, 'amountToSubtract');\n    requireNonNull(unit, 'unit');\n    requireInstance(unit, TemporalUnit, 'unit');\n    return amountToSubtract === MIN_SAFE_INTEGER ? this.plusAmountUnit(MAX_SAFE_INTEGER, unit).plusAmountUnit(1, unit) : this.plusAmount(-amountToSubtract, unit);\n  };\n\n  return DefaultInterfaceTemporal;\n}(Temporal);\n\nvar ChronoLocalDate = function (_DefaultInterfaceTemp) {\n  _inheritsLoose(ChronoLocalDate, _DefaultInterfaceTemp);\n\n  function ChronoLocalDate() {\n    return _DefaultInterfaceTemp.apply(this, arguments) || this;\n  }\n\n  var _proto = ChronoLocalDate.prototype;\n\n  _proto.isSupported = function isSupported(fieldOrUnit) {\n    if (fieldOrUnit instanceof ChronoField) {\n      return fieldOrUnit.isDateBased();\n    } else if (fieldOrUnit instanceof ChronoUnit) {\n      return fieldOrUnit.isDateBased();\n    }\n\n    return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);\n  };\n\n  _proto.query = function query(_query) {\n    if (_query === TemporalQueries.chronology()) {\n      return this.chronology();\n    } else if (_query === TemporalQueries.precision()) {\n      return ChronoUnit.DAYS;\n    } else if (_query === TemporalQueries.localDate()) {\n      return LocalDate.ofEpochDay(this.toEpochDay());\n    } else if (_query === TemporalQueries.localTime() || _query === TemporalQueries.zone() || _query === TemporalQueries.zoneId() || _query === TemporalQueries.offset()) {\n      return null;\n    }\n\n    return _DefaultInterfaceTemp.prototype.query.call(this, _query);\n  };\n\n  _proto.adjustInto = function adjustInto(temporal) {\n    return temporal.with(ChronoField.EPOCH_DAY, this.toEpochDay());\n  };\n\n  _proto.format = function format(formatter) {\n    requireNonNull(formatter, 'formatter');\n    requireInstance(formatter, DateTimeFormatter, 'formatter');\n    return formatter.format(this);\n  };\n\n  return ChronoLocalDate;\n}(DefaultInterfaceTemporal);\n\n/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\nvar StringUtil = function () {\n  function StringUtil() {}\n\n  StringUtil.startsWith = function startsWith(text, pattern) {\n    return text.indexOf(pattern) === 0;\n  };\n\n  StringUtil.hashCode = function hashCode(text) {\n    var len = text.length;\n\n    if (len === 0) {\n      return 0;\n    }\n\n    var hash = 0;\n\n    for (var i = 0; i < len; i++) {\n      var chr = text.charCodeAt(i);\n      hash = (hash << 5) - hash + chr;\n      hash |= 0;\n    }\n\n    return MathUtil.smi(hash);\n  };\n\n  return StringUtil;\n}();\n\n/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\nvar ZoneId = function () {\n  function ZoneId() {}\n\n  ZoneId.systemDefault = function systemDefault() {\n    throw new DateTimeException('not supported operation');\n  };\n\n  ZoneId.getAvailableZoneIds = function getAvailableZoneIds() {\n    throw new DateTimeException('not supported operation');\n  };\n\n  ZoneId.of = function of(zoneId) {\n    throw new DateTimeException('not supported operation' + zoneId);\n  };\n\n  ZoneId.ofOffset = function ofOffset(prefix, offset) {\n    throw new DateTimeException('not supported operation' + prefix + offset);\n  };\n\n  ZoneId.from = function from(temporal) {\n    throw new DateTimeException('not supported operation' + temporal);\n  };\n\n  var _proto = ZoneId.prototype;\n\n  _proto.id = function id() {\n    abstractMethodFail('ZoneId.id');\n  };\n\n  _proto.rules = function rules() {\n    abstractMethodFail('ZoneId.rules');\n  };\n\n  _proto.normalized = function normalized() {\n    var rules = this.rules();\n\n    if (rules.isFixedOffset()) {\n      return rules.offset(Instant.EPOCH);\n    }\n\n    return this;\n  };\n\n  _proto.equals = function equals(other) {\n    if (this === other) {\n      return true;\n    }\n\n    if (other instanceof ZoneId) {\n      return this.id() === other.id();\n    }\n\n    return false;\n  };\n\n  _proto.hashCode = function hashCode() {\n    return StringUtil.hashCode(this.id());\n  };\n\n  _proto.toString = function toString() {\n    return this.id();\n  };\n\n  _proto.toJSON = function toJSON() {\n    return this.toString();\n  };\n\n  return ZoneId;\n}();\n\nvar ZoneRules = function () {\n  function ZoneRules() {}\n\n  ZoneRules.of = function of(offset) {\n    requireNonNull(offset, 'offset');\n    return new Fixed(offset);\n  };\n\n  var _proto = ZoneRules.prototype;\n\n  _proto.isFixedOffset = function isFixedOffset() {\n    abstractMethodFail('ZoneRules.isFixedOffset');\n  };\n\n  _proto.offset = function offset(instantOrLocalDateTime) {\n    if (instantOrLocalDateTime instanceof Instant) {\n      return this.offsetOfInstant(instantOrLocalDateTime);\n    } else {\n      return this.offsetOfLocalDateTime(instantOrLocalDateTime);\n    }\n  };\n\n  _proto.offsetOfInstant = function offsetOfInstant(instant) {\n    abstractMethodFail('ZoneRules.offsetInstant');\n  };\n\n  _proto.offsetOfEpochMilli = function offsetOfEpochMilli(epochMilli) {\n    abstractMethodFail('ZoneRules.offsetOfEpochMilli');\n  };\n\n  _proto.offsetOfLocalDateTime = function offsetOfLocalDateTime(localDateTime) {\n    abstractMethodFail('ZoneRules.offsetLocalDateTime');\n  };\n\n  _proto.validOffsets = function validOffsets(localDateTime) {\n    abstractMethodFail('ZoneRules.validOffsets');\n  };\n\n  _proto.transition = function transition(localDateTime) {\n    abstractMethodFail('ZoneRules.transition');\n  };\n\n  _proto.standardOffset = function standardOffset(instant) {\n    abstractMethodFail('ZoneRules.standardOffset');\n  };\n\n  _proto.daylightSavings = function daylightSavings(instant) {\n    abstractMethodFail('ZoneRules.daylightSavings');\n  };\n\n  _proto.isDaylightSavings = function isDaylightSavings(instant) {\n    abstractMethodFail('ZoneRules.isDaylightSavings');\n  };\n\n  _proto.isValidOffset = function isValidOffset(localDateTime, offset) {\n    abstractMethodFail('ZoneRules.isValidOffset');\n  };\n\n  _proto.nextTransition = function nextTransition(instant) {\n    abstractMethodFail('ZoneRules.nextTransition');\n  };\n\n  _proto.previousTransition = function previousTransition(instant) {\n    abstractMethodFail('ZoneRules.previousTransition');\n  };\n\n  _proto.transitions = function transitions() {\n    abstractMethodFail('ZoneRules.transitions');\n  };\n\n  _proto.transitionRules = function transitionRules() {\n    abstractMethodFail('ZoneRules.transitionRules');\n  };\n\n  _proto.toString = function toString() {\n    abstractMethodFail('ZoneRules.toString');\n  };\n\n  _proto.toJSON = function toJSON() {\n    return this.toString();\n  };\n\n  return ZoneRules;\n}();\n\nvar Fixed = function (_ZoneRules) {\n  _inheritsLoose(Fixed, _ZoneRules);\n\n  function Fixed(offset) {\n    var _this;\n\n    _this = _ZoneRules.call(this) || this;\n    _this._offset = offset;\n    return _this;\n  }\n\n  var _proto2 = Fixed.prototype;\n\n  _proto2.isFixedOffset = function isFixedOffset() {\n    return true;\n  };\n\n  _proto2.offsetOfInstant = function offsetOfInstant() {\n    return this._offset;\n  };\n\n  _proto2.offsetOfEpochMilli = function offsetOfEpochMilli() {\n    return this._offset;\n  };\n\n  _proto2.offsetOfLocalDateTime = function offsetOfLocalDateTime() {\n    return this._offset;\n  };\n\n  _proto2.validOffsets = function validOffsets() {\n    return [this._offset];\n  };\n\n  _proto2.transition = function transition() {\n    return null;\n  };\n\n  _proto2.standardOffset = function standardOffset() {\n    return this._offset;\n  };\n\n  _proto2.daylightSavings = function daylightSavings() {\n    return Duration.ZERO;\n  };\n\n  _proto2.isDaylightSavings = function isDaylightSavings() {\n    return false;\n  };\n\n  _proto2.isValidOffset = function isValidOffset(localDateTime, offset) {\n    return this._offset.equals(offset);\n  };\n\n  _proto2.nextTransition = function nextTransition() {\n    return null;\n  };\n\n  _proto2.previousTransition = function previousTransition() {\n    return null;\n  };\n\n  _proto2.transitions = function transitions() {\n    return [];\n  };\n\n  _proto2.transitionRules = function transitionRules() {\n    return [];\n  };\n\n  _proto2.equals = function equals(other) {\n    if (this === other) {\n      return true;\n    }\n\n    if (other instanceof Fixed) {\n      return this._offset.equals(other._offset);\n    }\n\n    return false;\n  };\n\n  _proto2.toString = function toString() {\n    return 'FixedRules:' + this._offset.toString();\n  };\n\n  return Fixed;\n}(ZoneRules);\n\nvar SECONDS_CACHE = {};\nvar ID_CACHE = {};\nvar ZoneOffset = function (_ZoneId) {\n  _inheritsLoose(ZoneOffset, _ZoneId);\n\n  function ZoneOffset(totalSeconds) {\n    var _this;\n\n    _this = _ZoneId.call(this) || this;\n\n    ZoneOffset._validateTotalSeconds(totalSeconds);\n\n    _this._totalSeconds = MathUtil.safeToInt(totalSeconds);\n    _this._rules = ZoneRules.of(_assertThisInitialized(_this));\n    _this._id = ZoneOffset._buildId(totalSeconds);\n    return _this;\n  }\n\n  var _proto = ZoneOffset.prototype;\n\n  _proto.totalSeconds = function totalSeconds() {\n    return this._totalSeconds;\n  };\n\n  _proto.id = function id() {\n    return this._id;\n  };\n\n  ZoneOffset._buildId = function _buildId(totalSeconds) {\n    if (totalSeconds === 0) {\n      return 'Z';\n    } else {\n      var absTotalSeconds = Math.abs(totalSeconds);\n      var absHours = MathUtil.intDiv(absTotalSeconds, LocalTime.SECONDS_PER_HOUR);\n      var absMinutes = MathUtil.intMod(MathUtil.intDiv(absTotalSeconds, LocalTime.SECONDS_PER_MINUTE), LocalTime.MINUTES_PER_HOUR);\n      var buf = '' + (totalSeconds < 0 ? '-' : '+') + (absHours < 10 ? '0' : '') + absHours + (absMinutes < 10 ? ':0' : ':') + absMinutes;\n      var absSeconds = MathUtil.intMod(absTotalSeconds, LocalTime.SECONDS_PER_MINUTE);\n\n      if (absSeconds !== 0) {\n        buf += (absSeconds < 10 ? ':0' : ':') + absSeconds;\n      }\n\n      return buf;\n    }\n  };\n\n  ZoneOffset._validateTotalSeconds = function _validateTotalSeconds(totalSeconds) {\n    if (Math.abs(totalSeconds) > ZoneOffset.MAX_SECONDS) {\n      throw new DateTimeException('Zone offset not in valid range: -18:00 to +18:00');\n    }\n  };\n\n  ZoneOffset._validate = function _validate(hours, minutes, seconds) {\n    if (hours < -18 || hours > 18) {\n      throw new DateTimeException('Zone offset hours not in valid range: value ' + hours + ' is not in the range -18 to 18');\n    }\n\n    if (hours > 0) {\n      if (minutes < 0 || seconds < 0) {\n        throw new DateTimeException('Zone offset minutes and seconds must be positive because hours is positive');\n      }\n    } else if (hours < 0) {\n      if (minutes > 0 || seconds > 0) {\n        throw new DateTimeException('Zone offset minutes and seconds must be negative because hours is negative');\n      }\n    } else if (minutes > 0 && seconds < 0 || minutes < 0 && seconds > 0) {\n      throw new DateTimeException('Zone offset minutes and seconds must have the same sign');\n    }\n\n    if (Math.abs(minutes) > 59) {\n      throw new DateTimeException('Zone offset minutes not in valid range: abs(value) ' + Math.abs(minutes) + ' is not in the range 0 to 59');\n    }\n\n    if (Math.abs(seconds) > 59) {\n      throw new DateTimeException('Zone offset seconds not in valid range: abs(value) ' + Math.abs(seconds) + ' is not in the range 0 to 59');\n    }\n\n    if (Math.abs(hours) === 18 && (Math.abs(minutes) > 0 || Math.abs(seconds) > 0)) {\n      throw new DateTimeException('Zone offset not in valid range: -18:00 to +18:00');\n    }\n  };\n\n  ZoneOffset.of = function of(offsetId) {\n    requireNonNull(offsetId, 'offsetId');\n    var offset = ID_CACHE[offsetId];\n\n    if (offset != null) {\n      return offset;\n    }\n\n    var hours, minutes, seconds;\n\n    switch (offsetId.length) {\n      case 2:\n        offsetId = offsetId[0] + '0' + offsetId[1];\n\n      case 3:\n        hours = ZoneOffset._parseNumber(offsetId, 1, false);\n        minutes = 0;\n        seconds = 0;\n        break;\n\n      case 5:\n        hours = ZoneOffset._parseNumber(offsetId, 1, false);\n        minutes = ZoneOffset._parseNumber(offsetId, 3, false);\n        seconds = 0;\n        break;\n\n      case 6:\n        hours = ZoneOffset._parseNumber(offsetId, 1, false);\n        minutes = ZoneOffset._parseNumber(offsetId, 4, true);\n        seconds = 0;\n        break;\n\n      case 7:\n        hours = ZoneOffset._parseNumber(offsetId, 1, false);\n        minutes = ZoneOffset._parseNumber(offsetId, 3, false);\n        seconds = ZoneOffset._parseNumber(offsetId, 5, false);\n        break;\n\n      case 9:\n        hours = ZoneOffset._parseNumber(offsetId, 1, false);\n        minutes = ZoneOffset._parseNumber(offsetId, 4, true);\n        seconds = ZoneOffset._parseNumber(offsetId, 7, true);\n        break;\n\n      default:\n        throw new DateTimeException('Invalid ID for ZoneOffset, invalid format: ' + offsetId);\n    }\n\n    var first = offsetId[0];\n\n    if (first !== '+' && first !== '-') {\n      throw new DateTimeException('Invalid ID for ZoneOffset, plus/minus not found when expected: ' + offsetId);\n    }\n\n    if (first === '-') {\n      return ZoneOffset.ofHoursMinutesSeconds(-hours, -minutes, -seconds);\n    } else {\n      return ZoneOffset.ofHoursMinutesSeconds(hours, minutes, seconds);\n    }\n  };\n\n  ZoneOffset._parseNumber = function _parseNumber(offsetId, pos, precededByColon) {\n    if (precededByColon && offsetId[pos - 1] !== ':') {\n      throw new DateTimeException('Invalid ID for ZoneOffset, colon not found when expected: ' + offsetId);\n    }\n\n    var ch1 = offsetId[pos];\n    var ch2 = offsetId[pos + 1];\n\n    if (ch1 < '0' || ch1 > '9' || ch2 < '0' || ch2 > '9') {\n      throw new DateTimeException('Invalid ID for ZoneOffset, non numeric characters found: ' + offsetId);\n    }\n\n    return (ch1.charCodeAt(0) - 48) * 10 + (ch2.charCodeAt(0) - 48);\n  };\n\n  ZoneOffset.ofHours = function ofHours(hours) {\n    return ZoneOffset.ofHoursMinutesSeconds(hours, 0, 0);\n  };\n\n  ZoneOffset.ofHoursMinutes = function ofHoursMinutes(hours, minutes) {\n    return ZoneOffset.ofHoursMinutesSeconds(hours, minutes, 0);\n  };\n\n  ZoneOffset.ofHoursMinutesSeconds = function ofHoursMinutesSeconds(hours, minutes, seconds) {\n    ZoneOffset._validate(hours, minutes, seconds);\n\n    var totalSeconds = hours * LocalTime.SECONDS_PER_HOUR + minutes * LocalTime.SECONDS_PER_MINUTE + seconds;\n    return ZoneOffset.ofTotalSeconds(totalSeconds);\n  };\n\n  ZoneOffset.ofTotalMinutes = function ofTotalMinutes(totalMinutes) {\n    var totalSeconds = totalMinutes * LocalTime.SECONDS_PER_MINUTE;\n    return ZoneOffset.ofTotalSeconds(totalSeconds);\n  };\n\n  ZoneOffset.ofTotalSeconds = function ofTotalSeconds(totalSeconds) {\n    if (totalSeconds % (15 * LocalTime.SECONDS_PER_MINUTE) === 0) {\n      var totalSecs = totalSeconds;\n      var result = SECONDS_CACHE[totalSecs];\n\n      if (result == null) {\n        result = new ZoneOffset(totalSeconds);\n        SECONDS_CACHE[totalSecs] = result;\n        ID_CACHE[result.id()] = result;\n      }\n\n      return result;\n    } else {\n      return new ZoneOffset(totalSeconds);\n    }\n  };\n\n  _proto.rules = function rules() {\n    return this._rules;\n  };\n\n  _proto.get = function get(field) {\n    return this.getLong(field);\n  };\n\n  _proto.getLong = function getLong(field) {\n    if (field === ChronoField.OFFSET_SECONDS) {\n      return this._totalSeconds;\n    } else if (field instanceof ChronoField) {\n      throw new DateTimeException('Unsupported field: ' + field);\n    }\n\n    return field.getFrom(this);\n  };\n\n  _proto.query = function query(_query) {\n    requireNonNull(_query, 'query');\n\n    if (_query === TemporalQueries.offset() || _query === TemporalQueries.zone()) {\n      return this;\n    } else if (_query === TemporalQueries.localDate() || _query === TemporalQueries.localTime() || _query === TemporalQueries.precision() || _query === TemporalQueries.chronology() || _query === TemporalQueries.zoneId()) {\n      return null;\n    }\n\n    return _query.queryFrom(this);\n  };\n\n  _proto.adjustInto = function adjustInto(temporal) {\n    return temporal.with(ChronoField.OFFSET_SECONDS, this._totalSeconds);\n  };\n\n  _proto.compareTo = function compareTo(other) {\n    requireNonNull(other, 'other');\n    return other._totalSeconds - this._totalSeconds;\n  };\n\n  _proto.equals = function equals(obj) {\n    if (this === obj) {\n      return true;\n    }\n\n    if (obj instanceof ZoneOffset) {\n      return this._totalSeconds === obj._totalSeconds;\n    }\n\n    return false;\n  };\n\n  _proto.hashCode = function hashCode() {\n    return this._totalSeconds;\n  };\n\n  _proto.toString = function toString() {\n    return this._id;\n  };\n\n  return ZoneOffset;\n}(ZoneId);\nfunction _init$7() {\n  ZoneOffset.MAX_SECONDS = 18 * LocalTime.SECONDS_PER_HOUR;\n  ZoneOffset.UTC = ZoneOffset.ofTotalSeconds(0);\n  ZoneOffset.MIN = ZoneOffset.ofTotalSeconds(-ZoneOffset.MAX_SECONDS);\n  ZoneOffset.MAX = ZoneOffset.ofTotalSeconds(ZoneOffset.MAX_SECONDS);\n}\n\nvar DateTimeBuilder = function (_TemporalAccessor) {\n  _inheritsLoose(DateTimeBuilder, _TemporalAccessor);\n\n  DateTimeBuilder.create = function create(field, value) {\n    var dtb = new DateTimeBuilder();\n\n    dtb._addFieldValue(field, value);\n\n    return dtb;\n  };\n\n  function DateTimeBuilder() {\n    var _this;\n\n    _this = _TemporalAccessor.call(this) || this;\n    _this.fieldValues = new EnumMap();\n    _this.chrono = null;\n    _this.zone = null;\n    _this.date = null;\n    _this.time = null;\n    _this.leapSecond = false;\n    _this.excessDays = null;\n    return _this;\n  }\n\n  var _proto = DateTimeBuilder.prototype;\n\n  _proto.getFieldValue0 = function getFieldValue0(field) {\n    return this.fieldValues.get(field);\n  };\n\n  _proto._addFieldValue = function _addFieldValue(field, value) {\n    requireNonNull(field, 'field');\n    var old = this.getFieldValue0(field);\n\n    if (old != null && old !== value) {\n      throw new DateTimeException('Conflict found: ' + field + ' ' + old + ' differs from ' + field + ' ' + value + ': ' + this);\n    }\n\n    return this._putFieldValue0(field, value);\n  };\n\n  _proto._putFieldValue0 = function _putFieldValue0(field, value) {\n    this.fieldValues.put(field, value);\n    return this;\n  };\n\n  _proto.resolve = function resolve(resolverStyle, resolverFields) {\n    if (resolverFields != null) {\n      this.fieldValues.retainAll(resolverFields);\n    }\n\n    this._mergeDate(resolverStyle);\n\n    this._mergeTime(resolverStyle);\n\n    this._resolveTimeInferZeroes(resolverStyle);\n\n    if (this.excessDays != null && this.excessDays.isZero() === false && this.date != null && this.time != null) {\n      this.date = this.date.plus(this.excessDays);\n      this.excessDays = Period.ZERO;\n    }\n\n    this._resolveInstant();\n\n    return this;\n  };\n\n  _proto._mergeDate = function _mergeDate(resolverStyle) {\n    this._checkDate(IsoChronology.INSTANCE.resolveDate(this.fieldValues, resolverStyle));\n  };\n\n  _proto._checkDate = function _checkDate(date) {\n    if (date != null) {\n      this._addObject(date);\n\n      for (var fieldName in this.fieldValues.keySet()) {\n        var field = ChronoField.byName(fieldName);\n\n        if (field) {\n          if (this.fieldValues.get(field) !== undefined) {\n            if (field.isDateBased()) {\n              var val1 = void 0;\n\n              try {\n                val1 = date.getLong(field);\n              } catch (ex) {\n                if (ex instanceof DateTimeException) {\n                  continue;\n                } else {\n                  throw ex;\n                }\n              }\n\n              var val2 = this.fieldValues.get(field);\n\n              if (val1 !== val2) {\n                throw new DateTimeException('Conflict found: Field ' + field + ' ' + val1 + ' differs from ' + field + ' ' + val2 + ' derived from ' + date);\n              }\n            }\n          }\n        }\n      }\n    }\n  };\n\n  _proto._mergeTime = function _mergeTime(resolverStyle) {\n    if (this.fieldValues.containsKey(ChronoField.CLOCK_HOUR_OF_DAY)) {\n      var ch = this.fieldValues.remove(ChronoField.CLOCK_HOUR_OF_DAY);\n\n      if (resolverStyle !== ResolverStyle.LENIENT) {\n        if (resolverStyle === ResolverStyle.SMART && ch === 0) ; else {\n          ChronoField.CLOCK_HOUR_OF_DAY.checkValidValue(ch);\n        }\n      }\n\n      this._addFieldValue(ChronoField.HOUR_OF_DAY, ch === 24 ? 0 : ch);\n    }\n\n    if (this.fieldValues.containsKey(ChronoField.CLOCK_HOUR_OF_AMPM)) {\n      var _ch = this.fieldValues.remove(ChronoField.CLOCK_HOUR_OF_AMPM);\n\n      if (resolverStyle !== ResolverStyle.LENIENT) {\n        if (resolverStyle === ResolverStyle.SMART && _ch === 0) ; else {\n          ChronoField.CLOCK_HOUR_OF_AMPM.checkValidValue(_ch);\n        }\n      }\n\n      this._addFieldValue(ChronoField.HOUR_OF_AMPM, _ch === 12 ? 0 : _ch);\n    }\n\n    if (resolverStyle !== ResolverStyle.LENIENT) {\n      if (this.fieldValues.containsKey(ChronoField.AMPM_OF_DAY)) {\n        ChronoField.AMPM_OF_DAY.checkValidValue(this.fieldValues.get(ChronoField.AMPM_OF_DAY));\n      }\n\n      if (this.fieldValues.containsKey(ChronoField.HOUR_OF_AMPM)) {\n        ChronoField.HOUR_OF_AMPM.checkValidValue(this.fieldValues.get(ChronoField.HOUR_OF_AMPM));\n      }\n    }\n\n    if (this.fieldValues.containsKey(ChronoField.AMPM_OF_DAY) && this.fieldValues.containsKey(ChronoField.HOUR_OF_AMPM)) {\n      var ap = this.fieldValues.remove(ChronoField.AMPM_OF_DAY);\n      var hap = this.fieldValues.remove(ChronoField.HOUR_OF_AMPM);\n\n      this._addFieldValue(ChronoField.HOUR_OF_DAY, ap * 12 + hap);\n    }\n\n    if (this.fieldValues.containsKey(ChronoField.NANO_OF_DAY)) {\n      var nod = this.fieldValues.remove(ChronoField.NANO_OF_DAY);\n\n      if (resolverStyle !== ResolverStyle.LENIENT) {\n        ChronoField.NANO_OF_DAY.checkValidValue(nod);\n      }\n\n      this._addFieldValue(ChronoField.SECOND_OF_DAY, MathUtil.intDiv(nod, 1000000000));\n\n      this._addFieldValue(ChronoField.NANO_OF_SECOND, MathUtil.intMod(nod, 1000000000));\n    }\n\n    if (this.fieldValues.containsKey(ChronoField.MICRO_OF_DAY)) {\n      var cod = this.fieldValues.remove(ChronoField.MICRO_OF_DAY);\n\n      if (resolverStyle !== ResolverStyle.LENIENT) {\n        ChronoField.MICRO_OF_DAY.checkValidValue(cod);\n      }\n\n      this._addFieldValue(ChronoField.SECOND_OF_DAY, MathUtil.intDiv(cod, 1000000));\n\n      this._addFieldValue(ChronoField.MICRO_OF_SECOND, MathUtil.intMod(cod, 1000000));\n    }\n\n    if (this.fieldValues.containsKey(ChronoField.MILLI_OF_DAY)) {\n      var lod = this.fieldValues.remove(ChronoField.MILLI_OF_DAY);\n\n      if (resolverStyle !== ResolverStyle.LENIENT) {\n        ChronoField.MILLI_OF_DAY.checkValidValue(lod);\n      }\n\n      this._addFieldValue(ChronoField.SECOND_OF_DAY, MathUtil.intDiv(lod, 1000));\n\n      this._addFieldValue(ChronoField.MILLI_OF_SECOND, MathUtil.intMod(lod, 1000));\n    }\n\n    if (this.fieldValues.containsKey(ChronoField.SECOND_OF_DAY)) {\n      var sod = this.fieldValues.remove(ChronoField.SECOND_OF_DAY);\n\n      if (resolverStyle !== ResolverStyle.LENIENT) {\n        ChronoField.SECOND_OF_DAY.checkValidValue(sod);\n      }\n\n      this._addFieldValue(ChronoField.HOUR_OF_DAY, MathUtil.intDiv(sod, 3600));\n\n      this._addFieldValue(ChronoField.MINUTE_OF_HOUR, MathUtil.intMod(MathUtil.intDiv(sod, 60), 60));\n\n      this._addFieldValue(ChronoField.SECOND_OF_MINUTE, MathUtil.intMod(sod, 60));\n    }\n\n    if (this.fieldValues.containsKey(ChronoField.MINUTE_OF_DAY)) {\n      var mod = this.fieldValues.remove(ChronoField.MINUTE_OF_DAY);\n\n      if (resolverStyle !== ResolverStyle.LENIENT) {\n        ChronoField.MINUTE_OF_DAY.checkValidValue(mod);\n      }\n\n      this._addFieldValue(ChronoField.HOUR_OF_DAY, MathUtil.intDiv(mod, 60));\n\n      this._addFieldValue(ChronoField.MINUTE_OF_HOUR, MathUtil.intMod(mod, 60));\n    }\n\n    if (resolverStyle !== ResolverStyle.LENIENT) {\n      if (this.fieldValues.containsKey(ChronoField.MILLI_OF_SECOND)) {\n        ChronoField.MILLI_OF_SECOND.checkValidValue(this.fieldValues.get(ChronoField.MILLI_OF_SECOND));\n      }\n\n      if (this.fieldValues.containsKey(ChronoField.MICRO_OF_SECOND)) {\n        ChronoField.MICRO_OF_SECOND.checkValidValue(this.fieldValues.get(ChronoField.MICRO_OF_SECOND));\n      }\n    }\n\n    if (this.fieldValues.containsKey(ChronoField.MILLI_OF_SECOND) && this.fieldValues.containsKey(ChronoField.MICRO_OF_SECOND)) {\n      var los = this.fieldValues.remove(ChronoField.MILLI_OF_SECOND);\n      var cos = this.fieldValues.get(ChronoField.MICRO_OF_SECOND);\n\n      this._putFieldValue0(ChronoField.MICRO_OF_SECOND, los * 1000 + MathUtil.intMod(cos, 1000));\n    }\n\n    if (this.fieldValues.containsKey(ChronoField.MICRO_OF_SECOND) && this.fieldValues.containsKey(ChronoField.NANO_OF_SECOND)) {\n      var nos = this.fieldValues.get(ChronoField.NANO_OF_SECOND);\n\n      this._putFieldValue0(ChronoField.MICRO_OF_SECOND, MathUtil.intDiv(nos, 1000));\n\n      this.fieldValues.remove(ChronoField.MICRO_OF_SECOND);\n    }\n\n    if (this.fieldValues.containsKey(ChronoField.MILLI_OF_SECOND) && this.fieldValues.containsKey(ChronoField.NANO_OF_SECOND)) {\n      var _nos = this.fieldValues.get(ChronoField.NANO_OF_SECOND);\n\n      this._putFieldValue0(ChronoField.MILLI_OF_SECOND, MathUtil.intDiv(_nos, 1000000));\n\n      this.fieldValues.remove(ChronoField.MILLI_OF_SECOND);\n    }\n\n    if (this.fieldValues.containsKey(ChronoField.MICRO_OF_SECOND)) {\n      var _cos = this.fieldValues.remove(ChronoField.MICRO_OF_SECOND);\n\n      this._putFieldValue0(ChronoField.NANO_OF_SECOND, _cos * 1000);\n    } else if (this.fieldValues.containsKey(ChronoField.MILLI_OF_SECOND)) {\n      var _los = this.fieldValues.remove(ChronoField.MILLI_OF_SECOND);\n\n      this._putFieldValue0(ChronoField.NANO_OF_SECOND, _los * 1000000);\n    }\n  };\n\n  _proto._resolveTimeInferZeroes = function _resolveTimeInferZeroes(resolverStyle) {\n    var hod = this.fieldValues.get(ChronoField.HOUR_OF_DAY);\n    var moh = this.fieldValues.get(ChronoField.MINUTE_OF_HOUR);\n    var som = this.fieldValues.get(ChronoField.SECOND_OF_MINUTE);\n    var nos = this.fieldValues.get(ChronoField.NANO_OF_SECOND);\n\n    if (hod == null) {\n      return;\n    }\n\n    if (moh == null && (som != null || nos != null)) {\n      return;\n    }\n\n    if (moh != null && som == null && nos != null) {\n      return;\n    }\n\n    if (resolverStyle !== ResolverStyle.LENIENT) {\n      if (hod != null) {\n        if (resolverStyle === ResolverStyle.SMART && hod === 24 && (moh == null || moh === 0) && (som == null || som === 0) && (nos == null || nos === 0)) {\n          hod = 0;\n          this.excessDays = Period.ofDays(1);\n        }\n\n        var hodVal = ChronoField.HOUR_OF_DAY.checkValidIntValue(hod);\n\n        if (moh != null) {\n          var mohVal = ChronoField.MINUTE_OF_HOUR.checkValidIntValue(moh);\n\n          if (som != null) {\n            var somVal = ChronoField.SECOND_OF_MINUTE.checkValidIntValue(som);\n\n            if (nos != null) {\n              var nosVal = ChronoField.NANO_OF_SECOND.checkValidIntValue(nos);\n\n              this._addObject(LocalTime.of(hodVal, mohVal, somVal, nosVal));\n            } else {\n              this._addObject(LocalTime.of(hodVal, mohVal, somVal));\n            }\n          } else {\n            if (nos == null) {\n              this._addObject(LocalTime.of(hodVal, mohVal));\n            }\n          }\n        } else {\n          if (som == null && nos == null) {\n            this._addObject(LocalTime.of(hodVal, 0));\n          }\n        }\n      }\n    } else {\n      if (hod != null) {\n        var _hodVal = hod;\n\n        if (moh != null) {\n          if (som != null) {\n            if (nos == null) {\n              nos = 0;\n            }\n\n            var totalNanos = MathUtil.safeMultiply(_hodVal, 3600000000000);\n            totalNanos = MathUtil.safeAdd(totalNanos, MathUtil.safeMultiply(moh, 60000000000));\n            totalNanos = MathUtil.safeAdd(totalNanos, MathUtil.safeMultiply(som, 1000000000));\n            totalNanos = MathUtil.safeAdd(totalNanos, nos);\n            var excessDays = MathUtil.floorDiv(totalNanos, 86400000000000);\n            var nod = MathUtil.floorMod(totalNanos, 86400000000000);\n\n            this._addObject(LocalTime.ofNanoOfDay(nod));\n\n            this.excessDays = Period.ofDays(excessDays);\n          } else {\n            var totalSecs = MathUtil.safeMultiply(_hodVal, 3600);\n            totalSecs = MathUtil.safeAdd(totalSecs, MathUtil.safeMultiply(moh, 60));\n\n            var _excessDays = MathUtil.floorDiv(totalSecs, 86400);\n\n            var sod = MathUtil.floorMod(totalSecs, 86400);\n\n            this._addObject(LocalTime.ofSecondOfDay(sod));\n\n            this.excessDays = Period.ofDays(_excessDays);\n          }\n        } else {\n          var _excessDays2 = MathUtil.safeToInt(MathUtil.floorDiv(_hodVal, 24));\n\n          _hodVal = MathUtil.floorMod(_hodVal, 24);\n\n          this._addObject(LocalTime.of(_hodVal, 0));\n\n          this.excessDays = Period.ofDays(_excessDays2);\n        }\n      }\n    }\n\n    this.fieldValues.remove(ChronoField.HOUR_OF_DAY);\n    this.fieldValues.remove(ChronoField.MINUTE_OF_HOUR);\n    this.fieldValues.remove(ChronoField.SECOND_OF_MINUTE);\n    this.fieldValues.remove(ChronoField.NANO_OF_SECOND);\n  };\n\n  _proto._addObject = function _addObject(dateOrTime) {\n    if (dateOrTime instanceof ChronoLocalDate) {\n      this.date = dateOrTime;\n    } else if (dateOrTime instanceof LocalTime) {\n      this.time = dateOrTime;\n    }\n  };\n\n  _proto._resolveInstant = function _resolveInstant() {\n    if (this.date != null && this.time != null) {\n      var offsetSecs = this.fieldValues.get(ChronoField.OFFSET_SECONDS);\n\n      if (offsetSecs != null) {\n        var offset = ZoneOffset.ofTotalSeconds(offsetSecs);\n        var instant = this.date.atTime(this.time).atZone(offset).getLong(ChronoField.INSTANT_SECONDS);\n        this.fieldValues.put(ChronoField.INSTANT_SECONDS, instant);\n      } else if (this.zone != null) {\n        var _instant = this.date.atTime(this.time).atZone(this.zone).getLong(ChronoField.INSTANT_SECONDS);\n\n        this.fieldValues.put(ChronoField.INSTANT_SECONDS, _instant);\n      }\n    }\n  };\n\n  _proto.build = function build(type) {\n    return type.queryFrom(this);\n  };\n\n  _proto.isSupported = function isSupported(field) {\n    if (field == null) {\n      return false;\n    }\n\n    return this.fieldValues.containsKey(field) && this.fieldValues.get(field) !== undefined || this.date != null && this.date.isSupported(field) || this.time != null && this.time.isSupported(field);\n  };\n\n  _proto.getLong = function getLong(field) {\n    requireNonNull(field, 'field');\n    var value = this.getFieldValue0(field);\n\n    if (value == null) {\n      if (this.date != null && this.date.isSupported(field)) {\n        return this.date.getLong(field);\n      }\n\n      if (this.time != null && this.time.isSupported(field)) {\n        return this.time.getLong(field);\n      }\n\n      throw new DateTimeException('Field not found: ' + field);\n    }\n\n    return value;\n  };\n\n  _proto.query = function query(_query) {\n    if (_query === TemporalQueries.zoneId()) {\n      return this.zone;\n    } else if (_query === TemporalQueries.chronology()) {\n      return this.chrono;\n    } else if (_query === TemporalQueries.localDate()) {\n      return this.date != null ? LocalDate.from(this.date) : null;\n    } else if (_query === TemporalQueries.localTime()) {\n      return this.time;\n    } else if (_query === TemporalQueries.zone() || _query === TemporalQueries.offset()) {\n      return _query.queryFrom(this);\n    } else if (_query === TemporalQueries.precision()) {\n      return null;\n    }\n\n    return _query.queryFrom(this);\n  };\n\n  return DateTimeBuilder;\n}(TemporalAccessor);\n\nvar DateTimeParseContext = function () {\n  function DateTimeParseContext() {\n    if (arguments.length === 1) {\n      if (arguments[0] instanceof DateTimeParseContext) {\n        this._constructorSelf.apply(this, arguments);\n\n        return;\n      } else {\n        this._constructorFormatter.apply(this, arguments);\n      }\n    } else {\n      this._constructorParam.apply(this, arguments);\n    }\n\n    this._caseSensitive = true;\n    this._strict = true;\n    this._parsed = [new Parsed(this)];\n  }\n\n  var _proto = DateTimeParseContext.prototype;\n\n  _proto._constructorParam = function _constructorParam(locale, symbols, chronology) {\n    this._locale = locale;\n    this._symbols = symbols;\n    this._overrideChronology = chronology;\n  };\n\n  _proto._constructorFormatter = function _constructorFormatter(formatter) {\n    this._locale = formatter.locale();\n    this._symbols = formatter.decimalStyle();\n    this._overrideChronology = formatter.chronology();\n  };\n\n  _proto._constructorSelf = function _constructorSelf(other) {\n    this._locale = other._locale;\n    this._symbols = other._symbols;\n    this._overrideChronology = other._overrideChronology;\n    this._overrideZone = other._overrideZone;\n    this._caseSensitive = other._caseSensitive;\n    this._strict = other._strict;\n    this._parsed = [new Parsed(this)];\n  };\n\n  _proto.copy = function copy() {\n    return new DateTimeParseContext(this);\n  };\n\n  _proto.symbols = function symbols() {\n    return this._symbols;\n  };\n\n  _proto.isStrict = function isStrict() {\n    return this._strict;\n  };\n\n  _proto.setStrict = function setStrict(strict) {\n    this._strict = strict;\n  };\n\n  _proto.locale = function locale() {\n    return this._locale;\n  };\n\n  _proto.setLocale = function setLocale(locale) {\n    this._locale = locale;\n  };\n\n  _proto.startOptional = function startOptional() {\n    this._parsed.push(this.currentParsed().copy());\n  };\n\n  _proto.endOptional = function endOptional(successful) {\n    if (successful) {\n      this._parsed.splice(this._parsed.length - 2, 1);\n    } else {\n      this._parsed.splice(this._parsed.length - 1, 1);\n    }\n  };\n\n  _proto.isCaseSensitive = function isCaseSensitive() {\n    return this._caseSensitive;\n  };\n\n  _proto.setCaseSensitive = function setCaseSensitive(caseSensitive) {\n    this._caseSensitive = caseSensitive;\n  };\n\n  _proto.subSequenceEquals = function subSequenceEquals(cs1, offset1, cs2, offset2, length) {\n    if (offset1 + length > cs1.length || offset2 + length > cs2.length) {\n      return false;\n    }\n\n    if (!this.isCaseSensitive()) {\n      cs1 = cs1.toLowerCase();\n      cs2 = cs2.toLowerCase();\n    }\n\n    for (var i = 0; i < length; i++) {\n      var ch1 = cs1[offset1 + i];\n      var ch2 = cs2[offset2 + i];\n\n      if (ch1 !== ch2) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  _proto.charEquals = function charEquals(ch1, ch2) {\n    if (this.isCaseSensitive()) {\n      return ch1 === ch2;\n    }\n\n    return this.charEqualsIgnoreCase(ch1, ch2);\n  };\n\n  _proto.charEqualsIgnoreCase = function charEqualsIgnoreCase(c1, c2) {\n    return c1 === c2 || c1.toLowerCase() === c2.toLowerCase();\n  };\n\n  _proto.setParsedField = function setParsedField(field, value, errorPos, successPos) {\n    var currentParsedFieldValues = this.currentParsed().fieldValues;\n    var old = currentParsedFieldValues.get(field);\n    currentParsedFieldValues.set(field, value);\n    return old != null && old !== value ? ~errorPos : successPos;\n  };\n\n  _proto.setParsedZone = function setParsedZone(zone) {\n    requireNonNull(zone, 'zone');\n    this.currentParsed().zone = zone;\n  };\n\n  _proto.getParsed = function getParsed(field) {\n    return this.currentParsed().fieldValues.get(field);\n  };\n\n  _proto.toParsed = function toParsed() {\n    return this.currentParsed();\n  };\n\n  _proto.currentParsed = function currentParsed() {\n    return this._parsed[this._parsed.length - 1];\n  };\n\n  _proto.setParsedLeapSecond = function setParsedLeapSecond() {\n    this.currentParsed().leapSecond = true;\n  };\n\n  _proto.getEffectiveChronology = function getEffectiveChronology() {\n    var chrono = this.currentParsed().chrono;\n\n    if (chrono == null) {\n      chrono = this._overrideChronology;\n\n      if (chrono == null) {\n        chrono = IsoChronology.INSTANCE;\n      }\n    }\n\n    return chrono;\n  };\n\n  return DateTimeParseContext;\n}();\n\nvar Parsed = function (_Temporal) {\n  _inheritsLoose(Parsed, _Temporal);\n\n  function Parsed(dateTimeParseContext) {\n    var _this;\n\n    _this = _Temporal.call(this) || this;\n    _this.chrono = null;\n    _this.zone = null;\n    _this.fieldValues = new EnumMap();\n    _this.leapSecond = false;\n    _this.dateTimeParseContext = dateTimeParseContext;\n    return _this;\n  }\n\n  var _proto2 = Parsed.prototype;\n\n  _proto2.copy = function copy() {\n    var cloned = new Parsed();\n    cloned.chrono = this.chrono;\n    cloned.zone = this.zone;\n    cloned.fieldValues.putAll(this.fieldValues);\n    cloned.leapSecond = this.leapSecond;\n    cloned.dateTimeParseContext = this.dateTimeParseContext;\n    return cloned;\n  };\n\n  _proto2.toString = function toString() {\n    return this.fieldValues + \", \" + this.chrono + \", \" + this.zone;\n  };\n\n  _proto2.isSupported = function isSupported(field) {\n    return this.fieldValues.containsKey(field);\n  };\n\n  _proto2.get = function get(field) {\n    var val = this.fieldValues.get(field);\n    assert(val != null);\n    return val;\n  };\n\n  _proto2.query = function query(_query) {\n    if (_query === TemporalQueries.chronology()) {\n      return this.chrono;\n    }\n\n    if (_query === TemporalQueries.zoneId() || _query === TemporalQueries.zone()) {\n      return this.zone;\n    }\n\n    return _Temporal.prototype.query.call(this, _query);\n  };\n\n  _proto2.toBuilder = function toBuilder() {\n    var builder = new DateTimeBuilder();\n    builder.fieldValues.putAll(this.fieldValues);\n    builder.chrono = this.dateTimeParseContext.getEffectiveChronology();\n\n    if (this.zone != null) {\n      builder.zone = this.zone;\n    } else {\n      builder.zone = this.overrideZone;\n    }\n\n    builder.leapSecond = this.leapSecond;\n    builder.excessDays = this.excessDays;\n    return builder;\n  };\n\n  return Parsed;\n}(Temporal);\n\n/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\nvar DateTimePrintContext = function () {\n  function DateTimePrintContext(temporal, localeOrFormatter, symbols) {\n    if (arguments.length === 2 && arguments[1] instanceof DateTimeFormatter) {\n      this._temporal = DateTimePrintContext.adjust(temporal, localeOrFormatter);\n      this._locale = localeOrFormatter.locale();\n      this._symbols = localeOrFormatter.decimalStyle();\n    } else {\n      this._temporal = temporal;\n      this._locale = localeOrFormatter;\n      this._symbols = symbols;\n    }\n\n    this._optional = 0;\n  }\n\n  DateTimePrintContext.adjust = function adjust(temporal, formatter) {\n    return temporal;\n  };\n\n  var _proto = DateTimePrintContext.prototype;\n\n  _proto.symbols = function symbols() {\n    return this._symbols;\n  };\n\n  _proto.startOptional = function startOptional() {\n    this._optional++;\n  };\n\n  _proto.endOptional = function endOptional() {\n    this._optional--;\n  };\n\n  _proto.getValueQuery = function getValueQuery(query) {\n    var result = this._temporal.query(query);\n\n    if (result == null && this._optional === 0) {\n      throw new DateTimeException('Unable to extract value: ' + this._temporal);\n    }\n\n    return result;\n  };\n\n  _proto.getValue = function getValue(field) {\n    try {\n      return this._temporal.getLong(field);\n    } catch (ex) {\n      if (ex instanceof DateTimeException && this._optional > 0) {\n        return null;\n      }\n\n      throw ex;\n    }\n  };\n\n  _proto.temporal = function temporal() {\n    return this._temporal;\n  };\n\n  _proto.locale = function locale() {\n    return this._locale;\n  };\n\n  _proto.setDateTime = function setDateTime(temporal) {\n    this._temporal = temporal;\n  };\n\n  _proto.setLocale = function setLocale(locale) {\n    this._locale = locale;\n  };\n\n  return DateTimePrintContext;\n}();\n\nvar IsoFields = {};\nvar QUARTER_DAYS = [0, 90, 181, 273, 0, 91, 182, 274];\n\nvar Field = function (_TemporalField) {\n  _inheritsLoose(Field, _TemporalField);\n\n  function Field() {\n    return _TemporalField.apply(this, arguments) || this;\n  }\n\n  var _proto = Field.prototype;\n\n  _proto.isDateBased = function isDateBased() {\n    return true;\n  };\n\n  _proto.isTimeBased = function isTimeBased() {\n    return false;\n  };\n\n  _proto._isIso = function _isIso() {\n    return true;\n  };\n\n  Field._getWeekRangeByLocalDate = function _getWeekRangeByLocalDate(date) {\n    var wby = Field._getWeekBasedYear(date);\n\n    return ValueRange.of(1, Field._getWeekRangeByYear(wby));\n  };\n\n  Field._getWeekRangeByYear = function _getWeekRangeByYear(wby) {\n    var date = LocalDate.of(wby, 1, 1);\n\n    if (date.dayOfWeek() === DayOfWeek.THURSDAY || date.dayOfWeek() === DayOfWeek.WEDNESDAY && date.isLeapYear()) {\n      return 53;\n    }\n\n    return 52;\n  };\n\n  Field._getWeek = function _getWeek(date) {\n    var dow0 = date.dayOfWeek().ordinal();\n    var doy0 = date.dayOfYear() - 1;\n    var doyThu0 = doy0 + (3 - dow0);\n    var alignedWeek = MathUtil.intDiv(doyThu0, 7);\n    var firstThuDoy0 = doyThu0 - alignedWeek * 7;\n    var firstMonDoy0 = firstThuDoy0 - 3;\n\n    if (firstMonDoy0 < -3) {\n      firstMonDoy0 += 7;\n    }\n\n    if (doy0 < firstMonDoy0) {\n      return Field._getWeekRangeByLocalDate(date.withDayOfYear(180).minusYears(1)).maximum();\n    }\n\n    var week = MathUtil.intDiv(doy0 - firstMonDoy0, 7) + 1;\n\n    if (week === 53) {\n      if ((firstMonDoy0 === -3 || firstMonDoy0 === -2 && date.isLeapYear()) === false) {\n        week = 1;\n      }\n    }\n\n    return week;\n  };\n\n  Field._getWeekBasedYear = function _getWeekBasedYear(date) {\n    var year = date.year();\n    var doy = date.dayOfYear();\n\n    if (doy <= 3) {\n      var dow = date.dayOfWeek().ordinal();\n\n      if (doy - dow < -2) {\n        year--;\n      }\n    } else if (doy >= 363) {\n      var _dow = date.dayOfWeek().ordinal();\n\n      doy = doy - 363 - (date.isLeapYear() ? 1 : 0);\n\n      if (doy - _dow >= 0) {\n        year++;\n      }\n    }\n\n    return year;\n  };\n\n  _proto.displayName = function displayName() {\n    return this.toString();\n  };\n\n  _proto.resolve = function resolve() {\n    return null;\n  };\n\n  _proto.name = function name() {\n    return this.toString();\n  };\n\n  return Field;\n}(TemporalField);\n\nvar DAY_OF_QUARTER_FIELD = function (_Field) {\n  _inheritsLoose(DAY_OF_QUARTER_FIELD, _Field);\n\n  function DAY_OF_QUARTER_FIELD() {\n    return _Field.apply(this, arguments) || this;\n  }\n\n  var _proto2 = DAY_OF_QUARTER_FIELD.prototype;\n\n  _proto2.toString = function toString() {\n    return 'DayOfQuarter';\n  };\n\n  _proto2.baseUnit = function baseUnit() {\n    return ChronoUnit.DAYS;\n  };\n\n  _proto2.rangeUnit = function rangeUnit() {\n    return QUARTER_YEARS;\n  };\n\n  _proto2.range = function range() {\n    return ValueRange.of(1, 90, 92);\n  };\n\n  _proto2.isSupportedBy = function isSupportedBy(temporal) {\n    return temporal.isSupported(ChronoField.DAY_OF_YEAR) && temporal.isSupported(ChronoField.MONTH_OF_YEAR) && temporal.isSupported(ChronoField.YEAR) && this._isIso(temporal);\n  };\n\n  _proto2.rangeRefinedBy = function rangeRefinedBy(temporal) {\n    if (temporal.isSupported(this) === false) {\n      throw new UnsupportedTemporalTypeException('Unsupported field: DayOfQuarter');\n    }\n\n    var qoy = temporal.getLong(QUARTER_OF_YEAR);\n\n    if (qoy === 1) {\n      var year = temporal.getLong(ChronoField.YEAR);\n      return IsoChronology.isLeapYear(year) ? ValueRange.of(1, 91) : ValueRange.of(1, 90);\n    } else if (qoy === 2) {\n      return ValueRange.of(1, 91);\n    } else if (qoy === 3 || qoy === 4) {\n      return ValueRange.of(1, 92);\n    }\n\n    return this.range();\n  };\n\n  _proto2.getFrom = function getFrom(temporal) {\n    if (temporal.isSupported(this) === false) {\n      throw new UnsupportedTemporalTypeException('Unsupported field: DayOfQuarter');\n    }\n\n    var doy = temporal.get(ChronoField.DAY_OF_YEAR);\n    var moy = temporal.get(ChronoField.MONTH_OF_YEAR);\n    var year = temporal.getLong(ChronoField.YEAR);\n    return doy - QUARTER_DAYS[MathUtil.intDiv(moy - 1, 3) + (IsoChronology.isLeapYear(year) ? 4 : 0)];\n  };\n\n  _proto2.adjustInto = function adjustInto(temporal, newValue) {\n    var curValue = this.getFrom(temporal);\n    this.range().checkValidValue(newValue, this);\n    return temporal.with(ChronoField.DAY_OF_YEAR, temporal.getLong(ChronoField.DAY_OF_YEAR) + (newValue - curValue));\n  };\n\n  _proto2.resolve = function resolve(fieldValues, partialTemporal, resolverStyle) {\n    var yearLong = fieldValues.get(ChronoField.YEAR);\n    var qoyLong = fieldValues.get(QUARTER_OF_YEAR);\n\n    if (yearLong == null || qoyLong == null) {\n      return null;\n    }\n\n    var y = ChronoField.YEAR.checkValidIntValue(yearLong);\n    var doq = fieldValues.get(DAY_OF_QUARTER);\n    var date;\n\n    if (resolverStyle === ResolverStyle.LENIENT) {\n      var qoy = qoyLong;\n      date = LocalDate.of(y, 1, 1);\n      date = date.plusMonths(MathUtil.safeMultiply(MathUtil.safeSubtract(qoy, 1), 3));\n      date = date.plusDays(MathUtil.safeSubtract(doq, 1));\n    } else {\n      var _qoy = QUARTER_OF_YEAR.range().checkValidIntValue(qoyLong, QUARTER_OF_YEAR);\n\n      if (resolverStyle === ResolverStyle.STRICT) {\n        var max = 92;\n\n        if (_qoy === 1) {\n          max = IsoChronology.isLeapYear(y) ? 91 : 90;\n        } else if (_qoy === 2) {\n          max = 91;\n        }\n\n        ValueRange.of(1, max).checkValidValue(doq, this);\n      } else {\n        this.range().checkValidValue(doq, this);\n      }\n\n      date = LocalDate.of(y, (_qoy - 1) * 3 + 1, 1).plusDays(doq - 1);\n    }\n\n    fieldValues.remove(this);\n    fieldValues.remove(ChronoField.YEAR);\n    fieldValues.remove(QUARTER_OF_YEAR);\n    return date;\n  };\n\n  return DAY_OF_QUARTER_FIELD;\n}(Field);\n\nvar QUARTER_OF_YEAR_FIELD = function (_Field2) {\n  _inheritsLoose(QUARTER_OF_YEAR_FIELD, _Field2);\n\n  function QUARTER_OF_YEAR_FIELD() {\n    return _Field2.apply(this, arguments) || this;\n  }\n\n  var _proto3 = QUARTER_OF_YEAR_FIELD.prototype;\n\n  _proto3.toString = function toString() {\n    return 'QuarterOfYear';\n  };\n\n  _proto3.baseUnit = function baseUnit() {\n    return QUARTER_YEARS;\n  };\n\n  _proto3.rangeUnit = function rangeUnit() {\n    return ChronoUnit.YEARS;\n  };\n\n  _proto3.range = function range() {\n    return ValueRange.of(1, 4);\n  };\n\n  _proto3.isSupportedBy = function isSupportedBy(temporal) {\n    return temporal.isSupported(ChronoField.MONTH_OF_YEAR) && this._isIso(temporal);\n  };\n\n  _proto3.rangeRefinedBy = function rangeRefinedBy(temporal) {\n    return this.range();\n  };\n\n  _proto3.getFrom = function getFrom(temporal) {\n    if (temporal.isSupported(this) === false) {\n      throw new UnsupportedTemporalTypeException('Unsupported field: QuarterOfYear');\n    }\n\n    var moy = temporal.getLong(ChronoField.MONTH_OF_YEAR);\n    return MathUtil.intDiv(moy + 2, 3);\n  };\n\n  _proto3.adjustInto = function adjustInto(temporal, newValue) {\n    var curValue = this.getFrom(temporal);\n    this.range().checkValidValue(newValue, this);\n    return temporal.with(ChronoField.MONTH_OF_YEAR, temporal.getLong(ChronoField.MONTH_OF_YEAR) + (newValue - curValue) * 3);\n  };\n\n  return QUARTER_OF_YEAR_FIELD;\n}(Field);\n\nvar WEEK_OF_WEEK_BASED_YEAR_FIELD = function (_Field3) {\n  _inheritsLoose(WEEK_OF_WEEK_BASED_YEAR_FIELD, _Field3);\n\n  function WEEK_OF_WEEK_BASED_YEAR_FIELD() {\n    return _Field3.apply(this, arguments) || this;\n  }\n\n  var _proto4 = WEEK_OF_WEEK_BASED_YEAR_FIELD.prototype;\n\n  _proto4.toString = function toString() {\n    return 'WeekOfWeekBasedYear';\n  };\n\n  _proto4.baseUnit = function baseUnit() {\n    return ChronoUnit.WEEKS;\n  };\n\n  _proto4.rangeUnit = function rangeUnit() {\n    return WEEK_BASED_YEARS;\n  };\n\n  _proto4.range = function range() {\n    return ValueRange.of(1, 52, 53);\n  };\n\n  _proto4.isSupportedBy = function isSupportedBy(temporal) {\n    return temporal.isSupported(ChronoField.EPOCH_DAY) && this._isIso(temporal);\n  };\n\n  _proto4.rangeRefinedBy = function rangeRefinedBy(temporal) {\n    if (temporal.isSupported(this) === false) {\n      throw new UnsupportedTemporalTypeException('Unsupported field: WeekOfWeekBasedYear');\n    }\n\n    return Field._getWeekRangeByLocalDate(LocalDate.from(temporal));\n  };\n\n  _proto4.getFrom = function getFrom(temporal) {\n    if (temporal.isSupported(this) === false) {\n      throw new UnsupportedTemporalTypeException('Unsupported field: WeekOfWeekBasedYear');\n    }\n\n    return Field._getWeek(LocalDate.from(temporal));\n  };\n\n  _proto4.adjustInto = function adjustInto(temporal, newValue) {\n    this.range().checkValidValue(newValue, this);\n    return temporal.plus(MathUtil.safeSubtract(newValue, this.getFrom(temporal)), ChronoUnit.WEEKS);\n  };\n\n  _proto4.resolve = function resolve(fieldValues, partialTemporal, resolverStyle) {\n    var wbyLong = fieldValues.get(WEEK_BASED_YEAR);\n    var dowLong = fieldValues.get(ChronoField.DAY_OF_WEEK);\n\n    if (wbyLong == null || dowLong == null) {\n      return null;\n    }\n\n    var wby = WEEK_BASED_YEAR.range().checkValidIntValue(wbyLong, WEEK_BASED_YEAR);\n    var wowby = fieldValues.get(WEEK_OF_WEEK_BASED_YEAR);\n    var date;\n\n    if (resolverStyle === ResolverStyle.LENIENT) {\n      var dow = dowLong;\n      var weeks = 0;\n\n      if (dow > 7) {\n        weeks = MathUtil.intDiv(dow - 1, 7);\n        dow = MathUtil.intMod(dow - 1, 7) + 1;\n      } else if (dow < 1) {\n        weeks = MathUtil.intDiv(dow, 7) - 1;\n        dow = MathUtil.intMod(dow, 7) + 7;\n      }\n\n      date = LocalDate.of(wby, 1, 4).plusWeeks(wowby - 1).plusWeeks(weeks).with(ChronoField.DAY_OF_WEEK, dow);\n    } else {\n      var _dow2 = ChronoField.DAY_OF_WEEK.checkValidIntValue(dowLong);\n\n      if (resolverStyle === ResolverStyle.STRICT) {\n        var temp = LocalDate.of(wby, 1, 4);\n\n        var range = Field._getWeekRangeByLocalDate(temp);\n\n        range.checkValidValue(wowby, this);\n      } else {\n        this.range().checkValidValue(wowby, this);\n      }\n\n      date = LocalDate.of(wby, 1, 4).plusWeeks(wowby - 1).with(ChronoField.DAY_OF_WEEK, _dow2);\n    }\n\n    fieldValues.remove(this);\n    fieldValues.remove(WEEK_BASED_YEAR);\n    fieldValues.remove(ChronoField.DAY_OF_WEEK);\n    return date;\n  };\n\n  _proto4.displayName = function displayName() {\n    return 'Week';\n  };\n\n  return WEEK_OF_WEEK_BASED_YEAR_FIELD;\n}(Field);\n\nvar WEEK_BASED_YEAR_FIELD = function (_Field4) {\n  _inheritsLoose(WEEK_BASED_YEAR_FIELD, _Field4);\n\n  function WEEK_BASED_YEAR_FIELD() {\n    return _Field4.apply(this, arguments) || this;\n  }\n\n  var _proto5 = WEEK_BASED_YEAR_FIELD.prototype;\n\n  _proto5.toString = function toString() {\n    return 'WeekBasedYear';\n  };\n\n  _proto5.baseUnit = function baseUnit() {\n    return WEEK_BASED_YEARS;\n  };\n\n  _proto5.rangeUnit = function rangeUnit() {\n    return ChronoUnit.FOREVER;\n  };\n\n  _proto5.range = function range() {\n    return ChronoField.YEAR.range();\n  };\n\n  _proto5.isSupportedBy = function isSupportedBy(temporal) {\n    return temporal.isSupported(ChronoField.EPOCH_DAY) && this._isIso(temporal);\n  };\n\n  _proto5.rangeRefinedBy = function rangeRefinedBy(temporal) {\n    return ChronoField.YEAR.range();\n  };\n\n  _proto5.getFrom = function getFrom(temporal) {\n    if (temporal.isSupported(this) === false) {\n      throw new UnsupportedTemporalTypeException('Unsupported field: WeekBasedYear');\n    }\n\n    return Field._getWeekBasedYear(LocalDate.from(temporal));\n  };\n\n  _proto5.adjustInto = function adjustInto(temporal, newValue) {\n    if (this.isSupportedBy(temporal) === false) {\n      throw new UnsupportedTemporalTypeException('Unsupported field: WeekBasedYear');\n    }\n\n    var newWby = this.range().checkValidIntValue(newValue, WEEK_BASED_YEAR);\n    var date = LocalDate.from(temporal);\n    var dow = date.get(ChronoField.DAY_OF_WEEK);\n\n    var week = Field._getWeek(date);\n\n    if (week === 53 && Field._getWeekRangeByYear(newWby) === 52) {\n      week = 52;\n    }\n\n    var resolved = LocalDate.of(newWby, 1, 4);\n    var days = dow - resolved.get(ChronoField.DAY_OF_WEEK) + (week - 1) * 7;\n    resolved = resolved.plusDays(days);\n    return temporal.with(resolved);\n  };\n\n  return WEEK_BASED_YEAR_FIELD;\n}(Field);\n\nvar Unit = function (_TemporalUnit) {\n  _inheritsLoose(Unit, _TemporalUnit);\n\n  function Unit(name, estimatedDuration) {\n    var _this;\n\n    _this = _TemporalUnit.call(this) || this;\n    _this._name = name;\n    _this._duration = estimatedDuration;\n    return _this;\n  }\n\n  var _proto6 = Unit.prototype;\n\n  _proto6.duration = function duration() {\n    return this._duration;\n  };\n\n  _proto6.isDurationEstimated = function isDurationEstimated() {\n    return true;\n  };\n\n  _proto6.isDateBased = function isDateBased() {\n    return true;\n  };\n\n  _proto6.isTimeBased = function isTimeBased() {\n    return false;\n  };\n\n  _proto6.isSupportedBy = function isSupportedBy(temporal) {\n    return temporal.isSupported(ChronoField.EPOCH_DAY);\n  };\n\n  _proto6.addTo = function addTo(temporal, periodToAdd) {\n    switch (this) {\n      case WEEK_BASED_YEARS:\n        {\n          var added = MathUtil.safeAdd(temporal.get(WEEK_BASED_YEAR), periodToAdd);\n          return temporal.with(WEEK_BASED_YEAR, added);\n        }\n\n      case QUARTER_YEARS:\n        return temporal.plus(MathUtil.intDiv(periodToAdd, 256), ChronoUnit.YEARS).plus(MathUtil.intMod(periodToAdd, 256) * 3, ChronoUnit.MONTHS);\n\n      default:\n        throw new IllegalStateException('Unreachable');\n    }\n  };\n\n  _proto6.between = function between(temporal1, temporal2) {\n    switch (this) {\n      case WEEK_BASED_YEARS:\n        return MathUtil.safeSubtract(temporal2.getLong(WEEK_BASED_YEAR), temporal1.getLong(WEEK_BASED_YEAR));\n\n      case QUARTER_YEARS:\n        return MathUtil.intDiv(temporal1.until(temporal2, ChronoUnit.MONTHS), 3);\n\n      default:\n        throw new IllegalStateException('Unreachable');\n    }\n  };\n\n  _proto6.toString = function toString() {\n    return name;\n  };\n\n  return Unit;\n}(TemporalUnit);\n\nvar DAY_OF_QUARTER = null;\nvar QUARTER_OF_YEAR = null;\nvar WEEK_OF_WEEK_BASED_YEAR = null;\nvar WEEK_BASED_YEAR = null;\nvar WEEK_BASED_YEARS = null;\nvar QUARTER_YEARS = null;\nfunction _init$8() {\n  DAY_OF_QUARTER = new DAY_OF_QUARTER_FIELD();\n  QUARTER_OF_YEAR = new QUARTER_OF_YEAR_FIELD();\n  WEEK_OF_WEEK_BASED_YEAR = new WEEK_OF_WEEK_BASED_YEAR_FIELD();\n  WEEK_BASED_YEAR = new WEEK_BASED_YEAR_FIELD();\n  WEEK_BASED_YEARS = new Unit('WeekBasedYears', Duration.ofSeconds(31556952));\n  QUARTER_YEARS = new Unit('QuarterYears', Duration.ofSeconds(31556952 / 4));\n  IsoFields.DAY_OF_QUARTER = DAY_OF_QUARTER;\n  IsoFields.QUARTER_OF_YEAR = QUARTER_OF_YEAR;\n  IsoFields.WEEK_OF_WEEK_BASED_YEAR = WEEK_OF_WEEK_BASED_YEAR;\n  IsoFields.WEEK_BASED_YEAR = WEEK_BASED_YEAR;\n  IsoFields.WEEK_BASED_YEARS = WEEK_BASED_YEARS;\n  IsoFields.QUARTER_YEARS = QUARTER_YEARS;\n\n  LocalDate.prototype.isoWeekOfWeekyear = function () {\n    return this.get(IsoFields.WEEK_OF_WEEK_BASED_YEAR);\n  };\n\n  LocalDate.prototype.isoWeekyear = function () {\n    return this.get(IsoFields.WEEK_BASED_YEAR);\n  };\n}\n\n/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\nvar DecimalStyle = function () {\n  function DecimalStyle(zeroChar, positiveSignChar, negativeSignChar, decimalPointChar) {\n    this._zeroDigit = zeroChar;\n    this._zeroDigitCharCode = zeroChar.charCodeAt(0);\n    this._positiveSign = positiveSignChar;\n    this._negativeSign = negativeSignChar;\n    this._decimalSeparator = decimalPointChar;\n  }\n\n  var _proto = DecimalStyle.prototype;\n\n  _proto.positiveSign = function positiveSign() {\n    return this._positiveSign;\n  };\n\n  _proto.withPositiveSign = function withPositiveSign(positiveSign) {\n    if (positiveSign === this._positiveSign) {\n      return this;\n    }\n\n    return new DecimalStyle(this._zeroDigit, positiveSign, this._negativeSign, this._decimalSeparator);\n  };\n\n  _proto.negativeSign = function negativeSign() {\n    return this._negativeSign;\n  };\n\n  _proto.withNegativeSign = function withNegativeSign(negativeSign) {\n    if (negativeSign === this._negativeSign) {\n      return this;\n    }\n\n    return new DecimalStyle(this._zeroDigit, this._positiveSign, negativeSign, this._decimalSeparator);\n  };\n\n  _proto.zeroDigit = function zeroDigit() {\n    return this._zeroDigit;\n  };\n\n  _proto.withZeroDigit = function withZeroDigit(zeroDigit) {\n    if (zeroDigit === this._zeroDigit) {\n      return this;\n    }\n\n    return new DecimalStyle(zeroDigit, this._positiveSign, this._negativeSign, this._decimalSeparator);\n  };\n\n  _proto.decimalSeparator = function decimalSeparator() {\n    return this._decimalSeparator;\n  };\n\n  _proto.withDecimalSeparator = function withDecimalSeparator(decimalSeparator) {\n    if (decimalSeparator === this._decimalSeparator) {\n      return this;\n    }\n\n    return new DecimalStyle(this._zeroDigit, this._positiveSign, this._negativeSign, decimalSeparator);\n  };\n\n  _proto.convertToDigit = function convertToDigit(char) {\n    var val = char.charCodeAt(0) - this._zeroDigitCharCode;\n\n    return val >= 0 && val <= 9 ? val : -1;\n  };\n\n  _proto.convertNumberToI18N = function convertNumberToI18N(numericText) {\n    if (this._zeroDigit === '0') {\n      return numericText;\n    }\n\n    var diff = this._zeroDigitCharCode - '0'.charCodeAt(0);\n    var convertedText = '';\n\n    for (var i = 0; i < numericText.length; i++) {\n      convertedText += String.fromCharCode(numericText.charCodeAt(i) + diff);\n    }\n\n    return convertedText;\n  };\n\n  _proto.equals = function equals(other) {\n    if (this === other) {\n      return true;\n    }\n\n    if (other instanceof DecimalStyle) {\n      return this._zeroDigit === other._zeroDigit && this._positiveSign === other._positiveSign && this._negativeSign === other._negativeSign && this._decimalSeparator === other._decimalSeparator;\n    }\n\n    return false;\n  };\n\n  _proto.hashCode = function hashCode() {\n    return this._zeroDigit + this._positiveSign + this._negativeSign + this._decimalSeparator;\n  };\n\n  _proto.toString = function toString() {\n    return 'DecimalStyle[' + this._zeroDigit + this._positiveSign + this._negativeSign + this._decimalSeparator + ']';\n  };\n\n  DecimalStyle.of = function of() {\n    throw new Error('not yet supported');\n  };\n\n  DecimalStyle.availableLocales = function availableLocales() {\n    throw new Error('not yet supported');\n  };\n\n  return DecimalStyle;\n}();\nDecimalStyle.STANDARD = new DecimalStyle('0', '+', '-', '.');\n\nvar SignStyle = function (_Enum) {\n  _inheritsLoose(SignStyle, _Enum);\n\n  function SignStyle() {\n    return _Enum.apply(this, arguments) || this;\n  }\n\n  var _proto = SignStyle.prototype;\n\n  _proto.parse = function parse(positive, strict, fixedWidth) {\n    switch (this) {\n      case SignStyle.NORMAL:\n        return !positive || !strict;\n\n      case SignStyle.ALWAYS:\n      case SignStyle.EXCEEDS_PAD:\n        return true;\n\n      default:\n        return !strict && !fixedWidth;\n    }\n  };\n\n  return SignStyle;\n}(Enum);\nSignStyle.NORMAL = new SignStyle('NORMAL');\nSignStyle.NEVER = new SignStyle('NEVER');\nSignStyle.ALWAYS = new SignStyle('ALWAYS');\nSignStyle.EXCEEDS_PAD = new SignStyle('EXCEEDS_PAD');\nSignStyle.NOT_NEGATIVE = new SignStyle('NOT_NEGATIVE');\n\nvar TextStyle = function (_Enum) {\n  _inheritsLoose(TextStyle, _Enum);\n\n  function TextStyle() {\n    return _Enum.apply(this, arguments) || this;\n  }\n\n  var _proto = TextStyle.prototype;\n\n  _proto.isStandalone = function isStandalone() {\n    switch (this) {\n      case TextStyle.FULL_STANDALONE:\n      case TextStyle.SHORT_STANDALONE:\n      case TextStyle.NARROW_STANDALONE:\n        return true;\n\n      default:\n        return false;\n    }\n  };\n\n  _proto.asStandalone = function asStandalone() {\n    switch (this) {\n      case TextStyle.FULL:\n        return TextStyle.FULL_STANDALONE;\n\n      case TextStyle.SHORT:\n        return TextStyle.SHORT_STANDALONE;\n\n      case TextStyle.NARROW:\n        return TextStyle.NARROW_STANDALONE;\n\n      default:\n        return this;\n    }\n  };\n\n  _proto.asNormal = function asNormal() {\n    switch (this) {\n      case TextStyle.FULL_STANDALONE:\n        return TextStyle.FULL;\n\n      case TextStyle.SHORT_STANDALONE:\n        return TextStyle.SHORT;\n\n      case TextStyle.NARROW_STANDALONE:\n        return TextStyle.NARROW;\n\n      default:\n        return this;\n    }\n  };\n\n  return TextStyle;\n}(Enum);\nTextStyle.FULL = new TextStyle('FULL');\nTextStyle.FULL_STANDALONE = new TextStyle('FULL_STANDALONE');\nTextStyle.SHORT = new TextStyle('SHORT');\nTextStyle.SHORT_STANDALONE = new TextStyle('SHORT_STANDALONE');\nTextStyle.NARROW = new TextStyle('NARROW');\nTextStyle.NARROW_STANDALONE = new TextStyle('NARROW_STANDALONE');\n\n/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\nvar CharLiteralPrinterParser = function () {\n  function CharLiteralPrinterParser(literal) {\n    if (literal.length > 1) {\n      throw new IllegalArgumentException('invalid literal, too long: \"' + literal + '\"');\n    }\n\n    this._literal = literal;\n  }\n\n  var _proto = CharLiteralPrinterParser.prototype;\n\n  _proto.print = function print(context, buf) {\n    buf.append(this._literal);\n    return true;\n  };\n\n  _proto.parse = function parse(context, text, position) {\n    var length = text.length;\n\n    if (position === length) {\n      return ~position;\n    }\n\n    var ch = text.charAt(position);\n\n    if (context.charEquals(this._literal, ch) === false) {\n      return ~position;\n    }\n\n    return position + this._literal.length;\n  };\n\n  _proto.toString = function toString() {\n    if (this._literal === '\\'') {\n      return \"''\";\n    }\n\n    return \"'\" + this._literal + \"'\";\n  };\n\n  return CharLiteralPrinterParser;\n}();\n\n/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\nvar CompositePrinterParser = function () {\n  function CompositePrinterParser(printerParsers, optional) {\n    this._printerParsers = printerParsers;\n    this._optional = optional;\n  }\n\n  var _proto = CompositePrinterParser.prototype;\n\n  _proto.withOptional = function withOptional(optional) {\n    if (optional === this._optional) {\n      return this;\n    }\n\n    return new CompositePrinterParser(this._printerParsers, optional);\n  };\n\n  _proto.print = function print(context, buf) {\n    var length = buf.length();\n\n    if (this._optional) {\n      context.startOptional();\n    }\n\n    try {\n      for (var i = 0; i < this._printerParsers.length; i++) {\n        var pp = this._printerParsers[i];\n\n        if (pp.print(context, buf) === false) {\n          buf.setLength(length);\n          return true;\n        }\n      }\n    } finally {\n      if (this._optional) {\n        context.endOptional();\n      }\n    }\n\n    return true;\n  };\n\n  _proto.parse = function parse(context, text, position) {\n    if (this._optional) {\n      context.startOptional();\n      var pos = position;\n\n      for (var i = 0; i < this._printerParsers.length; i++) {\n        var pp = this._printerParsers[i];\n        pos = pp.parse(context, text, pos);\n\n        if (pos < 0) {\n          context.endOptional(false);\n          return position;\n        }\n      }\n\n      context.endOptional(true);\n      return pos;\n    } else {\n      for (var _i = 0; _i < this._printerParsers.length; _i++) {\n        var _pp = this._printerParsers[_i];\n        position = _pp.parse(context, text, position);\n\n        if (position < 0) {\n          break;\n        }\n      }\n\n      return position;\n    }\n  };\n\n  _proto.toString = function toString() {\n    var buf = '';\n\n    if (this._printerParsers != null) {\n      buf += this._optional ? '[' : '(';\n\n      for (var i = 0; i < this._printerParsers.length; i++) {\n        var pp = this._printerParsers[i];\n        buf += pp.toString();\n      }\n\n      buf += this._optional ? ']' : ')';\n    }\n\n    return buf;\n  };\n\n  return CompositePrinterParser;\n}();\n\n/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\nvar FractionPrinterParser = function () {\n  function FractionPrinterParser(field, minWidth, maxWidth, decimalPoint) {\n    requireNonNull(field, 'field');\n\n    if (field.range().isFixed() === false) {\n      throw new IllegalArgumentException('Field must have a fixed set of values: ' + field);\n    }\n\n    if (minWidth < 0 || minWidth > 9) {\n      throw new IllegalArgumentException('Minimum width must be from 0 to 9 inclusive but was ' + minWidth);\n    }\n\n    if (maxWidth < 1 || maxWidth > 9) {\n      throw new IllegalArgumentException('Maximum width must be from 1 to 9 inclusive but was ' + maxWidth);\n    }\n\n    if (maxWidth < minWidth) {\n      throw new IllegalArgumentException('Maximum width must exceed or equal the minimum width but ' + maxWidth + ' < ' + minWidth);\n    }\n\n    this.field = field;\n    this.minWidth = minWidth;\n    this.maxWidth = maxWidth;\n    this.decimalPoint = decimalPoint;\n  }\n\n  var _proto = FractionPrinterParser.prototype;\n\n  _proto.print = function print(context, buf) {\n    var value = context.getValue(this.field);\n\n    if (value === null) {\n      return false;\n    }\n\n    var symbols = context.symbols();\n\n    if (value === 0) {\n      if (this.minWidth > 0) {\n        if (this.decimalPoint) {\n          buf.append(symbols.decimalSeparator());\n        }\n\n        for (var i = 0; i < this.minWidth; i++) {\n          buf.append(symbols.zeroDigit());\n        }\n      }\n    } else {\n      var fraction = this.convertToFraction(value, symbols.zeroDigit());\n      var outputScale = Math.min(Math.max(fraction.length, this.minWidth), this.maxWidth);\n      fraction = fraction.substr(0, outputScale);\n\n      if (fraction * 1 > 0) {\n        while (fraction.length > this.minWidth && fraction[fraction.length - 1] === '0') {\n          fraction = fraction.substr(0, fraction.length - 1);\n        }\n      }\n\n      var str = fraction;\n      str = symbols.convertNumberToI18N(str);\n\n      if (this.decimalPoint) {\n        buf.append(symbols.decimalSeparator());\n      }\n\n      buf.append(str);\n    }\n\n    return true;\n  };\n\n  _proto.parse = function parse(context, text, position) {\n    var effectiveMin = context.isStrict() ? this.minWidth : 0;\n    var effectiveMax = context.isStrict() ? this.maxWidth : 9;\n    var length = text.length;\n\n    if (position === length) {\n      return effectiveMin > 0 ? ~position : position;\n    }\n\n    if (this.decimalPoint) {\n      if (text[position] !== context.symbols().decimalSeparator()) {\n        return effectiveMin > 0 ? ~position : position;\n      }\n\n      position++;\n    }\n\n    var minEndPos = position + effectiveMin;\n\n    if (minEndPos > length) {\n      return ~position;\n    }\n\n    var maxEndPos = Math.min(position + effectiveMax, length);\n    var total = 0;\n    var pos = position;\n\n    while (pos < maxEndPos) {\n      var ch = text.charAt(pos++);\n      var digit = context.symbols().convertToDigit(ch);\n\n      if (digit < 0) {\n        if (pos < minEndPos) {\n          return ~position;\n        }\n\n        pos--;\n        break;\n      }\n\n      total = total * 10 + digit;\n    }\n\n    var moveLeft = pos - position;\n    var scale = Math.pow(10, moveLeft);\n    var value = this.convertFromFraction(total, scale);\n    return context.setParsedField(this.field, value, position, pos);\n  };\n\n  _proto.convertToFraction = function convertToFraction(value, zeroDigit) {\n    var range = this.field.range();\n    range.checkValidValue(value, this.field);\n\n    var _min = range.minimum();\n\n    var _range = range.maximum() - _min + 1;\n\n    var _value = value - _min;\n\n    var _scaled = MathUtil.intDiv(_value * 1000000000, _range);\n\n    var fraction = '' + _scaled;\n\n    while (fraction.length < 9) {\n      fraction = zeroDigit + fraction;\n    }\n\n    return fraction;\n  };\n\n  _proto.convertFromFraction = function convertFromFraction(total, scale) {\n    var range = this.field.range();\n\n    var _min = range.minimum();\n\n    var _range = range.maximum() - _min + 1;\n\n    var _value = MathUtil.intDiv(total * _range, scale);\n\n    return _value;\n  };\n\n  _proto.toString = function toString() {\n    var decimal = this.decimalPoint ? ',DecimalPoint' : '';\n    return 'Fraction(' + this.field + ',' + this.minWidth + ',' + this.maxWidth + decimal + ')';\n  };\n\n  return FractionPrinterParser;\n}();\n\nvar MAX_WIDTH = 15;\nvar EXCEED_POINTS = [0, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000];\nvar NumberPrinterParser = function () {\n  function NumberPrinterParser(field, minWidth, maxWidth, signStyle, subsequentWidth) {\n    if (subsequentWidth === void 0) {\n      subsequentWidth = 0;\n    }\n\n    this._field = field;\n    this._minWidth = minWidth;\n    this._maxWidth = maxWidth;\n    this._signStyle = signStyle;\n    this._subsequentWidth = subsequentWidth;\n  }\n\n  var _proto = NumberPrinterParser.prototype;\n\n  _proto.field = function field() {\n    return this._field;\n  };\n\n  _proto.minWidth = function minWidth() {\n    return this._minWidth;\n  };\n\n  _proto.maxWidth = function maxWidth() {\n    return this._maxWidth;\n  };\n\n  _proto.signStyle = function signStyle() {\n    return this._signStyle;\n  };\n\n  _proto.withFixedWidth = function withFixedWidth() {\n    if (this._subsequentWidth === -1) {\n      return this;\n    }\n\n    return new NumberPrinterParser(this._field, this._minWidth, this._maxWidth, this._signStyle, -1);\n  };\n\n  _proto.withSubsequentWidth = function withSubsequentWidth(subsequentWidth) {\n    return new NumberPrinterParser(this._field, this._minWidth, this._maxWidth, this._signStyle, this._subsequentWidth + subsequentWidth);\n  };\n\n  _proto._isFixedWidth = function _isFixedWidth() {\n    return this._subsequentWidth === -1 || this._subsequentWidth > 0 && this._minWidth === this._maxWidth && this._signStyle === SignStyle.NOT_NEGATIVE;\n  };\n\n  _proto.print = function print(context, buf) {\n    var contextValue = context.getValue(this._field);\n\n    if (contextValue == null) {\n      return false;\n    }\n\n    var value = this._getValue(context, contextValue);\n\n    var symbols = context.symbols();\n    var str = '' + Math.abs(value);\n\n    if (str.length > this._maxWidth) {\n      throw new DateTimeException('Field ' + this._field + ' cannot be printed as the value ' + value + ' exceeds the maximum print width of ' + this._maxWidth);\n    }\n\n    str = symbols.convertNumberToI18N(str);\n\n    if (value >= 0) {\n      switch (this._signStyle) {\n        case SignStyle.EXCEEDS_PAD:\n          if (this._minWidth < MAX_WIDTH && value >= EXCEED_POINTS[this._minWidth]) {\n            buf.append(symbols.positiveSign());\n          }\n\n          break;\n\n        case SignStyle.ALWAYS:\n          buf.append(symbols.positiveSign());\n          break;\n      }\n    } else {\n      switch (this._signStyle) {\n        case SignStyle.NORMAL:\n        case SignStyle.EXCEEDS_PAD:\n        case SignStyle.ALWAYS:\n          buf.append(symbols.negativeSign());\n          break;\n\n        case SignStyle.NOT_NEGATIVE:\n          throw new DateTimeException('Field ' + this._field + ' cannot be printed as the value ' + value + ' cannot be negative according to the SignStyle');\n      }\n    }\n\n    for (var i = 0; i < this._minWidth - str.length; i++) {\n      buf.append(symbols.zeroDigit());\n    }\n\n    buf.append(str);\n    return true;\n  };\n\n  _proto.parse = function parse(context, text, position) {\n    var length = text.length;\n\n    if (position === length) {\n      return ~position;\n    }\n\n    assert(position >= 0 && position < length);\n    var sign = text.charAt(position);\n    var negative = false;\n    var positive = false;\n\n    if (sign === context.symbols().positiveSign()) {\n      if (this._signStyle.parse(true, context.isStrict(), this._minWidth === this._maxWidth) === false) {\n        return ~position;\n      }\n\n      positive = true;\n      position++;\n    } else if (sign === context.symbols().negativeSign()) {\n      if (this._signStyle.parse(false, context.isStrict(), this._minWidth === this._maxWidth) === false) {\n        return ~position;\n      }\n\n      negative = true;\n      position++;\n    } else {\n      if (this._signStyle === SignStyle.ALWAYS && context.isStrict()) {\n        return ~position;\n      }\n    }\n\n    var effMinWidth = context.isStrict() || this._isFixedWidth() ? this._minWidth : 1;\n    var minEndPos = position + effMinWidth;\n\n    if (minEndPos > length) {\n      return ~position;\n    }\n\n    var effMaxWidth = (context.isStrict() || this._isFixedWidth() ? this._maxWidth : 9) + Math.max(this._subsequentWidth, 0);\n    var total = 0;\n    var pos = position;\n\n    for (var pass = 0; pass < 2; pass++) {\n      var maxEndPos = Math.min(pos + effMaxWidth, length);\n\n      while (pos < maxEndPos) {\n        var ch = text.charAt(pos++);\n        var digit = context.symbols().convertToDigit(ch);\n\n        if (digit < 0) {\n          pos--;\n\n          if (pos < minEndPos) {\n            return ~position;\n          }\n\n          break;\n        }\n\n        if (pos - position > MAX_WIDTH) {\n          throw new ArithmeticException('number text exceeds length');\n        } else {\n          total = total * 10 + digit;\n        }\n      }\n\n      if (this._subsequentWidth > 0 && pass === 0) {\n        var parseLen = pos - position;\n        effMaxWidth = Math.max(effMinWidth, parseLen - this._subsequentWidth);\n        pos = position;\n        total = 0;\n      } else {\n        break;\n      }\n    }\n\n    if (negative) {\n      if (total === 0 && context.isStrict()) {\n        return ~(position - 1);\n      }\n\n      if (total !== 0) {\n        total = -total;\n      }\n    } else if (this._signStyle === SignStyle.EXCEEDS_PAD && context.isStrict()) {\n      var _parseLen = pos - position;\n\n      if (positive) {\n        if (_parseLen <= this._minWidth) {\n          return ~(position - 1);\n        }\n      } else {\n        if (_parseLen > this._minWidth) {\n          return ~position;\n        }\n      }\n    }\n\n    return this._setValue(context, total, position, pos);\n  };\n\n  _proto._getValue = function _getValue(context, value) {\n    return value;\n  };\n\n  _proto._setValue = function _setValue(context, value, errorPos, successPos) {\n    return context.setParsedField(this._field, value, errorPos, successPos);\n  };\n\n  _proto.toString = function toString() {\n    if (this._minWidth === 1 && this._maxWidth === MAX_WIDTH && this._signStyle === SignStyle.NORMAL) {\n      return 'Value(' + this._field + ')';\n    }\n\n    if (this._minWidth === this._maxWidth && this._signStyle === SignStyle.NOT_NEGATIVE) {\n      return 'Value(' + this._field + ',' + this._minWidth + ')';\n    }\n\n    return 'Value(' + this._field + ',' + this._minWidth + ',' + this._maxWidth + ',' + this._signStyle + ')';\n  };\n\n  return NumberPrinterParser;\n}();\nvar ReducedPrinterParser = function (_NumberPrinterParser) {\n  _inheritsLoose(ReducedPrinterParser, _NumberPrinterParser);\n\n  function ReducedPrinterParser(field, width, maxWidth, baseValue, baseDate) {\n    var _this;\n\n    _this = _NumberPrinterParser.call(this, field, width, maxWidth, SignStyle.NOT_NEGATIVE) || this;\n\n    if (width < 1 || width > 10) {\n      throw new IllegalArgumentException('The width must be from 1 to 10 inclusive but was ' + width);\n    }\n\n    if (maxWidth < 1 || maxWidth > 10) {\n      throw new IllegalArgumentException('The maxWidth must be from 1 to 10 inclusive but was ' + maxWidth);\n    }\n\n    if (maxWidth < width) {\n      throw new IllegalArgumentException('The maxWidth must be greater than the width');\n    }\n\n    if (baseDate === null) {\n      if (field.range().isValidValue(baseValue) === false) {\n        throw new IllegalArgumentException('The base value must be within the range of the field');\n      }\n\n      if (baseValue + EXCEED_POINTS[width] > MathUtil.MAX_SAFE_INTEGER) {\n        throw new DateTimeException('Unable to add printer-parser as the range exceeds the capacity of an int');\n      }\n    }\n\n    _this._baseValue = baseValue;\n    _this._baseDate = baseDate;\n    return _this;\n  }\n\n  var _proto2 = ReducedPrinterParser.prototype;\n\n  _proto2._getValue = function _getValue(context, value) {\n    var absValue = Math.abs(value);\n    var baseValue = this._baseValue;\n\n    if (this._baseDate !== null) {\n      context.temporal();\n      var chrono = IsoChronology.INSTANCE;\n      baseValue = chrono.date(this._baseDate).get(this._field);\n    }\n\n    if (value >= baseValue && value < baseValue + EXCEED_POINTS[this._minWidth]) {\n      return absValue % EXCEED_POINTS[this._minWidth];\n    }\n\n    return absValue % EXCEED_POINTS[this._maxWidth];\n  };\n\n  _proto2._setValue = function _setValue(context, value, errorPos, successPos) {\n    var baseValue = this._baseValue;\n\n    if (this._baseDate != null) {\n      var chrono = context.getEffectiveChronology();\n      baseValue = chrono.date(this._baseDate).get(this._field);\n    }\n\n    var parseLen = successPos - errorPos;\n\n    if (parseLen === this._minWidth && value >= 0) {\n      var range = EXCEED_POINTS[this._minWidth];\n      var lastPart = baseValue % range;\n      var basePart = baseValue - lastPart;\n\n      if (baseValue > 0) {\n        value = basePart + value;\n      } else {\n        value = basePart - value;\n      }\n\n      if (value < baseValue) {\n        value += range;\n      }\n    }\n\n    return context.setParsedField(this._field, value, errorPos, successPos);\n  };\n\n  _proto2.withFixedWidth = function withFixedWidth() {\n    if (this._subsequentWidth === -1) {\n      return this;\n    }\n\n    return new ReducedPrinterParser(this._field, this._minWidth, this._maxWidth, this._baseValue, this._baseDate, -1);\n  };\n\n  _proto2.withSubsequentWidth = function withSubsequentWidth(subsequentWidth) {\n    return new ReducedPrinterParser(this._field, this._minWidth, this._maxWidth, this._baseValue, this._baseDate, this._subsequentWidth + subsequentWidth);\n  };\n\n  _proto2.isFixedWidth = function isFixedWidth(context) {\n    if (context.isStrict() === false) {\n      return false;\n    }\n\n    return _NumberPrinterParser.prototype.isFixedWidth.call(this, context);\n  };\n\n  _proto2.toString = function toString() {\n    return 'ReducedValue(' + this._field + ',' + this._minWidth + ',' + this._maxWidth + ',' + (this._baseDate != null ? this._baseDate : this._baseValue) + ')';\n  };\n\n  return ReducedPrinterParser;\n}(NumberPrinterParser);\n\n/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\nvar PATTERNS = ['+HH', '+HHmm', '+HH:mm', '+HHMM', '+HH:MM', '+HHMMss', '+HH:MM:ss', '+HHMMSS', '+HH:MM:SS'];\nvar OffsetIdPrinterParser = function () {\n  function OffsetIdPrinterParser(noOffsetText, pattern) {\n    requireNonNull(noOffsetText, 'noOffsetText');\n    requireNonNull(pattern, 'pattern');\n    this.noOffsetText = noOffsetText;\n    this.type = this._checkPattern(pattern);\n  }\n\n  var _proto = OffsetIdPrinterParser.prototype;\n\n  _proto._checkPattern = function _checkPattern(pattern) {\n    for (var i = 0; i < PATTERNS.length; i++) {\n      if (PATTERNS[i] === pattern) {\n        return i;\n      }\n    }\n\n    throw new IllegalArgumentException('Invalid zone offset pattern: ' + pattern);\n  };\n\n  _proto.print = function print(context, buf) {\n    var offsetSecs = context.getValue(ChronoField.OFFSET_SECONDS);\n\n    if (offsetSecs == null) {\n      return false;\n    }\n\n    var totalSecs = MathUtil.safeToInt(offsetSecs);\n\n    if (totalSecs === 0) {\n      buf.append(this.noOffsetText);\n    } else {\n      var absHours = Math.abs(MathUtil.intMod(MathUtil.intDiv(totalSecs, 3600), 100));\n      var absMinutes = Math.abs(MathUtil.intMod(MathUtil.intDiv(totalSecs, 60), 60));\n      var absSeconds = Math.abs(MathUtil.intMod(totalSecs, 60));\n      var bufPos = buf.length();\n      var output = absHours;\n      buf.append(totalSecs < 0 ? '-' : '+').appendChar(MathUtil.intDiv(absHours, 10) + '0').appendChar(MathUtil.intMod(absHours, 10) + '0');\n\n      if (this.type >= 3 || this.type >= 1 && absMinutes > 0) {\n        buf.append(this.type % 2 === 0 ? ':' : '').appendChar(MathUtil.intDiv(absMinutes, 10) + '0').appendChar(absMinutes % 10 + '0');\n        output += absMinutes;\n\n        if (this.type >= 7 || this.type >= 5 && absSeconds > 0) {\n          buf.append(this.type % 2 === 0 ? ':' : '').appendChar(MathUtil.intDiv(absSeconds, 10) + '0').appendChar(absSeconds % 10 + '0');\n          output += absSeconds;\n        }\n      }\n\n      if (output === 0) {\n        buf.setLength(bufPos);\n        buf.append(this.noOffsetText);\n      }\n    }\n\n    return true;\n  };\n\n  _proto.parse = function parse(context, text, position) {\n    var length = text.length;\n    var noOffsetLen = this.noOffsetText.length;\n\n    if (noOffsetLen === 0) {\n      if (position === length) {\n        return context.setParsedField(ChronoField.OFFSET_SECONDS, 0, position, position);\n      }\n    } else {\n      if (position === length) {\n        return ~position;\n      }\n\n      if (context.subSequenceEquals(text, position, this.noOffsetText, 0, noOffsetLen)) {\n        return context.setParsedField(ChronoField.OFFSET_SECONDS, 0, position, position + noOffsetLen);\n      }\n    }\n\n    var sign = text[position];\n\n    if (sign === '+' || sign === '-') {\n      var negative = sign === '-' ? -1 : 1;\n      var array = [0, 0, 0, 0];\n      array[0] = position + 1;\n\n      if ((this._parseNumber(array, 1, text, true) || this._parseNumber(array, 2, text, this.type >= 3) || this._parseNumber(array, 3, text, false)) === false) {\n        var offsetSecs = MathUtil.safeZero(negative * (array[1] * 3600 + array[2] * 60 + array[3]));\n        return context.setParsedField(ChronoField.OFFSET_SECONDS, offsetSecs, position, array[0]);\n      }\n    }\n\n    if (noOffsetLen === 0) {\n      return context.setParsedField(ChronoField.OFFSET_SECONDS, 0, position, position + noOffsetLen);\n    }\n\n    return ~position;\n  };\n\n  _proto._parseNumber = function _parseNumber(array, arrayIndex, parseText, required) {\n    if ((this.type + 3) / 2 < arrayIndex) {\n      return false;\n    }\n\n    var pos = array[0];\n\n    if (this.type % 2 === 0 && arrayIndex > 1) {\n      if (pos + 1 > parseText.length || parseText[pos] !== ':') {\n        return required;\n      }\n\n      pos++;\n    }\n\n    if (pos + 2 > parseText.length) {\n      return required;\n    }\n\n    var ch1 = parseText[pos++];\n    var ch2 = parseText[pos++];\n\n    if (ch1 < '0' || ch1 > '9' || ch2 < '0' || ch2 > '9') {\n      return required;\n    }\n\n    var value = (ch1.charCodeAt(0) - 48) * 10 + (ch2.charCodeAt(0) - 48);\n\n    if (value < 0 || value > 59) {\n      return required;\n    }\n\n    array[arrayIndex] = value;\n    array[0] = pos;\n    return false;\n  };\n\n  _proto.toString = function toString() {\n    var converted = this.noOffsetText.replace('\\'', '\\'\\'');\n    return 'Offset(' + PATTERNS[this.type] + ',\\'' + converted + '\\')';\n  };\n\n  return OffsetIdPrinterParser;\n}();\nOffsetIdPrinterParser.INSTANCE_ID = new OffsetIdPrinterParser('Z', '+HH:MM:ss');\nOffsetIdPrinterParser.PATTERNS = PATTERNS;\n\n/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\nvar PadPrinterParserDecorator = function () {\n  function PadPrinterParserDecorator(printerParser, padWidth, padChar) {\n    this._printerParser = printerParser;\n    this._padWidth = padWidth;\n    this._padChar = padChar;\n  }\n\n  var _proto = PadPrinterParserDecorator.prototype;\n\n  _proto.print = function print(context, buf) {\n    var preLen = buf.length();\n\n    if (this._printerParser.print(context, buf) === false) {\n      return false;\n    }\n\n    var len = buf.length() - preLen;\n\n    if (len > this._padWidth) {\n      throw new DateTimeException(\"Cannot print as output of \" + len + \" characters exceeds pad width of \" + this._padWidth);\n    }\n\n    for (var i = 0; i < this._padWidth - len; i++) {\n      buf.insert(preLen, this._padChar);\n    }\n\n    return true;\n  };\n\n  _proto.parse = function parse(context, text, position) {\n    var strict = context.isStrict();\n    var caseSensitive = context.isCaseSensitive();\n    assert(!(position > text.length));\n    assert(position >= 0);\n\n    if (position === text.length) {\n      return ~position;\n    }\n\n    var endPos = position + this._padWidth;\n\n    if (endPos > text.length) {\n      if (strict) {\n        return ~position;\n      }\n\n      endPos = text.length;\n    }\n\n    var pos = position;\n\n    while (pos < endPos && (caseSensitive ? text[pos] === this._padChar : context.charEquals(text[pos], this._padChar))) {\n      pos++;\n    }\n\n    text = text.substring(0, endPos);\n\n    var resultPos = this._printerParser.parse(context, text, pos);\n\n    if (resultPos !== endPos && strict) {\n      return ~(position + pos);\n    }\n\n    return resultPos;\n  };\n\n  _proto.toString = function toString() {\n    return \"Pad(\" + this._printerParser + \",\" + this._padWidth + (this._padChar === ' ' ? ')' : ',\\'' + this._padChar + '\\')');\n  };\n\n  return PadPrinterParserDecorator;\n}();\n\nvar SettingsParser = function (_Enum) {\n  _inheritsLoose(SettingsParser, _Enum);\n\n  function SettingsParser() {\n    return _Enum.apply(this, arguments) || this;\n  }\n\n  var _proto = SettingsParser.prototype;\n\n  _proto.print = function print() {\n    return true;\n  };\n\n  _proto.parse = function parse(context, text, position) {\n    switch (this) {\n      case SettingsParser.SENSITIVE:\n        context.setCaseSensitive(true);\n        break;\n\n      case SettingsParser.INSENSITIVE:\n        context.setCaseSensitive(false);\n        break;\n\n      case SettingsParser.STRICT:\n        context.setStrict(true);\n        break;\n\n      case SettingsParser.LENIENT:\n        context.setStrict(false);\n        break;\n    }\n\n    return position;\n  };\n\n  _proto.toString = function toString() {\n    switch (this) {\n      case SettingsParser.SENSITIVE:\n        return 'ParseCaseSensitive(true)';\n\n      case SettingsParser.INSENSITIVE:\n        return 'ParseCaseSensitive(false)';\n\n      case SettingsParser.STRICT:\n        return 'ParseStrict(true)';\n\n      case SettingsParser.LENIENT:\n        return 'ParseStrict(false)';\n    }\n  };\n\n  return SettingsParser;\n}(Enum);\nSettingsParser.SENSITIVE = new SettingsParser('SENSITIVE');\nSettingsParser.INSENSITIVE = new SettingsParser('INSENSITIVE');\nSettingsParser.STRICT = new SettingsParser('STRICT');\nSettingsParser.LENIENT = new SettingsParser('LENIENT');\n\n/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\nvar StringLiteralPrinterParser = function () {\n  function StringLiteralPrinterParser(literal) {\n    this._literal = literal;\n  }\n\n  var _proto = StringLiteralPrinterParser.prototype;\n\n  _proto.print = function print(context, buf) {\n    buf.append(this._literal);\n    return true;\n  };\n\n  _proto.parse = function parse(context, text, position) {\n    var length = text.length;\n    assert(!(position > length || position < 0));\n\n    if (context.subSequenceEquals(text, position, this._literal, 0, this._literal.length) === false) {\n      return ~position;\n    }\n\n    return position + this._literal.length;\n  };\n\n  _proto.toString = function toString() {\n    var converted = this._literal.replace(\"'\", \"''\");\n\n    return '\\'' + converted + '\\'';\n  };\n\n  return StringLiteralPrinterParser;\n}();\n\n/*\n * @copyright (c) 2016, Philipp Thürwächter, Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\nvar ZoneRulesProvider = function () {\n  function ZoneRulesProvider() {}\n\n  ZoneRulesProvider.getRules = function getRules(zoneId) {\n    throw new DateTimeException('unsupported ZoneId:' + zoneId);\n  };\n\n  ZoneRulesProvider.getAvailableZoneIds = function getAvailableZoneIds() {\n    return [];\n  };\n\n  return ZoneRulesProvider;\n}();\n\nvar ZoneRegion = function (_ZoneId) {\n  _inheritsLoose(ZoneRegion, _ZoneId);\n\n  ZoneRegion.ofId = function ofId(zoneId) {\n    var rules = ZoneRulesProvider.getRules(zoneId);\n    return new ZoneRegion(zoneId, rules);\n  };\n\n  function ZoneRegion(id, rules) {\n    var _this;\n\n    _this = _ZoneId.call(this) || this;\n    _this._id = id;\n    _this._rules = rules;\n    return _this;\n  }\n\n  var _proto = ZoneRegion.prototype;\n\n  _proto.id = function id() {\n    return this._id;\n  };\n\n  _proto.rules = function rules() {\n    return this._rules;\n  };\n\n  return ZoneRegion;\n}(ZoneId);\n\n/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\nvar ZoneIdPrinterParser = function () {\n  function ZoneIdPrinterParser(query, description) {\n    this.query = query;\n    this.description = description;\n  }\n\n  var _proto = ZoneIdPrinterParser.prototype;\n\n  _proto.print = function print(context, buf) {\n    var zone = context.getValueQuery(this.query);\n\n    if (zone == null) {\n      return false;\n    }\n\n    buf.append(zone.id());\n    return true;\n  };\n\n  _proto.parse = function parse(context, text, position) {\n    var length = text.length;\n\n    if (position > length) {\n      return ~position;\n    }\n\n    if (position === length) {\n      return ~position;\n    }\n\n    var nextChar = text.charAt(position);\n\n    if (nextChar === '+' || nextChar === '-') {\n      var newContext = context.copy();\n      var endPos = OffsetIdPrinterParser.INSTANCE_ID.parse(newContext, text, position);\n\n      if (endPos < 0) {\n        return endPos;\n      }\n\n      var offset = newContext.getParsed(ChronoField.OFFSET_SECONDS);\n      var zone = ZoneOffset.ofTotalSeconds(offset);\n      context.setParsedZone(zone);\n      return endPos;\n    } else if (length >= position + 2) {\n      var nextNextChar = text.charAt(position + 1);\n\n      if (context.charEquals(nextChar, 'U') && context.charEquals(nextNextChar, 'T')) {\n        if (length >= position + 3 && context.charEquals(text.charAt(position + 2), 'C')) {\n          return this._parsePrefixedOffset(context, text, position, position + 3);\n        }\n\n        return this._parsePrefixedOffset(context, text, position, position + 2);\n      } else if (context.charEquals(nextChar, 'G') && length >= position + 3 && context.charEquals(nextNextChar, 'M') && context.charEquals(text.charAt(position + 2), 'T')) {\n        return this._parsePrefixedOffset(context, text, position, position + 3);\n      }\n    }\n\n    if (text.substr(position, 6) === 'SYSTEM') {\n      context.setParsedZone(ZoneId.systemDefault());\n      return position + 6;\n    }\n\n    if (context.charEquals(nextChar, 'Z')) {\n      context.setParsedZone(ZoneOffset.UTC);\n      return position + 1;\n    }\n\n    var availableZoneIds = ZoneRulesProvider.getAvailableZoneIds();\n\n    if (zoneIdTree.size !== availableZoneIds.length) {\n      zoneIdTree = ZoneIdTree.createTreeMap(availableZoneIds);\n    }\n\n    var maxParseLength = length - position;\n    var treeMap = zoneIdTree.treeMap;\n    var parsedZoneId = null;\n    var parseLength = 0;\n\n    while (treeMap != null) {\n      var parsedSubZoneId = text.substr(position, Math.min(treeMap.length, maxParseLength));\n      treeMap = treeMap.get(parsedSubZoneId);\n\n      if (treeMap != null && treeMap.isLeaf) {\n        parsedZoneId = parsedSubZoneId;\n        parseLength = treeMap.length;\n      }\n    }\n\n    if (parsedZoneId != null) {\n      context.setParsedZone(ZoneRegion.ofId(parsedZoneId));\n      return position + parseLength;\n    }\n\n    return ~position;\n  };\n\n  _proto._parsePrefixedOffset = function _parsePrefixedOffset(context, text, prefixPos, position) {\n    var prefix = text.substring(prefixPos, position).toUpperCase();\n    var newContext = context.copy();\n\n    if (position < text.length && context.charEquals(text.charAt(position), 'Z')) {\n      context.setParsedZone(ZoneId.ofOffset(prefix, ZoneOffset.UTC));\n      return position;\n    }\n\n    var endPos = OffsetIdPrinterParser.INSTANCE_ID.parse(newContext, text, position);\n\n    if (endPos < 0) {\n      context.setParsedZone(ZoneId.ofOffset(prefix, ZoneOffset.UTC));\n      return position;\n    }\n\n    var offsetSecs = newContext.getParsed(ChronoField.OFFSET_SECONDS);\n    var offset = ZoneOffset.ofTotalSeconds(offsetSecs);\n    context.setParsedZone(ZoneId.ofOffset(prefix, offset));\n    return endPos;\n  };\n\n  _proto.toString = function toString() {\n    return this.description;\n  };\n\n  return ZoneIdPrinterParser;\n}();\n\nvar ZoneIdTree = function () {\n  ZoneIdTree.createTreeMap = function createTreeMap(availableZoneIds) {\n    var sortedZoneIds = availableZoneIds.sort(function (a, b) {\n      return a.length - b.length;\n    });\n    var treeMap = new ZoneIdTreeMap(sortedZoneIds[0].length, false);\n\n    for (var i = 0; i < sortedZoneIds.length; i++) {\n      treeMap.add(sortedZoneIds[i]);\n    }\n\n    return new ZoneIdTree(sortedZoneIds.length, treeMap);\n  };\n\n  function ZoneIdTree(size, treeMap) {\n    this.size = size;\n    this.treeMap = treeMap;\n  }\n\n  return ZoneIdTree;\n}();\n\nvar ZoneIdTreeMap = function () {\n  function ZoneIdTreeMap(length, isLeaf) {\n    if (length === void 0) {\n      length = 0;\n    }\n\n    if (isLeaf === void 0) {\n      isLeaf = false;\n    }\n\n    this.length = length;\n    this.isLeaf = isLeaf;\n    this._treeMap = {};\n  }\n\n  var _proto2 = ZoneIdTreeMap.prototype;\n\n  _proto2.add = function add(zoneId) {\n    var idLength = zoneId.length;\n\n    if (idLength === this.length) {\n      this._treeMap[zoneId] = new ZoneIdTreeMap(idLength, true);\n    } else if (idLength > this.length) {\n      var subZoneId = zoneId.substr(0, this.length);\n      var subTreeMap = this._treeMap[subZoneId];\n\n      if (subTreeMap == null) {\n        subTreeMap = new ZoneIdTreeMap(idLength, false);\n        this._treeMap[subZoneId] = subTreeMap;\n      }\n\n      subTreeMap.add(zoneId);\n    }\n  };\n\n  _proto2.get = function get(zoneId) {\n    return this._treeMap[zoneId];\n  };\n\n  return ZoneIdTreeMap;\n}();\n\nvar zoneIdTree = new ZoneIdTree([]);\n\n/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\nvar MAX_WIDTH$1 = 15;\nvar DateTimeFormatterBuilder = function () {\n  function DateTimeFormatterBuilder() {\n    this._active = this;\n    this._parent = null;\n    this._printerParsers = [];\n    this._optional = false;\n    this._padNextWidth = 0;\n    this._padNextChar = null;\n    this._valueParserIndex = -1;\n  }\n\n  DateTimeFormatterBuilder._of = function _of(parent, optional) {\n    requireNonNull(parent, 'parent');\n    requireNonNull(optional, 'optional');\n    var dtFormatterBuilder = new DateTimeFormatterBuilder();\n    dtFormatterBuilder._parent = parent;\n    dtFormatterBuilder._optional = optional;\n    return dtFormatterBuilder;\n  };\n\n  var _proto = DateTimeFormatterBuilder.prototype;\n\n  _proto.parseCaseSensitive = function parseCaseSensitive() {\n    this._appendInternalPrinterParser(SettingsParser.SENSITIVE);\n\n    return this;\n  };\n\n  _proto.parseCaseInsensitive = function parseCaseInsensitive() {\n    this._appendInternalPrinterParser(SettingsParser.INSENSITIVE);\n\n    return this;\n  };\n\n  _proto.parseStrict = function parseStrict() {\n    this._appendInternalPrinterParser(SettingsParser.STRICT);\n\n    return this;\n  };\n\n  _proto.parseLenient = function parseLenient() {\n    this._appendInternalPrinterParser(SettingsParser.LENIENT);\n\n    return this;\n  };\n\n  _proto.appendValue = function appendValue() {\n    if (arguments.length === 1) {\n      return this._appendValue1.apply(this, arguments);\n    } else if (arguments.length === 2) {\n      return this._appendValue2.apply(this, arguments);\n    } else {\n      return this._appendValue4.apply(this, arguments);\n    }\n  };\n\n  _proto._appendValue1 = function _appendValue1(field) {\n    requireNonNull(field);\n\n    this._appendValuePrinterParser(new NumberPrinterParser(field, 1, MAX_WIDTH$1, SignStyle.NORMAL));\n\n    return this;\n  };\n\n  _proto._appendValue2 = function _appendValue2(field, width) {\n    requireNonNull(field);\n\n    if (width < 1 || width > MAX_WIDTH$1) {\n      throw new IllegalArgumentException(\"The width must be from 1 to \" + MAX_WIDTH$1 + \" inclusive but was \" + width);\n    }\n\n    var pp = new NumberPrinterParser(field, width, width, SignStyle.NOT_NEGATIVE);\n\n    this._appendValuePrinterParser(pp);\n\n    return this;\n  };\n\n  _proto._appendValue4 = function _appendValue4(field, minWidth, maxWidth, signStyle) {\n    requireNonNull(field);\n    requireNonNull(signStyle);\n\n    if (minWidth === maxWidth && signStyle === SignStyle.NOT_NEGATIVE) {\n      return this._appendValue2(field, maxWidth);\n    }\n\n    if (minWidth < 1 || minWidth > MAX_WIDTH$1) {\n      throw new IllegalArgumentException(\"The minimum width must be from 1 to \" + MAX_WIDTH$1 + \" inclusive but was \" + minWidth);\n    }\n\n    if (maxWidth < 1 || maxWidth > MAX_WIDTH$1) {\n      throw new IllegalArgumentException(\"The minimum width must be from 1 to \" + MAX_WIDTH$1 + \" inclusive but was \" + maxWidth);\n    }\n\n    if (maxWidth < minWidth) {\n      throw new IllegalArgumentException(\"The maximum width must exceed or equal the minimum width but \" + maxWidth + \" < \" + minWidth);\n    }\n\n    var pp = new NumberPrinterParser(field, minWidth, maxWidth, signStyle);\n\n    this._appendValuePrinterParser(pp);\n\n    return this;\n  };\n\n  _proto.appendValueReduced = function appendValueReduced() {\n    if (arguments.length === 4 && arguments[3] instanceof ChronoLocalDate) {\n      return this._appendValueReducedFieldWidthMaxWidthBaseDate.apply(this, arguments);\n    } else {\n      return this._appendValueReducedFieldWidthMaxWidthBaseValue.apply(this, arguments);\n    }\n  };\n\n  _proto._appendValueReducedFieldWidthMaxWidthBaseValue = function _appendValueReducedFieldWidthMaxWidthBaseValue(field, width, maxWidth, baseValue) {\n    requireNonNull(field, 'field');\n    var pp = new ReducedPrinterParser(field, width, maxWidth, baseValue, null);\n\n    this._appendValuePrinterParser(pp);\n\n    return this;\n  };\n\n  _proto._appendValueReducedFieldWidthMaxWidthBaseDate = function _appendValueReducedFieldWidthMaxWidthBaseDate(field, width, maxWidth, baseDate) {\n    requireNonNull(field, 'field');\n    requireNonNull(baseDate, 'baseDate');\n    requireInstance(baseDate, ChronoLocalDate, 'baseDate');\n    var pp = new ReducedPrinterParser(field, width, maxWidth, 0, baseDate);\n\n    this._appendValuePrinterParser(pp);\n\n    return this;\n  };\n\n  _proto._appendValuePrinterParser = function _appendValuePrinterParser(pp) {\n    assert(pp != null);\n\n    if (this._active._valueParserIndex >= 0 && this._active._printerParsers[this._active._valueParserIndex] instanceof NumberPrinterParser) {\n      var activeValueParser = this._active._valueParserIndex;\n      var basePP = this._active._printerParsers[activeValueParser];\n\n      if (pp.minWidth() === pp.maxWidth() && pp.signStyle() === SignStyle.NOT_NEGATIVE) {\n        basePP = basePP.withSubsequentWidth(pp.maxWidth());\n\n        this._appendInternal(pp.withFixedWidth());\n\n        this._active._valueParserIndex = activeValueParser;\n      } else {\n        basePP = basePP.withFixedWidth();\n        this._active._valueParserIndex = this._appendInternal(pp);\n      }\n\n      this._active._printerParsers[activeValueParser] = basePP;\n    } else {\n      this._active._valueParserIndex = this._appendInternal(pp);\n    }\n\n    return this;\n  };\n\n  _proto.appendFraction = function appendFraction(field, minWidth, maxWidth, decimalPoint) {\n    this._appendInternal(new FractionPrinterParser(field, minWidth, maxWidth, decimalPoint));\n\n    return this;\n  };\n\n  _proto.appendInstant = function appendInstant(fractionalDigits) {\n    if (fractionalDigits === void 0) {\n      fractionalDigits = -2;\n    }\n\n    if (fractionalDigits < -2 || fractionalDigits > 9) {\n      throw new IllegalArgumentException('Invalid fractional digits: ' + fractionalDigits);\n    }\n\n    this._appendInternal(new InstantPrinterParser(fractionalDigits));\n\n    return this;\n  };\n\n  _proto.appendOffsetId = function appendOffsetId() {\n    this._appendInternal(OffsetIdPrinterParser.INSTANCE_ID);\n\n    return this;\n  };\n\n  _proto.appendOffset = function appendOffset(pattern, noOffsetText) {\n    this._appendInternalPrinterParser(new OffsetIdPrinterParser(noOffsetText, pattern));\n\n    return this;\n  };\n\n  _proto.appendZoneId = function appendZoneId() {\n    this._appendInternal(new ZoneIdPrinterParser(TemporalQueries.zoneId(), 'ZoneId()'));\n\n    return this;\n  };\n\n  _proto.appendPattern = function appendPattern(pattern) {\n    requireNonNull(pattern, 'pattern');\n\n    this._parsePattern(pattern);\n\n    return this;\n  };\n\n  _proto.appendZoneText = function appendZoneText() {\n    throw new IllegalArgumentException('Pattern using (localized) text not implemented, use js-joda-locale plugin!');\n  };\n\n  _proto.appendText = function appendText() {\n    throw new IllegalArgumentException('Pattern using (localized) text not implemented, use js-joda-locale plugin!');\n  };\n\n  _proto.appendLocalizedOffset = function appendLocalizedOffset() {\n    throw new IllegalArgumentException('Pattern using (localized) text not implemented, use js-joda-locale plugin!');\n  };\n\n  _proto.appendWeekField = function appendWeekField() {\n    throw new IllegalArgumentException('Pattern using (localized) text not implemented, use js-joda-locale plugin!');\n  };\n\n  _proto._parsePattern = function _parsePattern(pattern) {\n    var FIELD_MAP = {\n      'G': ChronoField.ERA,\n      'y': ChronoField.YEAR_OF_ERA,\n      'u': ChronoField.YEAR,\n      'Q': IsoFields.QUARTER_OF_YEAR,\n      'q': IsoFields.QUARTER_OF_YEAR,\n      'M': ChronoField.MONTH_OF_YEAR,\n      'L': ChronoField.MONTH_OF_YEAR,\n      'D': ChronoField.DAY_OF_YEAR,\n      'd': ChronoField.DAY_OF_MONTH,\n      'F': ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH,\n      'E': ChronoField.DAY_OF_WEEK,\n      'c': ChronoField.DAY_OF_WEEK,\n      'e': ChronoField.DAY_OF_WEEK,\n      'a': ChronoField.AMPM_OF_DAY,\n      'H': ChronoField.HOUR_OF_DAY,\n      'k': ChronoField.CLOCK_HOUR_OF_DAY,\n      'K': ChronoField.HOUR_OF_AMPM,\n      'h': ChronoField.CLOCK_HOUR_OF_AMPM,\n      'm': ChronoField.MINUTE_OF_HOUR,\n      's': ChronoField.SECOND_OF_MINUTE,\n      'S': ChronoField.NANO_OF_SECOND,\n      'A': ChronoField.MILLI_OF_DAY,\n      'n': ChronoField.NANO_OF_SECOND,\n      'N': ChronoField.NANO_OF_DAY\n    };\n\n    for (var pos = 0; pos < pattern.length; pos++) {\n      var cur = pattern.charAt(pos);\n\n      if (cur >= 'A' && cur <= 'Z' || cur >= 'a' && cur <= 'z') {\n        var start = pos++;\n\n        for (; pos < pattern.length && pattern.charAt(pos) === cur; pos++) {\n        }\n\n        var count = pos - start;\n\n        if (cur === 'p') {\n          var pad = 0;\n\n          if (pos < pattern.length) {\n            cur = pattern.charAt(pos);\n\n            if (cur >= 'A' && cur <= 'Z' || cur >= 'a' && cur <= 'z') {\n              pad = count;\n              start = pos++;\n\n              for (; pos < pattern.length && pattern.charAt(pos) === cur; pos++) {\n              }\n\n              count = pos - start;\n            }\n          }\n\n          if (pad === 0) {\n            throw new IllegalArgumentException('Pad letter \\'p\\' must be followed by valid pad pattern: ' + pattern);\n          }\n\n          this.padNext(pad);\n        }\n\n        var field = FIELD_MAP[cur];\n\n        if (field != null) {\n          this._parseField(cur, count, field);\n        } else if (cur === 'z') {\n          if (count > 4) {\n            throw new IllegalArgumentException('Too many pattern letters: ' + cur);\n          } else if (count === 4) {\n            this.appendZoneText(TextStyle.FULL);\n          } else {\n            this.appendZoneText(TextStyle.SHORT);\n          }\n        } else if (cur === 'V') {\n          if (count !== 2) {\n            throw new IllegalArgumentException('Pattern letter count must be 2: ' + cur);\n          }\n\n          this.appendZoneId();\n        } else if (cur === 'Z') {\n          if (count < 4) {\n            this.appendOffset('+HHMM', '+0000');\n          } else if (count === 4) {\n            this.appendLocalizedOffset(TextStyle.FULL);\n          } else if (count === 5) {\n            this.appendOffset('+HH:MM:ss', 'Z');\n          } else {\n            throw new IllegalArgumentException('Too many pattern letters: ' + cur);\n          }\n        } else if (cur === 'O') {\n          if (count === 1) {\n            this.appendLocalizedOffset(TextStyle.SHORT);\n          } else if (count === 4) {\n            this.appendLocalizedOffset(TextStyle.FULL);\n          } else {\n            throw new IllegalArgumentException('Pattern letter count must be 1 or 4: ' + cur);\n          }\n        } else if (cur === 'X') {\n          if (count > 5) {\n            throw new IllegalArgumentException('Too many pattern letters: ' + cur);\n          }\n\n          this.appendOffset(OffsetIdPrinterParser.PATTERNS[count + (count === 1 ? 0 : 1)], 'Z');\n        } else if (cur === 'x') {\n          if (count > 5) {\n            throw new IllegalArgumentException('Too many pattern letters: ' + cur);\n          }\n\n          var zero = count === 1 ? '+00' : count % 2 === 0 ? '+0000' : '+00:00';\n          this.appendOffset(OffsetIdPrinterParser.PATTERNS[count + (count === 1 ? 0 : 1)], zero);\n        } else if (cur === 'W') {\n          if (count > 1) {\n            throw new IllegalArgumentException('Too many pattern letters: ' + cur);\n          }\n\n          this.appendWeekField('W', count);\n        } else if (cur === 'w') {\n          if (count > 2) {\n            throw new IllegalArgumentException('Too many pattern letters: ' + cur);\n          }\n\n          this.appendWeekField('w', count);\n        } else if (cur === 'Y') {\n          this.appendWeekField('Y', count);\n        } else {\n          throw new IllegalArgumentException('Unknown pattern letter: ' + cur);\n        }\n\n        pos--;\n      } else if (cur === '\\'') {\n        var _start = pos++;\n\n        for (; pos < pattern.length; pos++) {\n          if (pattern.charAt(pos) === '\\'') {\n            if (pos + 1 < pattern.length && pattern.charAt(pos + 1) === '\\'') {\n              pos++;\n            } else {\n              break;\n            }\n          }\n        }\n\n        if (pos >= pattern.length) {\n          throw new IllegalArgumentException('Pattern ends with an incomplete string literal: ' + pattern);\n        }\n\n        var str = pattern.substring(_start + 1, pos);\n\n        if (str.length === 0) {\n          this.appendLiteral('\\'');\n        } else {\n          this.appendLiteral(str.replace('\\'\\'', '\\''));\n        }\n      } else if (cur === '[') {\n        this.optionalStart();\n      } else if (cur === ']') {\n        if (this._active._parent === null) {\n          throw new IllegalArgumentException('Pattern invalid as it contains ] without previous [');\n        }\n\n        this.optionalEnd();\n      } else if (cur === '{' || cur === '}' || cur === '#') {\n        throw new IllegalArgumentException('Pattern includes reserved character: \\'' + cur + '\\'');\n      } else {\n        this.appendLiteral(cur);\n      }\n    }\n  };\n\n  _proto._parseField = function _parseField(cur, count, field) {\n    switch (cur) {\n      case 'u':\n      case 'y':\n        if (count === 2) {\n          this.appendValueReduced(field, 2, 2, ReducedPrinterParser.BASE_DATE);\n        } else if (count < 4) {\n          this.appendValue(field, count, MAX_WIDTH$1, SignStyle.NORMAL);\n        } else {\n          this.appendValue(field, count, MAX_WIDTH$1, SignStyle.EXCEEDS_PAD);\n        }\n\n        break;\n\n      case 'M':\n      case 'Q':\n        switch (count) {\n          case 1:\n            this.appendValue(field);\n            break;\n\n          case 2:\n            this.appendValue(field, 2);\n            break;\n\n          case 3:\n            this.appendText(field, TextStyle.SHORT);\n            break;\n\n          case 4:\n            this.appendText(field, TextStyle.FULL);\n            break;\n\n          case 5:\n            this.appendText(field, TextStyle.NARROW);\n            break;\n\n          default:\n            throw new IllegalArgumentException('Too many pattern letters: ' + cur);\n        }\n\n        break;\n\n      case 'L':\n      case 'q':\n        switch (count) {\n          case 1:\n            this.appendValue(field);\n            break;\n\n          case 2:\n            this.appendValue(field, 2);\n            break;\n\n          case 3:\n            this.appendText(field, TextStyle.SHORT_STANDALONE);\n            break;\n\n          case 4:\n            this.appendText(field, TextStyle.FULL_STANDALONE);\n            break;\n\n          case 5:\n            this.appendText(field, TextStyle.NARROW_STANDALONE);\n            break;\n\n          default:\n            throw new IllegalArgumentException('Too many pattern letters: ' + cur);\n        }\n\n        break;\n\n      case 'e':\n        switch (count) {\n          case 1:\n          case 2:\n            this.appendWeekField('e', count);\n            break;\n\n          case 3:\n            this.appendText(field, TextStyle.SHORT);\n            break;\n\n          case 4:\n            this.appendText(field, TextStyle.FULL);\n            break;\n\n          case 5:\n            this.appendText(field, TextStyle.NARROW);\n            break;\n\n          default:\n            throw new IllegalArgumentException('Too many pattern letters: ' + cur);\n        }\n\n        break;\n\n      case 'c':\n        switch (count) {\n          case 1:\n            this.appendWeekField('c', count);\n            break;\n\n          case 2:\n            throw new IllegalArgumentException('Invalid number of pattern letters: ' + cur);\n\n          case 3:\n            this.appendText(field, TextStyle.SHORT_STANDALONE);\n            break;\n\n          case 4:\n            this.appendText(field, TextStyle.FULL_STANDALONE);\n            break;\n\n          case 5:\n            this.appendText(field, TextStyle.NARROW_STANDALONE);\n            break;\n\n          default:\n            throw new IllegalArgumentException('Too many pattern letters: ' + cur);\n        }\n\n        break;\n\n      case 'a':\n        if (count === 1) {\n          this.appendText(field, TextStyle.SHORT);\n        } else {\n          throw new IllegalArgumentException('Too many pattern letters: ' + cur);\n        }\n\n        break;\n\n      case 'E':\n      case 'G':\n        switch (count) {\n          case 1:\n          case 2:\n          case 3:\n            this.appendText(field, TextStyle.SHORT);\n            break;\n\n          case 4:\n            this.appendText(field, TextStyle.FULL);\n            break;\n\n          case 5:\n            this.appendText(field, TextStyle.NARROW);\n            break;\n\n          default:\n            throw new IllegalArgumentException('Too many pattern letters: ' + cur);\n        }\n\n        break;\n\n      case 'S':\n        this.appendFraction(ChronoField.NANO_OF_SECOND, count, count, false);\n        break;\n\n      case 'F':\n        if (count === 1) {\n          this.appendValue(field);\n        } else {\n          throw new IllegalArgumentException('Too many pattern letters: ' + cur);\n        }\n\n        break;\n\n      case 'd':\n      case 'h':\n      case 'H':\n      case 'k':\n      case 'K':\n      case 'm':\n      case 's':\n        if (count === 1) {\n          this.appendValue(field);\n        } else if (count === 2) {\n          this.appendValue(field, count);\n        } else {\n          throw new IllegalArgumentException('Too many pattern letters: ' + cur);\n        }\n\n        break;\n\n      case 'D':\n        if (count === 1) {\n          this.appendValue(field);\n        } else if (count <= 3) {\n          this.appendValue(field, count);\n        } else {\n          throw new IllegalArgumentException('Too many pattern letters: ' + cur);\n        }\n\n        break;\n\n      default:\n        if (count === 1) {\n          this.appendValue(field);\n        } else {\n          this.appendValue(field, count);\n        }\n\n        break;\n    }\n  };\n\n  _proto.padNext = function padNext() {\n    if (arguments.length === 1) {\n      return this._padNext1.apply(this, arguments);\n    } else {\n      return this._padNext2.apply(this, arguments);\n    }\n  };\n\n  _proto._padNext1 = function _padNext1(padWidth) {\n    return this._padNext2(padWidth, ' ');\n  };\n\n  _proto._padNext2 = function _padNext2(padWidth, padChar) {\n    if (padWidth < 1) {\n      throw new IllegalArgumentException('The pad width must be at least one but was ' + padWidth);\n    }\n\n    this._active._padNextWidth = padWidth;\n    this._active._padNextChar = padChar;\n    this._active._valueParserIndex = -1;\n    return this;\n  };\n\n  _proto.optionalStart = function optionalStart() {\n    this._active._valueParserIndex = -1;\n    this._active = DateTimeFormatterBuilder._of(this._active, true);\n    return this;\n  };\n\n  _proto.optionalEnd = function optionalEnd() {\n    if (this._active._parent == null) {\n      throw new IllegalStateException('Cannot call optionalEnd() as there was no previous call to optionalStart()');\n    }\n\n    if (this._active._printerParsers.length > 0) {\n      var cpp = new CompositePrinterParser(this._active._printerParsers, this._active._optional);\n      this._active = this._active._parent;\n\n      this._appendInternal(cpp);\n    } else {\n      this._active = this._active._parent;\n    }\n\n    return this;\n  };\n\n  _proto._appendInternal = function _appendInternal(pp) {\n    assert(pp != null);\n\n    if (this._active._padNextWidth > 0) {\n      if (pp != null) {\n        pp = new PadPrinterParserDecorator(pp, this._active._padNextWidth, this._active._padNextChar);\n      }\n\n      this._active._padNextWidth = 0;\n      this._active._padNextChar = 0;\n    }\n\n    this._active._printerParsers.push(pp);\n\n    this._active._valueParserIndex = -1;\n    return this._active._printerParsers.length - 1;\n  };\n\n  _proto.appendLiteral = function appendLiteral(literal) {\n    assert(literal != null);\n\n    if (literal.length > 0) {\n      if (literal.length === 1) {\n        this._appendInternalPrinterParser(new CharLiteralPrinterParser(literal.charAt(0)));\n      } else {\n        this._appendInternalPrinterParser(new StringLiteralPrinterParser(literal));\n      }\n    }\n\n    return this;\n  };\n\n  _proto._appendInternalPrinterParser = function _appendInternalPrinterParser(pp) {\n    assert(pp != null);\n\n    if (this._active._padNextWidth > 0) {\n      if (pp != null) {\n        pp = new PadPrinterParserDecorator(pp, this._active._padNextWidth, this._active._padNextChar);\n      }\n\n      this._active._padNextWidth = 0;\n      this._active._padNextChar = 0;\n    }\n\n    this._active._printerParsers.push(pp);\n\n    this._active._valueParserIndex = -1;\n    return this._active._printerParsers.length - 1;\n  };\n\n  _proto.append = function append(formatter) {\n    requireNonNull(formatter, 'formatter');\n\n    this._appendInternal(formatter._toPrinterParser(false));\n\n    return this;\n  };\n\n  _proto.toFormatter = function toFormatter(resolverStyle) {\n    if (resolverStyle === void 0) {\n      resolverStyle = ResolverStyle.SMART;\n    }\n\n    while (this._active._parent != null) {\n      this.optionalEnd();\n    }\n\n    var pp = new CompositePrinterParser(this._printerParsers, false);\n    return new DateTimeFormatter(pp, null, DecimalStyle.STANDARD, resolverStyle, null, null, null);\n  };\n\n  return DateTimeFormatterBuilder;\n}();\nvar SECONDS_PER_10000_YEARS = 146097 * 25 * 86400;\nvar SECONDS_0000_TO_1970 = (146097 * 5 - (30 * 365 + 7)) * 86400;\n\nvar InstantPrinterParser = function () {\n  function InstantPrinterParser(fractionalDigits) {\n    this.fractionalDigits = fractionalDigits;\n  }\n\n  var _proto2 = InstantPrinterParser.prototype;\n\n  _proto2.print = function print(context, buf) {\n    var inSecs = context.getValue(ChronoField.INSTANT_SECONDS);\n    var inNanos = 0;\n\n    if (context.temporal().isSupported(ChronoField.NANO_OF_SECOND)) {\n      inNanos = context.temporal().getLong(ChronoField.NANO_OF_SECOND);\n    }\n\n    if (inSecs == null) {\n      return false;\n    }\n\n    var inSec = inSecs;\n    var inNano = ChronoField.NANO_OF_SECOND.checkValidIntValue(inNanos);\n\n    if (inSec >= -SECONDS_0000_TO_1970) {\n      var zeroSecs = inSec - SECONDS_PER_10000_YEARS + SECONDS_0000_TO_1970;\n      var hi = MathUtil.floorDiv(zeroSecs, SECONDS_PER_10000_YEARS) + 1;\n      var lo = MathUtil.floorMod(zeroSecs, SECONDS_PER_10000_YEARS);\n      var ldt = LocalDateTime.ofEpochSecond(lo - SECONDS_0000_TO_1970, 0, ZoneOffset.UTC);\n\n      if (hi > 0) {\n        buf.append('+').append(hi);\n      }\n\n      buf.append(ldt);\n\n      if (ldt.second() === 0) {\n        buf.append(':00');\n      }\n    } else {\n      var _zeroSecs = inSec + SECONDS_0000_TO_1970;\n\n      var _hi = MathUtil.intDiv(_zeroSecs, SECONDS_PER_10000_YEARS);\n\n      var _lo = MathUtil.intMod(_zeroSecs, SECONDS_PER_10000_YEARS);\n\n      var _ldt = LocalDateTime.ofEpochSecond(_lo - SECONDS_0000_TO_1970, 0, ZoneOffset.UTC);\n\n      var pos = buf.length();\n      buf.append(_ldt);\n\n      if (_ldt.second() === 0) {\n        buf.append(':00');\n      }\n\n      if (_hi < 0) {\n        if (_ldt.year() === -10000) {\n          buf.replace(pos, pos + 2, '' + (_hi - 1));\n        } else if (_lo === 0) {\n          buf.insert(pos, _hi);\n        } else {\n          buf.insert(pos + 1, Math.abs(_hi));\n        }\n      }\n    }\n\n    if (this.fractionalDigits === -2) {\n      if (inNano !== 0) {\n        buf.append('.');\n\n        if (MathUtil.intMod(inNano, 1000000) === 0) {\n          buf.append(('' + (MathUtil.intDiv(inNano, 1000000) + 1000)).substring(1));\n        } else if (MathUtil.intMod(inNano, 1000) === 0) {\n          buf.append(('' + (MathUtil.intDiv(inNano, 1000) + 1000000)).substring(1));\n        } else {\n          buf.append(('' + (inNano + 1000000000)).substring(1));\n        }\n      }\n    } else if (this.fractionalDigits > 0 || this.fractionalDigits === -1 && inNano > 0) {\n      buf.append('.');\n      var div = 100000000;\n\n      for (var i = 0; this.fractionalDigits === -1 && inNano > 0 || i < this.fractionalDigits; i++) {\n        var digit = MathUtil.intDiv(inNano, div);\n        buf.append(digit);\n        inNano = inNano - digit * div;\n        div = MathUtil.intDiv(div, 10);\n      }\n    }\n\n    buf.append('Z');\n    return true;\n  };\n\n  _proto2.parse = function parse(context, text, position) {\n    var newContext = context.copy();\n    var minDigits = this.fractionalDigits < 0 ? 0 : this.fractionalDigits;\n    var maxDigits = this.fractionalDigits < 0 ? 9 : this.fractionalDigits;\n\n    var parser = new DateTimeFormatterBuilder().append(DateTimeFormatter.ISO_LOCAL_DATE).appendLiteral('T').appendValue(ChronoField.HOUR_OF_DAY, 2).appendLiteral(':').appendValue(ChronoField.MINUTE_OF_HOUR, 2).appendLiteral(':').appendValue(ChronoField.SECOND_OF_MINUTE, 2).appendFraction(ChronoField.NANO_OF_SECOND, minDigits, maxDigits, true).appendLiteral('Z').toFormatter()._toPrinterParser(false);\n\n    var pos = parser.parse(newContext, text, position);\n\n    if (pos < 0) {\n      return pos;\n    }\n\n    var yearParsed = newContext.getParsed(ChronoField.YEAR);\n    var month = newContext.getParsed(ChronoField.MONTH_OF_YEAR);\n    var day = newContext.getParsed(ChronoField.DAY_OF_MONTH);\n    var hour = newContext.getParsed(ChronoField.HOUR_OF_DAY);\n    var min = newContext.getParsed(ChronoField.MINUTE_OF_HOUR);\n    var secVal = newContext.getParsed(ChronoField.SECOND_OF_MINUTE);\n    var nanoVal = newContext.getParsed(ChronoField.NANO_OF_SECOND);\n    var sec = secVal != null ? secVal : 0;\n    var nano = nanoVal != null ? nanoVal : 0;\n    var year = MathUtil.intMod(yearParsed, 10000);\n    var days = 0;\n\n    if (hour === 24 && min === 0 && sec === 0 && nano === 0) {\n      hour = 0;\n      days = 1;\n    } else if (hour === 23 && min === 59 && sec === 60) {\n      context.setParsedLeapSecond();\n      sec = 59;\n    }\n\n    var instantSecs;\n\n    try {\n      var ldt = LocalDateTime.of(year, month, day, hour, min, sec, 0).plusDays(days);\n      instantSecs = ldt.toEpochSecond(ZoneOffset.UTC);\n      instantSecs += MathUtil.safeMultiply(MathUtil.intDiv(yearParsed, 10000), SECONDS_PER_10000_YEARS);\n    } catch (ex) {\n      return ~position;\n    }\n\n    var successPos = pos;\n    successPos = context.setParsedField(ChronoField.INSTANT_SECONDS, instantSecs, position, successPos);\n    return context.setParsedField(ChronoField.NANO_OF_SECOND, nano, position, successPos);\n  };\n\n  _proto2.toString = function toString() {\n    return 'Instant()';\n  };\n\n  return InstantPrinterParser;\n}();\n\nfunction _init$9() {\n  ReducedPrinterParser.BASE_DATE = LocalDate.of(2000, 1, 1);\n  DateTimeFormatterBuilder.CompositePrinterParser = CompositePrinterParser;\n  DateTimeFormatterBuilder.PadPrinterParserDecorator = PadPrinterParserDecorator;\n  DateTimeFormatterBuilder.SettingsParser = SettingsParser;\n  DateTimeFormatterBuilder.CharLiteralPrinterParser = StringLiteralPrinterParser;\n  DateTimeFormatterBuilder.StringLiteralPrinterParser = StringLiteralPrinterParser;\n  DateTimeFormatterBuilder.CharLiteralPrinterParser = CharLiteralPrinterParser;\n  DateTimeFormatterBuilder.NumberPrinterParser = NumberPrinterParser;\n  DateTimeFormatterBuilder.ReducedPrinterParser = ReducedPrinterParser;\n  DateTimeFormatterBuilder.FractionPrinterParser = FractionPrinterParser;\n  DateTimeFormatterBuilder.OffsetIdPrinterParser = OffsetIdPrinterParser;\n  DateTimeFormatterBuilder.ZoneIdPrinterParser = ZoneIdPrinterParser;\n}\n\n/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\nvar StringBuilder = function () {\n  function StringBuilder() {\n    this._str = '';\n  }\n\n  var _proto = StringBuilder.prototype;\n\n  _proto.append = function append(str) {\n    this._str += str;\n    return this;\n  };\n\n  _proto.appendChar = function appendChar(str) {\n    this._str += str[0];\n    return this;\n  };\n\n  _proto.insert = function insert(offset, str) {\n    this._str = this._str.slice(0, offset) + str + this._str.slice(offset);\n    return this;\n  };\n\n  _proto.replace = function replace(start, end, str) {\n    this._str = this._str.slice(0, start) + str + this._str.slice(end);\n    return this;\n  };\n\n  _proto.length = function length() {\n    return this._str.length;\n  };\n\n  _proto.setLength = function setLength(length) {\n    this._str = this._str.slice(0, length);\n    return this;\n  };\n\n  _proto.toString = function toString() {\n    return this._str;\n  };\n\n  return StringBuilder;\n}();\n\n/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\nvar DateTimeFormatter = function () {\n  DateTimeFormatter.parsedExcessDays = function parsedExcessDays() {\n    return DateTimeFormatter.PARSED_EXCESS_DAYS;\n  };\n\n  DateTimeFormatter.parsedLeapSecond = function parsedLeapSecond() {\n    return DateTimeFormatter.PARSED_LEAP_SECOND;\n  };\n\n  DateTimeFormatter.ofPattern = function ofPattern(pattern) {\n    return new DateTimeFormatterBuilder().appendPattern(pattern).toFormatter();\n  };\n\n  function DateTimeFormatter(printerParser, locale, decimalStyle, resolverStyle, resolverFields, chrono, zone) {\n    if (chrono === void 0) {\n      chrono = IsoChronology.INSTANCE;\n    }\n\n    assert(printerParser != null);\n    assert(decimalStyle != null);\n    assert(resolverStyle != null);\n    this._printerParser = printerParser;\n    this._locale = locale;\n    this._decimalStyle = decimalStyle;\n    this._resolverStyle = resolverStyle;\n    this._resolverFields = resolverFields;\n    this._chrono = chrono;\n    this._zone = zone;\n  }\n\n  var _proto = DateTimeFormatter.prototype;\n\n  _proto.locale = function locale() {\n    return this._locale;\n  };\n\n  _proto.decimalStyle = function decimalStyle() {\n    return this._decimalStyle;\n  };\n\n  _proto.chronology = function chronology() {\n    return this._chrono;\n  };\n\n  _proto.withChronology = function withChronology(chrono) {\n    if (this._chrono != null && this._chrono.equals(chrono)) {\n      return this;\n    }\n\n    return new DateTimeFormatter(this._printerParser, this._locale, this._decimalStyle, this._resolverStyle, this._resolverFields, chrono, this._zone);\n  };\n\n  _proto.withLocale = function withLocale() {\n    return this;\n  };\n\n  _proto.withResolverStyle = function withResolverStyle(resolverStyle) {\n    requireNonNull(resolverStyle, 'resolverStyle');\n\n    if (resolverStyle.equals(this._resolverStyle)) {\n      return this;\n    }\n\n    return new DateTimeFormatter(this._printerParser, this._locale, this._decimalStyle, resolverStyle, this._resolverFields, this._chrono, this._zone);\n  };\n\n  _proto.format = function format(temporal) {\n    var buf = new StringBuilder(32);\n\n    this._formatTo(temporal, buf);\n\n    return buf.toString();\n  };\n\n  _proto._formatTo = function _formatTo(temporal, appendable) {\n    requireNonNull(temporal, 'temporal');\n    requireNonNull(appendable, 'appendable');\n    var context = new DateTimePrintContext(temporal, this);\n\n    this._printerParser.print(context, appendable);\n  };\n\n  _proto.parse = function parse(text, type) {\n    if (arguments.length === 1) {\n      return this.parse1(text);\n    } else {\n      return this.parse2(text, type);\n    }\n  };\n\n  _proto.parse1 = function parse1(text) {\n    requireNonNull(text, 'text');\n\n    try {\n      return this._parseToBuilder(text, null).resolve(this._resolverStyle, this._resolverFields);\n    } catch (ex) {\n      if (ex instanceof DateTimeParseException) {\n        throw ex;\n      } else {\n        throw this._createError(text, ex);\n      }\n    }\n  };\n\n  _proto.parse2 = function parse2(text, type) {\n    requireNonNull(text, 'text');\n    requireNonNull(type, 'type');\n\n    try {\n      var builder = this._parseToBuilder(text, null).resolve(this._resolverStyle, this._resolverFields);\n\n      return builder.build(type);\n    } catch (ex) {\n      if (ex instanceof DateTimeParseException) {\n        throw ex;\n      } else {\n        throw this._createError(text, ex);\n      }\n    }\n  };\n\n  _proto._createError = function _createError(text, ex) {\n    var abbr = '';\n\n    if (text.length > 64) {\n      abbr = text.substring(0, 64) + '...';\n    } else {\n      abbr = text;\n    }\n\n    return new DateTimeParseException('Text \\'' + abbr + '\\' could not be parsed: ' + ex.message, text, 0, ex);\n  };\n\n  _proto._parseToBuilder = function _parseToBuilder(text, position) {\n    var pos = position != null ? position : new ParsePosition(0);\n\n    var result = this._parseUnresolved0(text, pos);\n\n    if (result == null || pos.getErrorIndex() >= 0 || position == null && pos.getIndex() < text.length) {\n      var abbr = '';\n\n      if (text.length > 64) {\n        abbr = text.substr(0, 64).toString() + '...';\n      } else {\n        abbr = text;\n      }\n\n      if (pos.getErrorIndex() >= 0) {\n        throw new DateTimeParseException('Text \\'' + abbr + '\\' could not be parsed at index ' + pos.getErrorIndex(), text, pos.getErrorIndex());\n      } else {\n        throw new DateTimeParseException('Text \\'' + abbr + '\\' could not be parsed, unparsed text found at index ' + pos.getIndex(), text, pos.getIndex());\n      }\n    }\n\n    return result.toBuilder();\n  };\n\n  _proto.parseUnresolved = function parseUnresolved(text, position) {\n    return this._parseUnresolved0(text, position);\n  };\n\n  _proto._parseUnresolved0 = function _parseUnresolved0(text, position) {\n    assert(text != null, 'text', NullPointerException);\n    assert(position != null, 'position', NullPointerException);\n    var context = new DateTimeParseContext(this);\n    var pos = position.getIndex();\n    pos = this._printerParser.parse(context, text, pos);\n\n    if (pos < 0) {\n      position.setErrorIndex(~pos);\n      return null;\n    }\n\n    position.setIndex(pos);\n    return context.toParsed();\n  };\n\n  _proto._toPrinterParser = function _toPrinterParser(optional) {\n    return this._printerParser.withOptional(optional);\n  };\n\n  _proto.toString = function toString() {\n    var pattern = this._printerParser.toString();\n\n    return pattern.indexOf('[') === 0 ? pattern : pattern.substring(1, pattern.length - 1);\n  };\n\n  return DateTimeFormatter;\n}();\nfunction _init$a() {\n  DateTimeFormatter.ISO_LOCAL_DATE = new DateTimeFormatterBuilder().appendValue(ChronoField.YEAR, 4, 10, SignStyle.EXCEEDS_PAD).appendLiteral('-').appendValue(ChronoField.MONTH_OF_YEAR, 2).appendLiteral('-').appendValue(ChronoField.DAY_OF_MONTH, 2).toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);\n  DateTimeFormatter.ISO_LOCAL_TIME = new DateTimeFormatterBuilder().appendValue(ChronoField.HOUR_OF_DAY, 2).appendLiteral(':').appendValue(ChronoField.MINUTE_OF_HOUR, 2).optionalStart().appendLiteral(':').appendValue(ChronoField.SECOND_OF_MINUTE, 2).optionalStart().appendFraction(ChronoField.NANO_OF_SECOND, 0, 9, true).toFormatter(ResolverStyle.STRICT);\n  DateTimeFormatter.ISO_LOCAL_DATE_TIME = new DateTimeFormatterBuilder().parseCaseInsensitive().append(DateTimeFormatter.ISO_LOCAL_DATE).appendLiteral('T').append(DateTimeFormatter.ISO_LOCAL_TIME).toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);\n  DateTimeFormatter.ISO_INSTANT = new DateTimeFormatterBuilder().parseCaseInsensitive().appendInstant().toFormatter(ResolverStyle.STRICT);\n  DateTimeFormatter.ISO_OFFSET_DATE_TIME = new DateTimeFormatterBuilder().parseCaseInsensitive().append(DateTimeFormatter.ISO_LOCAL_DATE_TIME).appendOffsetId().toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);\n  DateTimeFormatter.ISO_ZONED_DATE_TIME = new DateTimeFormatterBuilder().append(DateTimeFormatter.ISO_OFFSET_DATE_TIME).optionalStart().appendLiteral('[').parseCaseSensitive().appendZoneId().appendLiteral(']').toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);\n  DateTimeFormatter.BASIC_ISO_DATE = new DateTimeFormatterBuilder().appendValue(ChronoField.YEAR, 4, 10, SignStyle.EXCEEDS_PAD).appendValue(ChronoField.MONTH_OF_YEAR, 2).appendValue(ChronoField.DAY_OF_MONTH, 2).toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);\n  DateTimeFormatter.ISO_OFFSET_DATE = new DateTimeFormatterBuilder().parseCaseInsensitive().append(DateTimeFormatter.ISO_LOCAL_DATE).appendOffsetId().toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);\n  DateTimeFormatter.ISO_OFFSET_TIME = new DateTimeFormatterBuilder().parseCaseInsensitive().append(DateTimeFormatter.ISO_LOCAL_TIME).appendOffsetId().toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);\n  DateTimeFormatter.ISO_ORDINAL_DATE = new DateTimeFormatterBuilder().appendValue(ChronoField.YEAR, 4, 10, SignStyle.EXCEEDS_PAD).appendLiteral('-').appendValue(ChronoField.DAY_OF_YEAR).toFormatter(ResolverStyle.STRICT);\n  DateTimeFormatter.ISO_WEEK_DATE = new DateTimeFormatterBuilder().appendValue(ChronoField.YEAR, 4, 10, SignStyle.EXCEEDS_PAD).appendLiteral('-W').appendValue(ChronoField.ALIGNED_WEEK_OF_YEAR).appendLiteral('-').appendValue(ChronoField.DAY_OF_WEEK).toFormatter(ResolverStyle.STRICT);\n  DateTimeFormatter.PARSED_EXCESS_DAYS = createTemporalQuery('PARSED_EXCESS_DAYS', function (temporal) {\n    if (temporal instanceof DateTimeBuilder) {\n      return temporal.excessDays;\n    } else {\n      return Period.ZERO;\n    }\n  });\n  DateTimeFormatter.PARSED_LEAP_SECOND = createTemporalQuery('PARSED_LEAP_SECOND', function (temporal) {\n    if (temporal instanceof DateTimeBuilder) {\n      return temporal.leapSecond;\n    } else {\n      return false;\n    }\n  });\n}\n\nvar MonthDay = function (_TemporalAccessor) {\n  _inheritsLoose(MonthDay, _TemporalAccessor);\n\n  MonthDay.now = function now(zoneIdOrClock) {\n    if (arguments.length === 0) {\n      return MonthDay.now0();\n    } else if (arguments.length === 1 && zoneIdOrClock instanceof ZoneId) {\n      return MonthDay.nowZoneId(zoneIdOrClock);\n    } else {\n      return MonthDay.nowClock(zoneIdOrClock);\n    }\n  };\n\n  MonthDay.now0 = function now0() {\n    return this.nowClock(Clock.systemDefaultZone());\n  };\n\n  MonthDay.nowZoneId = function nowZoneId(zone) {\n    requireNonNull(zone, 'zone');\n    return this.nowClock(Clock.system(zone));\n  };\n\n  MonthDay.nowClock = function nowClock(clock) {\n    requireNonNull(clock, 'clock');\n    var now = LocalDate.now(clock);\n    return MonthDay.of(now.month(), now.dayOfMonth());\n  };\n\n  MonthDay.of = function of(monthOrNumber, number) {\n    if (arguments.length === 2 && monthOrNumber instanceof Month) {\n      return MonthDay.ofMonthNumber(monthOrNumber, number);\n    } else {\n      return MonthDay.ofNumberNumber(monthOrNumber, number);\n    }\n  };\n\n  MonthDay.ofMonthNumber = function ofMonthNumber(month, dayOfMonth) {\n    requireNonNull(month, 'month');\n    ChronoField.DAY_OF_MONTH.checkValidValue(dayOfMonth);\n\n    if (dayOfMonth > month.maxLength()) {\n      throw new DateTimeException('Illegal value for DayOfMonth field, value ' + dayOfMonth + ' is not valid for month ' + month.toString());\n    }\n\n    return new MonthDay(month.value(), dayOfMonth);\n  };\n\n  MonthDay.ofNumberNumber = function ofNumberNumber(month, dayOfMonth) {\n    requireNonNull(month, 'month');\n    requireNonNull(dayOfMonth, 'dayOfMonth');\n    return MonthDay.of(Month.of(month), dayOfMonth);\n  };\n\n  MonthDay.from = function from(temporal) {\n    requireNonNull(temporal, 'temporal');\n    requireInstance(temporal, TemporalAccessor, 'temporal');\n\n    if (temporal instanceof MonthDay) {\n      return temporal;\n    }\n\n    try {\n      return MonthDay.of(temporal.get(ChronoField.MONTH_OF_YEAR), temporal.get(ChronoField.DAY_OF_MONTH));\n    } catch (ex) {\n      throw new DateTimeException('Unable to obtain MonthDay from TemporalAccessor: ' + temporal + ', type ' + (temporal && temporal.constructor != null ? temporal.constructor.name : ''));\n    }\n  };\n\n  MonthDay.parse = function parse(text, formatter) {\n    if (arguments.length === 1) {\n      return MonthDay.parseString(text);\n    } else {\n      return MonthDay.parseStringFormatter(text, formatter);\n    }\n  };\n\n  MonthDay.parseString = function parseString(text) {\n    return MonthDay.parseStringFormatter(text, PARSER);\n  };\n\n  MonthDay.parseStringFormatter = function parseStringFormatter(text, formatter) {\n    requireNonNull(text, 'text');\n    requireNonNull(formatter, 'formatter');\n    requireInstance(formatter, DateTimeFormatter, 'formatter');\n    return formatter.parse(text, MonthDay.FROM);\n  };\n\n  function MonthDay(month, dayOfMonth) {\n    var _this;\n\n    _this = _TemporalAccessor.call(this) || this;\n    _this._month = MathUtil.safeToInt(month);\n    _this._day = MathUtil.safeToInt(dayOfMonth);\n    return _this;\n  }\n\n  var _proto = MonthDay.prototype;\n\n  _proto.monthValue = function monthValue() {\n    return this._month;\n  };\n\n  _proto.month = function month() {\n    return Month.of(this._month);\n  };\n\n  _proto.dayOfMonth = function dayOfMonth() {\n    return this._day;\n  };\n\n  _proto.isSupported = function isSupported(field) {\n    if (field instanceof ChronoField) {\n      return field === ChronoField.MONTH_OF_YEAR || field === ChronoField.DAY_OF_MONTH;\n    }\n\n    return field != null && field.isSupportedBy(this);\n  };\n\n  _proto.range = function range(field) {\n    if (field === ChronoField.MONTH_OF_YEAR) {\n      return field.range();\n    } else if (field === ChronoField.DAY_OF_MONTH) {\n      return ValueRange.of(1, this.month().minLength(), this.month().maxLength());\n    }\n\n    return _TemporalAccessor.prototype.range.call(this, field);\n  };\n\n  _proto.get = function get(field) {\n    return this.range(field).checkValidIntValue(this.getLong(field), field);\n  };\n\n  _proto.getLong = function getLong(field) {\n    requireNonNull(field, 'field');\n\n    if (field instanceof ChronoField) {\n      switch (field) {\n        case ChronoField.DAY_OF_MONTH:\n          return this._day;\n\n        case ChronoField.MONTH_OF_YEAR:\n          return this._month;\n      }\n\n      throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);\n    }\n\n    return field.getFrom(this);\n  };\n\n  _proto.isValidYear = function isValidYear(year) {\n    return (this._day === 29 && this._month === 2 && Year.isLeap(year) === false) === false;\n  };\n\n  _proto.withMonth = function withMonth(month) {\n    return this.with(Month.of(month));\n  };\n\n  _proto.with = function _with(month) {\n    requireNonNull(month, 'month');\n\n    if (month.value() === this._month) {\n      return this;\n    }\n\n    var day = Math.min(this._day, month.maxLength());\n    return new MonthDay(month.value(), day);\n  };\n\n  _proto.withDayOfMonth = function withDayOfMonth(dayOfMonth) {\n    if (dayOfMonth === this._day) {\n      return this;\n    }\n\n    return MonthDay.of(this._month, dayOfMonth);\n  };\n\n  _proto.query = function query(_query) {\n    requireNonNull(_query, 'query');\n    requireInstance(_query, TemporalQuery, 'query');\n\n    if (_query === TemporalQueries.chronology()) {\n      return IsoChronology.INSTANCE;\n    }\n\n    return _TemporalAccessor.prototype.query.call(this, _query);\n  };\n\n  _proto.adjustInto = function adjustInto(temporal) {\n    requireNonNull(temporal, 'temporal');\n    temporal = temporal.with(ChronoField.MONTH_OF_YEAR, this._month);\n    return temporal.with(ChronoField.DAY_OF_MONTH, Math.min(temporal.range(ChronoField.DAY_OF_MONTH).maximum(), this._day));\n  };\n\n  _proto.atYear = function atYear(year) {\n    return LocalDate.of(year, this._month, this.isValidYear(year) ? this._day : 28);\n  };\n\n  _proto.compareTo = function compareTo(other) {\n    requireNonNull(other, 'other');\n    requireInstance(other, MonthDay, 'other');\n    var cmp = this._month - other.monthValue();\n\n    if (cmp === 0) {\n      cmp = this._day - other.dayOfMonth();\n    }\n\n    return cmp;\n  };\n\n  _proto.isAfter = function isAfter(other) {\n    requireNonNull(other, 'other');\n    requireInstance(other, MonthDay, 'other');\n    return this.compareTo(other) > 0;\n  };\n\n  _proto.isBefore = function isBefore(other) {\n    requireNonNull(other, 'other');\n    requireInstance(other, MonthDay, 'other');\n    return this.compareTo(other) < 0;\n  };\n\n  _proto.equals = function equals(obj) {\n    if (this === obj) {\n      return true;\n    }\n\n    if (obj instanceof MonthDay) {\n      var other = obj;\n      return this.monthValue() === other.monthValue() && this.dayOfMonth() === other.dayOfMonth();\n    }\n\n    return false;\n  };\n\n  _proto.toString = function toString() {\n    return '--' + (this._month < 10 ? '0' : '') + this._month + (this._day < 10 ? '-0' : '-') + this._day;\n  };\n\n  _proto.toJSON = function toJSON() {\n    return this.toString();\n  };\n\n  _proto.format = function format(formatter) {\n    requireNonNull(formatter, 'formatter');\n    requireInstance(formatter, DateTimeFormatter, 'formatter');\n    return formatter.format(this);\n  };\n\n  return MonthDay;\n}(TemporalAccessor);\nvar PARSER;\nfunction _init$b() {\n  PARSER = new DateTimeFormatterBuilder().appendLiteral('--').appendValue(ChronoField.MONTH_OF_YEAR, 2).appendLiteral('-').appendValue(ChronoField.DAY_OF_MONTH, 2).toFormatter();\n  MonthDay.FROM = createTemporalQuery('MonthDay.FROM', function (temporal) {\n    return MonthDay.from(temporal);\n  });\n}\n\nvar YearMonth = function (_Temporal) {\n  _inheritsLoose(YearMonth, _Temporal);\n\n  YearMonth.now = function now(zoneIdOrClock) {\n    if (arguments.length === 0) {\n      return YearMonth.now0();\n    } else if (arguments.length === 1 && zoneIdOrClock instanceof ZoneId) {\n      return YearMonth.nowZoneId(zoneIdOrClock);\n    } else {\n      return YearMonth.nowClock(zoneIdOrClock);\n    }\n  };\n\n  YearMonth.now0 = function now0() {\n    return YearMonth.nowClock(Clock.systemDefaultZone());\n  };\n\n  YearMonth.nowZoneId = function nowZoneId(zone) {\n    return YearMonth.nowClock(Clock.system(zone));\n  };\n\n  YearMonth.nowClock = function nowClock(clock) {\n    var now = LocalDate.now(clock);\n    return YearMonth.of(now.year(), now.month());\n  };\n\n  YearMonth.of = function of(year, monthOrNumber) {\n    if (arguments.length === 2 && monthOrNumber instanceof Month) {\n      return YearMonth.ofNumberMonth(year, monthOrNumber);\n    } else {\n      return YearMonth.ofNumberNumber(year, monthOrNumber);\n    }\n  };\n\n  YearMonth.ofNumberMonth = function ofNumberMonth(year, month) {\n    requireNonNull(month, 'month');\n    requireInstance(month, Month, 'month');\n    return YearMonth.ofNumberNumber(year, month.value());\n  };\n\n  YearMonth.ofNumberNumber = function ofNumberNumber(year, month) {\n    requireNonNull(year, 'year');\n    requireNonNull(month, 'month');\n    ChronoField.YEAR.checkValidValue(year);\n    ChronoField.MONTH_OF_YEAR.checkValidValue(month);\n    return new YearMonth(year, month);\n  };\n\n  YearMonth.from = function from(temporal) {\n    requireNonNull(temporal, 'temporal');\n\n    if (temporal instanceof YearMonth) {\n      return temporal;\n    }\n\n    try {\n      return YearMonth.of(temporal.get(ChronoField.YEAR), temporal.get(ChronoField.MONTH_OF_YEAR));\n    } catch (ex) {\n      throw new DateTimeException('Unable to obtain YearMonth from TemporalAccessor: ' + temporal + ', type ' + (temporal && temporal.constructor != null ? temporal.constructor.name : ''));\n    }\n  };\n\n  YearMonth.parse = function parse(text, formatter) {\n    if (arguments.length === 1) {\n      return YearMonth.parseString(text);\n    } else {\n      return YearMonth.parseStringFormatter(text, formatter);\n    }\n  };\n\n  YearMonth.parseString = function parseString(text) {\n    return YearMonth.parseStringFormatter(text, PARSER$1);\n  };\n\n  YearMonth.parseStringFormatter = function parseStringFormatter(text, formatter) {\n    requireNonNull(formatter, 'formatter');\n    return formatter.parse(text, YearMonth.FROM);\n  };\n\n  function YearMonth(year, month) {\n    var _this;\n\n    _this = _Temporal.call(this) || this;\n    _this._year = MathUtil.safeToInt(year);\n    _this._month = MathUtil.safeToInt(month);\n    return _this;\n  }\n\n  var _proto = YearMonth.prototype;\n\n  _proto.isSupported = function isSupported(fieldOrUnit) {\n    if (arguments.length === 1 && fieldOrUnit instanceof TemporalField) {\n      return this.isSupportedField(fieldOrUnit);\n    } else {\n      return this.isSupportedUnit(fieldOrUnit);\n    }\n  };\n\n  _proto.isSupportedField = function isSupportedField(field) {\n    if (field instanceof ChronoField) {\n      return field === ChronoField.YEAR || field === ChronoField.MONTH_OF_YEAR || field === ChronoField.PROLEPTIC_MONTH || field === ChronoField.YEAR_OF_ERA || field === ChronoField.ERA;\n    }\n\n    return field != null && field.isSupportedBy(this);\n  };\n\n  _proto.isSupportedUnit = function isSupportedUnit(unit) {\n    if (unit instanceof ChronoUnit) {\n      return unit === ChronoUnit.MONTHS || unit === ChronoUnit.YEARS || unit === ChronoUnit.DECADES || unit === ChronoUnit.CENTURIES || unit === ChronoUnit.MILLENNIA || unit === ChronoUnit.ERAS;\n    }\n\n    return unit != null && unit.isSupportedBy(this);\n  };\n\n  _proto.range = function range(field) {\n    if (field === ChronoField.YEAR_OF_ERA) {\n      return this.year() <= 0 ? ValueRange.of(1, Year.MAX_VALUE + 1) : ValueRange.of(1, Year.MAX_VALUE);\n    }\n\n    return _Temporal.prototype.range.call(this, field);\n  };\n\n  _proto.get = function get(field) {\n    requireNonNull(field, 'field');\n    requireInstance(field, TemporalField, 'field');\n    return this.range(field).checkValidIntValue(this.getLong(field), field);\n  };\n\n  _proto.getLong = function getLong(field) {\n    requireNonNull(field, 'field');\n    requireInstance(field, TemporalField, 'field');\n\n    if (field instanceof ChronoField) {\n      switch (field) {\n        case ChronoField.MONTH_OF_YEAR:\n          return this._month;\n\n        case ChronoField.PROLEPTIC_MONTH:\n          return this._getProlepticMonth();\n\n        case ChronoField.YEAR_OF_ERA:\n          return this._year < 1 ? 1 - this._year : this._year;\n\n        case ChronoField.YEAR:\n          return this._year;\n\n        case ChronoField.ERA:\n          return this._year < 1 ? 0 : 1;\n      }\n\n      throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);\n    }\n\n    return field.getFrom(this);\n  };\n\n  _proto._getProlepticMonth = function _getProlepticMonth() {\n    return MathUtil.safeAdd(MathUtil.safeMultiply(this._year, 12), this._month - 1);\n  };\n\n  _proto.year = function year() {\n    return this._year;\n  };\n\n  _proto.monthValue = function monthValue() {\n    return this._month;\n  };\n\n  _proto.month = function month() {\n    return Month.of(this._month);\n  };\n\n  _proto.isLeapYear = function isLeapYear() {\n    return IsoChronology.isLeapYear(this._year);\n  };\n\n  _proto.isValidDay = function isValidDay(dayOfMonth) {\n    return dayOfMonth >= 1 && dayOfMonth <= this.lengthOfMonth();\n  };\n\n  _proto.lengthOfMonth = function lengthOfMonth() {\n    return this.month().length(this.isLeapYear());\n  };\n\n  _proto.lengthOfYear = function lengthOfYear() {\n    return this.isLeapYear() ? 366 : 365;\n  };\n\n  _proto.with = function _with(adjusterOrField, value) {\n    if (arguments.length === 1) {\n      return this.withAdjuster(adjusterOrField);\n    } else {\n      return this.withFieldValue(adjusterOrField, value);\n    }\n  };\n\n  _proto.withAdjuster = function withAdjuster(adjuster) {\n    requireNonNull(adjuster, 'adjuster');\n    return adjuster.adjustInto(this);\n  };\n\n  _proto.withFieldValue = function withFieldValue(field, newValue) {\n    requireNonNull(field, 'field');\n    requireInstance(field, TemporalField, 'field');\n\n    if (field instanceof ChronoField) {\n      var f = field;\n      f.checkValidValue(newValue);\n\n      switch (f) {\n        case ChronoField.MONTH_OF_YEAR:\n          return this.withMonth(newValue);\n\n        case ChronoField.PROLEPTIC_MONTH:\n          return this.plusMonths(newValue - this.getLong(ChronoField.PROLEPTIC_MONTH));\n\n        case ChronoField.YEAR_OF_ERA:\n          return this.withYear(this._year < 1 ? 1 - newValue : newValue);\n\n        case ChronoField.YEAR:\n          return this.withYear(newValue);\n\n        case ChronoField.ERA:\n          return this.getLong(ChronoField.ERA) === newValue ? this : this.withYear(1 - this._year);\n      }\n\n      throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);\n    }\n\n    return field.adjustInto(this, newValue);\n  };\n\n  _proto.withYear = function withYear(year) {\n    ChronoField.YEAR.checkValidValue(year);\n    return new YearMonth(year, this._month);\n  };\n\n  _proto.withMonth = function withMonth(month) {\n    ChronoField.MONTH_OF_YEAR.checkValidValue(month);\n    return new YearMonth(this._year, month);\n  };\n\n  _proto.plusAmount = function plusAmount(amount) {\n    requireNonNull(amount, 'amount');\n    requireInstance(amount, TemporalAmount, 'amount');\n    return amount.addTo(this);\n  };\n\n  _proto.plusAmountUnit = function plusAmountUnit(amountToAdd, unit) {\n    requireNonNull(unit, 'unit');\n    requireInstance(unit, TemporalUnit, 'unit');\n\n    if (unit instanceof ChronoUnit) {\n      switch (unit) {\n        case ChronoUnit.MONTHS:\n          return this.plusMonths(amountToAdd);\n\n        case ChronoUnit.YEARS:\n          return this.plusYears(amountToAdd);\n\n        case ChronoUnit.DECADES:\n          return this.plusYears(MathUtil.safeMultiply(amountToAdd, 10));\n\n        case ChronoUnit.CENTURIES:\n          return this.plusYears(MathUtil.safeMultiply(amountToAdd, 100));\n\n        case ChronoUnit.MILLENNIA:\n          return this.plusYears(MathUtil.safeMultiply(amountToAdd, 1000));\n\n        case ChronoUnit.ERAS:\n          return this.with(ChronoField.ERA, MathUtil.safeAdd(this.getLong(ChronoField.ERA), amountToAdd));\n      }\n\n      throw new UnsupportedTemporalTypeException('Unsupported unit: ' + unit);\n    }\n\n    return unit.addTo(this, amountToAdd);\n  };\n\n  _proto.plusYears = function plusYears(yearsToAdd) {\n    if (yearsToAdd === 0) {\n      return this;\n    }\n\n    var newYear = ChronoField.YEAR.checkValidIntValue(this._year + yearsToAdd);\n    return this.withYear(newYear);\n  };\n\n  _proto.plusMonths = function plusMonths(monthsToAdd) {\n    if (monthsToAdd === 0) {\n      return this;\n    }\n\n    var monthCount = this._year * 12 + (this._month - 1);\n    var calcMonths = monthCount + monthsToAdd;\n    var newYear = ChronoField.YEAR.checkValidIntValue(MathUtil.floorDiv(calcMonths, 12));\n    var newMonth = MathUtil.floorMod(calcMonths, 12) + 1;\n    return new YearMonth(newYear, newMonth);\n  };\n\n  _proto.minusAmount = function minusAmount(amount) {\n    requireNonNull(amount, 'amount');\n    return amount.subtractFrom(this);\n  };\n\n  _proto.minusAmountUnit = function minusAmountUnit(amountToSubtract, unit) {\n    return amountToSubtract === MathUtil.MIN_SAFE_INTEGER ? this.plusAmountUnit(MathUtil.MAX_SAFE_INTEGER, unit).plusAmountUnit(1, unit) : this.plusAmountUnit(-amountToSubtract, unit);\n  };\n\n  _proto.minusYears = function minusYears(yearsToSubtract) {\n    return yearsToSubtract === MathUtil.MIN_SAFE_INTEGER ? this.plusYears(MathUtil.MIN_SAFE_INTEGER).plusYears(1) : this.plusYears(-yearsToSubtract);\n  };\n\n  _proto.minusMonths = function minusMonths(monthsToSubtract) {\n    return monthsToSubtract === MathUtil.MIN_SAFE_INTEGER ? this.plusMonths(Math.MAX_SAFE_INTEGER).plusMonths(1) : this.plusMonths(-monthsToSubtract);\n  };\n\n  _proto.query = function query(_query) {\n    requireNonNull(_query, 'query');\n    requireInstance(_query, TemporalQuery, 'query');\n\n    if (_query === TemporalQueries.chronology()) {\n      return IsoChronology.INSTANCE;\n    } else if (_query === TemporalQueries.precision()) {\n      return ChronoUnit.MONTHS;\n    } else if (_query === TemporalQueries.localDate() || _query === TemporalQueries.localTime() || _query === TemporalQueries.zone() || _query === TemporalQueries.zoneId() || _query === TemporalQueries.offset()) {\n      return null;\n    }\n\n    return _Temporal.prototype.query.call(this, _query);\n  };\n\n  _proto.adjustInto = function adjustInto(temporal) {\n    requireNonNull(temporal, 'temporal');\n    requireInstance(temporal, Temporal, 'temporal');\n    return temporal.with(ChronoField.PROLEPTIC_MONTH, this._getProlepticMonth());\n  };\n\n  _proto.until = function until(endExclusive, unit) {\n    requireNonNull(endExclusive, 'endExclusive');\n    requireNonNull(unit, 'unit');\n    requireInstance(endExclusive, Temporal, 'endExclusive');\n    requireInstance(unit, TemporalUnit, 'unit');\n    var end = YearMonth.from(endExclusive);\n\n    if (unit instanceof ChronoUnit) {\n      var monthsUntil = end._getProlepticMonth() - this._getProlepticMonth();\n\n      switch (unit) {\n        case ChronoUnit.MONTHS:\n          return monthsUntil;\n\n        case ChronoUnit.YEARS:\n          return monthsUntil / 12;\n\n        case ChronoUnit.DECADES:\n          return monthsUntil / 120;\n\n        case ChronoUnit.CENTURIES:\n          return monthsUntil / 1200;\n\n        case ChronoUnit.MILLENNIA:\n          return monthsUntil / 12000;\n\n        case ChronoUnit.ERAS:\n          return end.getLong(ChronoField.ERA) - this.getLong(ChronoField.ERA);\n      }\n\n      throw new UnsupportedTemporalTypeException('Unsupported unit: ' + unit);\n    }\n\n    return unit.between(this, end);\n  };\n\n  _proto.atDay = function atDay(dayOfMonth) {\n    return LocalDate.of(this._year, this._month, dayOfMonth);\n  };\n\n  _proto.atEndOfMonth = function atEndOfMonth() {\n    return LocalDate.of(this._year, this._month, this.lengthOfMonth());\n  };\n\n  _proto.compareTo = function compareTo(other) {\n    requireNonNull(other, 'other');\n    requireInstance(other, YearMonth, 'other');\n    var cmp = this._year - other.year();\n\n    if (cmp === 0) {\n      cmp = this._month - other.monthValue();\n    }\n\n    return cmp;\n  };\n\n  _proto.isAfter = function isAfter(other) {\n    return this.compareTo(other) > 0;\n  };\n\n  _proto.isBefore = function isBefore(other) {\n    return this.compareTo(other) < 0;\n  };\n\n  _proto.equals = function equals(obj) {\n    if (this === obj) {\n      return true;\n    }\n\n    if (obj instanceof YearMonth) {\n      var other = obj;\n      return this.year() === other.year() && this.monthValue() === other.monthValue();\n    }\n\n    return false;\n  };\n\n  _proto.toString = function toString() {\n    return PARSER$1.format(this);\n  };\n\n  _proto.toJSON = function toJSON() {\n    return this.toString();\n  };\n\n  _proto.format = function format(formatter) {\n    requireNonNull(formatter, 'formatter');\n    return formatter.format(this);\n  };\n\n  return YearMonth;\n}(Temporal);\nvar PARSER$1;\nfunction _init$c() {\n  PARSER$1 = new DateTimeFormatterBuilder().appendValue(ChronoField.YEAR, 4, 10, SignStyle.EXCEEDS_PAD).appendLiteral('-').appendValue(ChronoField.MONTH_OF_YEAR, 2).toFormatter();\n  YearMonth.FROM = createTemporalQuery('YearMonth.FROM', function (temporal) {\n    return YearMonth.from(temporal);\n  });\n}\n\nvar Year = function (_Temporal) {\n  _inheritsLoose(Year, _Temporal);\n\n  function Year(value) {\n    var _this;\n\n    _this = _Temporal.call(this) || this;\n    _this._year = MathUtil.safeToInt(value);\n    return _this;\n  }\n\n  var _proto = Year.prototype;\n\n  _proto.value = function value() {\n    return this._year;\n  };\n\n  Year.now = function now(zoneIdOrClock) {\n    if (zoneIdOrClock === void 0) {\n      zoneIdOrClock = undefined;\n    }\n\n    if (zoneIdOrClock === undefined) {\n      return Year.now0();\n    } else if (zoneIdOrClock instanceof ZoneId) {\n      return Year.nowZoneId(zoneIdOrClock);\n    } else {\n      return Year.nowClock(zoneIdOrClock);\n    }\n  };\n\n  Year.now0 = function now0() {\n    return Year.nowClock(Clock.systemDefaultZone());\n  };\n\n  Year.nowZoneId = function nowZoneId(zone) {\n    requireNonNull(zone, 'zone');\n    requireInstance(zone, ZoneId, 'zone');\n    return Year.nowClock(Clock.system(zone));\n  };\n\n  Year.nowClock = function nowClock(clock) {\n    requireNonNull(clock, 'clock');\n    requireInstance(clock, Clock, 'clock');\n    var now = LocalDate.now(clock);\n    return Year.of(now.year());\n  };\n\n  Year.of = function of(isoYear) {\n    requireNonNull(isoYear, 'isoYear');\n    ChronoField.YEAR.checkValidValue(isoYear);\n    return new Year(isoYear);\n  };\n\n  Year.from = function from(temporal) {\n    requireNonNull(temporal, 'temporal');\n    requireInstance(temporal, TemporalAccessor, 'temporal');\n\n    if (temporal instanceof Year) {\n      return temporal;\n    }\n\n    try {\n      return Year.of(temporal.get(ChronoField.YEAR));\n    } catch (ex) {\n      throw new DateTimeException('Unable to obtain Year from TemporalAccessor: ' + temporal + ', type ' + (temporal && temporal.constructor != null ? temporal.constructor.name : ''));\n    }\n  };\n\n  Year.parse = function parse(text, formatter) {\n    if (arguments.length <= 1) {\n      return Year.parseText(text);\n    } else {\n      return Year.parseTextFormatter(text, formatter);\n    }\n  };\n\n  Year.parseText = function parseText(text) {\n    requireNonNull(text, 'text');\n    return Year.parse(text, PARSER$2);\n  };\n\n  Year.parseTextFormatter = function parseTextFormatter(text, formatter) {\n    if (formatter === void 0) {\n      formatter = PARSER$2;\n    }\n\n    requireNonNull(text, 'text');\n    requireNonNull(formatter, 'formatter');\n    requireInstance(formatter, DateTimeFormatter, 'formatter');\n    return formatter.parse(text, Year.FROM);\n  };\n\n  Year.isLeap = function isLeap(year) {\n    return MathUtil.intMod(year, 4) === 0 && (MathUtil.intMod(year, 100) !== 0 || MathUtil.intMod(year, 400) === 0);\n  };\n\n  _proto.isSupported = function isSupported(fieldOrUnit) {\n    if (arguments.length === 1 && fieldOrUnit instanceof TemporalField) {\n      return this.isSupportedField(fieldOrUnit);\n    } else {\n      return this.isSupportedUnit(fieldOrUnit);\n    }\n  };\n\n  _proto.isSupportedField = function isSupportedField(field) {\n    if (field instanceof ChronoField) {\n      return field === ChronoField.YEAR || field === ChronoField.YEAR_OF_ERA || field === ChronoField.ERA;\n    }\n\n    return field != null && field.isSupportedBy(this);\n  };\n\n  _proto.isSupportedUnit = function isSupportedUnit(unit) {\n    if (unit instanceof ChronoUnit) {\n      return unit === ChronoUnit.YEARS || unit === ChronoUnit.DECADES || unit === ChronoUnit.CENTURIES || unit === ChronoUnit.MILLENNIA || unit === ChronoUnit.ERAS;\n    }\n\n    return unit != null && unit.isSupportedBy(this);\n  };\n\n  _proto.range = function range(field) {\n    if (this.isSupported(field)) {\n      return field.range();\n    } else if (field instanceof ChronoField) {\n      throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);\n    }\n\n    return _Temporal.prototype.range.call(this, field);\n  };\n\n  _proto.get = function get(field) {\n    return this.range(field).checkValidIntValue(this.getLong(field), field);\n  };\n\n  _proto.getLong = function getLong(field) {\n    requireNonNull(field, 'field');\n\n    if (field instanceof ChronoField) {\n      switch (field) {\n        case ChronoField.YEAR_OF_ERA:\n          return this._year < 1 ? 1 - this._year : this._year;\n\n        case ChronoField.YEAR:\n          return this._year;\n\n        case ChronoField.ERA:\n          return this._year < 1 ? 0 : 1;\n      }\n\n      throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);\n    }\n\n    return field.getFrom(this);\n  };\n\n  _proto.isLeap = function isLeap() {\n    return Year.isLeap(this._year);\n  };\n\n  _proto.withAdjuster = function withAdjuster(adjuster) {\n    requireNonNull(adjuster, 'adjuster');\n    return adjuster.adjustInto(this);\n  };\n\n  _proto.withFieldValue = function withFieldValue(field, newValue) {\n    requireNonNull(field, 'field');\n    requireInstance(field, TemporalField, 'field');\n\n    if (field instanceof ChronoField) {\n      field.checkValidValue(newValue);\n\n      switch (field) {\n        case ChronoField.YEAR_OF_ERA:\n          return Year.of(this._year < 1 ? 1 - newValue : newValue);\n\n        case ChronoField.YEAR:\n          return Year.of(newValue);\n\n        case ChronoField.ERA:\n          return this.getLong(ChronoField.ERA) === newValue ? this : Year.of(1 - this._year);\n      }\n\n      throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);\n    }\n\n    return field.adjustInto(this, newValue);\n  };\n\n  _proto.plusAmount = function plusAmount(amount) {\n    requireNonNull(amount, 'amount');\n    requireInstance(amount, TemporalAmount, 'amount');\n    return amount.addTo(this);\n  };\n\n  _proto.plusAmountUnit = function plusAmountUnit(amountToAdd, unit) {\n    requireNonNull(amountToAdd, 'amountToAdd');\n    requireNonNull(unit, 'unit');\n    requireInstance(unit, TemporalUnit, 'unit');\n\n    if (unit instanceof ChronoUnit) {\n      switch (unit) {\n        case ChronoUnit.YEARS:\n          return this.plusYears(amountToAdd);\n\n        case ChronoUnit.DECADES:\n          return this.plusYears(MathUtil.safeMultiply(amountToAdd, 10));\n\n        case ChronoUnit.CENTURIES:\n          return this.plusYears(MathUtil.safeMultiply(amountToAdd, 100));\n\n        case ChronoUnit.MILLENNIA:\n          return this.plusYears(MathUtil.safeMultiply(amountToAdd, 1000));\n\n        case ChronoUnit.ERAS:\n          return this.with(ChronoField.ERA, MathUtil.safeAdd(this.getLong(ChronoField.ERA), amountToAdd));\n      }\n\n      throw new UnsupportedTemporalTypeException('Unsupported unit: ' + unit);\n    }\n\n    return unit.addTo(this, amountToAdd);\n  };\n\n  _proto.plusYears = function plusYears(yearsToAdd) {\n    if (yearsToAdd === 0) {\n      return this;\n    }\n\n    return Year.of(ChronoField.YEAR.checkValidIntValue(MathUtil.safeAdd(this._year, yearsToAdd)));\n  };\n\n  _proto.minusAmount = function minusAmount(amount) {\n    requireNonNull(amount, 'amount');\n    requireInstance(amount, TemporalAmount, 'amount');\n    return amount.subtractFrom(this);\n  };\n\n  _proto.minusAmountUnit = function minusAmountUnit(amountToSubtract, unit) {\n    requireNonNull(amountToSubtract, 'amountToSubtract');\n    requireNonNull(unit, 'unit');\n    requireInstance(unit, TemporalUnit, 'unit');\n    return amountToSubtract === MathUtil.MIN_SAFE_INTEGER ? this.plus(MathUtil.MAX_SAFE_INTEGER, unit).plus(1, unit) : this.plus(-amountToSubtract, unit);\n  };\n\n  _proto.minusYears = function minusYears(yearsToSubtract) {\n    return yearsToSubtract === MathUtil.MIN_SAFE_INTEGER ? this.plusYears(MathUtil.MAX_SAFE_INTEGER).plusYears(1) : this.plusYears(-yearsToSubtract);\n  };\n\n  _proto.adjustInto = function adjustInto(temporal) {\n    requireNonNull(temporal, 'temporal');\n    return temporal.with(ChronoField.YEAR, this._year);\n  };\n\n  _proto.isValidMonthDay = function isValidMonthDay(monthDay) {\n    return monthDay != null && monthDay.isValidYear(this._year);\n  };\n\n  _proto.length = function length() {\n    return this.isLeap() ? 366 : 365;\n  };\n\n  _proto.atDay = function atDay(dayOfYear) {\n    return LocalDate.ofYearDay(this._year, dayOfYear);\n  };\n\n  _proto.atMonth = function atMonth(monthOrNumber) {\n    if (arguments.length === 1 && monthOrNumber instanceof Month) {\n      return this.atMonthMonth(monthOrNumber);\n    } else {\n      return this.atMonthNumber(monthOrNumber);\n    }\n  };\n\n  _proto.atMonthMonth = function atMonthMonth(month) {\n    requireNonNull(month, 'month');\n    requireInstance(month, Month, 'month');\n    return YearMonth.of(this._year, month);\n  };\n\n  _proto.atMonthNumber = function atMonthNumber(month) {\n    requireNonNull(month, 'month');\n    return YearMonth.of(this._year, month);\n  };\n\n  _proto.atMonthDay = function atMonthDay(monthDay) {\n    requireNonNull(monthDay, 'monthDay');\n    requireInstance(monthDay, MonthDay, 'monthDay');\n    return monthDay.atYear(this._year);\n  };\n\n  _proto.query = function query(_query) {\n    requireNonNull(_query, 'query()');\n    requireInstance(_query, TemporalQuery, 'query()');\n\n    if (_query === TemporalQueries.chronology()) {\n      return IsoChronology.INSTANCE;\n    } else if (_query === TemporalQueries.precision()) {\n      return ChronoUnit.YEARS;\n    } else if (_query === TemporalQueries.localDate() || _query === TemporalQueries.localTime() || _query === TemporalQueries.zone() || _query === TemporalQueries.zoneId() || _query === TemporalQueries.offset()) {\n      return null;\n    }\n\n    return _Temporal.prototype.query.call(this, _query);\n  };\n\n  _proto.compareTo = function compareTo(other) {\n    requireNonNull(other, 'other');\n    requireInstance(other, Year, 'other');\n    return this._year - other._year;\n  };\n\n  _proto.isAfter = function isAfter(other) {\n    requireNonNull(other, 'other');\n    requireInstance(other, Year, 'other');\n    return this._year > other._year;\n  };\n\n  _proto.isBefore = function isBefore(other) {\n    requireNonNull(other, 'other');\n    requireInstance(other, Year, 'other');\n    return this._year < other._year;\n  };\n\n  _proto.format = function format(formatter) {\n    requireNonNull(formatter, 'formatter');\n    requireInstance(formatter, DateTimeFormatter, 'formatter');\n    return formatter.format(this);\n  };\n\n  _proto.equals = function equals(other) {\n    if (this === other) {\n      return true;\n    }\n\n    if (other instanceof Year) {\n      return this.value() === other.value();\n    }\n\n    return false;\n  };\n\n  _proto.toString = function toString() {\n    return '' + this._year;\n  };\n\n  _proto.toJSON = function toJSON() {\n    return this.toString();\n  };\n\n  _proto.until = function until(endExclusive, unit) {\n    var end = Year.from(endExclusive);\n\n    if (unit instanceof ChronoUnit) {\n      var yearsUntil = end.value() - this.value();\n\n      switch (unit) {\n        case ChronoUnit.YEARS:\n          return yearsUntil;\n\n        case ChronoUnit.DECADES:\n          return MathUtil.intDiv(yearsUntil, 10);\n\n        case ChronoUnit.CENTURIES:\n          return MathUtil.intDiv(yearsUntil, 100);\n\n        case ChronoUnit.MILLENNIA:\n          return MathUtil.intDiv(yearsUntil, 1000);\n\n        case ChronoUnit.ERAS:\n          return end.getLong(ChronoField.ERA) - this.getLong(ChronoField.ERA);\n      }\n\n      throw new UnsupportedTemporalTypeException('Unsupported unit: ' + unit);\n    }\n\n    return unit.between(this, end);\n  };\n\n  return Year;\n}(Temporal);\nvar PARSER$2;\nfunction _init$d() {\n  Year.MIN_VALUE = YearConstants.MIN_VALUE;\n  Year.MAX_VALUE = YearConstants.MAX_VALUE;\n  PARSER$2 = new DateTimeFormatterBuilder().appendValue(ChronoField.YEAR, 4, 10, SignStyle.EXCEEDS_PAD).toFormatter();\n  Year.FROM = createTemporalQuery('Year.FROM', function (temporal) {\n    return Year.from(temporal);\n  });\n}\n\nvar TemporalAdjusters = function () {\n  function TemporalAdjusters() {}\n\n  TemporalAdjusters.firstDayOfMonth = function firstDayOfMonth() {\n    return Impl.FIRST_DAY_OF_MONTH;\n  };\n\n  TemporalAdjusters.lastDayOfMonth = function lastDayOfMonth() {\n    return Impl.LAST_DAY_OF_MONTH;\n  };\n\n  TemporalAdjusters.firstDayOfNextMonth = function firstDayOfNextMonth() {\n    return Impl.FIRST_DAY_OF_NEXT_MONTH;\n  };\n\n  TemporalAdjusters.firstDayOfYear = function firstDayOfYear() {\n    return Impl.FIRST_DAY_OF_YEAR;\n  };\n\n  TemporalAdjusters.lastDayOfYear = function lastDayOfYear() {\n    return Impl.LAST_DAY_OF_YEAR;\n  };\n\n  TemporalAdjusters.firstDayOfNextYear = function firstDayOfNextYear() {\n    return Impl.FIRST_DAY_OF_NEXT_YEAR;\n  };\n\n  TemporalAdjusters.firstInMonth = function firstInMonth(dayOfWeek) {\n    requireNonNull(dayOfWeek, 'dayOfWeek');\n    return new DayOfWeekInMonth(1, dayOfWeek);\n  };\n\n  TemporalAdjusters.lastInMonth = function lastInMonth(dayOfWeek) {\n    requireNonNull(dayOfWeek, 'dayOfWeek');\n    return new DayOfWeekInMonth(-1, dayOfWeek);\n  };\n\n  TemporalAdjusters.dayOfWeekInMonth = function dayOfWeekInMonth(ordinal, dayOfWeek) {\n    requireNonNull(dayOfWeek, 'dayOfWeek');\n    return new DayOfWeekInMonth(ordinal, dayOfWeek);\n  };\n\n  TemporalAdjusters.next = function next(dayOfWeek) {\n    return new RelativeDayOfWeek(2, dayOfWeek);\n  };\n\n  TemporalAdjusters.nextOrSame = function nextOrSame(dayOfWeek) {\n    return new RelativeDayOfWeek(0, dayOfWeek);\n  };\n\n  TemporalAdjusters.previous = function previous(dayOfWeek) {\n    return new RelativeDayOfWeek(3, dayOfWeek);\n  };\n\n  TemporalAdjusters.previousOrSame = function previousOrSame(dayOfWeek) {\n    return new RelativeDayOfWeek(1, dayOfWeek);\n  };\n\n  return TemporalAdjusters;\n}();\n\nvar Impl = function (_TemporalAdjuster) {\n  _inheritsLoose(Impl, _TemporalAdjuster);\n\n  function Impl(ordinal) {\n    var _this;\n\n    _this = _TemporalAdjuster.call(this) || this;\n    _this._ordinal = ordinal;\n    return _this;\n  }\n\n  var _proto = Impl.prototype;\n\n  _proto.adjustInto = function adjustInto(temporal) {\n    switch (this._ordinal) {\n      case 0:\n        return temporal.with(ChronoField.DAY_OF_MONTH, 1);\n\n      case 1:\n        return temporal.with(ChronoField.DAY_OF_MONTH, temporal.range(ChronoField.DAY_OF_MONTH).maximum());\n\n      case 2:\n        return temporal.with(ChronoField.DAY_OF_MONTH, 1).plus(1, ChronoUnit.MONTHS);\n\n      case 3:\n        return temporal.with(ChronoField.DAY_OF_YEAR, 1);\n\n      case 4:\n        return temporal.with(ChronoField.DAY_OF_YEAR, temporal.range(ChronoField.DAY_OF_YEAR).maximum());\n\n      case 5:\n        return temporal.with(ChronoField.DAY_OF_YEAR, 1).plus(1, ChronoUnit.YEARS);\n    }\n\n    throw new IllegalStateException('Unreachable');\n  };\n\n  return Impl;\n}(TemporalAdjuster);\n\nImpl.FIRST_DAY_OF_MONTH = new Impl(0);\nImpl.LAST_DAY_OF_MONTH = new Impl(1);\nImpl.FIRST_DAY_OF_NEXT_MONTH = new Impl(2);\nImpl.FIRST_DAY_OF_YEAR = new Impl(3);\nImpl.LAST_DAY_OF_YEAR = new Impl(4);\nImpl.FIRST_DAY_OF_NEXT_YEAR = new Impl(5);\n\nvar DayOfWeekInMonth = function (_TemporalAdjuster2) {\n  _inheritsLoose(DayOfWeekInMonth, _TemporalAdjuster2);\n\n  function DayOfWeekInMonth(ordinal, dow) {\n    var _this2;\n\n    _this2 = _TemporalAdjuster2.call(this) || this;\n    _this2._ordinal = ordinal;\n    _this2._dowValue = dow.value();\n    return _this2;\n  }\n\n  var _proto2 = DayOfWeekInMonth.prototype;\n\n  _proto2.adjustInto = function adjustInto(temporal) {\n    if (this._ordinal >= 0) {\n      var temp = temporal.with(ChronoField.DAY_OF_MONTH, 1);\n      var curDow = temp.get(ChronoField.DAY_OF_WEEK);\n      var dowDiff = MathUtil.intMod(this._dowValue - curDow + 7, 7);\n      dowDiff += (this._ordinal - 1) * 7;\n      return temp.plus(dowDiff, ChronoUnit.DAYS);\n    } else {\n      var _temp = temporal.with(ChronoField.DAY_OF_MONTH, temporal.range(ChronoField.DAY_OF_MONTH).maximum());\n\n      var _curDow = _temp.get(ChronoField.DAY_OF_WEEK);\n\n      var daysDiff = this._dowValue - _curDow;\n      daysDiff = daysDiff === 0 ? 0 : daysDiff > 0 ? daysDiff - 7 : daysDiff;\n      daysDiff -= (-this._ordinal - 1) * 7;\n      return _temp.plus(daysDiff, ChronoUnit.DAYS);\n    }\n  };\n\n  return DayOfWeekInMonth;\n}(TemporalAdjuster);\n\nvar RelativeDayOfWeek = function (_TemporalAdjuster3) {\n  _inheritsLoose(RelativeDayOfWeek, _TemporalAdjuster3);\n\n  function RelativeDayOfWeek(relative, dayOfWeek) {\n    var _this3;\n\n    _this3 = _TemporalAdjuster3.call(this) || this;\n    requireNonNull(dayOfWeek, 'dayOfWeek');\n    _this3._relative = relative;\n    _this3._dowValue = dayOfWeek.value();\n    return _this3;\n  }\n\n  var _proto3 = RelativeDayOfWeek.prototype;\n\n  _proto3.adjustInto = function adjustInto(temporal) {\n    var calDow = temporal.get(ChronoField.DAY_OF_WEEK);\n\n    if (this._relative < 2 && calDow === this._dowValue) {\n      return temporal;\n    }\n\n    if ((this._relative & 1) === 0) {\n      var daysDiff = calDow - this._dowValue;\n      return temporal.plus(daysDiff >= 0 ? 7 - daysDiff : -daysDiff, ChronoUnit.DAYS);\n    } else {\n      var _daysDiff = this._dowValue - calDow;\n\n      return temporal.minus(_daysDiff >= 0 ? 7 - _daysDiff : -_daysDiff, ChronoUnit.DAYS);\n    }\n  };\n\n  return RelativeDayOfWeek;\n}(TemporalAdjuster);\n\nvar IsoChronology = function (_Enum) {\n  _inheritsLoose(IsoChronology, _Enum);\n\n  function IsoChronology() {\n    return _Enum.apply(this, arguments) || this;\n  }\n\n  IsoChronology.isLeapYear = function isLeapYear(prolepticYear) {\n    return (prolepticYear & 3) === 0 && (prolepticYear % 100 !== 0 || prolepticYear % 400 === 0);\n  };\n\n  var _proto = IsoChronology.prototype;\n\n  _proto._updateResolveMap = function _updateResolveMap(fieldValues, field, value) {\n    requireNonNull(fieldValues, 'fieldValues');\n    requireNonNull(field, 'field');\n    var current = fieldValues.get(field);\n\n    if (current != null && current !== value) {\n      throw new DateTimeException('Invalid state, field: ' + field + ' ' + current + ' conflicts with ' + field + ' ' + value);\n    }\n\n    fieldValues.put(field, value);\n  };\n\n  _proto.resolveDate = function resolveDate(fieldValues, resolverStyle) {\n    if (fieldValues.containsKey(ChronoField.EPOCH_DAY)) {\n      return LocalDate.ofEpochDay(fieldValues.remove(ChronoField.EPOCH_DAY));\n    }\n\n    var prolepticMonth = fieldValues.remove(ChronoField.PROLEPTIC_MONTH);\n\n    if (prolepticMonth != null) {\n      if (resolverStyle !== ResolverStyle.LENIENT) {\n        ChronoField.PROLEPTIC_MONTH.checkValidValue(prolepticMonth);\n      }\n\n      this._updateResolveMap(fieldValues, ChronoField.MONTH_OF_YEAR, MathUtil.floorMod(prolepticMonth, 12) + 1);\n\n      this._updateResolveMap(fieldValues, ChronoField.YEAR, MathUtil.floorDiv(prolepticMonth, 12));\n    }\n\n    var yoeLong = fieldValues.remove(ChronoField.YEAR_OF_ERA);\n\n    if (yoeLong != null) {\n      if (resolverStyle !== ResolverStyle.LENIENT) {\n        ChronoField.YEAR_OF_ERA.checkValidValue(yoeLong);\n      }\n\n      var era = fieldValues.remove(ChronoField.ERA);\n\n      if (era == null) {\n        var year = fieldValues.get(ChronoField.YEAR);\n\n        if (resolverStyle === ResolverStyle.STRICT) {\n          if (year != null) {\n            this._updateResolveMap(fieldValues, ChronoField.YEAR, year > 0 ? yoeLong : MathUtil.safeSubtract(1, yoeLong));\n          } else {\n            fieldValues.put(ChronoField.YEAR_OF_ERA, yoeLong);\n          }\n        } else {\n          this._updateResolveMap(fieldValues, ChronoField.YEAR, year == null || year > 0 ? yoeLong : MathUtil.safeSubtract(1, yoeLong));\n        }\n      } else if (era === 1) {\n        this._updateResolveMap(fieldValues, ChronoField.YEAR, yoeLong);\n      } else if (era === 0) {\n        this._updateResolveMap(fieldValues, ChronoField.YEAR, MathUtil.safeSubtract(1, yoeLong));\n      } else {\n        throw new DateTimeException('Invalid value for era: ' + era);\n      }\n    } else if (fieldValues.containsKey(ChronoField.ERA)) {\n      ChronoField.ERA.checkValidValue(fieldValues.get(ChronoField.ERA));\n    }\n\n    if (fieldValues.containsKey(ChronoField.YEAR)) {\n      if (fieldValues.containsKey(ChronoField.MONTH_OF_YEAR)) {\n        if (fieldValues.containsKey(ChronoField.DAY_OF_MONTH)) {\n          var y = ChronoField.YEAR.checkValidIntValue(fieldValues.remove(ChronoField.YEAR));\n          var moy = fieldValues.remove(ChronoField.MONTH_OF_YEAR);\n          var dom = fieldValues.remove(ChronoField.DAY_OF_MONTH);\n\n          if (resolverStyle === ResolverStyle.LENIENT) {\n            var months = moy - 1;\n            var days = dom - 1;\n            return LocalDate.of(y, 1, 1).plusMonths(months).plusDays(days);\n          } else if (resolverStyle === ResolverStyle.SMART) {\n            ChronoField.DAY_OF_MONTH.checkValidValue(dom);\n\n            if (moy === 4 || moy === 6 || moy === 9 || moy === 11) {\n              dom = Math.min(dom, 30);\n            } else if (moy === 2) {\n              dom = Math.min(dom, Month.FEBRUARY.length(Year.isLeap(y)));\n            }\n\n            return LocalDate.of(y, moy, dom);\n          } else {\n            return LocalDate.of(y, moy, dom);\n          }\n        }\n      }\n\n      if (fieldValues.containsKey(ChronoField.DAY_OF_YEAR)) {\n        var _y = ChronoField.YEAR.checkValidIntValue(fieldValues.remove(ChronoField.YEAR));\n\n        if (resolverStyle === ResolverStyle.LENIENT) {\n          var _days = MathUtil.safeSubtract(fieldValues.remove(ChronoField.DAY_OF_YEAR), 1);\n\n          return LocalDate.ofYearDay(_y, 1).plusDays(_days);\n        }\n\n        var doy = ChronoField.DAY_OF_YEAR.checkValidIntValue(fieldValues.remove(ChronoField.DAY_OF_YEAR));\n        return LocalDate.ofYearDay(_y, doy);\n      }\n\n      if (fieldValues.containsKey(ChronoField.ALIGNED_WEEK_OF_YEAR)) {\n        if (fieldValues.containsKey(ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR)) {\n          var _y2 = ChronoField.YEAR.checkValidIntValue(fieldValues.remove(ChronoField.YEAR));\n\n          if (resolverStyle === ResolverStyle.LENIENT) {\n            var weeks = MathUtil.safeSubtract(fieldValues.remove(ChronoField.ALIGNED_WEEK_OF_YEAR), 1);\n\n            var _days2 = MathUtil.safeSubtract(fieldValues.remove(ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR), 1);\n\n            return LocalDate.of(_y2, 1, 1).plusWeeks(weeks).plusDays(_days2);\n          }\n\n          var aw = ChronoField.ALIGNED_WEEK_OF_YEAR.checkValidIntValue(fieldValues.remove(ChronoField.ALIGNED_WEEK_OF_YEAR));\n          var ad = ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR.checkValidIntValue(fieldValues.remove(ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR));\n          var date = LocalDate.of(_y2, 1, 1).plusDays((aw - 1) * 7 + (ad - 1));\n\n          if (resolverStyle === ResolverStyle.STRICT && date.get(ChronoField.YEAR) !== _y2) {\n            throw new DateTimeException('Strict mode rejected date parsed to a different year');\n          }\n\n          return date;\n        }\n\n        if (fieldValues.containsKey(ChronoField.DAY_OF_WEEK)) {\n          var _y3 = ChronoField.YEAR.checkValidIntValue(fieldValues.remove(ChronoField.YEAR));\n\n          if (resolverStyle === ResolverStyle.LENIENT) {\n            var _weeks = MathUtil.safeSubtract(fieldValues.remove(ChronoField.ALIGNED_WEEK_OF_YEAR), 1);\n\n            var _days3 = MathUtil.safeSubtract(fieldValues.remove(ChronoField.DAY_OF_WEEK), 1);\n\n            return LocalDate.of(_y3, 1, 1).plusWeeks(_weeks).plusDays(_days3);\n          }\n\n          var _aw = ChronoField.ALIGNED_WEEK_OF_YEAR.checkValidIntValue(fieldValues.remove(ChronoField.ALIGNED_WEEK_OF_YEAR));\n\n          var dow = ChronoField.DAY_OF_WEEK.checkValidIntValue(fieldValues.remove(ChronoField.DAY_OF_WEEK));\n\n          var _date = LocalDate.of(_y3, 1, 1).plusWeeks(_aw - 1).with(TemporalAdjusters.nextOrSame(DayOfWeek.of(dow)));\n\n          if (resolverStyle === ResolverStyle.STRICT && _date.get(ChronoField.YEAR) !== _y3) {\n            throw new DateTimeException('Strict mode rejected date parsed to a different month');\n          }\n\n          return _date;\n        }\n      }\n    }\n\n    return null;\n  };\n\n  _proto.date = function date(temporal) {\n    return LocalDate.from(temporal);\n  };\n\n  return IsoChronology;\n}(Enum);\nfunction _init$e() {\n  IsoChronology.INSTANCE = new IsoChronology('IsoChronology');\n}\n\nvar OffsetTime = function (_DefaultInterfaceTemp) {\n  _inheritsLoose(OffsetTime, _DefaultInterfaceTemp);\n\n  OffsetTime.from = function from(temporal) {\n    requireNonNull(temporal, 'temporal');\n\n    if (temporal instanceof OffsetTime) {\n      return temporal;\n    } else if (temporal instanceof OffsetDateTime) {\n      return temporal.toOffsetTime();\n    }\n\n    try {\n      var time = LocalTime.from(temporal);\n      var offset = ZoneOffset.from(temporal);\n      return new OffsetTime(time, offset);\n    } catch (ex) {\n      throw new DateTimeException(\"Unable to obtain OffsetTime TemporalAccessor: \" + temporal + \", type \" + (temporal.constructor != null ? temporal.constructor.name : ''));\n    }\n  };\n\n  OffsetTime.now = function now(clockOrZone) {\n    if (arguments.length === 0) {\n      return OffsetTime._now(Clock.systemDefaultZone());\n    } else if (clockOrZone instanceof Clock) {\n      return OffsetTime._now(clockOrZone);\n    } else {\n      return OffsetTime._now(Clock.system(clockOrZone));\n    }\n  };\n\n  OffsetTime._now = function _now(clock) {\n    requireNonNull(clock, 'clock');\n    var now = clock.instant();\n    return OffsetTime.ofInstant(now, clock.zone().rules().offset(now));\n  };\n\n  OffsetTime.of = function of() {\n    if (arguments.length <= 2) {\n      return OffsetTime.ofTimeAndOffset.apply(this, arguments);\n    } else {\n      return OffsetTime.ofNumbers.apply(this, arguments);\n    }\n  };\n\n  OffsetTime.ofNumbers = function ofNumbers(hour, minute, second, nanoOfSecond, offset) {\n    var time = LocalTime.of(hour, minute, second, nanoOfSecond);\n    return new OffsetTime(time, offset);\n  };\n\n  OffsetTime.ofTimeAndOffset = function ofTimeAndOffset(time, offset) {\n    return new OffsetTime(time, offset);\n  };\n\n  OffsetTime.ofInstant = function ofInstant(instant, zone) {\n    requireNonNull(instant, 'instant');\n    requireInstance(instant, Instant, 'instant');\n    requireNonNull(zone, 'zone');\n    requireInstance(zone, ZoneId, 'zone');\n    var rules = zone.rules();\n    var offset = rules.offset(instant);\n    var secsOfDay = instant.epochSecond() % LocalTime.SECONDS_PER_DAY;\n    secsOfDay = (secsOfDay + offset.totalSeconds()) % LocalTime.SECONDS_PER_DAY;\n\n    if (secsOfDay < 0) {\n      secsOfDay += LocalTime.SECONDS_PER_DAY;\n    }\n\n    var time = LocalTime.ofSecondOfDay(secsOfDay, instant.nano());\n    return new OffsetTime(time, offset);\n  };\n\n  OffsetTime.parse = function parse(text, formatter) {\n    if (formatter === void 0) {\n      formatter = DateTimeFormatter.ISO_OFFSET_TIME;\n    }\n\n    requireNonNull(formatter, 'formatter');\n    return formatter.parse(text, OffsetTime.FROM);\n  };\n\n  function OffsetTime(time, offset) {\n    var _this;\n\n    _this = _DefaultInterfaceTemp.call(this) || this;\n    requireNonNull(time, 'time');\n    requireInstance(time, LocalTime, 'time');\n    requireNonNull(offset, 'offset');\n    requireInstance(offset, ZoneOffset, 'offset');\n    _this._time = time;\n    _this._offset = offset;\n    return _this;\n  }\n\n  var _proto = OffsetTime.prototype;\n\n  _proto.adjustInto = function adjustInto(temporal) {\n    return temporal.with(ChronoField.NANO_OF_DAY, this._time.toNanoOfDay()).with(ChronoField.OFFSET_SECONDS, this.offset().totalSeconds());\n  };\n\n  _proto.atDate = function atDate(date) {\n    return OffsetDateTime.of(date, this._time, this._offset);\n  };\n\n  _proto.format = function format(formatter) {\n    requireNonNull(formatter, 'formatter');\n    return formatter.format(this, OffsetTime.FROM);\n  };\n\n  _proto.get = function get(field) {\n    return _DefaultInterfaceTemp.prototype.get.call(this, field);\n  };\n\n  _proto.getLong = function getLong(field) {\n    if (field instanceof ChronoField) {\n      if (field === ChronoField.OFFSET_SECONDS) {\n        return this._offset.totalSeconds();\n      }\n\n      return this._time.getLong(field);\n    }\n\n    return field.getFrom(this);\n  };\n\n  _proto.hour = function hour() {\n    return this._time.hour();\n  };\n\n  _proto.minute = function minute() {\n    return this._time.minute();\n  };\n\n  _proto.second = function second() {\n    return this._time.second();\n  };\n\n  _proto.nano = function nano() {\n    return this._time.nano();\n  };\n\n  _proto.offset = function offset() {\n    return this._offset;\n  };\n\n  _proto.isAfter = function isAfter(other) {\n    requireNonNull(other, 'other');\n    return this._toEpochNano() > other._toEpochNano();\n  };\n\n  _proto.isBefore = function isBefore(other) {\n    requireNonNull(other, 'other');\n    return this._toEpochNano() < other._toEpochNano();\n  };\n\n  _proto.isEqual = function isEqual(other) {\n    requireNonNull(other, 'other');\n    return this._toEpochNano() === other._toEpochNano();\n  };\n\n  _proto.isSupported = function isSupported(fieldOrUnit) {\n    if (fieldOrUnit instanceof ChronoField) {\n      return fieldOrUnit.isTimeBased() || fieldOrUnit === ChronoField.OFFSET_SECONDS;\n    } else if (fieldOrUnit instanceof ChronoUnit) {\n      return fieldOrUnit.isTimeBased();\n    }\n\n    return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);\n  };\n\n  _proto.minusHours = function minusHours(hours) {\n    return this._withLocalTimeOffset(this._time.minusHours(hours), this._offset);\n  };\n\n  _proto.minusMinutes = function minusMinutes(minutes) {\n    return this._withLocalTimeOffset(this._time.minusMinutes(minutes), this._offset);\n  };\n\n  _proto.minusSeconds = function minusSeconds(seconds) {\n    return this._withLocalTimeOffset(this._time.minusSeconds(seconds), this._offset);\n  };\n\n  _proto.minusNanos = function minusNanos(nanos) {\n    return this._withLocalTimeOffset(this._time.minusNanos(nanos), this._offset);\n  };\n\n  _proto.minusAmount = function minusAmount(amount) {\n    requireNonNull(amount);\n    return amount.subtractFrom(this);\n  };\n\n  _proto.minusAmountUnit = function minusAmountUnit(amountToSubtract, unit) {\n    return this.plus(-1 * amountToSubtract, unit);\n  };\n\n  _proto.plusAmount = function plusAmount(amount) {\n    requireNonNull(amount);\n    return amount.addTo(this);\n  };\n\n  _proto.plusAmountUnit = function plusAmountUnit(amountToAdd, unit) {\n    if (unit instanceof ChronoUnit) {\n      return this._withLocalTimeOffset(this._time.plus(amountToAdd, unit), this._offset);\n    }\n\n    return unit.addTo(this, amountToAdd);\n  };\n\n  _proto.plusHours = function plusHours(hours) {\n    return this._withLocalTimeOffset(this._time.plusHours(hours), this._offset);\n  };\n\n  _proto.plusMinutes = function plusMinutes(minutes) {\n    return this._withLocalTimeOffset(this._time.plusMinutes(minutes), this._offset);\n  };\n\n  _proto.plusSeconds = function plusSeconds(seconds) {\n    return this._withLocalTimeOffset(this._time.plusSeconds(seconds), this._offset);\n  };\n\n  _proto.plusNanos = function plusNanos(nanos) {\n    return this._withLocalTimeOffset(this._time.plusNanos(nanos), this._offset);\n  };\n\n  _proto.query = function query(_query) {\n    requireNonNull(_query, 'query');\n\n    if (_query === TemporalQueries.precision()) {\n      return ChronoUnit.NANOS;\n    } else if (_query === TemporalQueries.offset() || _query === TemporalQueries.zone()) {\n      return this.offset();\n    } else if (_query === TemporalQueries.localTime()) {\n      return this._time;\n    } else if (_query === TemporalQueries.chronology() || _query === TemporalQueries.localDate() || _query === TemporalQueries.zoneId()) {\n      return null;\n    }\n\n    return _DefaultInterfaceTemp.prototype.query.call(this, _query);\n  };\n\n  _proto.range = function range(field) {\n    if (field instanceof ChronoField) {\n      if (field === ChronoField.OFFSET_SECONDS) {\n        return field.range();\n      }\n\n      return this._time.range(field);\n    }\n\n    return field.rangeRefinedBy(this);\n  };\n\n  _proto.toLocalTime = function toLocalTime() {\n    return this._time;\n  };\n\n  _proto.truncatedTo = function truncatedTo(unit) {\n    return this._withLocalTimeOffset(this._time.truncatedTo(unit), this._offset);\n  };\n\n  _proto.until = function until(endExclusive, unit) {\n    requireNonNull(endExclusive, 'endExclusive');\n    requireNonNull(unit, 'unit');\n    var end = OffsetTime.from(endExclusive);\n\n    if (unit instanceof ChronoUnit) {\n      var nanosUntil = end._toEpochNano() - this._toEpochNano();\n\n      switch (unit) {\n        case ChronoUnit.NANOS:\n          return nanosUntil;\n\n        case ChronoUnit.MICROS:\n          return Math.floor(nanosUntil / 1000);\n\n        case ChronoUnit.MILLIS:\n          return Math.floor(nanosUntil / 1000000);\n\n        case ChronoUnit.SECONDS:\n          return Math.floor(nanosUntil / LocalTime.NANOS_PER_SECOND);\n\n        case ChronoUnit.MINUTES:\n          return Math.floor(nanosUntil / LocalTime.NANOS_PER_MINUTE);\n\n        case ChronoUnit.HOURS:\n          return Math.floor(nanosUntil / LocalTime.NANOS_PER_HOUR);\n\n        case ChronoUnit.HALF_DAYS:\n          return Math.floor(nanosUntil / (12 * LocalTime.NANOS_PER_HOUR));\n      }\n\n      throw new UnsupportedTemporalTypeException('Unsupported unit: ' + unit);\n    }\n\n    return unit.between(this, end);\n  };\n\n  _proto.withHour = function withHour(hour) {\n    return this._withLocalTimeOffset(this._time.withHour(hour), this._offset);\n  };\n\n  _proto.withMinute = function withMinute(minute) {\n    return this._withLocalTimeOffset(this._time.withMinute(minute), this._offset);\n  };\n\n  _proto.withSecond = function withSecond(second) {\n    return this._withLocalTimeOffset(this._time.withSecond(second), this._offset);\n  };\n\n  _proto.withNano = function withNano(nano) {\n    return this._withLocalTimeOffset(this._time.withNano(nano), this._offset);\n  };\n\n  _proto.withOffsetSameInstant = function withOffsetSameInstant(offset) {\n    requireNonNull(offset, 'offset');\n\n    if (offset.equals(this._offset)) {\n      return this;\n    }\n\n    var difference = offset.totalSeconds() - this._offset.totalSeconds();\n\n    var adjusted = this._time.plusSeconds(difference);\n\n    return new OffsetTime(adjusted, offset);\n  };\n\n  _proto.withOffsetSameLocal = function withOffsetSameLocal(offset) {\n    return offset != null && offset.equals(this._offset) ? this : new OffsetTime(this._time, offset);\n  };\n\n  _proto._toEpochNano = function _toEpochNano() {\n    var nod = this._time.toNanoOfDay();\n\n    var offsetNanos = this._offset.totalSeconds() * LocalTime.NANOS_PER_SECOND;\n    return nod - offsetNanos;\n  };\n\n  _proto.withAdjuster = function withAdjuster(adjuster) {\n    requireNonNull(adjuster, 'adjuster');\n\n    if (adjuster instanceof LocalTime) {\n      return this._withLocalTimeOffset(adjuster, this._offset);\n    } else if (adjuster instanceof ZoneOffset) {\n      return this._withLocalTimeOffset(this._time, adjuster);\n    } else if (adjuster instanceof OffsetTime) {\n      return adjuster;\n    }\n\n    return adjuster.adjustInto(this);\n  };\n\n  _proto.withFieldValue = function withFieldValue(field, newValue) {\n    requireNonNull(field, 'field');\n\n    if (field instanceof ChronoField) {\n      if (field === ChronoField.OFFSET_SECONDS) {\n        return this._withLocalTimeOffset(this._time, ZoneOffset.ofTotalSeconds(field.checkValidIntValue(newValue)));\n      }\n\n      return this._withLocalTimeOffset(this._time.with(field, newValue), this._offset);\n    }\n\n    return field.adjustInto(this, newValue);\n  };\n\n  _proto._withLocalTimeOffset = function _withLocalTimeOffset(time, offset) {\n    if (this._time === time && this._offset.equals(offset)) {\n      return this;\n    }\n\n    return new OffsetTime(time, offset);\n  };\n\n  _proto.compareTo = function compareTo(other) {\n    requireNonNull(other, 'other');\n    requireInstance(other, OffsetTime, 'other');\n\n    if (this._offset.equals(other._offset)) {\n      return this._time.compareTo(other._time);\n    }\n\n    var compare = MathUtil.compareNumbers(this._toEpochNano(), other._toEpochNano());\n\n    if (compare === 0) {\n      return this._time.compareTo(other._time);\n    }\n\n    return compare;\n  };\n\n  _proto.equals = function equals(other) {\n    if (this === other) {\n      return true;\n    }\n\n    if (other instanceof OffsetTime) {\n      return this._time.equals(other._time) && this._offset.equals(other._offset);\n    }\n\n    return false;\n  };\n\n  _proto.hashCode = function hashCode() {\n    return this._time.hashCode() ^ this._offset.hashCode();\n  };\n\n  _proto.toString = function toString() {\n    return this._time.toString() + this._offset.toString();\n  };\n\n  _proto.toJSON = function toJSON() {\n    return this.toString();\n  };\n\n  return OffsetTime;\n}(DefaultInterfaceTemporal);\nfunction _init$f() {\n  OffsetTime.MIN = OffsetTime.ofNumbers(0, 0, 0, 0, ZoneOffset.MAX);\n  OffsetTime.MAX = OffsetTime.ofNumbers(23, 59, 59, 999999999, ZoneOffset.MIN);\n  OffsetTime.FROM = createTemporalQuery('OffsetTime.FROM', function (temporal) {\n    return OffsetTime.from(temporal);\n  });\n}\n\nvar ChronoZonedDateTime = function (_DefaultInterfaceTemp) {\n  _inheritsLoose(ChronoZonedDateTime, _DefaultInterfaceTemp);\n\n  function ChronoZonedDateTime() {\n    return _DefaultInterfaceTemp.apply(this, arguments) || this;\n  }\n\n  var _proto = ChronoZonedDateTime.prototype;\n\n  _proto.query = function query(_query) {\n    if (_query === TemporalQueries.zoneId() || _query === TemporalQueries.zone()) {\n      return this.zone();\n    } else if (_query === TemporalQueries.chronology()) {\n      return this.toLocalDate().chronology();\n    } else if (_query === TemporalQueries.precision()) {\n      return ChronoUnit.NANOS;\n    } else if (_query === TemporalQueries.offset()) {\n      return this.offset();\n    } else if (_query === TemporalQueries.localDate()) {\n      return LocalDate.ofEpochDay(this.toLocalDate().toEpochDay());\n    } else if (_query === TemporalQueries.localTime()) {\n      return this.toLocalTime();\n    }\n\n    return _DefaultInterfaceTemp.prototype.query.call(this, _query);\n  };\n\n  _proto.format = function format(formatter) {\n    requireNonNull(formatter, 'formatter');\n    return formatter.format(this);\n  };\n\n  _proto.toInstant = function toInstant() {\n    return Instant.ofEpochSecond(this.toEpochSecond(), this.toLocalTime().nano());\n  };\n\n  _proto.toEpochSecond = function toEpochSecond() {\n    var epochDay = this.toLocalDate().toEpochDay();\n    var secs = epochDay * 86400 + this.toLocalTime().toSecondOfDay();\n    secs -= this.offset().totalSeconds();\n    return secs;\n  };\n\n  _proto.compareTo = function compareTo(other) {\n    requireNonNull(other, 'other');\n    var cmp = MathUtil.compareNumbers(this.toEpochSecond(), other.toEpochSecond());\n\n    if (cmp === 0) {\n      cmp = this.toLocalTime().nano() - other.toLocalTime().nano();\n\n      if (cmp === 0) {\n        cmp = this.toLocalDateTime().compareTo(other.toLocalDateTime());\n\n        if (cmp === 0) {\n          cmp = strcmp(this.zone().id(), other.zone().id());\n        }\n      }\n    }\n\n    return cmp;\n  };\n\n  _proto.isAfter = function isAfter(other) {\n    requireNonNull(other, 'other');\n    var thisEpochSec = this.toEpochSecond();\n    var otherEpochSec = other.toEpochSecond();\n    return thisEpochSec > otherEpochSec || thisEpochSec === otherEpochSec && this.toLocalTime().nano() > other.toLocalTime().nano();\n  };\n\n  _proto.isBefore = function isBefore(other) {\n    requireNonNull(other, 'other');\n    var thisEpochSec = this.toEpochSecond();\n    var otherEpochSec = other.toEpochSecond();\n    return thisEpochSec < otherEpochSec || thisEpochSec === otherEpochSec && this.toLocalTime().nano() < other.toLocalTime().nano();\n  };\n\n  _proto.isEqual = function isEqual(other) {\n    requireNonNull(other, 'other');\n    return this.toEpochSecond() === other.toEpochSecond() && this.toLocalTime().nano() === other.toLocalTime().nano();\n  };\n\n  _proto.equals = function equals(other) {\n    if (this === other) {\n      return true;\n    }\n\n    if (other instanceof ChronoZonedDateTime) {\n      return this.compareTo(other) === 0;\n    }\n\n    return false;\n  };\n\n  return ChronoZonedDateTime;\n}(DefaultInterfaceTemporal);\n\nfunction strcmp(a, b) {\n  if (a < b) {\n    return -1;\n  }\n\n  if (a > b) {\n    return 1;\n  }\n\n  return 0;\n}\n\nvar ZonedDateTime = function (_ChronoZonedDateTime) {\n  _inheritsLoose(ZonedDateTime, _ChronoZonedDateTime);\n\n  ZonedDateTime.now = function now(clockOrZone) {\n    var clock;\n\n    if (clockOrZone instanceof ZoneId) {\n      clock = Clock.system(clockOrZone);\n    } else {\n      clock = clockOrZone == null ? Clock.systemDefaultZone() : clockOrZone;\n    }\n\n    return ZonedDateTime.ofInstant(clock.instant(), clock.zone());\n  };\n\n  ZonedDateTime.of = function of() {\n    if (arguments.length <= 2) {\n      return ZonedDateTime.of2.apply(this, arguments);\n    } else if (arguments.length === 3 && arguments[0] instanceof LocalDate) {\n      return ZonedDateTime.of3.apply(this, arguments);\n    } else {\n      return ZonedDateTime.of8.apply(this, arguments);\n    }\n  };\n\n  ZonedDateTime.of3 = function of3(date, time, zone) {\n    return ZonedDateTime.of2(LocalDateTime.of(date, time), zone);\n  };\n\n  ZonedDateTime.of2 = function of2(localDateTime, zone) {\n    return ZonedDateTime.ofLocal(localDateTime, zone, null);\n  };\n\n  ZonedDateTime.of8 = function of8(year, month, dayOfMonth, hour, minute, second, nanoOfSecond, zone) {\n    var dt = LocalDateTime.of(year, month, dayOfMonth, hour, minute, second, nanoOfSecond);\n    return ZonedDateTime.ofLocal(dt, zone, null);\n  };\n\n  ZonedDateTime.ofLocal = function ofLocal(localDateTime, zone, preferredOffset) {\n    requireNonNull(localDateTime, 'localDateTime');\n    requireNonNull(zone, 'zone');\n\n    if (zone instanceof ZoneOffset) {\n      return new ZonedDateTime(localDateTime, zone, zone);\n    }\n\n    var offset = null;\n    var rules = zone.rules();\n    var validOffsets = rules.validOffsets(localDateTime);\n\n    if (validOffsets.length === 1) {\n      offset = validOffsets[0];\n    } else if (validOffsets.length === 0) {\n      var trans = rules.transition(localDateTime);\n      localDateTime = localDateTime.plusSeconds(trans.duration().seconds());\n      offset = trans.offsetAfter();\n    } else {\n      if (preferredOffset != null && validOffsets.some(function (validOffset) {\n        return validOffset.equals(preferredOffset);\n      })) {\n        offset = preferredOffset;\n      } else {\n        offset = requireNonNull(validOffsets[0], 'offset');\n      }\n    }\n\n    return new ZonedDateTime(localDateTime, offset, zone);\n  };\n\n  ZonedDateTime.ofInstant = function ofInstant() {\n    if (arguments.length === 2) {\n      return ZonedDateTime.ofInstant2.apply(this, arguments);\n    } else {\n      return ZonedDateTime.ofInstant3.apply(this, arguments);\n    }\n  };\n\n  ZonedDateTime.ofInstant2 = function ofInstant2(instant, zone) {\n    requireNonNull(instant, 'instant');\n    requireNonNull(zone, 'zone');\n    return ZonedDateTime._create(instant.epochSecond(), instant.nano(), zone);\n  };\n\n  ZonedDateTime.ofInstant3 = function ofInstant3(localDateTime, offset, zone) {\n    requireNonNull(localDateTime, 'localDateTime');\n    requireNonNull(offset, 'offset');\n    requireNonNull(zone, 'zone');\n    return ZonedDateTime._create(localDateTime.toEpochSecond(offset), localDateTime.nano(), zone);\n  };\n\n  ZonedDateTime._create = function _create(epochSecond, nanoOfSecond, zone) {\n    var rules = zone.rules();\n    var instant = Instant.ofEpochSecond(epochSecond, nanoOfSecond);\n    var offset = rules.offset(instant);\n    var ldt = LocalDateTime.ofEpochSecond(epochSecond, nanoOfSecond, offset);\n    return new ZonedDateTime(ldt, offset, zone);\n  };\n\n  ZonedDateTime.ofStrict = function ofStrict(localDateTime, offset, zone) {\n    requireNonNull(localDateTime, 'localDateTime');\n    requireNonNull(offset, 'offset');\n    requireNonNull(zone, 'zone');\n    var rules = zone.rules();\n\n    if (rules.isValidOffset(localDateTime, offset) === false) {\n      var trans = rules.transition(localDateTime);\n\n      if (trans != null && trans.isGap()) {\n        throw new DateTimeException('LocalDateTime ' + localDateTime + ' does not exist in zone ' + zone + ' due to a gap in the local time-line, typically caused by daylight savings');\n      }\n\n      throw new DateTimeException('ZoneOffset \"' + offset + '\" is not valid for LocalDateTime \"' + localDateTime + '\" in zone \"' + zone + '\"');\n    }\n\n    return new ZonedDateTime(localDateTime, offset, zone);\n  };\n\n  ZonedDateTime.ofLenient = function ofLenient(localDateTime, offset, zone) {\n    requireNonNull(localDateTime, 'localDateTime');\n    requireNonNull(offset, 'offset');\n    requireNonNull(zone, 'zone');\n\n    if (zone instanceof ZoneOffset && offset.equals(zone) === false) {\n      throw new IllegalArgumentException('ZoneId must match ZoneOffset');\n    }\n\n    return new ZonedDateTime(localDateTime, offset, zone);\n  };\n\n  ZonedDateTime.from = function from(temporal) {\n    requireNonNull(temporal, 'temporal');\n\n    if (temporal instanceof ZonedDateTime) {\n      return temporal;\n    }\n\n    var zone = ZoneId.from(temporal);\n\n    if (temporal.isSupported(ChronoField.INSTANT_SECONDS)) {\n      var zdt = ZonedDateTime._from(temporal, zone);\n\n      if (zdt != null) return zdt;\n    }\n\n    var ldt = LocalDateTime.from(temporal);\n    return ZonedDateTime.of2(ldt, zone);\n  };\n\n  ZonedDateTime._from = function _from(temporal, zone) {\n    try {\n      return ZonedDateTime.__from(temporal, zone);\n    } catch (ex) {\n      if (!(ex instanceof DateTimeException)) throw ex;\n    }\n  };\n\n  ZonedDateTime.__from = function __from(temporal, zone) {\n    var epochSecond = temporal.getLong(ChronoField.INSTANT_SECONDS);\n    var nanoOfSecond = temporal.get(ChronoField.NANO_OF_SECOND);\n    return ZonedDateTime._create(epochSecond, nanoOfSecond, zone);\n  };\n\n  ZonedDateTime.parse = function parse(text, formatter) {\n    if (formatter === void 0) {\n      formatter = DateTimeFormatter.ISO_ZONED_DATE_TIME;\n    }\n\n    requireNonNull(formatter, 'formatter');\n    return formatter.parse(text, ZonedDateTime.FROM);\n  };\n\n  function ZonedDateTime(dateTime, offset, zone) {\n    var _this;\n\n    requireNonNull(dateTime, 'dateTime');\n    requireNonNull(offset, 'offset');\n    requireNonNull(zone, 'zone');\n    _this = _ChronoZonedDateTime.call(this) || this;\n    _this._dateTime = dateTime;\n    _this._offset = offset;\n    _this._zone = zone;\n    return _this;\n  }\n\n  var _proto = ZonedDateTime.prototype;\n\n  _proto._resolveLocal = function _resolveLocal(newDateTime) {\n    requireNonNull(newDateTime, 'newDateTime');\n    return ZonedDateTime.ofLocal(newDateTime, this._zone, this._offset);\n  };\n\n  _proto._resolveInstant = function _resolveInstant(newDateTime) {\n    return ZonedDateTime.ofInstant3(newDateTime, this._offset, this._zone);\n  };\n\n  _proto._resolveOffset = function _resolveOffset(offset) {\n    if (offset.equals(this._offset) === false && this._zone.rules().isValidOffset(this._dateTime, offset)) {\n      return new ZonedDateTime(this._dateTime, offset, this._zone);\n    }\n\n    return this;\n  };\n\n  _proto.isSupported = function isSupported(fieldOrUnit) {\n    if (fieldOrUnit instanceof ChronoField) {\n      return true;\n    } else if (fieldOrUnit instanceof ChronoUnit) {\n      return fieldOrUnit.isDateBased() || fieldOrUnit.isTimeBased();\n    }\n\n    return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);\n  };\n\n  _proto.range = function range(field) {\n    if (field instanceof ChronoField) {\n      if (field === ChronoField.INSTANT_SECONDS || field === ChronoField.OFFSET_SECONDS) {\n        return field.range();\n      }\n\n      return this._dateTime.range(field);\n    }\n\n    return field.rangeRefinedBy(this);\n  };\n\n  _proto.get = function get(field) {\n    return this.getLong(field);\n  };\n\n  _proto.getLong = function getLong(field) {\n    if (field instanceof ChronoField) {\n      switch (field) {\n        case ChronoField.INSTANT_SECONDS:\n          return this.toEpochSecond();\n\n        case ChronoField.OFFSET_SECONDS:\n          return this._offset.totalSeconds();\n      }\n\n      return this._dateTime.getLong(field);\n    }\n\n    requireNonNull(field, 'field');\n    return field.getFrom(this);\n  };\n\n  _proto.offset = function offset() {\n    return this._offset;\n  };\n\n  _proto.withEarlierOffsetAtOverlap = function withEarlierOffsetAtOverlap() {\n    var trans = this._zone.rules().transition(this._dateTime);\n\n    if (trans != null && trans.isOverlap()) {\n      var earlierOffset = trans.offsetBefore();\n\n      if (earlierOffset.equals(this._offset) === false) {\n        return new ZonedDateTime(this._dateTime, earlierOffset, this._zone);\n      }\n    }\n\n    return this;\n  };\n\n  _proto.withLaterOffsetAtOverlap = function withLaterOffsetAtOverlap() {\n    var trans = this._zone.rules().transition(this.toLocalDateTime());\n\n    if (trans != null) {\n      var laterOffset = trans.offsetAfter();\n\n      if (laterOffset.equals(this._offset) === false) {\n        return new ZonedDateTime(this._dateTime, laterOffset, this._zone);\n      }\n    }\n\n    return this;\n  };\n\n  _proto.zone = function zone() {\n    return this._zone;\n  };\n\n  _proto.withZoneSameLocal = function withZoneSameLocal(zone) {\n    requireNonNull(zone, 'zone');\n    return this._zone.equals(zone) ? this : ZonedDateTime.ofLocal(this._dateTime, zone, this._offset);\n  };\n\n  _proto.withZoneSameInstant = function withZoneSameInstant(zone) {\n    requireNonNull(zone, 'zone');\n    return this._zone.equals(zone) ? this : ZonedDateTime._create(this._dateTime.toEpochSecond(this._offset), this._dateTime.nano(), zone);\n  };\n\n  _proto.withFixedOffsetZone = function withFixedOffsetZone() {\n    return this._zone.equals(this._offset) ? this : new ZonedDateTime(this._dateTime, this._offset, this._offset);\n  };\n\n  _proto.year = function year() {\n    return this._dateTime.year();\n  };\n\n  _proto.monthValue = function monthValue() {\n    return this._dateTime.monthValue();\n  };\n\n  _proto.month = function month() {\n    return this._dateTime.month();\n  };\n\n  _proto.dayOfMonth = function dayOfMonth() {\n    return this._dateTime.dayOfMonth();\n  };\n\n  _proto.dayOfYear = function dayOfYear() {\n    return this._dateTime.dayOfYear();\n  };\n\n  _proto.dayOfWeek = function dayOfWeek() {\n    return this._dateTime.dayOfWeek();\n  };\n\n  _proto.hour = function hour() {\n    return this._dateTime.hour();\n  };\n\n  _proto.minute = function minute() {\n    return this._dateTime.minute();\n  };\n\n  _proto.second = function second() {\n    return this._dateTime.second();\n  };\n\n  _proto.nano = function nano() {\n    return this._dateTime.nano();\n  };\n\n  _proto.withAdjuster = function withAdjuster(adjuster) {\n    if (adjuster instanceof LocalDate) {\n      return this._resolveLocal(LocalDateTime.of(adjuster, this._dateTime.toLocalTime()));\n    } else if (adjuster instanceof LocalTime) {\n      return this._resolveLocal(LocalDateTime.of(this._dateTime.toLocalDate(), adjuster));\n    } else if (adjuster instanceof LocalDateTime) {\n      return this._resolveLocal(adjuster);\n    } else if (adjuster instanceof Instant) {\n      var instant = adjuster;\n      return ZonedDateTime._create(instant.epochSecond(), instant.nano(), this._zone);\n    } else if (adjuster instanceof ZoneOffset) {\n      return this._resolveOffset(adjuster);\n    }\n\n    requireNonNull(adjuster, 'adjuster');\n    return adjuster.adjustInto(this);\n  };\n\n  _proto.withFieldValue = function withFieldValue(field, newValue) {\n    if (field instanceof ChronoField) {\n      switch (field) {\n        case ChronoField.INSTANT_SECONDS:\n          return ZonedDateTime._create(newValue, this.nano(), this._zone);\n\n        case ChronoField.OFFSET_SECONDS:\n          {\n            var offset = ZoneOffset.ofTotalSeconds(field.checkValidIntValue(newValue));\n            return this._resolveOffset(offset);\n          }\n      }\n\n      return this._resolveLocal(this._dateTime.with(field, newValue));\n    }\n\n    return field.adjustInto(this, newValue);\n  };\n\n  _proto.withYear = function withYear(year) {\n    return this._resolveLocal(this._dateTime.withYear(year));\n  };\n\n  _proto.withMonth = function withMonth(month) {\n    return this._resolveLocal(this._dateTime.withMonth(month));\n  };\n\n  _proto.withDayOfMonth = function withDayOfMonth(dayOfMonth) {\n    return this._resolveLocal(this._dateTime.withDayOfMonth(dayOfMonth));\n  };\n\n  _proto.withDayOfYear = function withDayOfYear(dayOfYear) {\n    return this._resolveLocal(this._dateTime.withDayOfYear(dayOfYear));\n  };\n\n  _proto.withHour = function withHour(hour) {\n    return this._resolveLocal(this._dateTime.withHour(hour));\n  };\n\n  _proto.withMinute = function withMinute(minute) {\n    return this._resolveLocal(this._dateTime.withMinute(minute));\n  };\n\n  _proto.withSecond = function withSecond(second) {\n    return this._resolveLocal(this._dateTime.withSecond(second));\n  };\n\n  _proto.withNano = function withNano(nanoOfSecond) {\n    return this._resolveLocal(this._dateTime.withNano(nanoOfSecond));\n  };\n\n  _proto.truncatedTo = function truncatedTo(unit) {\n    return this._resolveLocal(this._dateTime.truncatedTo(unit));\n  };\n\n  _proto.plusAmount = function plusAmount(amount) {\n    requireNonNull(amount);\n    return amount.addTo(this);\n  };\n\n  _proto.plusAmountUnit = function plusAmountUnit(amountToAdd, unit) {\n    if (unit instanceof ChronoUnit) {\n      if (unit.isDateBased()) {\n        return this._resolveLocal(this._dateTime.plus(amountToAdd, unit));\n      } else {\n        return this._resolveInstant(this._dateTime.plus(amountToAdd, unit));\n      }\n    }\n\n    requireNonNull(unit, 'unit');\n    return unit.addTo(this, amountToAdd);\n  };\n\n  _proto.plusYears = function plusYears(years) {\n    return this._resolveLocal(this._dateTime.plusYears(years));\n  };\n\n  _proto.plusMonths = function plusMonths(months) {\n    return this._resolveLocal(this._dateTime.plusMonths(months));\n  };\n\n  _proto.plusWeeks = function plusWeeks(weeks) {\n    return this._resolveLocal(this._dateTime.plusWeeks(weeks));\n  };\n\n  _proto.plusDays = function plusDays(days) {\n    return this._resolveLocal(this._dateTime.plusDays(days));\n  };\n\n  _proto.plusHours = function plusHours(hours) {\n    return this._resolveInstant(this._dateTime.plusHours(hours));\n  };\n\n  _proto.plusMinutes = function plusMinutes(minutes) {\n    return this._resolveInstant(this._dateTime.plusMinutes(minutes));\n  };\n\n  _proto.plusSeconds = function plusSeconds(seconds) {\n    return this._resolveInstant(this._dateTime.plusSeconds(seconds));\n  };\n\n  _proto.plusNanos = function plusNanos(nanos) {\n    return this._resolveInstant(this._dateTime.plusNanos(nanos));\n  };\n\n  _proto.minusAmount = function minusAmount(amount) {\n    requireNonNull(amount, 'amount');\n    return amount.subtractFrom(this);\n  };\n\n  _proto.minusAmountUnit = function minusAmountUnit(amountToSubtract, unit) {\n    return this.plusAmountUnit(-1 * amountToSubtract, unit);\n  };\n\n  _proto.minusYears = function minusYears(years) {\n    return this.plusYears(-1 * years);\n  };\n\n  _proto.minusMonths = function minusMonths(months) {\n    return this.plusMonths(-1 * months);\n  };\n\n  _proto.minusWeeks = function minusWeeks(weeks) {\n    return this.plusWeeks(-1 * weeks);\n  };\n\n  _proto.minusDays = function minusDays(days) {\n    return this.plusDays(-1 * days);\n  };\n\n  _proto.minusHours = function minusHours(hours) {\n    return this.plusHours(-1 * hours);\n  };\n\n  _proto.minusMinutes = function minusMinutes(minutes) {\n    return this.plusMinutes(-1 * minutes);\n  };\n\n  _proto.minusSeconds = function minusSeconds(seconds) {\n    return this.plusSeconds(-1 * seconds);\n  };\n\n  _proto.minusNanos = function minusNanos(nanos) {\n    return this.plusNanos(-1 * nanos);\n  };\n\n  _proto.query = function query(_query) {\n    if (_query === TemporalQueries.localDate()) {\n      return this.toLocalDate();\n    }\n\n    requireNonNull(_query, 'query');\n    return _ChronoZonedDateTime.prototype.query.call(this, _query);\n  };\n\n  _proto.until = function until(endExclusive, unit) {\n    var end = ZonedDateTime.from(endExclusive);\n\n    if (unit instanceof ChronoUnit) {\n      end = end.withZoneSameInstant(this._zone);\n\n      if (unit.isDateBased()) {\n        return this._dateTime.until(end._dateTime, unit);\n      } else {\n        var difference = this._offset.totalSeconds() - end._offset.totalSeconds();\n\n        var adjustedEnd = end._dateTime.plusSeconds(difference);\n\n        return this._dateTime.until(adjustedEnd, unit);\n      }\n    }\n\n    return unit.between(this, end);\n  };\n\n  _proto.toLocalDateTime = function toLocalDateTime() {\n    return this._dateTime;\n  };\n\n  _proto.toLocalDate = function toLocalDate() {\n    return this._dateTime.toLocalDate();\n  };\n\n  _proto.toLocalTime = function toLocalTime() {\n    return this._dateTime.toLocalTime();\n  };\n\n  _proto.toOffsetDateTime = function toOffsetDateTime() {\n    return OffsetDateTime.of(this._dateTime, this._offset);\n  };\n\n  _proto.equals = function equals(other) {\n    if (this === other) {\n      return true;\n    }\n\n    if (other instanceof ZonedDateTime) {\n      return this._dateTime.equals(other._dateTime) && this._offset.equals(other._offset) && this._zone.equals(other._zone);\n    }\n\n    return false;\n  };\n\n  _proto.hashCode = function hashCode() {\n    return MathUtil.hashCode(this._dateTime.hashCode(), this._offset.hashCode(), this._zone.hashCode());\n  };\n\n  _proto.toString = function toString() {\n    var str = this._dateTime.toString() + this._offset.toString();\n\n    if (this._offset !== this._zone) {\n      str += '[' + this._zone.toString() + ']';\n    }\n\n    return str;\n  };\n\n  _proto.toJSON = function toJSON() {\n    return this.toString();\n  };\n\n  _proto.format = function format(formatter) {\n    return _ChronoZonedDateTime.prototype.format.call(this, formatter);\n  };\n\n  return ZonedDateTime;\n}(ChronoZonedDateTime);\nfunction _init$g() {\n  ZonedDateTime.FROM = createTemporalQuery('ZonedDateTime.FROM', function (temporal) {\n    return ZonedDateTime.from(temporal);\n  });\n}\n\nvar OffsetDateTime = function (_DefaultInterfaceTemp) {\n  _inheritsLoose(OffsetDateTime, _DefaultInterfaceTemp);\n\n  OffsetDateTime.from = function from(temporal) {\n    requireNonNull(temporal, 'temporal');\n\n    if (temporal instanceof OffsetDateTime) {\n      return temporal;\n    }\n\n    try {\n      var offset = ZoneOffset.from(temporal);\n\n      try {\n        var ldt = LocalDateTime.from(temporal);\n        return OffsetDateTime.of(ldt, offset);\n      } catch (_) {\n        var instant = Instant.from(temporal);\n        return OffsetDateTime.ofInstant(instant, offset);\n      }\n    } catch (ex) {\n      throw new DateTimeException(\"Unable to obtain OffsetDateTime TemporalAccessor: \" + temporal + \", type \" + (temporal.constructor != null ? temporal.constructor.name : ''));\n    }\n  };\n\n  OffsetDateTime.now = function now(clockOrZone) {\n    if (arguments.length === 0) {\n      return OffsetDateTime.now(Clock.systemDefaultZone());\n    } else {\n      requireNonNull(clockOrZone, 'clockOrZone');\n\n      if (clockOrZone instanceof ZoneId) {\n        return OffsetDateTime.now(Clock.system(clockOrZone));\n      } else if (clockOrZone instanceof Clock) {\n        var now = clockOrZone.instant();\n        return OffsetDateTime.ofInstant(now, clockOrZone.zone().rules().offset(now));\n      } else {\n        throw new IllegalArgumentException('clockOrZone must be an instance of ZoneId or Clock');\n      }\n    }\n  };\n\n  OffsetDateTime.of = function of() {\n    if (arguments.length <= 2) {\n      return OffsetDateTime.ofDateTime.apply(this, arguments);\n    } else if (arguments.length === 3) {\n      return OffsetDateTime.ofDateAndTime.apply(this, arguments);\n    } else {\n      return OffsetDateTime.ofNumbers.apply(this, arguments);\n    }\n  };\n\n  OffsetDateTime.ofDateTime = function ofDateTime(dateTime, offset) {\n    return new OffsetDateTime(dateTime, offset);\n  };\n\n  OffsetDateTime.ofDateAndTime = function ofDateAndTime(date, time, offset) {\n    var dt = LocalDateTime.of(date, time);\n    return new OffsetDateTime(dt, offset);\n  };\n\n  OffsetDateTime.ofNumbers = function ofNumbers(year, month, dayOfMonth, hour, minute, second, nanoOfSecond, offset) {\n    if (hour === void 0) {\n      hour = 0;\n    }\n\n    if (minute === void 0) {\n      minute = 0;\n    }\n\n    if (second === void 0) {\n      second = 0;\n    }\n\n    if (nanoOfSecond === void 0) {\n      nanoOfSecond = 0;\n    }\n\n    var dt = LocalDateTime.of(year, month, dayOfMonth, hour, minute, second, nanoOfSecond);\n    return new OffsetDateTime(dt, offset);\n  };\n\n  OffsetDateTime.ofInstant = function ofInstant(instant, zone) {\n    requireNonNull(instant, 'instant');\n    requireNonNull(zone, 'zone');\n    var rules = zone.rules();\n    var offset = rules.offset(instant);\n    var ldt = LocalDateTime.ofEpochSecond(instant.epochSecond(), instant.nano(), offset);\n    return new OffsetDateTime(ldt, offset);\n  };\n\n  OffsetDateTime.parse = function parse(text, formatter) {\n    if (formatter === void 0) {\n      formatter = DateTimeFormatter.ISO_OFFSET_DATE_TIME;\n    }\n\n    requireNonNull(formatter, 'formatter');\n    return formatter.parse(text, OffsetDateTime.FROM);\n  };\n\n  function OffsetDateTime(dateTime, offset) {\n    var _this;\n\n    _this = _DefaultInterfaceTemp.call(this) || this;\n    requireNonNull(dateTime, 'dateTime');\n    requireInstance(dateTime, LocalDateTime, 'dateTime');\n    requireNonNull(offset, 'offset');\n    requireInstance(offset, ZoneOffset, 'offset');\n    _this._dateTime = dateTime;\n    _this._offset = offset;\n    return _this;\n  }\n\n  var _proto = OffsetDateTime.prototype;\n\n  _proto.adjustInto = function adjustInto(temporal) {\n    return temporal.with(ChronoField.EPOCH_DAY, this.toLocalDate().toEpochDay()).with(ChronoField.NANO_OF_DAY, this.toLocalTime().toNanoOfDay()).with(ChronoField.OFFSET_SECONDS, this.offset().totalSeconds());\n  };\n\n  _proto.until = function until(endExclusive, unit) {\n    var end = OffsetDateTime.from(endExclusive);\n\n    if (unit instanceof ChronoUnit) {\n      end = end.withOffsetSameInstant(this._offset);\n      return this._dateTime.until(end._dateTime, unit);\n    }\n\n    return unit.between(this, end);\n  };\n\n  _proto.atZoneSameInstant = function atZoneSameInstant(zone) {\n    return ZonedDateTime.ofInstant(this._dateTime, this._offset, zone);\n  };\n\n  _proto.atZoneSimilarLocal = function atZoneSimilarLocal(zone) {\n    return ZonedDateTime.ofLocal(this._dateTime, zone, this._offset);\n  };\n\n  _proto.query = function query(_query) {\n    requireNonNull(_query, 'query');\n\n    if (_query === TemporalQueries.chronology()) {\n      return IsoChronology.INSTANCE;\n    } else if (_query === TemporalQueries.precision()) {\n      return ChronoUnit.NANOS;\n    } else if (_query === TemporalQueries.offset() || _query === TemporalQueries.zone()) {\n      return this.offset();\n    } else if (_query === TemporalQueries.localDate()) {\n      return this.toLocalDate();\n    } else if (_query === TemporalQueries.localTime()) {\n      return this.toLocalTime();\n    } else if (_query === TemporalQueries.zoneId()) {\n      return null;\n    }\n\n    return _DefaultInterfaceTemp.prototype.query.call(this, _query);\n  };\n\n  _proto.get = function get(field) {\n    if (field instanceof ChronoField) {\n      switch (field) {\n        case ChronoField.INSTANT_SECONDS:\n          throw new DateTimeException('Field too large for an int: ' + field);\n\n        case ChronoField.OFFSET_SECONDS:\n          return this.offset().totalSeconds();\n      }\n\n      return this._dateTime.get(field);\n    }\n\n    return _DefaultInterfaceTemp.prototype.get.call(this, field);\n  };\n\n  _proto.getLong = function getLong(field) {\n    if (field instanceof ChronoField) {\n      switch (field) {\n        case ChronoField.INSTANT_SECONDS:\n          return this.toEpochSecond();\n\n        case ChronoField.OFFSET_SECONDS:\n          return this.offset().totalSeconds();\n      }\n\n      return this._dateTime.getLong(field);\n    }\n\n    return field.getFrom(this);\n  };\n\n  _proto.offset = function offset() {\n    return this._offset;\n  };\n\n  _proto.year = function year() {\n    return this._dateTime.year();\n  };\n\n  _proto.monthValue = function monthValue() {\n    return this._dateTime.monthValue();\n  };\n\n  _proto.month = function month() {\n    return this._dateTime.month();\n  };\n\n  _proto.dayOfMonth = function dayOfMonth() {\n    return this._dateTime.dayOfMonth();\n  };\n\n  _proto.dayOfYear = function dayOfYear() {\n    return this._dateTime.dayOfYear();\n  };\n\n  _proto.dayOfWeek = function dayOfWeek() {\n    return this._dateTime.dayOfWeek();\n  };\n\n  _proto.hour = function hour() {\n    return this._dateTime.hour();\n  };\n\n  _proto.minute = function minute() {\n    return this._dateTime.minute();\n  };\n\n  _proto.second = function second() {\n    return this._dateTime.second();\n  };\n\n  _proto.nano = function nano() {\n    return this._dateTime.nano();\n  };\n\n  _proto.toLocalDateTime = function toLocalDateTime() {\n    return this._dateTime;\n  };\n\n  _proto.toLocalDate = function toLocalDate() {\n    return this._dateTime.toLocalDate();\n  };\n\n  _proto.toLocalTime = function toLocalTime() {\n    return this._dateTime.toLocalTime();\n  };\n\n  _proto.toOffsetTime = function toOffsetTime() {\n    return OffsetTime.of(this._dateTime.toLocalTime(), this._offset);\n  };\n\n  _proto.toZonedDateTime = function toZonedDateTime() {\n    return ZonedDateTime.of(this._dateTime, this._offset);\n  };\n\n  _proto.toInstant = function toInstant() {\n    return this._dateTime.toInstant(this._offset);\n  };\n\n  _proto.toEpochSecond = function toEpochSecond() {\n    return this._dateTime.toEpochSecond(this._offset);\n  };\n\n  _proto.isSupported = function isSupported(fieldOrUnit) {\n    if (fieldOrUnit instanceof ChronoField) {\n      return fieldOrUnit.isDateBased() || fieldOrUnit.isTimeBased();\n    }\n\n    if (fieldOrUnit instanceof ChronoUnit) {\n      return fieldOrUnit.isDateBased() || fieldOrUnit.isTimeBased();\n    }\n\n    return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);\n  };\n\n  _proto.range = function range(field) {\n    if (field instanceof ChronoField) {\n      if (field === ChronoField.INSTANT_SECONDS || field === ChronoField.OFFSET_SECONDS) {\n        return field.range();\n      }\n\n      return this._dateTime.range(field);\n    }\n\n    return field.rangeRefinedBy(this);\n  };\n\n  _proto.withAdjuster = function withAdjuster(adjuster) {\n    requireNonNull(adjuster);\n\n    if (adjuster instanceof LocalDate || adjuster instanceof LocalTime || adjuster instanceof LocalDateTime) {\n      return this._withDateTimeOffset(this._dateTime.with(adjuster), this._offset);\n    } else if (adjuster instanceof Instant) {\n      return OffsetDateTime.ofInstant(adjuster, this._offset);\n    } else if (adjuster instanceof ZoneOffset) {\n      return this._withDateTimeOffset(this._dateTime, adjuster);\n    } else if (adjuster instanceof OffsetDateTime) {\n      return adjuster;\n    }\n\n    return adjuster.adjustInto(this);\n  };\n\n  _proto.withFieldValue = function withFieldValue(field, newValue) {\n    requireNonNull(field);\n\n    if (field instanceof ChronoField) {\n      var f = field;\n\n      switch (f) {\n        case ChronoField.INSTANT_SECONDS:\n          return OffsetDateTime.ofInstant(Instant.ofEpochSecond(newValue, this.nano()), this._offset);\n\n        case ChronoField.OFFSET_SECONDS:\n          {\n            return this._withDateTimeOffset(this._dateTime, ZoneOffset.ofTotalSeconds(f.checkValidIntValue(newValue)));\n          }\n      }\n\n      return this._withDateTimeOffset(this._dateTime.with(field, newValue), this._offset);\n    }\n\n    return field.adjustInto(this, newValue);\n  };\n\n  _proto._withDateTimeOffset = function _withDateTimeOffset(dateTime, offset) {\n    if (this._dateTime === dateTime && this._offset.equals(offset)) {\n      return this;\n    }\n\n    return new OffsetDateTime(dateTime, offset);\n  };\n\n  _proto.withYear = function withYear(year) {\n    return this._withDateTimeOffset(this._dateTime.withYear(year), this._offset);\n  };\n\n  _proto.withMonth = function withMonth(month) {\n    return this._withDateTimeOffset(this._dateTime.withMonth(month), this._offset);\n  };\n\n  _proto.withDayOfMonth = function withDayOfMonth(dayOfMonth) {\n    return this._withDateTimeOffset(this._dateTime.withDayOfMonth(dayOfMonth), this._offset);\n  };\n\n  _proto.withDayOfYear = function withDayOfYear(dayOfYear) {\n    return this._withDateTimeOffset(this._dateTime.withDayOfYear(dayOfYear), this._offset);\n  };\n\n  _proto.withHour = function withHour(hour) {\n    return this._withDateTimeOffset(this._dateTime.withHour(hour), this._offset);\n  };\n\n  _proto.withMinute = function withMinute(minute) {\n    return this._withDateTimeOffset(this._dateTime.withMinute(minute), this._offset);\n  };\n\n  _proto.withSecond = function withSecond(second) {\n    return this._withDateTimeOffset(this._dateTime.withSecond(second), this._offset);\n  };\n\n  _proto.withNano = function withNano(nanoOfSecond) {\n    return this._withDateTimeOffset(this._dateTime.withNano(nanoOfSecond), this._offset);\n  };\n\n  _proto.withOffsetSameLocal = function withOffsetSameLocal(offset) {\n    requireNonNull(offset, 'offset');\n    return this._withDateTimeOffset(this._dateTime, offset);\n  };\n\n  _proto.withOffsetSameInstant = function withOffsetSameInstant(offset) {\n    requireNonNull(offset, 'offset');\n\n    if (offset.equals(this._offset)) {\n      return this;\n    }\n\n    var difference = offset.totalSeconds() - this._offset.totalSeconds();\n\n    var adjusted = this._dateTime.plusSeconds(difference);\n\n    return new OffsetDateTime(adjusted, offset);\n  };\n\n  _proto.truncatedTo = function truncatedTo(unit) {\n    return this._withDateTimeOffset(this._dateTime.truncatedTo(unit), this._offset);\n  };\n\n  _proto.plusAmount = function plusAmount(amount) {\n    requireNonNull(amount, 'amount');\n    return amount.addTo(this);\n  };\n\n  _proto.plusAmountUnit = function plusAmountUnit(amountToAdd, unit) {\n    if (unit instanceof ChronoUnit) {\n      return this._withDateTimeOffset(this._dateTime.plus(amountToAdd, unit), this._offset);\n    }\n\n    return unit.addTo(this, amountToAdd);\n  };\n\n  _proto.plusYears = function plusYears(years) {\n    return this._withDateTimeOffset(this._dateTime.plusYears(years), this._offset);\n  };\n\n  _proto.plusMonths = function plusMonths(months) {\n    return this._withDateTimeOffset(this._dateTime.plusMonths(months), this._offset);\n  };\n\n  _proto.plusWeeks = function plusWeeks(weeks) {\n    return this._withDateTimeOffset(this._dateTime.plusWeeks(weeks), this._offset);\n  };\n\n  _proto.plusDays = function plusDays(days) {\n    return this._withDateTimeOffset(this._dateTime.plusDays(days), this._offset);\n  };\n\n  _proto.plusHours = function plusHours(hours) {\n    return this._withDateTimeOffset(this._dateTime.plusHours(hours), this._offset);\n  };\n\n  _proto.plusMinutes = function plusMinutes(minutes) {\n    return this._withDateTimeOffset(this._dateTime.plusMinutes(minutes), this._offset);\n  };\n\n  _proto.plusSeconds = function plusSeconds(seconds) {\n    return this._withDateTimeOffset(this._dateTime.plusSeconds(seconds), this._offset);\n  };\n\n  _proto.plusNanos = function plusNanos(nanos) {\n    return this._withDateTimeOffset(this._dateTime.plusNanos(nanos), this._offset);\n  };\n\n  _proto.minusAmount = function minusAmount(amount) {\n    requireNonNull(amount);\n    return amount.subtractFrom(this);\n  };\n\n  _proto.minusAmountUnit = function minusAmountUnit(amountToSubtract, unit) {\n    return this.plus(-1 * amountToSubtract, unit);\n  };\n\n  _proto.minusYears = function minusYears(years) {\n    return this._withDateTimeOffset(this._dateTime.minusYears(years), this._offset);\n  };\n\n  _proto.minusMonths = function minusMonths(months) {\n    return this._withDateTimeOffset(this._dateTime.minusMonths(months), this._offset);\n  };\n\n  _proto.minusWeeks = function minusWeeks(weeks) {\n    return this._withDateTimeOffset(this._dateTime.minusWeeks(weeks), this._offset);\n  };\n\n  _proto.minusDays = function minusDays(days) {\n    return this._withDateTimeOffset(this._dateTime.minusDays(days), this._offset);\n  };\n\n  _proto.minusHours = function minusHours(hours) {\n    return this._withDateTimeOffset(this._dateTime.minusHours(hours), this._offset);\n  };\n\n  _proto.minusMinutes = function minusMinutes(minutes) {\n    return this._withDateTimeOffset(this._dateTime.minusMinutes(minutes), this._offset);\n  };\n\n  _proto.minusSeconds = function minusSeconds(seconds) {\n    return this._withDateTimeOffset(this._dateTime.minusSeconds(seconds), this._offset);\n  };\n\n  _proto.minusNanos = function minusNanos(nanos) {\n    return this._withDateTimeOffset(this._dateTime.minusNanos(nanos), this._offset);\n  };\n\n  _proto.compareTo = function compareTo(other) {\n    requireNonNull(other, 'other');\n    requireInstance(other, OffsetDateTime, 'other');\n\n    if (this.offset().equals(other.offset())) {\n      return this.toLocalDateTime().compareTo(other.toLocalDateTime());\n    }\n\n    var cmp = MathUtil.compareNumbers(this.toEpochSecond(), other.toEpochSecond());\n\n    if (cmp === 0) {\n      cmp = this.toLocalTime().nano() - other.toLocalTime().nano();\n\n      if (cmp === 0) {\n        cmp = this.toLocalDateTime().compareTo(other.toLocalDateTime());\n      }\n    }\n\n    return cmp;\n  };\n\n  _proto.isAfter = function isAfter(other) {\n    requireNonNull(other, 'other');\n    var thisEpochSec = this.toEpochSecond();\n    var otherEpochSec = other.toEpochSecond();\n    return thisEpochSec > otherEpochSec || thisEpochSec === otherEpochSec && this.toLocalTime().nano() > other.toLocalTime().nano();\n  };\n\n  _proto.isBefore = function isBefore(other) {\n    requireNonNull(other, 'other');\n    var thisEpochSec = this.toEpochSecond();\n    var otherEpochSec = other.toEpochSecond();\n    return thisEpochSec < otherEpochSec || thisEpochSec === otherEpochSec && this.toLocalTime().nano() < other.toLocalTime().nano();\n  };\n\n  _proto.isEqual = function isEqual(other) {\n    requireNonNull(other, 'other');\n    return this.toEpochSecond() === other.toEpochSecond() && this.toLocalTime().nano() === other.toLocalTime().nano();\n  };\n\n  _proto.equals = function equals(other) {\n    if (this === other) {\n      return true;\n    }\n\n    if (other instanceof OffsetDateTime) {\n      return this._dateTime.equals(other._dateTime) && this._offset.equals(other._offset);\n    }\n\n    return false;\n  };\n\n  _proto.hashCode = function hashCode() {\n    return this._dateTime.hashCode() ^ this._offset.hashCode();\n  };\n\n  _proto.toString = function toString() {\n    return this._dateTime.toString() + this._offset.toString();\n  };\n\n  _proto.toJSON = function toJSON() {\n    return this.toString();\n  };\n\n  _proto.format = function format(formatter) {\n    requireNonNull(formatter, 'formatter');\n    return formatter.format(this);\n  };\n\n  return OffsetDateTime;\n}(DefaultInterfaceTemporal);\nfunction _init$h() {\n  OffsetDateTime.MIN = LocalDateTime.MIN.atOffset(ZoneOffset.MAX);\n  OffsetDateTime.MAX = LocalDateTime.MAX.atOffset(ZoneOffset.MIN);\n  OffsetDateTime.FROM = createTemporalQuery('OffsetDateTime.FROM', function (temporal) {\n    return OffsetDateTime.from(temporal);\n  });\n}\n\nvar DAYS_PER_CYCLE = 146097;\nvar DAYS_0000_TO_1970 = DAYS_PER_CYCLE * 5 - (30 * 365 + 7);\nvar LocalDate = function (_ChronoLocalDate) {\n  _inheritsLoose(LocalDate, _ChronoLocalDate);\n\n  LocalDate.now = function now(clockOrZone) {\n    var clock;\n\n    if (clockOrZone == null) {\n      clock = Clock.systemDefaultZone();\n    } else if (clockOrZone instanceof ZoneId) {\n      clock = Clock.system(clockOrZone);\n    } else {\n      clock = clockOrZone;\n    }\n\n    return LocalDate.ofInstant(clock.instant(), clock.zone());\n  };\n\n  LocalDate.ofInstant = function ofInstant(instant, zone) {\n    if (zone === void 0) {\n      zone = ZoneId.systemDefault();\n    }\n\n    requireNonNull(instant, 'instant');\n    var offset = zone.rules().offset(instant);\n    var epochSec = instant.epochSecond() + offset.totalSeconds();\n    var epochDay = MathUtil.floorDiv(epochSec, LocalTime.SECONDS_PER_DAY);\n    return LocalDate.ofEpochDay(epochDay);\n  };\n\n  LocalDate.of = function of(year, month, dayOfMonth) {\n    return new LocalDate(year, month, dayOfMonth);\n  };\n\n  LocalDate.ofYearDay = function ofYearDay(year, dayOfYear) {\n    ChronoField.YEAR.checkValidValue(year);\n    var leap = IsoChronology.isLeapYear(year);\n\n    if (dayOfYear === 366 && leap === false) {\n      assert(false, 'Invalid date \\'DayOfYear 366\\' as \\'' + year + '\\' is not a leap year', DateTimeException);\n    }\n\n    var moy = Month.of(Math.floor((dayOfYear - 1) / 31 + 1));\n    var monthEnd = moy.firstDayOfYear(leap) + moy.length(leap) - 1;\n\n    if (dayOfYear > monthEnd) {\n      moy = moy.plus(1);\n    }\n\n    var dom = dayOfYear - moy.firstDayOfYear(leap) + 1;\n    return new LocalDate(year, moy.value(), dom);\n  };\n\n  LocalDate.ofEpochDay = function ofEpochDay(epochDay) {\n    if (epochDay === void 0) {\n      epochDay = 0;\n    }\n\n    var adjust, adjustCycles, doyEst, yearEst, zeroDay;\n    zeroDay = epochDay + DAYS_0000_TO_1970;\n    zeroDay -= 60;\n    adjust = 0;\n\n    if (zeroDay < 0) {\n      adjustCycles = MathUtil.intDiv(zeroDay + 1, DAYS_PER_CYCLE) - 1;\n      adjust = adjustCycles * 400;\n      zeroDay += -adjustCycles * DAYS_PER_CYCLE;\n    }\n\n    yearEst = MathUtil.intDiv(400 * zeroDay + 591, DAYS_PER_CYCLE);\n    doyEst = zeroDay - (365 * yearEst + MathUtil.intDiv(yearEst, 4) - MathUtil.intDiv(yearEst, 100) + MathUtil.intDiv(yearEst, 400));\n\n    if (doyEst < 0) {\n      yearEst--;\n      doyEst = zeroDay - (365 * yearEst + MathUtil.intDiv(yearEst, 4) - MathUtil.intDiv(yearEst, 100) + MathUtil.intDiv(yearEst, 400));\n    }\n\n    yearEst += adjust;\n    var marchDoy0 = doyEst;\n    var marchMonth0 = MathUtil.intDiv(marchDoy0 * 5 + 2, 153);\n    var month = (marchMonth0 + 2) % 12 + 1;\n    var dom = marchDoy0 - MathUtil.intDiv(marchMonth0 * 306 + 5, 10) + 1;\n    yearEst += MathUtil.intDiv(marchMonth0, 10);\n    var year = yearEst;\n    return new LocalDate(year, month, dom);\n  };\n\n  LocalDate.from = function from(temporal) {\n    requireNonNull(temporal, 'temporal');\n    var date = temporal.query(TemporalQueries.localDate());\n\n    if (date == null) {\n      throw new DateTimeException(\"Unable to obtain LocalDate from TemporalAccessor: \" + temporal + \", type \" + (temporal.constructor != null ? temporal.constructor.name : ''));\n    }\n\n    return date;\n  };\n\n  LocalDate.parse = function parse(text, formatter) {\n    if (formatter === void 0) {\n      formatter = DateTimeFormatter.ISO_LOCAL_DATE;\n    }\n\n    assert(formatter != null, 'formatter', NullPointerException);\n    return formatter.parse(text, LocalDate.FROM);\n  };\n\n  LocalDate._resolvePreviousValid = function _resolvePreviousValid(year, month, day) {\n    switch (month) {\n      case 2:\n        day = Math.min(day, IsoChronology.isLeapYear(year) ? 29 : 28);\n        break;\n\n      case 4:\n      case 6:\n      case 9:\n      case 11:\n        day = Math.min(day, 30);\n        break;\n    }\n\n    return LocalDate.of(year, month, day);\n  };\n\n  function LocalDate(year, month, dayOfMonth) {\n    var _this;\n\n    _this = _ChronoLocalDate.call(this) || this;\n    requireNonNull(year, 'year');\n    requireNonNull(month, 'month');\n    requireNonNull(dayOfMonth, 'dayOfMonth');\n\n    if (month instanceof Month) {\n      month = month.value();\n    }\n\n    _this._year = MathUtil.safeToInt(year);\n    _this._month = MathUtil.safeToInt(month);\n    _this._day = MathUtil.safeToInt(dayOfMonth);\n\n    LocalDate._validate(_this._year, _this._month, _this._day);\n\n    return _this;\n  }\n\n  LocalDate._validate = function _validate(year, month, dayOfMonth) {\n    var dom;\n    ChronoField.YEAR.checkValidValue(year);\n    ChronoField.MONTH_OF_YEAR.checkValidValue(month);\n    ChronoField.DAY_OF_MONTH.checkValidValue(dayOfMonth);\n\n    if (dayOfMonth > 28) {\n      dom = 31;\n\n      switch (month) {\n        case 2:\n          dom = IsoChronology.isLeapYear(year) ? 29 : 28;\n          break;\n\n        case 4:\n        case 6:\n        case 9:\n        case 11:\n          dom = 30;\n      }\n\n      if (dayOfMonth > dom) {\n        if (dayOfMonth === 29) {\n          assert(false, 'Invalid date \\'February 29\\' as \\'' + year + '\\' is not a leap year', DateTimeException);\n        } else {\n          assert(false, 'Invalid date \\'' + year + '\\' \\'' + month + '\\' \\'' + dayOfMonth + '\\'', DateTimeException);\n        }\n      }\n    }\n  };\n\n  var _proto = LocalDate.prototype;\n\n  _proto.isSupported = function isSupported(field) {\n    return _ChronoLocalDate.prototype.isSupported.call(this, field);\n  };\n\n  _proto.range = function range(field) {\n    if (field instanceof ChronoField) {\n      if (field.isDateBased()) {\n        switch (field) {\n          case ChronoField.DAY_OF_MONTH:\n            return ValueRange.of(1, this.lengthOfMonth());\n\n          case ChronoField.DAY_OF_YEAR:\n            return ValueRange.of(1, this.lengthOfYear());\n\n          case ChronoField.ALIGNED_WEEK_OF_MONTH:\n            return ValueRange.of(1, this.month() === Month.FEBRUARY && this.isLeapYear() === false ? 4 : 5);\n\n          case ChronoField.YEAR_OF_ERA:\n            return this._year <= 0 ? ValueRange.of(1, Year.MAX_VALUE + 1) : ValueRange.of(1, Year.MAX_VALUE);\n        }\n\n        return field.range();\n      }\n\n      throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);\n    }\n\n    return field.rangeRefinedBy(this);\n  };\n\n  _proto.get = function get(field) {\n    return this.getLong(field);\n  };\n\n  _proto.getLong = function getLong(field) {\n    assert(field != null, '', NullPointerException);\n\n    if (field instanceof ChronoField) {\n      return this._get0(field);\n    }\n\n    return field.getFrom(this);\n  };\n\n  _proto._get0 = function _get0(field) {\n    switch (field) {\n      case ChronoField.DAY_OF_WEEK:\n        return this.dayOfWeek().value();\n\n      case ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH:\n        return MathUtil.intMod(this._day - 1, 7) + 1;\n\n      case ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR:\n        return MathUtil.intMod(this.dayOfYear() - 1, 7) + 1;\n\n      case ChronoField.DAY_OF_MONTH:\n        return this._day;\n\n      case ChronoField.DAY_OF_YEAR:\n        return this.dayOfYear();\n\n      case ChronoField.EPOCH_DAY:\n        return this.toEpochDay();\n\n      case ChronoField.ALIGNED_WEEK_OF_MONTH:\n        return MathUtil.intDiv(this._day - 1, 7) + 1;\n\n      case ChronoField.ALIGNED_WEEK_OF_YEAR:\n        return MathUtil.intDiv(this.dayOfYear() - 1, 7) + 1;\n\n      case ChronoField.MONTH_OF_YEAR:\n        return this._month;\n\n      case ChronoField.PROLEPTIC_MONTH:\n        return this._prolepticMonth();\n\n      case ChronoField.YEAR_OF_ERA:\n        return this._year >= 1 ? this._year : 1 - this._year;\n\n      case ChronoField.YEAR:\n        return this._year;\n\n      case ChronoField.ERA:\n        return this._year >= 1 ? 1 : 0;\n    }\n\n    throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);\n  };\n\n  _proto._prolepticMonth = function _prolepticMonth() {\n    return this._year * 12 + (this._month - 1);\n  };\n\n  _proto.chronology = function chronology() {\n    return IsoChronology.INSTANCE;\n  };\n\n  _proto.year = function year() {\n    return this._year;\n  };\n\n  _proto.monthValue = function monthValue() {\n    return this._month;\n  };\n\n  _proto.month = function month() {\n    return Month.of(this._month);\n  };\n\n  _proto.dayOfMonth = function dayOfMonth() {\n    return this._day;\n  };\n\n  _proto.dayOfYear = function dayOfYear() {\n    return this.month().firstDayOfYear(this.isLeapYear()) + this._day - 1;\n  };\n\n  _proto.dayOfWeek = function dayOfWeek() {\n    var dow0 = MathUtil.floorMod(this.toEpochDay() + 3, 7);\n    return DayOfWeek.of(dow0 + 1);\n  };\n\n  _proto.isLeapYear = function isLeapYear() {\n    return IsoChronology.isLeapYear(this._year);\n  };\n\n  _proto.lengthOfMonth = function lengthOfMonth() {\n    switch (this._month) {\n      case 2:\n        return this.isLeapYear() ? 29 : 28;\n\n      case 4:\n      case 6:\n      case 9:\n      case 11:\n        return 30;\n\n      default:\n        return 31;\n    }\n  };\n\n  _proto.lengthOfYear = function lengthOfYear() {\n    return this.isLeapYear() ? 366 : 365;\n  };\n\n  _proto.withAdjuster = function withAdjuster(adjuster) {\n    requireNonNull(adjuster, 'adjuster');\n\n    if (adjuster instanceof LocalDate) {\n      return adjuster;\n    }\n\n    assert(typeof adjuster.adjustInto === 'function', 'adjuster', IllegalArgumentException);\n    return adjuster.adjustInto(this);\n  };\n\n  _proto.withFieldValue = function withFieldValue(field, newValue) {\n    assert(field != null, 'field', NullPointerException);\n\n    if (field instanceof ChronoField) {\n      var f = field;\n      f.checkValidValue(newValue);\n\n      switch (f) {\n        case ChronoField.DAY_OF_WEEK:\n          return this.plusDays(newValue - this.dayOfWeek().value());\n\n        case ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH:\n          return this.plusDays(newValue - this.getLong(ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH));\n\n        case ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR:\n          return this.plusDays(newValue - this.getLong(ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR));\n\n        case ChronoField.DAY_OF_MONTH:\n          return this.withDayOfMonth(newValue);\n\n        case ChronoField.DAY_OF_YEAR:\n          return this.withDayOfYear(newValue);\n\n        case ChronoField.EPOCH_DAY:\n          return LocalDate.ofEpochDay(newValue);\n\n        case ChronoField.ALIGNED_WEEK_OF_MONTH:\n          return this.plusWeeks(newValue - this.getLong(ChronoField.ALIGNED_WEEK_OF_MONTH));\n\n        case ChronoField.ALIGNED_WEEK_OF_YEAR:\n          return this.plusWeeks(newValue - this.getLong(ChronoField.ALIGNED_WEEK_OF_YEAR));\n\n        case ChronoField.MONTH_OF_YEAR:\n          return this.withMonth(newValue);\n\n        case ChronoField.PROLEPTIC_MONTH:\n          return this.plusMonths(newValue - this.getLong(ChronoField.PROLEPTIC_MONTH));\n\n        case ChronoField.YEAR_OF_ERA:\n          return this.withYear(this._year >= 1 ? newValue : 1 - newValue);\n\n        case ChronoField.YEAR:\n          return this.withYear(newValue);\n\n        case ChronoField.ERA:\n          return this.getLong(ChronoField.ERA) === newValue ? this : this.withYear(1 - this._year);\n      }\n\n      throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);\n    }\n\n    return field.adjustInto(this, newValue);\n  };\n\n  _proto.withYear = function withYear(year) {\n    if (this._year === year) {\n      return this;\n    }\n\n    ChronoField.YEAR.checkValidValue(year);\n    return LocalDate._resolvePreviousValid(year, this._month, this._day);\n  };\n\n  _proto.withMonth = function withMonth(month) {\n    var m = month instanceof Month ? month.value() : month;\n\n    if (this._month === m) {\n      return this;\n    }\n\n    ChronoField.MONTH_OF_YEAR.checkValidValue(m);\n    return LocalDate._resolvePreviousValid(this._year, m, this._day);\n  };\n\n  _proto.withDayOfMonth = function withDayOfMonth(dayOfMonth) {\n    if (this._day === dayOfMonth) {\n      return this;\n    }\n\n    return LocalDate.of(this._year, this._month, dayOfMonth);\n  };\n\n  _proto.withDayOfYear = function withDayOfYear(dayOfYear) {\n    if (this.dayOfYear() === dayOfYear) {\n      return this;\n    }\n\n    return LocalDate.ofYearDay(this._year, dayOfYear);\n  };\n\n  _proto.plusAmount = function plusAmount(amount) {\n    requireNonNull(amount, 'amount');\n    return amount.addTo(this);\n  };\n\n  _proto.plusAmountUnit = function plusAmountUnit(amountToAdd, unit) {\n    requireNonNull(amountToAdd, 'amountToAdd');\n    requireNonNull(unit, 'unit');\n\n    if (unit instanceof ChronoUnit) {\n      switch (unit) {\n        case ChronoUnit.DAYS:\n          return this.plusDays(amountToAdd);\n\n        case ChronoUnit.WEEKS:\n          return this.plusWeeks(amountToAdd);\n\n        case ChronoUnit.MONTHS:\n          return this.plusMonths(amountToAdd);\n\n        case ChronoUnit.YEARS:\n          return this.plusYears(amountToAdd);\n\n        case ChronoUnit.DECADES:\n          return this.plusYears(MathUtil.safeMultiply(amountToAdd, 10));\n\n        case ChronoUnit.CENTURIES:\n          return this.plusYears(MathUtil.safeMultiply(amountToAdd, 100));\n\n        case ChronoUnit.MILLENNIA:\n          return this.plusYears(MathUtil.safeMultiply(amountToAdd, 1000));\n\n        case ChronoUnit.ERAS:\n          return this.with(ChronoField.ERA, MathUtil.safeAdd(this.getLong(ChronoField.ERA), amountToAdd));\n      }\n\n      throw new UnsupportedTemporalTypeException('Unsupported unit: ' + unit);\n    }\n\n    return unit.addTo(this, amountToAdd);\n  };\n\n  _proto.plusYears = function plusYears(yearsToAdd) {\n    if (yearsToAdd === 0) {\n      return this;\n    }\n\n    var newYear = ChronoField.YEAR.checkValidIntValue(this._year + yearsToAdd);\n    return LocalDate._resolvePreviousValid(newYear, this._month, this._day);\n  };\n\n  _proto.plusMonths = function plusMonths(monthsToAdd) {\n    if (monthsToAdd === 0) {\n      return this;\n    }\n\n    var monthCount = this._year * 12 + (this._month - 1);\n    var calcMonths = monthCount + monthsToAdd;\n    var newYear = ChronoField.YEAR.checkValidIntValue(MathUtil.floorDiv(calcMonths, 12));\n    var newMonth = MathUtil.floorMod(calcMonths, 12) + 1;\n    return LocalDate._resolvePreviousValid(newYear, newMonth, this._day);\n  };\n\n  _proto.plusWeeks = function plusWeeks(weeksToAdd) {\n    return this.plusDays(MathUtil.safeMultiply(weeksToAdd, 7));\n  };\n\n  _proto.plusDays = function plusDays(daysToAdd) {\n    if (daysToAdd === 0) {\n      return this;\n    }\n\n    var mjDay = MathUtil.safeAdd(this.toEpochDay(), daysToAdd);\n    return LocalDate.ofEpochDay(mjDay);\n  };\n\n  _proto.minusAmount = function minusAmount(amount) {\n    requireNonNull(amount, 'amount');\n    return amount.subtractFrom(this);\n  };\n\n  _proto.minusAmountUnit = function minusAmountUnit(amountToSubtract, unit) {\n    requireNonNull(amountToSubtract, 'amountToSubtract');\n    requireNonNull(unit, 'unit');\n    return this.plusAmountUnit(-1 * amountToSubtract, unit);\n  };\n\n  _proto.minusYears = function minusYears(yearsToSubtract) {\n    return this.plusYears(yearsToSubtract * -1);\n  };\n\n  _proto.minusMonths = function minusMonths(monthsToSubtract) {\n    return this.plusMonths(monthsToSubtract * -1);\n  };\n\n  _proto.minusWeeks = function minusWeeks(weeksToSubtract) {\n    return this.plusWeeks(weeksToSubtract * -1);\n  };\n\n  _proto.minusDays = function minusDays(daysToSubtract) {\n    return this.plusDays(daysToSubtract * -1);\n  };\n\n  _proto.query = function query(_query) {\n    requireNonNull(_query, 'query');\n\n    if (_query === TemporalQueries.localDate()) {\n      return this;\n    }\n\n    return _ChronoLocalDate.prototype.query.call(this, _query);\n  };\n\n  _proto.adjustInto = function adjustInto(temporal) {\n    return _ChronoLocalDate.prototype.adjustInto.call(this, temporal);\n  };\n\n  _proto.until = function until(p1, p2) {\n    if (arguments.length < 2) {\n      return this.until1(p1);\n    } else {\n      return this.until2(p1, p2);\n    }\n  };\n\n  _proto.until2 = function until2(endExclusive, unit) {\n    var end = LocalDate.from(endExclusive);\n\n    if (unit instanceof ChronoUnit) {\n      switch (unit) {\n        case ChronoUnit.DAYS:\n          return this.daysUntil(end);\n\n        case ChronoUnit.WEEKS:\n          return MathUtil.intDiv(this.daysUntil(end), 7);\n\n        case ChronoUnit.MONTHS:\n          return this._monthsUntil(end);\n\n        case ChronoUnit.YEARS:\n          return MathUtil.intDiv(this._monthsUntil(end), 12);\n\n        case ChronoUnit.DECADES:\n          return MathUtil.intDiv(this._monthsUntil(end), 120);\n\n        case ChronoUnit.CENTURIES:\n          return MathUtil.intDiv(this._monthsUntil(end), 1200);\n\n        case ChronoUnit.MILLENNIA:\n          return MathUtil.intDiv(this._monthsUntil(end), 12000);\n\n        case ChronoUnit.ERAS:\n          return end.getLong(ChronoField.ERA) - this.getLong(ChronoField.ERA);\n      }\n\n      throw new UnsupportedTemporalTypeException('Unsupported unit: ' + unit);\n    }\n\n    return unit.between(this, end);\n  };\n\n  _proto.daysUntil = function daysUntil(end) {\n    return end.toEpochDay() - this.toEpochDay();\n  };\n\n  _proto._monthsUntil = function _monthsUntil(end) {\n    var packed1 = this._prolepticMonth() * 32 + this.dayOfMonth();\n    var packed2 = end._prolepticMonth() * 32 + end.dayOfMonth();\n    return MathUtil.intDiv(packed2 - packed1, 32);\n  };\n\n  _proto.until1 = function until1(endDate) {\n    var end = LocalDate.from(endDate);\n\n    var totalMonths = end._prolepticMonth() - this._prolepticMonth();\n\n    var days = end._day - this._day;\n\n    if (totalMonths > 0 && days < 0) {\n      totalMonths--;\n      var calcDate = this.plusMonths(totalMonths);\n      days = end.toEpochDay() - calcDate.toEpochDay();\n    } else if (totalMonths < 0 && days > 0) {\n      totalMonths++;\n      days -= end.lengthOfMonth();\n    }\n\n    var years = MathUtil.intDiv(totalMonths, 12);\n    var months = MathUtil.intMod(totalMonths, 12);\n    return Period.of(years, months, days);\n  };\n\n  _proto.atTime = function atTime() {\n    if (arguments.length === 1) {\n      return this.atTime1.apply(this, arguments);\n    } else {\n      return this.atTime4.apply(this, arguments);\n    }\n  };\n\n  _proto.atTime1 = function atTime1(time) {\n    requireNonNull(time, 'time');\n\n    if (time instanceof LocalTime) {\n      return LocalDateTime.of(this, time);\n    } else if (time instanceof OffsetTime) {\n      return this._atTimeOffsetTime(time);\n    } else {\n      throw new IllegalArgumentException('time must be an instance of LocalTime or OffsetTime' + (time && time.constructor && time.constructor.name ? ', but is ' + time.constructor.name : ''));\n    }\n  };\n\n  _proto.atTime4 = function atTime4(hour, minute, second, nanoOfSecond) {\n    if (second === void 0) {\n      second = 0;\n    }\n\n    if (nanoOfSecond === void 0) {\n      nanoOfSecond = 0;\n    }\n\n    return this.atTime1(LocalTime.of(hour, minute, second, nanoOfSecond));\n  };\n\n  _proto._atTimeOffsetTime = function _atTimeOffsetTime(time) {\n    return OffsetDateTime.of(LocalDateTime.of(this, time.toLocalTime()), time.offset());\n  };\n\n  _proto.atStartOfDay = function atStartOfDay(zone) {\n    if (zone != null) {\n      return this.atStartOfDayWithZone(zone);\n    } else {\n      return LocalDateTime.of(this, LocalTime.MIDNIGHT);\n    }\n  };\n\n  _proto.atStartOfDayWithZone = function atStartOfDayWithZone(zone) {\n    requireNonNull(zone, 'zone');\n    var ldt = this.atTime(LocalTime.MIDNIGHT);\n\n    if (zone instanceof ZoneOffset === false) {\n      var trans = zone.rules().transition(ldt);\n\n      if (trans != null && trans.isGap()) {\n        ldt = trans.dateTimeAfter();\n      }\n    }\n\n    return ZonedDateTime.of(ldt, zone);\n  };\n\n  _proto.toEpochDay = function toEpochDay() {\n    var y = this._year;\n    var m = this._month;\n    var total = 0;\n    total += 365 * y;\n\n    if (y >= 0) {\n      total += MathUtil.intDiv(y + 3, 4) - MathUtil.intDiv(y + 99, 100) + MathUtil.intDiv(y + 399, 400);\n    } else {\n      total -= MathUtil.intDiv(y, -4) - MathUtil.intDiv(y, -100) + MathUtil.intDiv(y, -400);\n    }\n\n    total += MathUtil.intDiv(367 * m - 362, 12);\n    total += this.dayOfMonth() - 1;\n\n    if (m > 2) {\n      total--;\n\n      if (!IsoChronology.isLeapYear(y)) {\n        total--;\n      }\n    }\n\n    return total - DAYS_0000_TO_1970;\n  };\n\n  _proto.compareTo = function compareTo(other) {\n    requireNonNull(other, 'other');\n    requireInstance(other, LocalDate, 'other');\n    return this._compareTo0(other);\n  };\n\n  _proto._compareTo0 = function _compareTo0(otherDate) {\n    var cmp = this._year - otherDate._year;\n\n    if (cmp === 0) {\n      cmp = this._month - otherDate._month;\n\n      if (cmp === 0) {\n        cmp = this._day - otherDate._day;\n      }\n    }\n\n    return cmp;\n  };\n\n  _proto.isAfter = function isAfter(other) {\n    return this.compareTo(other) > 0;\n  };\n\n  _proto.isBefore = function isBefore(other) {\n    return this.compareTo(other) < 0;\n  };\n\n  _proto.isEqual = function isEqual(other) {\n    return this.compareTo(other) === 0;\n  };\n\n  _proto.equals = function equals(other) {\n    if (this === other) {\n      return true;\n    }\n\n    if (other instanceof LocalDate) {\n      return this._compareTo0(other) === 0;\n    }\n\n    return false;\n  };\n\n  _proto.hashCode = function hashCode() {\n    var yearValue = this._year;\n    var monthValue = this._month;\n    var dayValue = this._day;\n    return MathUtil.hash(yearValue & 0xFFFFF800 ^ (yearValue << 11) + (monthValue << 6) + dayValue);\n  };\n\n  _proto.toString = function toString() {\n    var dayString, monthString, yearString;\n    var yearValue = this._year;\n    var monthValue = this._month;\n    var dayValue = this._day;\n    var absYear = Math.abs(yearValue);\n\n    if (absYear < 1000) {\n      if (yearValue < 0) {\n        yearString = '-' + ('' + (yearValue - 10000)).slice(-4);\n      } else {\n        yearString = ('' + (yearValue + 10000)).slice(-4);\n      }\n    } else {\n      if (yearValue > 9999) {\n        yearString = '+' + yearValue;\n      } else {\n        yearString = '' + yearValue;\n      }\n    }\n\n    if (monthValue < 10) {\n      monthString = '-0' + monthValue;\n    } else {\n      monthString = '-' + monthValue;\n    }\n\n    if (dayValue < 10) {\n      dayString = '-0' + dayValue;\n    } else {\n      dayString = '-' + dayValue;\n    }\n\n    return yearString + monthString + dayString;\n  };\n\n  _proto.toJSON = function toJSON() {\n    return this.toString();\n  };\n\n  _proto.format = function format(formatter) {\n    requireNonNull(formatter, 'formatter');\n    requireInstance(formatter, DateTimeFormatter, 'formatter');\n    return _ChronoLocalDate.prototype.format.call(this, formatter);\n  };\n\n  return LocalDate;\n}(ChronoLocalDate);\nfunction _init$i() {\n  LocalDate.MIN = LocalDate.of(YearConstants.MIN_VALUE, 1, 1);\n  LocalDate.MAX = LocalDate.of(YearConstants.MAX_VALUE, 12, 31);\n  LocalDate.EPOCH_0 = LocalDate.ofEpochDay(0);\n  LocalDate.FROM = createTemporalQuery('LocalDate.FROM', function (temporal) {\n    return LocalDate.from(temporal);\n  });\n}\n\nvar ChronoLocalDateTime = function (_DefaultInterfaceTemp) {\n  _inheritsLoose(ChronoLocalDateTime, _DefaultInterfaceTemp);\n\n  function ChronoLocalDateTime() {\n    return _DefaultInterfaceTemp.apply(this, arguments) || this;\n  }\n\n  var _proto = ChronoLocalDateTime.prototype;\n\n  _proto.chronology = function chronology() {\n    return this.toLocalDate().chronology();\n  };\n\n  _proto.query = function query(_query) {\n    if (_query === TemporalQueries.chronology()) {\n      return this.chronology();\n    } else if (_query === TemporalQueries.precision()) {\n      return ChronoUnit.NANOS;\n    } else if (_query === TemporalQueries.localDate()) {\n      return LocalDate.ofEpochDay(this.toLocalDate().toEpochDay());\n    } else if (_query === TemporalQueries.localTime()) {\n      return this.toLocalTime();\n    } else if (_query === TemporalQueries.zone() || _query === TemporalQueries.zoneId() || _query === TemporalQueries.offset()) {\n      return null;\n    }\n\n    return _DefaultInterfaceTemp.prototype.query.call(this, _query);\n  };\n\n  _proto.adjustInto = function adjustInto(temporal) {\n    return temporal.with(ChronoField.EPOCH_DAY, this.toLocalDate().toEpochDay()).with(ChronoField.NANO_OF_DAY, this.toLocalTime().toNanoOfDay());\n  };\n\n  _proto.toInstant = function toInstant(offset) {\n    requireInstance(offset, ZoneOffset, 'zoneId');\n    return Instant.ofEpochSecond(this.toEpochSecond(offset), this.toLocalTime().nano());\n  };\n\n  _proto.toEpochSecond = function toEpochSecond(offset) {\n    requireNonNull(offset, 'offset');\n    var epochDay = this.toLocalDate().toEpochDay();\n    var secs = epochDay * 86400 + this.toLocalTime().toSecondOfDay();\n    secs -= offset.totalSeconds();\n    return MathUtil.safeToInt(secs);\n  };\n\n  return ChronoLocalDateTime;\n}(DefaultInterfaceTemporal);\n\nvar LocalDateTime = function (_ChronoLocalDateTime) {\n  _inheritsLoose(LocalDateTime, _ChronoLocalDateTime);\n\n  LocalDateTime.now = function now(clockOrZone) {\n    if (clockOrZone == null) {\n      return LocalDateTime._now(Clock.systemDefaultZone());\n    } else if (clockOrZone instanceof Clock) {\n      return LocalDateTime._now(clockOrZone);\n    } else {\n      return LocalDateTime._now(Clock.system(clockOrZone));\n    }\n  };\n\n  LocalDateTime._now = function _now(clock) {\n    requireNonNull(clock, 'clock');\n    return LocalDateTime.ofInstant(clock.instant(), clock.zone());\n  };\n\n  LocalDateTime._ofEpochMillis = function _ofEpochMillis(epochMilli, offset) {\n    var localSecond = MathUtil.floorDiv(epochMilli, 1000) + offset.totalSeconds();\n    var localEpochDay = MathUtil.floorDiv(localSecond, LocalTime.SECONDS_PER_DAY);\n    var secsOfDay = MathUtil.floorMod(localSecond, LocalTime.SECONDS_PER_DAY);\n    var nanoOfSecond = MathUtil.floorMod(epochMilli, 1000) * 1000000;\n    var date = LocalDate.ofEpochDay(localEpochDay);\n    var time = LocalTime.ofSecondOfDay(secsOfDay, nanoOfSecond);\n    return new LocalDateTime(date, time);\n  };\n\n  LocalDateTime.of = function of() {\n    if (arguments.length <= 2) {\n      return LocalDateTime.ofDateAndTime.apply(this, arguments);\n    } else {\n      return LocalDateTime.ofNumbers.apply(this, arguments);\n    }\n  };\n\n  LocalDateTime.ofNumbers = function ofNumbers(year, month, dayOfMonth, hour, minute, second, nanoOfSecond) {\n    if (hour === void 0) {\n      hour = 0;\n    }\n\n    if (minute === void 0) {\n      minute = 0;\n    }\n\n    if (second === void 0) {\n      second = 0;\n    }\n\n    if (nanoOfSecond === void 0) {\n      nanoOfSecond = 0;\n    }\n\n    var date = LocalDate.of(year, month, dayOfMonth);\n    var time = LocalTime.of(hour, minute, second, nanoOfSecond);\n    return new LocalDateTime(date, time);\n  };\n\n  LocalDateTime.ofDateAndTime = function ofDateAndTime(date, time) {\n    requireNonNull(date, 'date');\n    requireNonNull(time, 'time');\n    return new LocalDateTime(date, time);\n  };\n\n  LocalDateTime.ofInstant = function ofInstant(instant, zone) {\n    if (zone === void 0) {\n      zone = ZoneId.systemDefault();\n    }\n\n    requireNonNull(instant, 'instant');\n    requireInstance(instant, Instant, 'instant');\n    requireNonNull(zone, 'zone');\n    var offset = zone.rules().offset(instant);\n    return LocalDateTime.ofEpochSecond(instant.epochSecond(), instant.nano(), offset);\n  };\n\n  LocalDateTime.ofEpochSecond = function ofEpochSecond(epochSecond, nanoOfSecond, offset) {\n    if (epochSecond === void 0) {\n      epochSecond = 0;\n    }\n\n    if (nanoOfSecond === void 0) {\n      nanoOfSecond = 0;\n    }\n\n    if (arguments.length === 2 && nanoOfSecond instanceof ZoneOffset) {\n      offset = nanoOfSecond;\n      nanoOfSecond = 0;\n    }\n\n    requireNonNull(offset, 'offset');\n    var localSecond = epochSecond + offset.totalSeconds();\n    var localEpochDay = MathUtil.floorDiv(localSecond, LocalTime.SECONDS_PER_DAY);\n    var secsOfDay = MathUtil.floorMod(localSecond, LocalTime.SECONDS_PER_DAY);\n    var date = LocalDate.ofEpochDay(localEpochDay);\n    var time = LocalTime.ofSecondOfDay(secsOfDay, nanoOfSecond);\n    return new LocalDateTime(date, time);\n  };\n\n  LocalDateTime.from = function from(temporal) {\n    requireNonNull(temporal, 'temporal');\n\n    if (temporal instanceof LocalDateTime) {\n      return temporal;\n    } else if (temporal instanceof ZonedDateTime) {\n      return temporal.toLocalDateTime();\n    }\n\n    try {\n      var date = LocalDate.from(temporal);\n      var time = LocalTime.from(temporal);\n      return new LocalDateTime(date, time);\n    } catch (ex) {\n      throw new DateTimeException(\"Unable to obtain LocalDateTime TemporalAccessor: \" + temporal + \", type \" + (temporal.constructor != null ? temporal.constructor.name : ''));\n    }\n  };\n\n  LocalDateTime.parse = function parse(text, formatter) {\n    if (formatter === void 0) {\n      formatter = DateTimeFormatter.ISO_LOCAL_DATE_TIME;\n    }\n\n    requireNonNull(formatter, 'formatter');\n    return formatter.parse(text, LocalDateTime.FROM);\n  };\n\n  function LocalDateTime(date, time) {\n    var _this;\n\n    _this = _ChronoLocalDateTime.call(this) || this;\n    requireInstance(date, LocalDate, 'date');\n    requireInstance(time, LocalTime, 'time');\n    _this._date = date;\n    _this._time = time;\n    return _this;\n  }\n\n  var _proto = LocalDateTime.prototype;\n\n  _proto._withDateTime = function _withDateTime(newDate, newTime) {\n    if (this._date.equals(newDate) && this._time.equals(newTime)) {\n      return this;\n    }\n\n    return new LocalDateTime(newDate, newTime);\n  };\n\n  _proto.isSupported = function isSupported(fieldOrUnit) {\n    if (fieldOrUnit instanceof ChronoField) {\n      return fieldOrUnit.isDateBased() || fieldOrUnit.isTimeBased();\n    } else if (fieldOrUnit instanceof ChronoUnit) {\n      return fieldOrUnit.isDateBased() || fieldOrUnit.isTimeBased();\n    }\n\n    return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);\n  };\n\n  _proto.range = function range(field) {\n    if (field instanceof ChronoField) {\n      return field.isTimeBased() ? this._time.range(field) : this._date.range(field);\n    }\n\n    return field.rangeRefinedBy(this);\n  };\n\n  _proto.get = function get(field) {\n    if (field instanceof ChronoField) {\n      return field.isTimeBased() ? this._time.get(field) : this._date.get(field);\n    }\n\n    return _ChronoLocalDateTime.prototype.get.call(this, field);\n  };\n\n  _proto.getLong = function getLong(field) {\n    requireNonNull(field, 'field');\n\n    if (field instanceof ChronoField) {\n      return field.isTimeBased() ? this._time.getLong(field) : this._date.getLong(field);\n    }\n\n    return field.getFrom(this);\n  };\n\n  _proto.year = function year() {\n    return this._date.year();\n  };\n\n  _proto.monthValue = function monthValue() {\n    return this._date.monthValue();\n  };\n\n  _proto.month = function month() {\n    return this._date.month();\n  };\n\n  _proto.dayOfMonth = function dayOfMonth() {\n    return this._date.dayOfMonth();\n  };\n\n  _proto.dayOfYear = function dayOfYear() {\n    return this._date.dayOfYear();\n  };\n\n  _proto.dayOfWeek = function dayOfWeek() {\n    return this._date.dayOfWeek();\n  };\n\n  _proto.hour = function hour() {\n    return this._time.hour();\n  };\n\n  _proto.minute = function minute() {\n    return this._time.minute();\n  };\n\n  _proto.second = function second() {\n    return this._time.second();\n  };\n\n  _proto.nano = function nano() {\n    return this._time.nano();\n  };\n\n  _proto.withAdjuster = function withAdjuster(adjuster) {\n    requireNonNull(adjuster, 'adjuster');\n\n    if (adjuster instanceof LocalDate) {\n      return this._withDateTime(adjuster, this._time);\n    } else if (adjuster instanceof LocalTime) {\n      return this._withDateTime(this._date, adjuster);\n    } else if (adjuster instanceof LocalDateTime) {\n      return adjuster;\n    }\n\n    assert(typeof adjuster.adjustInto === 'function', 'adjuster', IllegalArgumentException);\n    return adjuster.adjustInto(this);\n  };\n\n  _proto.withFieldValue = function withFieldValue(field, newValue) {\n    requireNonNull(field, 'field');\n\n    if (field instanceof ChronoField) {\n      if (field.isTimeBased()) {\n        return this._withDateTime(this._date, this._time.with(field, newValue));\n      } else {\n        return this._withDateTime(this._date.with(field, newValue), this._time);\n      }\n    }\n\n    return field.adjustInto(this, newValue);\n  };\n\n  _proto.withYear = function withYear(year) {\n    return this._withDateTime(this._date.withYear(year), this._time);\n  };\n\n  _proto.withMonth = function withMonth(month) {\n    return this._withDateTime(this._date.withMonth(month), this._time);\n  };\n\n  _proto.withDayOfMonth = function withDayOfMonth(dayOfMonth) {\n    return this._withDateTime(this._date.withDayOfMonth(dayOfMonth), this._time);\n  };\n\n  _proto.withDayOfYear = function withDayOfYear(dayOfYear) {\n    return this._withDateTime(this._date.withDayOfYear(dayOfYear), this._time);\n  };\n\n  _proto.withHour = function withHour(hour) {\n    var newTime = this._time.withHour(hour);\n\n    return this._withDateTime(this._date, newTime);\n  };\n\n  _proto.withMinute = function withMinute(minute) {\n    var newTime = this._time.withMinute(minute);\n\n    return this._withDateTime(this._date, newTime);\n  };\n\n  _proto.withSecond = function withSecond(second) {\n    var newTime = this._time.withSecond(second);\n\n    return this._withDateTime(this._date, newTime);\n  };\n\n  _proto.withNano = function withNano(nanoOfSecond) {\n    var newTime = this._time.withNano(nanoOfSecond);\n\n    return this._withDateTime(this._date, newTime);\n  };\n\n  _proto.truncatedTo = function truncatedTo(unit) {\n    return this._withDateTime(this._date, this._time.truncatedTo(unit));\n  };\n\n  _proto.plusAmount = function plusAmount(amount) {\n    requireNonNull(amount, 'amount');\n    return amount.addTo(this);\n  };\n\n  _proto.plusAmountUnit = function plusAmountUnit(amountToAdd, unit) {\n    requireNonNull(unit, 'unit');\n\n    if (unit instanceof ChronoUnit) {\n      switch (unit) {\n        case ChronoUnit.NANOS:\n          return this.plusNanos(amountToAdd);\n\n        case ChronoUnit.MICROS:\n          return this.plusDays(MathUtil.intDiv(amountToAdd, LocalTime.MICROS_PER_DAY)).plusNanos(MathUtil.intMod(amountToAdd, LocalTime.MICROS_PER_DAY) * 1000);\n\n        case ChronoUnit.MILLIS:\n          return this.plusDays(MathUtil.intDiv(amountToAdd, LocalTime.MILLIS_PER_DAY)).plusNanos(MathUtil.intMod(amountToAdd, LocalTime.MILLIS_PER_DAY) * 1000000);\n\n        case ChronoUnit.SECONDS:\n          return this.plusSeconds(amountToAdd);\n\n        case ChronoUnit.MINUTES:\n          return this.plusMinutes(amountToAdd);\n\n        case ChronoUnit.HOURS:\n          return this.plusHours(amountToAdd);\n\n        case ChronoUnit.HALF_DAYS:\n          return this.plusDays(MathUtil.intDiv(amountToAdd, 256)).plusHours(MathUtil.intMod(amountToAdd, 256) * 12);\n      }\n\n      return this._withDateTime(this._date.plus(amountToAdd, unit), this._time);\n    }\n\n    return unit.addTo(this, amountToAdd);\n  };\n\n  _proto.plusYears = function plusYears(years) {\n    var newDate = this._date.plusYears(years);\n\n    return this._withDateTime(newDate, this._time);\n  };\n\n  _proto.plusMonths = function plusMonths(months) {\n    var newDate = this._date.plusMonths(months);\n\n    return this._withDateTime(newDate, this._time);\n  };\n\n  _proto.plusWeeks = function plusWeeks(weeks) {\n    var newDate = this._date.plusWeeks(weeks);\n\n    return this._withDateTime(newDate, this._time);\n  };\n\n  _proto.plusDays = function plusDays(days) {\n    var newDate = this._date.plusDays(days);\n\n    return this._withDateTime(newDate, this._time);\n  };\n\n  _proto.plusHours = function plusHours(hours) {\n    return this._plusWithOverflow(this._date, hours, 0, 0, 0, 1);\n  };\n\n  _proto.plusMinutes = function plusMinutes(minutes) {\n    return this._plusWithOverflow(this._date, 0, minutes, 0, 0, 1);\n  };\n\n  _proto.plusSeconds = function plusSeconds(seconds) {\n    return this._plusWithOverflow(this._date, 0, 0, seconds, 0, 1);\n  };\n\n  _proto.plusNanos = function plusNanos(nanos) {\n    return this._plusWithOverflow(this._date, 0, 0, 0, nanos, 1);\n  };\n\n  _proto.minusAmount = function minusAmount(amount) {\n    requireNonNull(amount, 'amount');\n    return amount.subtractFrom(this);\n  };\n\n  _proto.minusAmountUnit = function minusAmountUnit(amountToSubtract, unit) {\n    requireNonNull(unit, 'unit');\n    return this.plusAmountUnit(-1 * amountToSubtract, unit);\n  };\n\n  _proto.minusYears = function minusYears(years) {\n    return this.plusYears(-1 * years);\n  };\n\n  _proto.minusMonths = function minusMonths(months) {\n    return this.plusMonths(-1 * months);\n  };\n\n  _proto.minusWeeks = function minusWeeks(weeks) {\n    return this.plusWeeks(-1 * weeks);\n  };\n\n  _proto.minusDays = function minusDays(days) {\n    return this.plusDays(-1 * days);\n  };\n\n  _proto.minusHours = function minusHours(hours) {\n    return this._plusWithOverflow(this._date, hours, 0, 0, 0, -1);\n  };\n\n  _proto.minusMinutes = function minusMinutes(minutes) {\n    return this._plusWithOverflow(this._date, 0, minutes, 0, 0, -1);\n  };\n\n  _proto.minusSeconds = function minusSeconds(seconds) {\n    return this._plusWithOverflow(this._date, 0, 0, seconds, 0, -1);\n  };\n\n  _proto.minusNanos = function minusNanos(nanos) {\n    return this._plusWithOverflow(this._date, 0, 0, 0, nanos, -1);\n  };\n\n  _proto._plusWithOverflow = function _plusWithOverflow(newDate, hours, minutes, seconds, nanos, sign) {\n    if (hours === 0 && minutes === 0 && seconds === 0 && nanos === 0) {\n      return this._withDateTime(newDate, this._time);\n    }\n\n    var totDays = MathUtil.intDiv(nanos, LocalTime.NANOS_PER_DAY) + MathUtil.intDiv(seconds, LocalTime.SECONDS_PER_DAY) + MathUtil.intDiv(minutes, LocalTime.MINUTES_PER_DAY) + MathUtil.intDiv(hours, LocalTime.HOURS_PER_DAY);\n    totDays *= sign;\n    var totNanos = MathUtil.intMod(nanos, LocalTime.NANOS_PER_DAY) + MathUtil.intMod(seconds, LocalTime.SECONDS_PER_DAY) * LocalTime.NANOS_PER_SECOND + MathUtil.intMod(minutes, LocalTime.MINUTES_PER_DAY) * LocalTime.NANOS_PER_MINUTE + MathUtil.intMod(hours, LocalTime.HOURS_PER_DAY) * LocalTime.NANOS_PER_HOUR;\n\n    var curNoD = this._time.toNanoOfDay();\n\n    totNanos = totNanos * sign + curNoD;\n    totDays += MathUtil.floorDiv(totNanos, LocalTime.NANOS_PER_DAY);\n    var newNoD = MathUtil.floorMod(totNanos, LocalTime.NANOS_PER_DAY);\n    var newTime = newNoD === curNoD ? this._time : LocalTime.ofNanoOfDay(newNoD);\n    return this._withDateTime(newDate.plusDays(totDays), newTime);\n  };\n\n  _proto.query = function query(_query) {\n    requireNonNull(_query, 'query');\n\n    if (_query === TemporalQueries.localDate()) {\n      return this.toLocalDate();\n    }\n\n    return _ChronoLocalDateTime.prototype.query.call(this, _query);\n  };\n\n  _proto.adjustInto = function adjustInto(temporal) {\n    return _ChronoLocalDateTime.prototype.adjustInto.call(this, temporal);\n  };\n\n  _proto.until = function until(endExclusive, unit) {\n    requireNonNull(endExclusive, 'endExclusive');\n    requireNonNull(unit, 'unit');\n    var end = LocalDateTime.from(endExclusive);\n\n    if (unit instanceof ChronoUnit) {\n      if (unit.isTimeBased()) {\n        var daysUntil = this._date.daysUntil(end._date);\n\n        var timeUntil = end._time.toNanoOfDay() - this._time.toNanoOfDay();\n\n        if (daysUntil > 0 && timeUntil < 0) {\n          daysUntil--;\n          timeUntil += LocalTime.NANOS_PER_DAY;\n        } else if (daysUntil < 0 && timeUntil > 0) {\n          daysUntil++;\n          timeUntil -= LocalTime.NANOS_PER_DAY;\n        }\n\n        var amount = daysUntil;\n\n        switch (unit) {\n          case ChronoUnit.NANOS:\n            amount = MathUtil.safeMultiply(amount, LocalTime.NANOS_PER_DAY);\n            return MathUtil.safeAdd(amount, timeUntil);\n\n          case ChronoUnit.MICROS:\n            amount = MathUtil.safeMultiply(amount, LocalTime.MICROS_PER_DAY);\n            return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, 1000));\n\n          case ChronoUnit.MILLIS:\n            amount = MathUtil.safeMultiply(amount, LocalTime.MILLIS_PER_DAY);\n            return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, 1000000));\n\n          case ChronoUnit.SECONDS:\n            amount = MathUtil.safeMultiply(amount, LocalTime.SECONDS_PER_DAY);\n            return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, LocalTime.NANOS_PER_SECOND));\n\n          case ChronoUnit.MINUTES:\n            amount = MathUtil.safeMultiply(amount, LocalTime.MINUTES_PER_DAY);\n            return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, LocalTime.NANOS_PER_MINUTE));\n\n          case ChronoUnit.HOURS:\n            amount = MathUtil.safeMultiply(amount, LocalTime.HOURS_PER_DAY);\n            return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, LocalTime.NANOS_PER_HOUR));\n\n          case ChronoUnit.HALF_DAYS:\n            amount = MathUtil.safeMultiply(amount, 2);\n            return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, LocalTime.NANOS_PER_HOUR * 12));\n        }\n\n        throw new UnsupportedTemporalTypeException('Unsupported unit: ' + unit);\n      }\n\n      var endDate = end._date;\n      var endTime = end._time;\n\n      if (endDate.isAfter(this._date) && endTime.isBefore(this._time)) {\n        endDate = endDate.minusDays(1);\n      } else if (endDate.isBefore(this._date) && endTime.isAfter(this._time)) {\n        endDate = endDate.plusDays(1);\n      }\n\n      return this._date.until(endDate, unit);\n    }\n\n    return unit.between(this, end);\n  };\n\n  _proto.atOffset = function atOffset(offset) {\n    return OffsetDateTime.of(this, offset);\n  };\n\n  _proto.atZone = function atZone(zone) {\n    return ZonedDateTime.of(this, zone);\n  };\n\n  _proto.toLocalDate = function toLocalDate() {\n    return this._date;\n  };\n\n  _proto.toLocalTime = function toLocalTime() {\n    return this._time;\n  };\n\n  _proto.compareTo = function compareTo(other) {\n    requireNonNull(other, 'other');\n    requireInstance(other, LocalDateTime, 'other');\n    return this._compareTo0(other);\n  };\n\n  _proto._compareTo0 = function _compareTo0(other) {\n    var cmp = this._date.compareTo(other.toLocalDate());\n\n    if (cmp === 0) {\n      cmp = this._time.compareTo(other.toLocalTime());\n    }\n\n    return cmp;\n  };\n\n  _proto.isAfter = function isAfter(other) {\n    return this.compareTo(other) > 0;\n  };\n\n  _proto.isBefore = function isBefore(other) {\n    return this.compareTo(other) < 0;\n  };\n\n  _proto.isEqual = function isEqual(other) {\n    return this.compareTo(other) === 0;\n  };\n\n  _proto.equals = function equals(other) {\n    if (this === other) {\n      return true;\n    }\n\n    if (other instanceof LocalDateTime) {\n      return this._date.equals(other._date) && this._time.equals(other._time);\n    }\n\n    return false;\n  };\n\n  _proto.hashCode = function hashCode() {\n    return this._date.hashCode() ^ this._time.hashCode();\n  };\n\n  _proto.toString = function toString() {\n    return this._date.toString() + 'T' + this._time.toString();\n  };\n\n  _proto.toJSON = function toJSON() {\n    return this.toString();\n  };\n\n  _proto.format = function format(formatter) {\n    requireNonNull(formatter, 'formatter');\n    return formatter.format(this);\n  };\n\n  return LocalDateTime;\n}(ChronoLocalDateTime);\nfunction _init$j() {\n  LocalDateTime.MIN = LocalDateTime.of(LocalDate.MIN, LocalTime.MIN);\n  LocalDateTime.MAX = LocalDateTime.of(LocalDate.MAX, LocalTime.MAX);\n  LocalDateTime.FROM = createTemporalQuery('LocalDateTime.FROM', function (temporal) {\n    return LocalDateTime.from(temporal);\n  });\n}\n\nvar LocalTime = function (_Temporal) {\n  _inheritsLoose(LocalTime, _Temporal);\n\n  LocalTime.now = function now(clockOrZone) {\n    if (clockOrZone == null) {\n      return LocalTime._now(Clock.systemDefaultZone());\n    } else if (clockOrZone instanceof Clock) {\n      return LocalTime._now(clockOrZone);\n    } else {\n      return LocalTime._now(Clock.system(clockOrZone));\n    }\n  };\n\n  LocalTime._now = function _now(clock) {\n    if (clock === void 0) {\n      clock = Clock.systemDefaultZone();\n    }\n\n    requireNonNull(clock, 'clock');\n    return LocalTime.ofInstant(clock.instant(), clock.zone());\n  };\n\n  LocalTime.ofInstant = function ofInstant(instant, zone) {\n    if (zone === void 0) {\n      zone = ZoneId.systemDefault();\n    }\n\n    var offset = zone.rules().offset(instant);\n    var secsOfDay = MathUtil.intMod(instant.epochSecond(), LocalTime.SECONDS_PER_DAY);\n    secsOfDay = MathUtil.intMod(secsOfDay + offset.totalSeconds(), LocalTime.SECONDS_PER_DAY);\n\n    if (secsOfDay < 0) {\n      secsOfDay += LocalTime.SECONDS_PER_DAY;\n    }\n\n    return LocalTime.ofSecondOfDay(secsOfDay, instant.nano());\n  };\n\n  LocalTime.of = function of(hour, minute, second, nanoOfSecond) {\n    return new LocalTime(hour, minute, second, nanoOfSecond);\n  };\n\n  LocalTime.ofSecondOfDay = function ofSecondOfDay(secondOfDay, nanoOfSecond) {\n    if (secondOfDay === void 0) {\n      secondOfDay = 0;\n    }\n\n    if (nanoOfSecond === void 0) {\n      nanoOfSecond = 0;\n    }\n\n    ChronoField.SECOND_OF_DAY.checkValidValue(secondOfDay);\n    ChronoField.NANO_OF_SECOND.checkValidValue(nanoOfSecond);\n    var hours = MathUtil.intDiv(secondOfDay, LocalTime.SECONDS_PER_HOUR);\n    secondOfDay -= hours * LocalTime.SECONDS_PER_HOUR;\n    var minutes = MathUtil.intDiv(secondOfDay, LocalTime.SECONDS_PER_MINUTE);\n    secondOfDay -= minutes * LocalTime.SECONDS_PER_MINUTE;\n    return new LocalTime(hours, minutes, secondOfDay, nanoOfSecond);\n  };\n\n  LocalTime.ofNanoOfDay = function ofNanoOfDay(nanoOfDay) {\n    if (nanoOfDay === void 0) {\n      nanoOfDay = 0;\n    }\n\n    ChronoField.NANO_OF_DAY.checkValidValue(nanoOfDay);\n    var hours = MathUtil.intDiv(nanoOfDay, LocalTime.NANOS_PER_HOUR);\n    nanoOfDay -= hours * LocalTime.NANOS_PER_HOUR;\n    var minutes = MathUtil.intDiv(nanoOfDay, LocalTime.NANOS_PER_MINUTE);\n    nanoOfDay -= minutes * LocalTime.NANOS_PER_MINUTE;\n    var seconds = MathUtil.intDiv(nanoOfDay, LocalTime.NANOS_PER_SECOND);\n    nanoOfDay -= seconds * LocalTime.NANOS_PER_SECOND;\n    return new LocalTime(hours, minutes, seconds, nanoOfDay);\n  };\n\n  LocalTime.from = function from(temporal) {\n    requireNonNull(temporal, 'temporal');\n    var time = temporal.query(TemporalQueries.localTime());\n\n    if (time == null) {\n      throw new DateTimeException(\"Unable to obtain LocalTime TemporalAccessor: \" + temporal + \", type \" + (temporal.constructor != null ? temporal.constructor.name : ''));\n    }\n\n    return time;\n  };\n\n  LocalTime.parse = function parse(text, formatter) {\n    if (formatter === void 0) {\n      formatter = DateTimeFormatter.ISO_LOCAL_TIME;\n    }\n\n    requireNonNull(formatter, 'formatter');\n    return formatter.parse(text, LocalTime.FROM);\n  };\n\n  function LocalTime(hour, minute, second, nanoOfSecond) {\n    var _this;\n\n    if (hour === void 0) {\n      hour = 0;\n    }\n\n    if (minute === void 0) {\n      minute = 0;\n    }\n\n    if (second === void 0) {\n      second = 0;\n    }\n\n    if (nanoOfSecond === void 0) {\n      nanoOfSecond = 0;\n    }\n\n    _this = _Temporal.call(this) || this;\n\n    var _hour = MathUtil.safeToInt(hour);\n\n    var _minute = MathUtil.safeToInt(minute);\n\n    var _second = MathUtil.safeToInt(second);\n\n    var _nanoOfSecond = MathUtil.safeToInt(nanoOfSecond);\n\n    LocalTime._validate(_hour, _minute, _second, _nanoOfSecond);\n\n    if (_minute === 0 && _second === 0 && _nanoOfSecond === 0) {\n      if (!LocalTime.HOURS[_hour]) {\n        _this._hour = _hour;\n        _this._minute = _minute;\n        _this._second = _second;\n        _this._nano = _nanoOfSecond;\n        LocalTime.HOURS[_hour] = _assertThisInitialized(_this);\n      }\n\n      return LocalTime.HOURS[_hour] || _assertThisInitialized(_this);\n    }\n\n    _this._hour = _hour;\n    _this._minute = _minute;\n    _this._second = _second;\n    _this._nano = _nanoOfSecond;\n    return _this;\n  }\n\n  LocalTime._validate = function _validate(hour, minute, second, nanoOfSecond) {\n    ChronoField.HOUR_OF_DAY.checkValidValue(hour);\n    ChronoField.MINUTE_OF_HOUR.checkValidValue(minute);\n    ChronoField.SECOND_OF_MINUTE.checkValidValue(second);\n    ChronoField.NANO_OF_SECOND.checkValidValue(nanoOfSecond);\n  };\n\n  var _proto = LocalTime.prototype;\n\n  _proto.isSupported = function isSupported(fieldOrUnit) {\n    if (fieldOrUnit instanceof ChronoField) {\n      return fieldOrUnit.isTimeBased();\n    } else if (fieldOrUnit instanceof ChronoUnit) {\n      return fieldOrUnit.isTimeBased();\n    }\n\n    return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);\n  };\n\n  _proto.range = function range(field) {\n    requireNonNull(field);\n    return _Temporal.prototype.range.call(this, field);\n  };\n\n  _proto.get = function get(field) {\n    return this.getLong(field);\n  };\n\n  _proto.getLong = function getLong(field) {\n    requireNonNull(field, 'field');\n\n    if (field instanceof ChronoField) {\n      return this._get0(field);\n    }\n\n    return field.getFrom(this);\n  };\n\n  _proto._get0 = function _get0(field) {\n    switch (field) {\n      case ChronoField.NANO_OF_SECOND:\n        return this._nano;\n\n      case ChronoField.NANO_OF_DAY:\n        return this.toNanoOfDay();\n\n      case ChronoField.MICRO_OF_SECOND:\n        return MathUtil.intDiv(this._nano, 1000);\n\n      case ChronoField.MICRO_OF_DAY:\n        return MathUtil.intDiv(this.toNanoOfDay(), 1000);\n\n      case ChronoField.MILLI_OF_SECOND:\n        return MathUtil.intDiv(this._nano, 1000000);\n\n      case ChronoField.MILLI_OF_DAY:\n        return MathUtil.intDiv(this.toNanoOfDay(), 1000000);\n\n      case ChronoField.SECOND_OF_MINUTE:\n        return this._second;\n\n      case ChronoField.SECOND_OF_DAY:\n        return this.toSecondOfDay();\n\n      case ChronoField.MINUTE_OF_HOUR:\n        return this._minute;\n\n      case ChronoField.MINUTE_OF_DAY:\n        return this._hour * 60 + this._minute;\n\n      case ChronoField.HOUR_OF_AMPM:\n        return MathUtil.intMod(this._hour, 12);\n\n      case ChronoField.CLOCK_HOUR_OF_AMPM:\n        {\n          var ham = MathUtil.intMod(this._hour, 12);\n          return ham % 12 === 0 ? 12 : ham;\n        }\n\n      case ChronoField.HOUR_OF_DAY:\n        return this._hour;\n\n      case ChronoField.CLOCK_HOUR_OF_DAY:\n        return this._hour === 0 ? 24 : this._hour;\n\n      case ChronoField.AMPM_OF_DAY:\n        return MathUtil.intDiv(this._hour, 12);\n    }\n\n    throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);\n  };\n\n  _proto.hour = function hour() {\n    return this._hour;\n  };\n\n  _proto.minute = function minute() {\n    return this._minute;\n  };\n\n  _proto.second = function second() {\n    return this._second;\n  };\n\n  _proto.nano = function nano() {\n    return this._nano;\n  };\n\n  _proto.withAdjuster = function withAdjuster(adjuster) {\n    requireNonNull(adjuster, 'adjuster');\n\n    if (adjuster instanceof LocalTime) {\n      return adjuster;\n    }\n\n    assert(typeof adjuster.adjustInto === 'function', 'adjuster', IllegalArgumentException);\n    return adjuster.adjustInto(this);\n  };\n\n  _proto.withFieldValue = function withFieldValue(field, newValue) {\n    requireNonNull(field, 'field');\n    requireInstance(field, TemporalField, 'field');\n\n    if (field instanceof ChronoField) {\n      field.checkValidValue(newValue);\n\n      switch (field) {\n        case ChronoField.NANO_OF_SECOND:\n          return this.withNano(newValue);\n\n        case ChronoField.NANO_OF_DAY:\n          return LocalTime.ofNanoOfDay(newValue);\n\n        case ChronoField.MICRO_OF_SECOND:\n          return this.withNano(newValue * 1000);\n\n        case ChronoField.MICRO_OF_DAY:\n          return LocalTime.ofNanoOfDay(newValue * 1000);\n\n        case ChronoField.MILLI_OF_SECOND:\n          return this.withNano(newValue * 1000000);\n\n        case ChronoField.MILLI_OF_DAY:\n          return LocalTime.ofNanoOfDay(newValue * 1000000);\n\n        case ChronoField.SECOND_OF_MINUTE:\n          return this.withSecond(newValue);\n\n        case ChronoField.SECOND_OF_DAY:\n          return this.plusSeconds(newValue - this.toSecondOfDay());\n\n        case ChronoField.MINUTE_OF_HOUR:\n          return this.withMinute(newValue);\n\n        case ChronoField.MINUTE_OF_DAY:\n          return this.plusMinutes(newValue - (this._hour * 60 + this._minute));\n\n        case ChronoField.HOUR_OF_AMPM:\n          return this.plusHours(newValue - MathUtil.intMod(this._hour, 12));\n\n        case ChronoField.CLOCK_HOUR_OF_AMPM:\n          return this.plusHours((newValue === 12 ? 0 : newValue) - MathUtil.intMod(this._hour, 12));\n\n        case ChronoField.HOUR_OF_DAY:\n          return this.withHour(newValue);\n\n        case ChronoField.CLOCK_HOUR_OF_DAY:\n          return this.withHour(newValue === 24 ? 0 : newValue);\n\n        case ChronoField.AMPM_OF_DAY:\n          return this.plusHours((newValue - MathUtil.intDiv(this._hour, 12)) * 12);\n      }\n\n      throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);\n    }\n\n    return field.adjustInto(this, newValue);\n  };\n\n  _proto.withHour = function withHour(hour) {\n    if (hour === void 0) {\n      hour = 0;\n    }\n\n    if (this._hour === hour) {\n      return this;\n    }\n\n    return new LocalTime(hour, this._minute, this._second, this._nano);\n  };\n\n  _proto.withMinute = function withMinute(minute) {\n    if (minute === void 0) {\n      minute = 0;\n    }\n\n    if (this._minute === minute) {\n      return this;\n    }\n\n    return new LocalTime(this._hour, minute, this._second, this._nano);\n  };\n\n  _proto.withSecond = function withSecond(second) {\n    if (second === void 0) {\n      second = 0;\n    }\n\n    if (this._second === second) {\n      return this;\n    }\n\n    return new LocalTime(this._hour, this._minute, second, this._nano);\n  };\n\n  _proto.withNano = function withNano(nanoOfSecond) {\n    if (nanoOfSecond === void 0) {\n      nanoOfSecond = 0;\n    }\n\n    if (this._nano === nanoOfSecond) {\n      return this;\n    }\n\n    return new LocalTime(this._hour, this._minute, this._second, nanoOfSecond);\n  };\n\n  _proto.truncatedTo = function truncatedTo(unit) {\n    requireNonNull(unit, 'unit');\n\n    if (unit === ChronoUnit.NANOS) {\n      return this;\n    }\n\n    var unitDur = unit.duration();\n\n    if (unitDur.seconds() > LocalTime.SECONDS_PER_DAY) {\n      throw new DateTimeException('Unit is too large to be used for truncation');\n    }\n\n    var dur = unitDur.toNanos();\n\n    if (MathUtil.intMod(LocalTime.NANOS_PER_DAY, dur) !== 0) {\n      throw new DateTimeException('Unit must divide into a standard day without remainder');\n    }\n\n    var nod = this.toNanoOfDay();\n    return LocalTime.ofNanoOfDay(MathUtil.intDiv(nod, dur) * dur);\n  };\n\n  _proto.plusAmount = function plusAmount(amount) {\n    requireNonNull(amount, 'amount');\n    return amount.addTo(this);\n  };\n\n  _proto.plusAmountUnit = function plusAmountUnit(amountToAdd, unit) {\n    requireNonNull(unit, 'unit');\n\n    if (unit instanceof ChronoUnit) {\n      switch (unit) {\n        case ChronoUnit.NANOS:\n          return this.plusNanos(amountToAdd);\n\n        case ChronoUnit.MICROS:\n          return this.plusNanos(MathUtil.intMod(amountToAdd, LocalTime.MICROS_PER_DAY) * 1000);\n\n        case ChronoUnit.MILLIS:\n          return this.plusNanos(MathUtil.intMod(amountToAdd, LocalTime.MILLIS_PER_DAY) * 1000000);\n\n        case ChronoUnit.SECONDS:\n          return this.plusSeconds(amountToAdd);\n\n        case ChronoUnit.MINUTES:\n          return this.plusMinutes(amountToAdd);\n\n        case ChronoUnit.HOURS:\n          return this.plusHours(amountToAdd);\n\n        case ChronoUnit.HALF_DAYS:\n          return this.plusHours(MathUtil.intMod(amountToAdd, 2) * 12);\n      }\n\n      throw new UnsupportedTemporalTypeException('Unsupported unit: ' + unit);\n    }\n\n    return unit.addTo(this, amountToAdd);\n  };\n\n  _proto.plusHours = function plusHours(hoursToAdd) {\n    if (hoursToAdd === 0) {\n      return this;\n    }\n\n    var newHour = MathUtil.intMod(MathUtil.intMod(hoursToAdd, LocalTime.HOURS_PER_DAY) + this._hour + LocalTime.HOURS_PER_DAY, LocalTime.HOURS_PER_DAY);\n    return new LocalTime(newHour, this._minute, this._second, this._nano);\n  };\n\n  _proto.plusMinutes = function plusMinutes(minutesToAdd) {\n    if (minutesToAdd === 0) {\n      return this;\n    }\n\n    var mofd = this._hour * LocalTime.MINUTES_PER_HOUR + this._minute;\n    var newMofd = MathUtil.intMod(MathUtil.intMod(minutesToAdd, LocalTime.MINUTES_PER_DAY) + mofd + LocalTime.MINUTES_PER_DAY, LocalTime.MINUTES_PER_DAY);\n\n    if (mofd === newMofd) {\n      return this;\n    }\n\n    var newHour = MathUtil.intDiv(newMofd, LocalTime.MINUTES_PER_HOUR);\n    var newMinute = MathUtil.intMod(newMofd, LocalTime.MINUTES_PER_HOUR);\n    return new LocalTime(newHour, newMinute, this._second, this._nano);\n  };\n\n  _proto.plusSeconds = function plusSeconds(secondsToAdd) {\n    if (secondsToAdd === 0) {\n      return this;\n    }\n\n    var sofd = this._hour * LocalTime.SECONDS_PER_HOUR + this._minute * LocalTime.SECONDS_PER_MINUTE + this._second;\n    var newSofd = MathUtil.intMod(MathUtil.intMod(secondsToAdd, LocalTime.SECONDS_PER_DAY) + sofd + LocalTime.SECONDS_PER_DAY, LocalTime.SECONDS_PER_DAY);\n\n    if (sofd === newSofd) {\n      return this;\n    }\n\n    var newHour = MathUtil.intDiv(newSofd, LocalTime.SECONDS_PER_HOUR);\n    var newMinute = MathUtil.intMod(MathUtil.intDiv(newSofd, LocalTime.SECONDS_PER_MINUTE), LocalTime.MINUTES_PER_HOUR);\n    var newSecond = MathUtil.intMod(newSofd, LocalTime.SECONDS_PER_MINUTE);\n    return new LocalTime(newHour, newMinute, newSecond, this._nano);\n  };\n\n  _proto.plusNanos = function plusNanos(nanosToAdd) {\n    if (nanosToAdd === 0) {\n      return this;\n    }\n\n    var nofd = this.toNanoOfDay();\n    var newNofd = MathUtil.intMod(MathUtil.intMod(nanosToAdd, LocalTime.NANOS_PER_DAY) + nofd + LocalTime.NANOS_PER_DAY, LocalTime.NANOS_PER_DAY);\n\n    if (nofd === newNofd) {\n      return this;\n    }\n\n    var newHour = MathUtil.intDiv(newNofd, LocalTime.NANOS_PER_HOUR);\n    var newMinute = MathUtil.intMod(MathUtil.intDiv(newNofd, LocalTime.NANOS_PER_MINUTE), LocalTime.MINUTES_PER_HOUR);\n    var newSecond = MathUtil.intMod(MathUtil.intDiv(newNofd, LocalTime.NANOS_PER_SECOND), LocalTime.SECONDS_PER_MINUTE);\n    var newNano = MathUtil.intMod(newNofd, LocalTime.NANOS_PER_SECOND);\n    return new LocalTime(newHour, newMinute, newSecond, newNano);\n  };\n\n  _proto.minusAmount = function minusAmount(amount) {\n    requireNonNull(amount, 'amount');\n    return amount.subtractFrom(this);\n  };\n\n  _proto.minusAmountUnit = function minusAmountUnit(amountToSubtract, unit) {\n    requireNonNull(unit, 'unit');\n    return this.plusAmountUnit(-1 * amountToSubtract, unit);\n  };\n\n  _proto.minusHours = function minusHours(hoursToSubtract) {\n    return this.plusHours(-1 * MathUtil.intMod(hoursToSubtract, LocalTime.HOURS_PER_DAY));\n  };\n\n  _proto.minusMinutes = function minusMinutes(minutesToSubtract) {\n    return this.plusMinutes(-1 * MathUtil.intMod(minutesToSubtract, LocalTime.MINUTES_PER_DAY));\n  };\n\n  _proto.minusSeconds = function minusSeconds(secondsToSubtract) {\n    return this.plusSeconds(-1 * MathUtil.intMod(secondsToSubtract, LocalTime.SECONDS_PER_DAY));\n  };\n\n  _proto.minusNanos = function minusNanos(nanosToSubtract) {\n    return this.plusNanos(-1 * MathUtil.intMod(nanosToSubtract, LocalTime.NANOS_PER_DAY));\n  };\n\n  _proto.query = function query(_query) {\n    requireNonNull(_query, 'query');\n\n    if (_query === TemporalQueries.precision()) {\n      return ChronoUnit.NANOS;\n    } else if (_query === TemporalQueries.localTime()) {\n      return this;\n    }\n\n    if (_query === TemporalQueries.chronology() || _query === TemporalQueries.zoneId() || _query === TemporalQueries.zone() || _query === TemporalQueries.offset() || _query === TemporalQueries.localDate()) {\n      return null;\n    }\n\n    return _query.queryFrom(this);\n  };\n\n  _proto.adjustInto = function adjustInto(temporal) {\n    return temporal.with(LocalTime.NANO_OF_DAY, this.toNanoOfDay());\n  };\n\n  _proto.until = function until(endExclusive, unit) {\n    requireNonNull(endExclusive, 'endExclusive');\n    requireNonNull(unit, 'unit');\n    var end = LocalTime.from(endExclusive);\n\n    if (unit instanceof ChronoUnit) {\n      var nanosUntil = end.toNanoOfDay() - this.toNanoOfDay();\n\n      switch (unit) {\n        case ChronoUnit.NANOS:\n          return nanosUntil;\n\n        case ChronoUnit.MICROS:\n          return MathUtil.intDiv(nanosUntil, 1000);\n\n        case ChronoUnit.MILLIS:\n          return MathUtil.intDiv(nanosUntil, 1000000);\n\n        case ChronoUnit.SECONDS:\n          return MathUtil.intDiv(nanosUntil, LocalTime.NANOS_PER_SECOND);\n\n        case ChronoUnit.MINUTES:\n          return MathUtil.intDiv(nanosUntil, LocalTime.NANOS_PER_MINUTE);\n\n        case ChronoUnit.HOURS:\n          return MathUtil.intDiv(nanosUntil, LocalTime.NANOS_PER_HOUR);\n\n        case ChronoUnit.HALF_DAYS:\n          return MathUtil.intDiv(nanosUntil, 12 * LocalTime.NANOS_PER_HOUR);\n      }\n\n      throw new UnsupportedTemporalTypeException('Unsupported unit: ' + unit);\n    }\n\n    return unit.between(this, end);\n  };\n\n  _proto.atDate = function atDate(date) {\n    return LocalDateTime.of(date, this);\n  };\n\n  _proto.toSecondOfDay = function toSecondOfDay() {\n    var total = this._hour * LocalTime.SECONDS_PER_HOUR;\n    total += this._minute * LocalTime.SECONDS_PER_MINUTE;\n    total += this._second;\n    return total;\n  };\n\n  _proto.toNanoOfDay = function toNanoOfDay() {\n    var total = this._hour * LocalTime.NANOS_PER_HOUR;\n    total += this._minute * LocalTime.NANOS_PER_MINUTE;\n    total += this._second * LocalTime.NANOS_PER_SECOND;\n    total += this._nano;\n    return total;\n  };\n\n  _proto.compareTo = function compareTo(other) {\n    requireNonNull(other, 'other');\n    requireInstance(other, LocalTime, 'other');\n    var cmp = MathUtil.compareNumbers(this._hour, other._hour);\n\n    if (cmp === 0) {\n      cmp = MathUtil.compareNumbers(this._minute, other._minute);\n\n      if (cmp === 0) {\n        cmp = MathUtil.compareNumbers(this._second, other._second);\n\n        if (cmp === 0) {\n          cmp = MathUtil.compareNumbers(this._nano, other._nano);\n        }\n      }\n    }\n\n    return cmp;\n  };\n\n  _proto.isAfter = function isAfter(other) {\n    return this.compareTo(other) > 0;\n  };\n\n  _proto.isBefore = function isBefore(other) {\n    return this.compareTo(other) < 0;\n  };\n\n  _proto.equals = function equals(other) {\n    if (this === other) {\n      return true;\n    }\n\n    if (other instanceof LocalTime) {\n      return this._hour === other._hour && this._minute === other._minute && this._second === other._second && this._nano === other._nano;\n    }\n\n    return false;\n  };\n\n  _proto.hashCode = function hashCode() {\n    var nod = this.toNanoOfDay();\n    return MathUtil.hash(nod);\n  };\n\n  _proto.toString = function toString() {\n    var buf = '';\n    var hourValue = this._hour;\n    var minuteValue = this._minute;\n    var secondValue = this._second;\n    var nanoValue = this._nano;\n    buf += hourValue < 10 ? '0' : '';\n    buf += hourValue;\n    buf += minuteValue < 10 ? ':0' : ':';\n    buf += minuteValue;\n\n    if (secondValue > 0 || nanoValue > 0) {\n      buf += secondValue < 10 ? ':0' : ':';\n      buf += secondValue;\n\n      if (nanoValue > 0) {\n        buf += '.';\n\n        if (MathUtil.intMod(nanoValue, 1000000) === 0) {\n          buf += ('' + (MathUtil.intDiv(nanoValue, 1000000) + 1000)).substring(1);\n        } else if (MathUtil.intMod(nanoValue, 1000) === 0) {\n          buf += ('' + (MathUtil.intDiv(nanoValue, 1000) + 1000000)).substring(1);\n        } else {\n          buf += ('' + (nanoValue + 1000000000)).substring(1);\n        }\n      }\n    }\n\n    return buf;\n  };\n\n  _proto.toJSON = function toJSON() {\n    return this.toString();\n  };\n\n  _proto.format = function format(formatter) {\n    requireNonNull(formatter, 'formatter');\n    return formatter.format(this);\n  };\n\n  return LocalTime;\n}(Temporal);\nfunction _init$k() {\n  LocalTime.HOURS = [];\n\n  for (var hour = 0; hour < 24; hour++) {\n    LocalTime.of(hour, 0, 0, 0);\n  }\n\n  LocalTime.MIN = LocalTime.HOURS[0];\n  LocalTime.MAX = new LocalTime(23, 59, 59, 999999999);\n  LocalTime.MIDNIGHT = LocalTime.HOURS[0];\n  LocalTime.NOON = LocalTime.HOURS[12];\n  LocalTime.FROM = createTemporalQuery('LocalTime.FROM', function (temporal) {\n    return LocalTime.from(temporal);\n  });\n}\nLocalTime.HOURS_PER_DAY = 24;\nLocalTime.MINUTES_PER_HOUR = 60;\nLocalTime.MINUTES_PER_DAY = LocalTime.MINUTES_PER_HOUR * LocalTime.HOURS_PER_DAY;\nLocalTime.SECONDS_PER_MINUTE = 60;\nLocalTime.SECONDS_PER_HOUR = LocalTime.SECONDS_PER_MINUTE * LocalTime.MINUTES_PER_HOUR;\nLocalTime.SECONDS_PER_DAY = LocalTime.SECONDS_PER_HOUR * LocalTime.HOURS_PER_DAY;\nLocalTime.MILLIS_PER_DAY = LocalTime.SECONDS_PER_DAY * 1000;\nLocalTime.MICROS_PER_DAY = LocalTime.SECONDS_PER_DAY * 1000000;\nLocalTime.NANOS_PER_SECOND = 1000000000;\nLocalTime.NANOS_PER_MINUTE = LocalTime.NANOS_PER_SECOND * LocalTime.SECONDS_PER_MINUTE;\nLocalTime.NANOS_PER_HOUR = LocalTime.NANOS_PER_MINUTE * LocalTime.MINUTES_PER_HOUR;\nLocalTime.NANOS_PER_DAY = LocalTime.NANOS_PER_HOUR * LocalTime.HOURS_PER_DAY;\n\nvar NANOS_PER_MILLI = 1000000;\nvar Instant = function (_Temporal) {\n  _inheritsLoose(Instant, _Temporal);\n\n  Instant.now = function now(clock) {\n    if (clock === void 0) {\n      clock = Clock.systemUTC();\n    }\n\n    return clock.instant();\n  };\n\n  Instant.ofEpochSecond = function ofEpochSecond(epochSecond, nanoAdjustment) {\n    if (nanoAdjustment === void 0) {\n      nanoAdjustment = 0;\n    }\n\n    var secs = epochSecond + MathUtil.floorDiv(nanoAdjustment, LocalTime.NANOS_PER_SECOND);\n    var nos = MathUtil.floorMod(nanoAdjustment, LocalTime.NANOS_PER_SECOND);\n    return Instant._create(secs, nos);\n  };\n\n  Instant.ofEpochMilli = function ofEpochMilli(epochMilli) {\n    var secs = MathUtil.floorDiv(epochMilli, 1000);\n    var mos = MathUtil.floorMod(epochMilli, 1000);\n    return Instant._create(secs, mos * 1000000);\n  };\n\n  Instant.from = function from(temporal) {\n    try {\n      var instantSecs = temporal.getLong(ChronoField.INSTANT_SECONDS);\n      var nanoOfSecond = temporal.get(ChronoField.NANO_OF_SECOND);\n      return Instant.ofEpochSecond(instantSecs, nanoOfSecond);\n    } catch (ex) {\n      throw new DateTimeException('Unable to obtain Instant from TemporalAccessor: ' + temporal + ', type ' + typeof temporal, ex);\n    }\n  };\n\n  Instant.parse = function parse(text) {\n    return DateTimeFormatter.ISO_INSTANT.parse(text, Instant.FROM);\n  };\n\n  Instant._create = function _create(seconds, nanoOfSecond) {\n    if (seconds === 0 && nanoOfSecond === 0) {\n      return Instant.EPOCH;\n    }\n\n    return new Instant(seconds, nanoOfSecond);\n  };\n\n  Instant._validate = function _validate(seconds, nanoOfSecond) {\n    if (seconds < Instant.MIN_SECONDS || seconds > Instant.MAX_SECONDS) {\n      throw new DateTimeException('Instant exceeds minimum or maximum instant');\n    }\n\n    if (nanoOfSecond < 0 || nanoOfSecond > LocalTime.NANOS_PER_SECOND) {\n      throw new DateTimeException('Instant exceeds minimum or maximum instant');\n    }\n  };\n\n  function Instant(seconds, nanoOfSecond) {\n    var _this;\n\n    _this = _Temporal.call(this) || this;\n\n    Instant._validate(seconds, nanoOfSecond);\n\n    _this._seconds = MathUtil.safeToInt(seconds);\n    _this._nanos = MathUtil.safeToInt(nanoOfSecond);\n    return _this;\n  }\n\n  var _proto = Instant.prototype;\n\n  _proto.isSupported = function isSupported(fieldOrUnit) {\n    if (fieldOrUnit instanceof ChronoField) {\n      return fieldOrUnit === ChronoField.INSTANT_SECONDS || fieldOrUnit === ChronoField.NANO_OF_SECOND || fieldOrUnit === ChronoField.MICRO_OF_SECOND || fieldOrUnit === ChronoField.MILLI_OF_SECOND;\n    }\n\n    if (fieldOrUnit instanceof ChronoUnit) {\n      return fieldOrUnit.isTimeBased() || fieldOrUnit === ChronoUnit.DAYS;\n    }\n\n    return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);\n  };\n\n  _proto.range = function range(field) {\n    return _Temporal.prototype.range.call(this, field);\n  };\n\n  _proto.get = function get(field) {\n    return this.getLong(field);\n  };\n\n  _proto.getLong = function getLong(field) {\n    if (field instanceof ChronoField) {\n      switch (field) {\n        case ChronoField.NANO_OF_SECOND:\n          return this._nanos;\n\n        case ChronoField.MICRO_OF_SECOND:\n          return MathUtil.intDiv(this._nanos, 1000);\n\n        case ChronoField.MILLI_OF_SECOND:\n          return MathUtil.intDiv(this._nanos, NANOS_PER_MILLI);\n\n        case ChronoField.INSTANT_SECONDS:\n          return this._seconds;\n      }\n\n      throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);\n    }\n\n    return field.getFrom(this);\n  };\n\n  _proto.epochSecond = function epochSecond() {\n    return this._seconds;\n  };\n\n  _proto.nano = function nano() {\n    return this._nanos;\n  };\n\n  _proto.withAdjuster = function withAdjuster(adjuster) {\n    requireNonNull(adjuster, 'adjuster');\n    return adjuster.adjustInto(this);\n  };\n\n  _proto.withFieldValue = function withFieldValue(field, newValue) {\n    requireNonNull(field, 'field');\n\n    if (field instanceof ChronoField) {\n      field.checkValidValue(newValue);\n\n      switch (field) {\n        case ChronoField.MILLI_OF_SECOND:\n          {\n            var nval = newValue * NANOS_PER_MILLI;\n            return nval !== this._nanos ? Instant._create(this._seconds, nval) : this;\n          }\n\n        case ChronoField.MICRO_OF_SECOND:\n          {\n            var _nval = newValue * 1000;\n\n            return _nval !== this._nanos ? Instant._create(this._seconds, _nval) : this;\n          }\n\n        case ChronoField.NANO_OF_SECOND:\n          return newValue !== this._nanos ? Instant._create(this._seconds, newValue) : this;\n\n        case ChronoField.INSTANT_SECONDS:\n          return newValue !== this._seconds ? Instant._create(newValue, this._nanos) : this;\n      }\n\n      throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);\n    }\n\n    return field.adjustInto(this, newValue);\n  };\n\n  _proto.truncatedTo = function truncatedTo(unit) {\n    requireNonNull(unit, 'unit');\n\n    if (unit === ChronoUnit.NANOS) {\n      return this;\n    }\n\n    var unitDur = unit.duration();\n\n    if (unitDur.seconds() > LocalTime.SECONDS_PER_DAY) {\n      throw new DateTimeException('Unit is too large to be used for truncation');\n    }\n\n    var dur = unitDur.toNanos();\n\n    if (MathUtil.intMod(LocalTime.NANOS_PER_DAY, dur) !== 0) {\n      throw new DateTimeException('Unit must divide into a standard day without remainder');\n    }\n\n    var nod = MathUtil.intMod(this._seconds, LocalTime.SECONDS_PER_DAY) * LocalTime.NANOS_PER_SECOND + this._nanos;\n\n    var result = MathUtil.intDiv(nod, dur) * dur;\n    return this.plusNanos(result - nod);\n  };\n\n  _proto.plusAmount = function plusAmount(amount) {\n    requireNonNull(amount, 'amount');\n    return amount.addTo(this);\n  };\n\n  _proto.plusAmountUnit = function plusAmountUnit(amountToAdd, unit) {\n    requireNonNull(amountToAdd, 'amountToAdd');\n    requireNonNull(unit, 'unit');\n    requireInstance(unit, TemporalUnit);\n\n    if (unit instanceof ChronoUnit) {\n      switch (unit) {\n        case ChronoUnit.NANOS:\n          return this.plusNanos(amountToAdd);\n\n        case ChronoUnit.MICROS:\n          return this._plus(MathUtil.intDiv(amountToAdd, 1000000), MathUtil.intMod(amountToAdd, 1000000) * 1000);\n\n        case ChronoUnit.MILLIS:\n          return this.plusMillis(amountToAdd);\n\n        case ChronoUnit.SECONDS:\n          return this.plusSeconds(amountToAdd);\n\n        case ChronoUnit.MINUTES:\n          return this.plusSeconds(MathUtil.safeMultiply(amountToAdd, LocalTime.SECONDS_PER_MINUTE));\n\n        case ChronoUnit.HOURS:\n          return this.plusSeconds(MathUtil.safeMultiply(amountToAdd, LocalTime.SECONDS_PER_HOUR));\n\n        case ChronoUnit.HALF_DAYS:\n          return this.plusSeconds(MathUtil.safeMultiply(amountToAdd, LocalTime.SECONDS_PER_DAY / 2));\n\n        case ChronoUnit.DAYS:\n          return this.plusSeconds(MathUtil.safeMultiply(amountToAdd, LocalTime.SECONDS_PER_DAY));\n      }\n\n      throw new UnsupportedTemporalTypeException('Unsupported unit: ' + unit);\n    }\n\n    return unit.addTo(this, amountToAdd);\n  };\n\n  _proto.plusSeconds = function plusSeconds(secondsToAdd) {\n    return this._plus(secondsToAdd, 0);\n  };\n\n  _proto.plusMillis = function plusMillis(millisToAdd) {\n    return this._plus(MathUtil.intDiv(millisToAdd, 1000), MathUtil.intMod(millisToAdd, 1000) * NANOS_PER_MILLI);\n  };\n\n  _proto.plusNanos = function plusNanos(nanosToAdd) {\n    return this._plus(0, nanosToAdd);\n  };\n\n  _proto._plus = function _plus(secondsToAdd, nanosToAdd) {\n    if (secondsToAdd === 0 && nanosToAdd === 0) {\n      return this;\n    }\n\n    var epochSec = this._seconds + secondsToAdd;\n    epochSec = epochSec + MathUtil.intDiv(nanosToAdd, LocalTime.NANOS_PER_SECOND);\n    var nanoAdjustment = this._nanos + nanosToAdd % LocalTime.NANOS_PER_SECOND;\n    return Instant.ofEpochSecond(epochSec, nanoAdjustment);\n  };\n\n  _proto.minusAmount = function minusAmount(amount) {\n    requireNonNull(amount, 'amount');\n    return amount.subtractFrom(this);\n  };\n\n  _proto.minusAmountUnit = function minusAmountUnit(amountToSubtract, unit) {\n    return this.plusAmountUnit(-1 * amountToSubtract, unit);\n  };\n\n  _proto.minusSeconds = function minusSeconds(secondsToSubtract) {\n    return this.plusSeconds(secondsToSubtract * -1);\n  };\n\n  _proto.minusMillis = function minusMillis(millisToSubtract) {\n    return this.plusMillis(-1 * millisToSubtract);\n  };\n\n  _proto.minusNanos = function minusNanos(nanosToSubtract) {\n    return this.plusNanos(-1 * nanosToSubtract);\n  };\n\n  _proto.query = function query(_query) {\n    requireNonNull(_query, 'query');\n\n    if (_query === TemporalQueries.precision()) {\n      return ChronoUnit.NANOS;\n    }\n\n    if (_query === TemporalQueries.localDate() || _query === TemporalQueries.localTime() || _query === TemporalQueries.chronology() || _query === TemporalQueries.zoneId() || _query === TemporalQueries.zone() || _query === TemporalQueries.offset()) {\n      return null;\n    }\n\n    return _query.queryFrom(this);\n  };\n\n  _proto.adjustInto = function adjustInto(temporal) {\n    requireNonNull(temporal, 'temporal');\n    return temporal.with(ChronoField.INSTANT_SECONDS, this._seconds).with(ChronoField.NANO_OF_SECOND, this._nanos);\n  };\n\n  _proto.until = function until(endExclusive, unit) {\n    requireNonNull(endExclusive, 'endExclusive');\n    requireNonNull(unit, 'unit');\n    var end = Instant.from(endExclusive);\n\n    if (unit instanceof ChronoUnit) {\n      switch (unit) {\n        case ChronoUnit.NANOS:\n          return this._nanosUntil(end);\n\n        case ChronoUnit.MICROS:\n          return MathUtil.intDiv(this._nanosUntil(end), 1000);\n\n        case ChronoUnit.MILLIS:\n          return MathUtil.safeSubtract(end.toEpochMilli(), this.toEpochMilli());\n\n        case ChronoUnit.SECONDS:\n          return this._secondsUntil(end);\n\n        case ChronoUnit.MINUTES:\n          return MathUtil.intDiv(this._secondsUntil(end), LocalTime.SECONDS_PER_MINUTE);\n\n        case ChronoUnit.HOURS:\n          return MathUtil.intDiv(this._secondsUntil(end), LocalTime.SECONDS_PER_HOUR);\n\n        case ChronoUnit.HALF_DAYS:\n          return MathUtil.intDiv(this._secondsUntil(end), 12 * LocalTime.SECONDS_PER_HOUR);\n\n        case ChronoUnit.DAYS:\n          return MathUtil.intDiv(this._secondsUntil(end), LocalTime.SECONDS_PER_DAY);\n      }\n\n      throw new UnsupportedTemporalTypeException('Unsupported unit: ' + unit);\n    }\n\n    return unit.between(this, end);\n  };\n\n  _proto._nanosUntil = function _nanosUntil(end) {\n    var secsDiff = MathUtil.safeSubtract(end.epochSecond(), this.epochSecond());\n    var totalNanos = MathUtil.safeMultiply(secsDiff, LocalTime.NANOS_PER_SECOND);\n    return MathUtil.safeAdd(totalNanos, end.nano() - this.nano());\n  };\n\n  _proto._secondsUntil = function _secondsUntil(end) {\n    var secsDiff = MathUtil.safeSubtract(end.epochSecond(), this.epochSecond());\n    var nanosDiff = end.nano() - this.nano();\n\n    if (secsDiff > 0 && nanosDiff < 0) {\n      secsDiff--;\n    } else if (secsDiff < 0 && nanosDiff > 0) {\n      secsDiff++;\n    }\n\n    return secsDiff;\n  };\n\n  _proto.atOffset = function atOffset(offset) {\n    return OffsetDateTime.ofInstant(this, offset);\n  };\n\n  _proto.atZone = function atZone(zone) {\n    return ZonedDateTime.ofInstant(this, zone);\n  };\n\n  _proto.toEpochMilli = function toEpochMilli() {\n    var millis = MathUtil.safeMultiply(this._seconds, 1000);\n    return millis + MathUtil.intDiv(this._nanos, NANOS_PER_MILLI);\n  };\n\n  _proto.compareTo = function compareTo(otherInstant) {\n    requireNonNull(otherInstant, 'otherInstant');\n    requireInstance(otherInstant, Instant, 'otherInstant');\n    var cmp = MathUtil.compareNumbers(this._seconds, otherInstant._seconds);\n\n    if (cmp !== 0) {\n      return cmp;\n    }\n\n    return this._nanos - otherInstant._nanos;\n  };\n\n  _proto.isAfter = function isAfter(otherInstant) {\n    return this.compareTo(otherInstant) > 0;\n  };\n\n  _proto.isBefore = function isBefore(otherInstant) {\n    return this.compareTo(otherInstant) < 0;\n  };\n\n  _proto.equals = function equals(other) {\n    if (this === other) {\n      return true;\n    }\n\n    if (other instanceof Instant) {\n      return this.epochSecond() === other.epochSecond() && this.nano() === other.nano();\n    }\n\n    return false;\n  };\n\n  _proto.hashCode = function hashCode() {\n    return MathUtil.hashCode(this._seconds, this._nanos);\n  };\n\n  _proto.toString = function toString() {\n    return DateTimeFormatter.ISO_INSTANT.format(this);\n  };\n\n  _proto.toJSON = function toJSON() {\n    return this.toString();\n  };\n\n  return Instant;\n}(Temporal);\nfunction _init$l() {\n  Instant.MIN_SECONDS = -31619119219200;\n  Instant.MAX_SECONDS = 31494816403199;\n  Instant.EPOCH = new Instant(0, 0);\n  Instant.MIN = Instant.ofEpochSecond(Instant.MIN_SECONDS, 0);\n  Instant.MAX = Instant.ofEpochSecond(Instant.MAX_SECONDS, 999999999);\n  Instant.FROM = createTemporalQuery('Instant.FROM', function (temporal) {\n    return Instant.from(temporal);\n  });\n}\n\nvar Clock = function () {\n  function Clock() {}\n\n  Clock.systemUTC = function systemUTC() {\n    return new SystemClock(ZoneOffset.UTC);\n  };\n\n  Clock.systemDefaultZone = function systemDefaultZone() {\n    return new SystemClock(ZoneId.systemDefault());\n  };\n\n  Clock.system = function system(zone) {\n    return new SystemClock(zone);\n  };\n\n  Clock.fixed = function fixed(fixedInstant, zoneId) {\n    return new FixedClock(fixedInstant, zoneId);\n  };\n\n  Clock.offset = function offset(baseClock, duration) {\n    return new OffsetClock(baseClock, duration);\n  };\n\n  var _proto = Clock.prototype;\n\n  _proto.millis = function millis() {\n    abstractMethodFail('Clock.millis');\n  };\n\n  _proto.instant = function instant() {\n    abstractMethodFail('Clock.instant');\n  };\n\n  _proto.zone = function zone() {\n    abstractMethodFail('Clock.zone');\n  };\n\n  _proto.withZone = function withZone() {\n    abstractMethodFail('Clock.withZone');\n  };\n\n  return Clock;\n}();\n\nvar SystemClock = function (_Clock) {\n  _inheritsLoose(SystemClock, _Clock);\n\n  function SystemClock(zone) {\n    var _this;\n\n    requireNonNull(zone, 'zone');\n    _this = _Clock.call(this) || this;\n    _this._zone = zone;\n    return _this;\n  }\n\n  var _proto2 = SystemClock.prototype;\n\n  _proto2.zone = function zone() {\n    return this._zone;\n  };\n\n  _proto2.millis = function millis() {\n    return new Date().getTime();\n  };\n\n  _proto2.instant = function instant() {\n    return Instant.ofEpochMilli(this.millis());\n  };\n\n  _proto2.equals = function equals(obj) {\n    if (obj instanceof SystemClock) {\n      return this._zone.equals(obj._zone);\n    }\n\n    return false;\n  };\n\n  _proto2.withZone = function withZone(zone) {\n    if (zone.equals(this._zone)) {\n      return this;\n    }\n\n    return new SystemClock(zone);\n  };\n\n  _proto2.toString = function toString() {\n    return 'SystemClock[' + this._zone.toString() + ']';\n  };\n\n  return SystemClock;\n}(Clock);\n\nvar FixedClock = function (_Clock2) {\n  _inheritsLoose(FixedClock, _Clock2);\n\n  function FixedClock(fixedInstant, zoneId) {\n    var _this2;\n\n    _this2 = _Clock2.call(this) || this;\n    _this2._instant = fixedInstant;\n    _this2._zoneId = zoneId;\n    return _this2;\n  }\n\n  var _proto3 = FixedClock.prototype;\n\n  _proto3.instant = function instant() {\n    return this._instant;\n  };\n\n  _proto3.millis = function millis() {\n    return this._instant.toEpochMilli();\n  };\n\n  _proto3.zone = function zone() {\n    return this._zoneId;\n  };\n\n  _proto3.toString = function toString() {\n    return 'FixedClock[]';\n  };\n\n  _proto3.equals = function equals(obj) {\n    if (obj instanceof FixedClock) {\n      return this._instant.equals(obj._instant) && this._zoneId.equals(obj._zoneId);\n    }\n\n    return false;\n  };\n\n  _proto3.withZone = function withZone(zone) {\n    if (zone.equals(this._zoneId)) {\n      return this;\n    }\n\n    return new FixedClock(this._instant, zone);\n  };\n\n  return FixedClock;\n}(Clock);\n\nvar OffsetClock = function (_Clock3) {\n  _inheritsLoose(OffsetClock, _Clock3);\n\n  function OffsetClock(baseClock, offset) {\n    var _this3;\n\n    _this3 = _Clock3.call(this) || this;\n    _this3._baseClock = baseClock;\n    _this3._offset = offset;\n    return _this3;\n  }\n\n  var _proto4 = OffsetClock.prototype;\n\n  _proto4.zone = function zone() {\n    return this._baseClock.zone();\n  };\n\n  _proto4.withZone = function withZone(zone) {\n    if (zone.equals(this._baseClock.zone())) {\n      return this;\n    }\n\n    return new OffsetClock(this._baseClock.withZone(zone), this._offset);\n  };\n\n  _proto4.millis = function millis() {\n    return this._baseClock.millis() + this._offset.toMillis();\n  };\n\n  _proto4.instant = function instant() {\n    return this._baseClock.instant().plus(this._offset);\n  };\n\n  _proto4.equals = function equals(obj) {\n    if (obj instanceof OffsetClock) {\n      return this._baseClock.equals(obj._baseClock) && this._offset.equals(obj._offset);\n    }\n\n    return false;\n  };\n\n  _proto4.toString = function toString() {\n    return 'OffsetClock[' + this._baseClock + ',' + this._offset + ']';\n  };\n\n  return OffsetClock;\n}(Clock);\n\n/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\nvar ZoneOffsetTransition = function () {\n  ZoneOffsetTransition.of = function of(transition, offsetBefore, offsetAfter) {\n    return new ZoneOffsetTransition(transition, offsetBefore, offsetAfter);\n  };\n\n  function ZoneOffsetTransition(transition, offsetBefore, offsetAfter) {\n    requireNonNull(transition, 'transition');\n    requireNonNull(offsetBefore, 'offsetBefore');\n    requireNonNull(offsetAfter, 'offsetAfter');\n\n    if (offsetBefore.equals(offsetAfter)) {\n      throw new IllegalArgumentException('Offsets must not be equal');\n    }\n\n    if (transition.nano() !== 0) {\n      throw new IllegalArgumentException('Nano-of-second must be zero');\n    }\n\n    if (transition instanceof LocalDateTime) {\n      this._transition = transition;\n    } else {\n      this._transition = LocalDateTime.ofEpochSecond(transition, 0, offsetBefore);\n    }\n\n    this._offsetBefore = offsetBefore;\n    this._offsetAfter = offsetAfter;\n  }\n\n  var _proto = ZoneOffsetTransition.prototype;\n\n  _proto.instant = function instant() {\n    return this._transition.toInstant(this._offsetBefore);\n  };\n\n  _proto.toEpochSecond = function toEpochSecond() {\n    return this._transition.toEpochSecond(this._offsetBefore);\n  };\n\n  _proto.dateTimeBefore = function dateTimeBefore() {\n    return this._transition;\n  };\n\n  _proto.dateTimeAfter = function dateTimeAfter() {\n    return this._transition.plusSeconds(this.durationSeconds());\n  };\n\n  _proto.offsetBefore = function offsetBefore() {\n    return this._offsetBefore;\n  };\n\n  _proto.offsetAfter = function offsetAfter() {\n    return this._offsetAfter;\n  };\n\n  _proto.duration = function duration() {\n    return Duration.ofSeconds(this.durationSeconds());\n  };\n\n  _proto.durationSeconds = function durationSeconds() {\n    return this._offsetAfter.totalSeconds() - this._offsetBefore.totalSeconds();\n  };\n\n  _proto.isGap = function isGap() {\n    return this._offsetAfter.totalSeconds() > this._offsetBefore.totalSeconds();\n  };\n\n  _proto.isOverlap = function isOverlap() {\n    return this._offsetAfter.totalSeconds() < this._offsetBefore.totalSeconds();\n  };\n\n  _proto.isValidOffset = function isValidOffset(offset) {\n    return this.isGap() ? false : this._offsetBefore.equals(offset) || this._offsetAfter.equals(offset);\n  };\n\n  _proto.validOffsets = function validOffsets() {\n    if (this.isGap()) {\n      return [];\n    } else {\n      return [this._offsetBefore, this._offsetAfter];\n    }\n  };\n\n  _proto.compareTo = function compareTo(transition) {\n    return this.instant().compareTo(transition.instant());\n  };\n\n  _proto.equals = function equals(other) {\n    if (other === this) {\n      return true;\n    }\n\n    if (other instanceof ZoneOffsetTransition) {\n      var d = other;\n      return this._transition.equals(d._transition) && this._offsetBefore.equals(d.offsetBefore()) && this._offsetAfter.equals(d.offsetAfter());\n    }\n\n    return false;\n  };\n\n  _proto.hashCode = function hashCode() {\n    return this._transition.hashCode() ^ this._offsetBefore.hashCode() ^ this._offsetAfter.hashCode() >>> 16;\n  };\n\n  _proto.toString = function toString() {\n    return 'Transition[' + (this.isGap() ? 'Gap' : 'Overlap') + ' at ' + this._transition.toString() + this._offsetBefore.toString() + ' to ' + this._offsetAfter + ']';\n  };\n\n  return ZoneOffsetTransition;\n}();\n\n/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\nfunction _init$m() {\n  TemporalQueries.ZONE_ID = createTemporalQuery('ZONE_ID', function (temporal) {\n    return temporal.query(TemporalQueries.ZONE_ID);\n  });\n  TemporalQueries.CHRONO = createTemporalQuery('CHRONO', function (temporal) {\n    return temporal.query(TemporalQueries.CHRONO);\n  });\n  TemporalQueries.PRECISION = createTemporalQuery('PRECISION', function (temporal) {\n    return temporal.query(TemporalQueries.PRECISION);\n  });\n  TemporalQueries.OFFSET = createTemporalQuery('OFFSET', function (temporal) {\n    if (temporal.isSupported(ChronoField.OFFSET_SECONDS)) {\n      return ZoneOffset.ofTotalSeconds(temporal.get(ChronoField.OFFSET_SECONDS));\n    }\n\n    return null;\n  });\n  TemporalQueries.ZONE = createTemporalQuery('ZONE', function (temporal) {\n    var zone = temporal.query(TemporalQueries.ZONE_ID);\n    return zone != null ? zone : temporal.query(TemporalQueries.OFFSET);\n  });\n  TemporalQueries.LOCAL_DATE = createTemporalQuery('LOCAL_DATE', function (temporal) {\n    if (temporal.isSupported(ChronoField.EPOCH_DAY)) {\n      return LocalDate.ofEpochDay(temporal.getLong(ChronoField.EPOCH_DAY));\n    }\n\n    return null;\n  });\n  TemporalQueries.LOCAL_TIME = createTemporalQuery('LOCAL_TIME', function (temporal) {\n    if (temporal.isSupported(ChronoField.NANO_OF_DAY)) {\n      return LocalTime.ofNanoOfDay(temporal.getLong(ChronoField.NANO_OF_DAY));\n    }\n\n    return null;\n  });\n}\n\nvar SystemDefaultZoneRules = function (_ZoneRules) {\n  _inheritsLoose(SystemDefaultZoneRules, _ZoneRules);\n\n  function SystemDefaultZoneRules() {\n    return _ZoneRules.apply(this, arguments) || this;\n  }\n\n  var _proto = SystemDefaultZoneRules.prototype;\n\n  _proto.isFixedOffset = function isFixedOffset() {\n    return false;\n  };\n\n  _proto.offsetOfInstant = function offsetOfInstant(instant) {\n    var offsetInMinutes = new Date(instant.toEpochMilli()).getTimezoneOffset();\n    return ZoneOffset.ofTotalMinutes(offsetInMinutes * -1);\n  };\n\n  _proto.offsetOfEpochMilli = function offsetOfEpochMilli(epochMilli) {\n    var offsetInMinutes = new Date(epochMilli).getTimezoneOffset();\n    return ZoneOffset.ofTotalMinutes(offsetInMinutes * -1);\n  };\n\n  _proto.offsetOfLocalDateTime = function offsetOfLocalDateTime(localDateTime) {\n    var epochMilli = localDateTime.toEpochSecond(ZoneOffset.UTC) * 1000;\n    var offsetInMinutesBeforePossibleTransition = new Date(epochMilli).getTimezoneOffset();\n    var epochMilliSystemZone = epochMilli + offsetInMinutesBeforePossibleTransition * 60000;\n    var offsetInMinutesAfterPossibleTransition = new Date(epochMilliSystemZone).getTimezoneOffset();\n    return ZoneOffset.ofTotalMinutes(offsetInMinutesAfterPossibleTransition * -1);\n  };\n\n  _proto.validOffsets = function validOffsets(localDateTime) {\n    return [this.offsetOfLocalDateTime(localDateTime)];\n  };\n\n  _proto.transition = function transition() {\n    return null;\n  };\n\n  _proto.standardOffset = function standardOffset(instant) {\n    return this.offsetOfInstant(instant);\n  };\n\n  _proto.daylightSavings = function daylightSavings() {\n    this._throwNotSupported();\n  };\n\n  _proto.isDaylightSavings = function isDaylightSavings() {\n    this._throwNotSupported();\n  };\n\n  _proto.isValidOffset = function isValidOffset(dateTime, offset) {\n    return this.offsetOfLocalDateTime(dateTime).equals(offset);\n  };\n\n  _proto.nextTransition = function nextTransition() {\n    this._throwNotSupported();\n  };\n\n  _proto.previousTransition = function previousTransition() {\n    this._throwNotSupported();\n  };\n\n  _proto.transitions = function transitions() {\n    this._throwNotSupported();\n  };\n\n  _proto.transitionRules = function transitionRules() {\n    this._throwNotSupported();\n  };\n\n  _proto._throwNotSupported = function _throwNotSupported() {\n    throw new DateTimeException('not supported operation');\n  };\n\n  _proto.equals = function equals(other) {\n    if (this === other || other instanceof SystemDefaultZoneRules) {\n      return true;\n    } else {\n      return false;\n    }\n  };\n\n  _proto.toString = function toString() {\n    return 'SYSTEM';\n  };\n\n  return SystemDefaultZoneRules;\n}(ZoneRules);\n\nvar SystemDefaultZoneId = function (_ZoneId) {\n  _inheritsLoose(SystemDefaultZoneId, _ZoneId);\n\n  function SystemDefaultZoneId() {\n    var _this;\n\n    _this = _ZoneId.call(this) || this;\n    _this._rules = new SystemDefaultZoneRules();\n    return _this;\n  }\n\n  var _proto = SystemDefaultZoneId.prototype;\n\n  _proto.rules = function rules() {\n    return this._rules;\n  };\n\n  _proto.equals = function equals(other) {\n    if (this === other) {\n      return true;\n    }\n\n    return false;\n  };\n\n  _proto.id = function id() {\n    return 'SYSTEM';\n  };\n\n  return SystemDefaultZoneId;\n}(ZoneId);\n\n/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\nvar ZoneIdFactory = function () {\n  function ZoneIdFactory() {}\n\n  ZoneIdFactory.systemDefault = function systemDefault() {\n    return SYSTEM_DEFAULT_ZONE_ID_INSTANCE;\n  };\n\n  ZoneIdFactory.getAvailableZoneIds = function getAvailableZoneIds() {\n    return ZoneRulesProvider.getAvailableZoneIds();\n  };\n\n  ZoneIdFactory.of = function of(zoneId) {\n    requireNonNull(zoneId, 'zoneId');\n\n    if (zoneId === 'Z') {\n      return ZoneOffset.UTC;\n    }\n\n    if (zoneId.length === 1) {\n      throw new DateTimeException('Invalid zone: ' + zoneId);\n    }\n\n    if (StringUtil.startsWith(zoneId, '+') || StringUtil.startsWith(zoneId, '-')) {\n      return ZoneOffset.of(zoneId);\n    }\n\n    if (zoneId === 'UTC' || zoneId === 'GMT' || zoneId === 'GMT0' || zoneId === 'UT') {\n      return new ZoneRegion(zoneId, ZoneOffset.UTC.rules());\n    }\n\n    if (StringUtil.startsWith(zoneId, 'UTC+') || StringUtil.startsWith(zoneId, 'GMT+') || StringUtil.startsWith(zoneId, 'UTC-') || StringUtil.startsWith(zoneId, 'GMT-')) {\n      var offset = ZoneOffset.of(zoneId.substring(3));\n\n      if (offset.totalSeconds() === 0) {\n        return new ZoneRegion(zoneId.substring(0, 3), offset.rules());\n      }\n\n      return new ZoneRegion(zoneId.substring(0, 3) + offset.id(), offset.rules());\n    }\n\n    if (StringUtil.startsWith(zoneId, 'UT+') || StringUtil.startsWith(zoneId, 'UT-')) {\n      var _offset = ZoneOffset.of(zoneId.substring(2));\n\n      if (_offset.totalSeconds() === 0) {\n        return new ZoneRegion('UT', _offset.rules());\n      }\n\n      return new ZoneRegion('UT' + _offset.id(), _offset.rules());\n    }\n\n    if (zoneId === 'SYSTEM') {\n      return ZoneId.systemDefault();\n    }\n\n    return ZoneRegion.ofId(zoneId);\n  };\n\n  ZoneIdFactory.ofOffset = function ofOffset(prefix, offset) {\n    requireNonNull(prefix, 'prefix');\n    requireNonNull(offset, 'offset');\n\n    if (prefix.length === 0) {\n      return offset;\n    }\n\n    if (prefix === 'GMT' || prefix === 'UTC' || prefix === 'UT') {\n      if (offset.totalSeconds() === 0) {\n        return new ZoneRegion(prefix, offset.rules());\n      }\n\n      return new ZoneRegion(prefix + offset.id(), offset.rules());\n    }\n\n    throw new IllegalArgumentException('Invalid prefix, must be GMT, UTC or UT: ' + prefix);\n  };\n\n  ZoneIdFactory.from = function from(temporal) {\n    requireNonNull(temporal, 'temporal');\n    var obj = temporal.query(TemporalQueries.zone());\n\n    if (obj == null) {\n      throw new DateTimeException('Unable to obtain ZoneId from TemporalAccessor: ' + temporal + ', type ' + (temporal.constructor != null ? temporal.constructor.name : ''));\n    }\n\n    return obj;\n  };\n\n  return ZoneIdFactory;\n}();\nvar SYSTEM_DEFAULT_ZONE_ID_INSTANCE = null;\nfunction _init$n() {\n  SYSTEM_DEFAULT_ZONE_ID_INSTANCE = new SystemDefaultZoneId();\n  ZoneId.systemDefault = ZoneIdFactory.systemDefault;\n  ZoneId.getAvailableZoneIds = ZoneIdFactory.getAvailableZoneIds;\n  ZoneId.of = ZoneIdFactory.of;\n  ZoneId.ofOffset = ZoneIdFactory.ofOffset;\n  ZoneId.from = ZoneIdFactory.from;\n  ZoneOffset.from = ZoneIdFactory.from;\n  ZoneId.SYSTEM = SYSTEM_DEFAULT_ZONE_ID_INSTANCE;\n  ZoneId.UTC = ZoneOffset.ofTotalSeconds(0);\n}\n\n/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\nvar isInit = false;\n\nfunction init() {\n  if (isInit) {\n    return;\n  }\n\n  isInit = true;\n  _init$1();\n  _init();\n  _init$2();\n  _init$3();\n  _init$k();\n  _init$8();\n  _init$m();\n  _init$4();\n  _init$l();\n  _init$i();\n  _init$j();\n  _init$d();\n  _init$5();\n  _init$c();\n  _init$b();\n  _init$6();\n  _init$7();\n  _init$g();\n  _init$n();\n  _init$e();\n  _init$a();\n  _init$9();\n  _init$h();\n  _init$f();\n}\n\ninit();\n\n/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\n\nvar ToNativeJsConverter = function () {\n  function ToNativeJsConverter(temporal, zone) {\n    var zonedDateTime;\n\n    if (temporal instanceof LocalDate) {\n      zone = zone == null ? ZoneId.systemDefault() : zone;\n      zonedDateTime = temporal.atStartOfDay(zone);\n    } else if (temporal instanceof LocalDateTime) {\n      zone = zone == null ? ZoneId.systemDefault() : zone;\n      zonedDateTime = temporal.atZone(zone);\n    } else if (temporal instanceof ZonedDateTime) {\n      if (zone == null) {\n        zonedDateTime = temporal;\n      } else {\n        zonedDateTime = temporal.withZoneSameInstant(zone);\n      }\n    } else {\n      throw new IllegalArgumentException('unsupported instance for convert operation:' + temporal);\n    }\n\n    this.instant = zonedDateTime.toInstant();\n  }\n\n  var _proto = ToNativeJsConverter.prototype;\n\n  _proto.toDate = function toDate() {\n    return new Date(this.instant.toEpochMilli());\n  };\n\n  _proto.toEpochMilli = function toEpochMilli() {\n    return this.instant.toEpochMilli();\n  };\n\n  return ToNativeJsConverter;\n}();\n\nfunction convert(temporal, zone) {\n  return new ToNativeJsConverter(temporal, zone);\n}\n\nvar NativeJsTemporal = function (_TemporalAccessor) {\n  _inheritsLoose(NativeJsTemporal, _TemporalAccessor);\n\n  function NativeJsTemporal(date, zone) {\n    var _this;\n\n    if (zone === void 0) {\n      zone = ZoneId.systemDefault();\n    }\n\n    _this = _TemporalAccessor.call(this) || this;\n    _this._zone = zone;\n\n    if (date instanceof Date) {\n      _this._epochMilli = date.getTime();\n      return _assertThisInitialized(_this);\n    } else if (typeof date.toDate === 'function' && date.toDate() instanceof Date) {\n      _this._epochMilli = date.toDate().getTime();\n      return _assertThisInitialized(_this);\n    }\n\n    assert(false, 'date must be either a javascript date or a moment');\n    return _this;\n  }\n\n  var _proto = NativeJsTemporal.prototype;\n\n  _proto.query = function query(_query) {\n    requireNonNull(_query, 'query');\n\n    if (_query === TemporalQueries.localDate()) {\n      return LocalDate.ofInstant(Instant.ofEpochMilli(this._epochMilli), this._zone);\n    } else if (_query === TemporalQueries.localTime()) {\n      return LocalTime.ofInstant(Instant.ofEpochMilli(this._epochMilli), this._zone);\n    } else if (_query === TemporalQueries.zone()) {\n      return this._zone;\n    }\n\n    return _TemporalAccessor.prototype.query.call(this, _query);\n  };\n\n  _proto.get = function get(field) {\n    return this.getLong(field);\n  };\n\n  _proto.getLong = function getLong(field) {\n    requireNonNull(field, 'field');\n\n    if (field instanceof ChronoField) {\n      switch (field) {\n        case ChronoField.NANO_OF_SECOND:\n          return MathUtil.floorMod(this._epochMilli, 1000) * 1000000;\n\n        case ChronoField.INSTANT_SECONDS:\n          return MathUtil.floorDiv(this._epochMilli, 1000);\n      }\n\n      throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);\n    }\n\n    return field.getFrom(this);\n  };\n\n  _proto.isSupported = function isSupported(field) {\n    return field === ChronoField.INSTANT_SECONDS || field === ChronoField.NANO_OF_SECOND;\n  };\n\n  return NativeJsTemporal;\n}(TemporalAccessor);\n\nfunction nativeJs(date, zone) {\n  return new NativeJsTemporal(date, zone);\n}\n\nfunction bindUse(jsJoda) {\n  var used = [];\n  return function use(fn) {\n    if (!~used.indexOf(fn)) {\n      fn(jsJoda);\n      used.push(fn);\n    }\n\n    return jsJoda;\n  };\n}\n\n/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */\nvar _ = {\n  assert: assert$1,\n  DateTimeBuilder: DateTimeBuilder,\n  DateTimeParseContext: DateTimeParseContext,\n  DateTimePrintContext: DateTimePrintContext,\n  MathUtil: MathUtil,\n  StringUtil: StringUtil,\n  StringBuilder: StringBuilder\n};\nvar jsJodaExports = {\n  _: _,\n  convert: convert,\n  nativeJs: nativeJs,\n  ArithmeticException: ArithmeticException,\n  DateTimeException: DateTimeException,\n  DateTimeParseException: DateTimeParseException,\n  IllegalArgumentException: IllegalArgumentException,\n  IllegalStateException: IllegalStateException,\n  UnsupportedTemporalTypeException: UnsupportedTemporalTypeException,\n  NullPointerException: NullPointerException,\n  Clock: Clock,\n  DayOfWeek: DayOfWeek,\n  Duration: Duration,\n  Instant: Instant,\n  LocalDate: LocalDate,\n  LocalTime: LocalTime,\n  LocalDateTime: LocalDateTime,\n  OffsetTime: OffsetTime,\n  OffsetDateTime: OffsetDateTime,\n  Month: Month,\n  MonthDay: MonthDay,\n  Period: Period,\n  Year: Year,\n  YearConstants: YearConstants,\n  YearMonth: YearMonth,\n  ZonedDateTime: ZonedDateTime,\n  ZoneOffset: ZoneOffset,\n  ZoneId: ZoneId,\n  ZoneRegion: ZoneRegion,\n  ZoneOffsetTransition: ZoneOffsetTransition,\n  ZoneRules: ZoneRules,\n  ZoneRulesProvider: ZoneRulesProvider,\n  ChronoLocalDate: ChronoLocalDate,\n  ChronoLocalDateTime: ChronoLocalDateTime,\n  ChronoZonedDateTime: ChronoZonedDateTime,\n  IsoChronology: IsoChronology,\n  ChronoField: ChronoField,\n  ChronoUnit: ChronoUnit,\n  IsoFields: IsoFields,\n  Temporal: Temporal,\n  TemporalAccessor: TemporalAccessor,\n  TemporalAdjuster: TemporalAdjuster,\n  TemporalAdjusters: TemporalAdjusters,\n  TemporalAmount: TemporalAmount,\n  TemporalField: TemporalField,\n  TemporalQueries: TemporalQueries,\n  TemporalQuery: TemporalQuery,\n  TemporalUnit: TemporalUnit,\n  ValueRange: ValueRange,\n  DateTimeFormatter: DateTimeFormatter,\n  DateTimeFormatterBuilder: DateTimeFormatterBuilder,\n  DecimalStyle: DecimalStyle,\n  ResolverStyle: ResolverStyle,\n  SignStyle: SignStyle,\n  TextStyle: TextStyle\n};\nvar use = bindUse(jsJodaExports);\njsJodaExports.use = use;\n\nexport { ArithmeticException, ChronoField, ChronoLocalDate, ChronoLocalDateTime, ChronoUnit, ChronoZonedDateTime, Clock, DateTimeException, DateTimeFormatter, DateTimeFormatterBuilder, DateTimeParseException, DayOfWeek, DecimalStyle, Duration, IllegalArgumentException, IllegalStateException, Instant, IsoChronology, IsoFields, LocalDate, LocalDateTime, LocalTime, Month, MonthDay, NullPointerException, OffsetDateTime, OffsetTime, Period, ResolverStyle, SignStyle, Temporal, TemporalAccessor, TemporalAdjuster, TemporalAdjusters, TemporalAmount, TemporalField, TemporalQueries, TemporalQuery, TemporalUnit, TextStyle, UnsupportedTemporalTypeException, ValueRange, Year, YearConstants, YearMonth, ZoneId, ZoneOffset, ZoneOffsetTransition, ZoneRegion, ZoneRules, ZoneRulesProvider, ZonedDateTime, _, convert, nativeJs, use };\n",null,"/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StringsKt\")\n@file:Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\n\npackage kotlin.text\n\nimport kotlin.contracts.*\n\n/**\n * A mutable sequence of characters.\n *\n * String builder can be used to efficiently perform multiple string manipulation operations.\n */\nexpect class StringBuilder : Appendable, CharSequence {\n    /** Constructs an empty string builder. */\n    constructor()\n\n    /** Constructs an empty string builder with the specified initial [capacity]. */\n    constructor(capacity: Int)\n\n    /** Constructs a string builder that contains the same characters as the specified [content] char sequence. */\n    constructor(content: CharSequence)\n\n    /** Constructs a string builder that contains the same characters as the specified [content] string. */\n    @SinceKotlin(\"1.3\")\n//    @ExperimentalStdlibApi\n    constructor(content: String)\n\n    override val length: Int\n\n    override operator fun get(index: Int): Char\n\n    override fun subSequence(startIndex: Int, endIndex: Int): CharSequence\n\n    override fun append(value: Char): StringBuilder\n    override fun append(value: CharSequence?): StringBuilder\n    override fun append(value: CharSequence?, startIndex: Int, endIndex: Int): StringBuilder\n\n    /**\n     * Reverses the contents of this string builder and returns this instance.\n     *\n     * Surrogate pairs included in this string builder are treated as single characters.\n     * Therefore, the order of the high-low surrogates is never reversed.\n     *\n     * Note that the reverse operation may produce new surrogate pairs that were unpaired low-surrogates and high-surrogates before the operation.\n     * For example, reversing `\"\\uDC00\\uD800\"` produces `\"\\uD800\\uDC00\"` which is a valid surrogate pair.\n     */\n    fun reverse(): StringBuilder\n\n    /**\n     * Appends the string representation of the specified object [value] to this string builder and returns this instance.\n     *\n     * The overall effect is exactly as if the [value] were converted to a string by the `value.toString()` method,\n     * and then that string was appended to this string builder.\n     */\n    fun append(value: Any?): StringBuilder\n\n    /**\n     * Appends the string representation of the specified boolean [value] to this string builder and returns this instance.\n     *\n     * The overall effect is exactly as if the [value] were converted to a string by the `value.toString()` method,\n     * and then that string was appended to this string builder.\n     */\n    @SinceKotlin(\"1.3\")\n    fun append(value: Boolean): StringBuilder\n\n    /**\n     * Appends characters in the specified character array [value] to this string builder and returns this instance.\n     *\n     * Characters are appended in order, starting at the index 0.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun append(value: CharArray): StringBuilder\n\n    /**\n     * Appends the specified string [value] to this string builder and returns this instance.\n     *\n     * If [value] is `null`, then the four characters `\"null\"` are appended.\n     */\n    @SinceKotlin(\"1.3\")\n    fun append(value: String?): StringBuilder\n\n    /**\n     * Returns the current capacity of this string builder.\n     *\n     * The capacity is the maximum length this string builder can have before an allocation occurs.\n     */\n    @SinceKotlin(\"1.3\")\n//    @ExperimentalStdlibApi\n    @Deprecated(\"Obtaining StringBuilder capacity is not supported in JS and common code.\", level = DeprecationLevel.ERROR)\n    fun capacity(): Int\n\n    /**\n     * Ensures that the capacity of this string builder is at least equal to the specified [minimumCapacity].\n     *\n     * If the current capacity is less than the [minimumCapacity], a new backing storage is allocated with greater capacity.\n     * Otherwise, this method takes no action and simply returns.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun ensureCapacity(minimumCapacity: Int)\n\n    /**\n     * Returns the index within this string builder of the first occurrence of the specified [string].\n     *\n     * Returns `-1` if the specified [string] does not occur in this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun indexOf(string: String): Int\n\n    /**\n     * Returns the index within this string builder of the first occurrence of the specified [string],\n     * starting at the specified [startIndex].\n     *\n     * Returns `-1` if the specified [string] does not occur in this string builder starting at the specified [startIndex].\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun indexOf(string: String, startIndex: Int): Int\n\n    /**\n     * Returns the index within this string builder of the last occurrence of the specified [string].\n     * The last occurrence of empty string `\"\"` is considered to be at the index equal to `this.length`.\n     *\n     * Returns `-1` if the specified [string] does not occur in this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun lastIndexOf(string: String): Int\n\n    /**\n     * Returns the index within this string builder of the last occurrence of the specified [string],\n     * starting from the specified [startIndex] toward the beginning.\n     *\n     * Returns `-1` if the specified [string] does not occur in this string builder starting at the specified [startIndex].\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun lastIndexOf(string: String, startIndex: Int): Int\n\n    /**\n     * Inserts the string representation of the specified boolean [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The overall effect is exactly as if the [value] were converted to a string by the `value.toString()` method,\n     * and then that string was inserted into this string builder at the specified [index].\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun insert(index: Int, value: Boolean): StringBuilder\n\n    /**\n     * Inserts the specified character [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun insert(index: Int, value: Char): StringBuilder\n\n    /**\n     * Inserts characters in the specified character array [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The inserted characters go in same order as in the [value] character array, starting at [index].\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun insert(index: Int, value: CharArray): StringBuilder\n\n    /**\n     * Inserts characters in the specified character sequence [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The inserted characters go in the same order as in the [value] character sequence, starting at [index].\n     *\n     * @param index the position in this string builder to insert at.\n     * @param value the character sequence from which characters are inserted. If [value] is `null`, then the four characters `\"null\"` are inserted.\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun insert(index: Int, value: CharSequence?): StringBuilder\n\n    /**\n     * Inserts the string representation of the specified object [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The overall effect is exactly as if the [value] were converted to a string by the `value.toString()` method,\n     * and then that string was inserted into this string builder at the specified [index].\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun insert(index: Int, value: Any?): StringBuilder\n\n    /**\n     * Inserts the string [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * If [value] is `null`, then the four characters `\"null\"` are inserted.\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun insert(index: Int, value: String?): StringBuilder\n\n    /**\n     *  Sets the length of this string builder to the specified [newLength].\n     *\n     *  If the [newLength] is less than the current length, it is changed to the specified [newLength].\n     *  Otherwise, null characters '\\u0000' are appended to this string builder until its length is less than the [newLength].\n     *\n     *  Note that in Kotlin/JS [set] operator function has non-constant execution time complexity.\n     *  Therefore, increasing length of this string builder and then updating each character by index may slow down your program.\n     *\n     *  @throws IndexOutOfBoundsException or [IllegalArgumentException] if [newLength] is less than zero.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun setLength(newLength: Int)\n\n    /**\n     * Returns a new [String] that contains characters in this string builder at [startIndex] (inclusive) and up to the [length] (exclusive).\n     *\n     * @throws IndexOutOfBoundsException if [startIndex] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun substring(startIndex: Int): String\n\n    /**\n     * Returns a new [String] that contains characters in this string builder at [startIndex] (inclusive) and up to the [endIndex] (exclusive).\n     *\n     * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this string builder indices or when `startIndex > endIndex`.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun substring(startIndex: Int, endIndex: Int): String\n\n    /**\n     * Attempts to reduce storage used for this string builder.\n     *\n     * If the backing storage of this string builder is larger than necessary to hold its current contents,\n     * then it may be resized to become more space efficient.\n     * Calling this method may, but is not required to, affect the value of the [capacity] property.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun trimToSize()\n}\n\n\n/**\n * Clears the content of this string builder making it empty and returns this instance.\n *\n * @sample samples.text.Strings.clearStringBuilder\n */\n@SinceKotlin(\"1.3\")\npublic expect fun StringBuilder.clear(): StringBuilder\n\n/**\n * Sets the character at the specified [index] to the specified [value].\n *\n * @throws IndexOutOfBoundsException if [index] is out of bounds of this string builder.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect operator fun StringBuilder.set(index: Int, value: Char)\n\n/**\n * Replaces characters in the specified range of this string builder with characters in the specified string [value] and returns this instance.\n *\n * @param startIndex the beginning (inclusive) of the range to replace.\n * @param endIndex the end (exclusive) of the range to replace.\n * @param value the string to replace with.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] if [startIndex] is less than zero, greater than the length of this string builder, or `startIndex > endIndex`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.setRange(startIndex: Int, endIndex: Int, value: String): StringBuilder\n\n/**\n * Removes the character at the specified [index] from this string builder and returns this instance.\n *\n * If the `Char` at the specified [index] is part of a supplementary code point, this method does not remove the entire supplementary character.\n *\n * @param index the index of `Char` to remove.\n *\n * @throws IndexOutOfBoundsException if [index] is out of bounds of this string builder.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.deleteAt(index: Int): StringBuilder\n\n/**\n * Removes characters in the specified range from this string builder and returns this instance.\n *\n * @param startIndex the beginning (inclusive) of the range to remove.\n * @param endIndex the end (exclusive) of the range to remove.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] is out of range of this string builder indices or when `startIndex > endIndex`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.deleteRange(startIndex: Int, endIndex: Int): StringBuilder\n\n/**\n * Copies characters from this string builder into the [destination] character array.\n *\n * @param destination the array to copy to.\n * @param destinationOffset the position in the array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the range to copy, 0 by default.\n * @param endIndex the end (exclusive) of the range to copy, length of this string builder by default.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this string builder indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n *  or when that index is out of the [destination] array indices range.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.toCharArray(destination: CharArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = this.length)\n\n/**\n * Appends characters in a subarray of the specified character array [value] to this string builder and returns this instance.\n *\n * Characters are appended in order, starting at specified [startIndex].\n *\n * @param value the array from which characters are appended.\n * @param startIndex the beginning (inclusive) of the subarray to append.\n * @param endIndex the end (exclusive) of the subarray to append.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] array indices or when `startIndex > endIndex`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.appendRange(value: CharArray, startIndex: Int, endIndex: Int): StringBuilder\n\n/**\n * Appends a subsequence of the specified character sequence [value] to this string builder and returns this instance.\n *\n * @param value the character sequence from which a subsequence is appended.\n * @param startIndex the beginning (inclusive) of the subsequence to append.\n * @param endIndex the end (exclusive) of the subsequence to append.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] character sequence indices or when `startIndex > endIndex`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.appendRange(value: CharSequence, startIndex: Int, endIndex: Int): StringBuilder\n\n/**\n * Inserts characters in a subarray of the specified character array [value] into this string builder at the specified [index] and returns this instance.\n *\n * The inserted characters go in same order as in the [value] array, starting at [index].\n *\n * @param index the position in this string builder to insert at.\n * @param value the array from which characters are inserted.\n * @param startIndex the beginning (inclusive) of the subarray to insert.\n * @param endIndex the end (exclusive) of the subarray to insert.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.insertRange(index: Int, value: CharArray, startIndex: Int, endIndex: Int): StringBuilder\n\n/**\n * Inserts characters in a subsequence of the specified character sequence [value] into this string builder at the specified [index] and returns this instance.\n *\n * The inserted characters go in the same order as in the [value] character sequence, starting at [index].\n *\n * @param index the position in this string builder to insert at.\n * @param value the character sequence from which a subsequence is inserted.\n * @param startIndex the beginning (inclusive) of the subsequence to insert.\n * @param endIndex the end (exclusive) of the subsequence to insert.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] character sequence indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.insertRange(index: Int, value: CharSequence, startIndex: Int, endIndex: Int): StringBuilder\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\n@Deprecated(\"Use append(value: Any?) instead\", ReplaceWith(\"append(value = obj)\"), DeprecationLevel.WARNING)\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.append(obj: Any?): StringBuilder = this.append(obj)\n\n/**\n * Builds new string by populating newly created [StringBuilder] using provided [builderAction]\n * and then converting it to [String].\n */\n@kotlin.internal.InlineOnly\npublic inline fun buildString(builderAction: StringBuilder.() -> Unit): String {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return StringBuilder().apply(builderAction).toString()\n}\n\n/**\n * Builds new string by populating newly created [StringBuilder] initialized with the given [capacity]\n * using provided [builderAction] and then converting it to [String].\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun buildString(capacity: Int, builderAction: StringBuilder.() -> Unit): String {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return StringBuilder(capacity).apply(builderAction).toString()\n}\n\n/**\n * Appends all arguments to the given StringBuilder.\n */\npublic fun StringBuilder.append(vararg value: String?): StringBuilder {\n    for (item in value)\n        append(item)\n    return this\n}\n\n/**\n * Appends all arguments to the given StringBuilder.\n */\npublic fun StringBuilder.append(vararg value: Any?): StringBuilder {\n    for (item in value)\n        append(item)\n    return this\n}\n\n/** Appends a line feed character (`\\n`) to this StringBuilder. */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.appendLine(): StringBuilder = append('\\n')\n\n/** Appends [value] to this [StringBuilder], followed by a line feed character (`\\n`). */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.appendLine(value: CharSequence?): StringBuilder = append(value).appendLine()\n\n/** Appends [value] to this [StringBuilder], followed by a line feed character (`\\n`). */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.appendLine(value: String?): StringBuilder = append(value).appendLine()\n\n/** Appends [value] to this [StringBuilder], followed by a line feed character (`\\n`). */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.appendLine(value: Any?): StringBuilder = append(value).appendLine()\n\n/** Appends [value] to this [StringBuilder], followed by a line feed character (`\\n`). */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.appendLine(value: CharArray): StringBuilder = append(value).appendLine()\n\n/** Appends [value] to this [StringBuilder], followed by a line feed character (`\\n`). */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.appendLine(value: Char): StringBuilder = append(value).appendLine()\n\n/** Appends [value] to this [StringBuilder], followed by a line feed character (`\\n`). */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.appendLine(value: Boolean): StringBuilder = append(value).appendLine()\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\n/**\n * Converts this character to lower case using Unicode mapping rules of the invariant locale.\n */\n@Deprecated(\"Use lowercaseChar() instead.\", ReplaceWith(\"lowercaseChar()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\n@kotlin.internal.InlineOnly\npublic actual inline fun Char.toLowerCase(): Char = lowercaseChar()\n\n/**\n * Converts this character to lower case using Unicode mapping rules of the invariant locale.\n *\n * This function performs one-to-one character mapping.\n * To support one-to-many character mapping use the [lowercase] function.\n * If this character has no mapping equivalent, the character itself is returned.\n *\n * @sample samples.text.Chars.lowercase\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic actual inline fun Char.lowercaseChar(): Char = lowercase()[0]\n\n/**\n * Converts this character to lower case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many character mapping, thus the length of the returned string can be greater than one.\n * For example, `'\\u0130'.lowercase()` returns `\"\\u0069\\u0307\"`,\n * where `'\\u0130'` is the LATIN CAPITAL LETTER I WITH DOT ABOVE character (`İ`).\n * If this character has no lower case mapping, the result of `toString()` of this char is returned.\n *\n * @sample samples.text.Chars.lowercase\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic actual inline fun Char.lowercase(): String = toString().asDynamic().toLowerCase().unsafeCast<String>()\n\n/**\n * Converts this character to upper case using Unicode mapping rules of the invariant locale.\n */\n@Deprecated(\"Use uppercaseChar() instead.\", ReplaceWith(\"uppercaseChar()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\n@kotlin.internal.InlineOnly\npublic actual inline fun Char.toUpperCase(): Char = uppercaseChar()\n\n/**\n * Converts this character to upper case using Unicode mapping rules of the invariant locale.\n *\n * This function performs one-to-one character mapping.\n * To support one-to-many character mapping use the [uppercase] function.\n * If this character has no mapping equivalent, the character itself is returned.\n *\n * @sample samples.text.Chars.uppercase\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun Char.uppercaseChar(): Char {\n    val uppercase = uppercase()\n    return if (uppercase.length > 1) this else uppercase[0]\n}\n\n/**\n * Converts this character to upper case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many character mapping, thus the length of the returned string can be greater than one.\n * For example, `'\\uFB00'.uppercase()` returns `\"\\u0046\\u0046\"`,\n * where `'\\uFB00'` is the LATIN SMALL LIGATURE FF character (`ﬀ`).\n * If this character has no upper case mapping, the result of `toString()` of this char is returned.\n *\n * @sample samples.text.Chars.uppercase\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic actual inline fun Char.uppercase(): String = toString().asDynamic().toUpperCase().unsafeCast<String>()\n\n/**\n * Converts this character to title case using Unicode mapping rules of the invariant locale.\n *\n * This function performs one-to-one character mapping.\n * To support one-to-many character mapping use the [titlecase] function.\n * If this character has no mapping equivalent, the result of calling [uppercaseChar] is returned.\n *\n * @sample samples.text.Chars.titlecase\n */\n@SinceKotlin(\"1.5\")\npublic actual fun Char.titlecaseChar(): Char = titlecaseCharImpl()\n\n/**\n * Returns `true` if this character is a Unicode high-surrogate code unit (also known as leading-surrogate code unit).\n */\npublic actual fun Char.isHighSurrogate(): Boolean = this in Char.MIN_HIGH_SURROGATE..Char.MAX_HIGH_SURROGATE\n\n/**\n * Returns `true` if this character is a Unicode low-surrogate code unit (also known as trailing-surrogate code unit).\n */\npublic actual fun Char.isLowSurrogate(): Boolean = this in Char.MIN_LOW_SURROGATE..Char.MAX_LOW_SURROGATE\n\n/**\n * Returns the Unicode general category of this character.\n */\n@SinceKotlin(\"1.5\")\npublic actual val Char.category: CharCategory\n    get() = CharCategory.valueOf(getCategoryValue())\n\n/**\n * Returns `true` if this character (Unicode code point) is defined in Unicode.\n *\n * A character is considered to be defined in Unicode if its [category] is not [CharCategory.UNASSIGNED].\n */\n@SinceKotlin(\"1.5\")\npublic actual fun Char.isDefined(): Boolean {\n    if (this < '\\u0080') {\n        return true\n    }\n    return getCategoryValue() != CharCategory.UNASSIGNED.value\n}\n\n/**\n * Returns `true` if this character is a letter.\n *\n * A character is considered to be a letter if its [category] is [CharCategory.UPPERCASE_LETTER],\n * [CharCategory.LOWERCASE_LETTER], [CharCategory.TITLECASE_LETTER], [CharCategory.MODIFIER_LETTER], or [CharCategory.OTHER_LETTER].\n *\n * @sample samples.text.Chars.isLetter\n */\n@SinceKotlin(\"1.5\")\npublic actual fun Char.isLetter(): Boolean {\n    if (this in 'a'..'z' || this in 'A'..'Z') {\n        return true\n    }\n    if (this < '\\u0080') {\n        return false\n    }\n    return isLetterImpl()\n}\n\n/**\n * Returns `true` if this character is a letter or digit.\n *\n * @see isLetter\n * @see isDigit\n *\n * @sample samples.text.Chars.isLetterOrDigit\n */\n@SinceKotlin(\"1.5\")\npublic actual fun Char.isLetterOrDigit(): Boolean {\n    if (this in 'a'..'z' || this in 'A'..'Z' || this in '0'..'9') {\n        return true\n    }\n    if (this < '\\u0080') {\n        return false\n    }\n\n    return isDigitImpl() || isLetterImpl()\n}\n\n/**\n * Returns `true` if this character is a digit.\n *\n * A character is considered to be a digit if its [category] is [CharCategory.DECIMAL_DIGIT_NUMBER].\n *\n * @sample samples.text.Chars.isDigit\n */\n@SinceKotlin(\"1.5\")\npublic actual fun Char.isDigit(): Boolean {\n    if (this in '0'..'9') {\n        return true\n    }\n    if (this < '\\u0080') {\n        return false\n    }\n    return isDigitImpl()\n}\n\n/**\n * Returns `true` if this character is an upper case letter.\n *\n * A character is considered to be an upper case letter if its [category] is [CharCategory.UPPERCASE_LETTER].\n *\n * @sample samples.text.Chars.isUpperCase\n */\n@SinceKotlin(\"1.5\")\npublic actual fun Char.isUpperCase(): Boolean {\n    if (this in 'A'..'Z') {\n        return true\n    }\n    if (this < '\\u0080') {\n        return false\n    }\n    return isUpperCaseImpl()\n}\n\n/**\n * Returns `true` if this character is a lower case letter.\n *\n * A character is considered to be a lower case letter if its [category] is [CharCategory.LOWERCASE_LETTER].\n *\n * @sample samples.text.Chars.isLowerCase\n */\n@SinceKotlin(\"1.5\")\npublic actual fun Char.isLowerCase(): Boolean {\n    if (this in 'a'..'z') {\n        return true\n    }\n    if (this < '\\u0080') {\n        return false\n    }\n    return isLowerCaseImpl()\n}\n\n/**\n * Returns `true` if this character is a title case letter.\n *\n * A character is considered to be a title case letter if its [category] is [CharCategory.TITLECASE_LETTER].\n *\n * @sample samples.text.Chars.isTitleCase\n */\n@SinceKotlin(\"1.5\")\npublic actual fun Char.isTitleCase(): Boolean {\n    if (this < '\\u0080') {\n        return false\n    }\n    return getCategoryValue() == CharCategory.TITLECASE_LETTER.value\n}\n\n/**\n * Returns `true` if this character is an ISO control character.\n *\n * A character is considered to be an ISO control character if its [category] is [CharCategory.CONTROL],\n * meaning the Char is in the range `'\\u0000'..'\\u001F'` or in the range `'\\u007F'..'\\u009F'`.\n *\n * @sample samples.text.Chars.isISOControl\n */\n@SinceKotlin(\"1.5\")\npublic actual fun Char.isISOControl(): Boolean {\n    return this <= '\\u001F' || this in '\\u007F'..'\\u009F'\n}\n\n/**\n * Determines whether a character is whitespace according to the Unicode standard.\n * Returns `true` if the character is whitespace.\n *\n * @sample samples.text.Chars.isWhitespace\n */\npublic actual fun Char.isWhitespace(): Boolean = isWhitespaceImpl()",null,null,null,null,null,null,null,null,null,"/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\npackage kotlin.math\n\n\nimport kotlin.internal.InlineOnly\nimport kotlin.js.JsMath as nativeMath\n\n\n// region ================ Double Math ========================================\n\n/** Computes the sine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `sin(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sin(x: Double): Double = nativeMath.sin(x)\n\n/** Computes the cosine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `cos(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cos(x: Double): Double = nativeMath.cos(x)\n\n/** Computes the tangent of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `tan(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tan(x: Double): Double = nativeMath.tan(x)\n\n/**\n * Computes the arc sine of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *    - `asin(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asin(x: Double): Double = nativeMath.asin(x)\n\n/**\n * Computes the arc cosine of the value [x];\n * the returned value is an angle in the range from `0.0` to `PI` radians.\n *\n * Special cases:\n *    - `acos(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acos(x: Double): Double = nativeMath.acos(x)\n\n/**\n * Computes the arc tangent of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *   - `atan(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan(x: Double): Double = nativeMath.atan(x)\n\n/**\n * Returns the angle `theta` of the polar coordinates `(r, theta)` that correspond\n * to the rectangular coordinates `(x, y)` by computing the arc tangent of the value [y] / [x];\n * the returned value is an angle in the range from `-PI` to `PI` radians.\n *\n * Special cases:\n *   - `atan2(0.0, 0.0)` is `0.0`\n *   - `atan2(0.0, x)` is  `0.0` for `x > 0` and `PI` for `x < 0`\n *   - `atan2(-0.0, x)` is `-0.0` for 'x > 0` and `-PI` for `x < 0`\n *   - `atan2(y, +Inf)` is `0.0` for `0 < y < +Inf` and `-0.0` for '-Inf < y < 0`\n *   - `atan2(y, -Inf)` is `PI` for `0 < y < +Inf` and `-PI` for `-Inf < y < 0`\n *   - `atan2(y, 0.0)` is `PI/2` for `y > 0` and `-PI/2` for `y < 0`\n *   - `atan2(+Inf, x)` is `PI/2` for finite `x`y\n *   - `atan2(-Inf, x)` is `-PI/2` for finite `x`\n *   - `atan2(NaN, x)` and `atan2(y, NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan2(y: Double, x: Double): Double = nativeMath.atan2(y, x)\n\n/**\n * Computes the hyperbolic sine of the value [x].\n *\n * Special cases:\n *   - `sinh(NaN)` is `NaN`\n *   - `sinh(+Inf)` is `+Inf`\n *   - `sinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sinh(x: Double): Double = nativeMath.sinh(x)\n\n/**\n * Computes the hyperbolic cosine of the value [x].\n *\n * Special cases:\n *   - `cosh(NaN)` is `NaN`\n *   - `cosh(+Inf|-Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cosh(x: Double): Double = nativeMath.cosh(x)\n\n/**\n * Computes the hyperbolic tangent of the value [x].\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(+Inf)` is `1.0`\n *   - `tanh(-Inf)` is `-1.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tanh(x: Double): Double = nativeMath.tanh(x)\n\n/**\n * Computes the inverse hyperbolic sine of the value [x].\n *\n * The returned value is `y` such that `sinh(y) == x`.\n *\n * Special cases:\n *   - `asinh(NaN)` is `NaN`\n *   - `asinh(+Inf)` is `+Inf`\n *   - `asinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asinh(x: Double): Double = nativeMath.asinh(x)\n\n/**\n * Computes the inverse hyperbolic cosine of the value [x].\n *\n * The returned value is positive `y` such that `cosh(y) == x`.\n *\n * Special cases:\n *   - `acosh(NaN)` is `NaN`\n *   - `acosh(x)` is `NaN` when `x < 1`\n *   - `acosh(+Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acosh(x: Double): Double = nativeMath.acosh(x)\n\n/**\n * Computes the inverse hyperbolic tangent of the value [x].\n *\n * The returned value is `y` such that `tanh(y) == x`.\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(x)` is `NaN` when `x > 1` or `x < -1`\n *   - `tanh(1.0)` is `+Inf`\n *   - `tanh(-1.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atanh(x: Double): Double = nativeMath.atanh(x)\n\n/**\n * Computes `sqrt(x^2 + y^2)` without intermediate overflow or underflow.\n *\n * Special cases:\n *   - returns `+Inf` if any of arguments is infinite\n *   - returns `NaN` if any of arguments is `NaN` and the other is not infinite\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun hypot(x: Double, y: Double): Double = nativeMath.hypot(x, y)\n\n/**\n * Computes the positive square root of the value [x].\n *\n * Special cases:\n *   - `sqrt(x)` is `NaN` when `x < 0` or `x` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sqrt(x: Double): Double = nativeMath.sqrt(x)\n\n/**\n * Computes Euler's number `e` raised to the power of the value [x].\n *\n * Special cases:\n *   - `exp(NaN)` is `NaN`\n *   - `exp(+Inf)` is `+Inf`\n *   - `exp(-Inf)` is `0.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun exp(x: Double): Double = nativeMath.exp(x)\n\n/**\n * Computes `exp(x) - 1`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `expm1(NaN)` is `NaN`\n *   - `expm1(+Inf)` is `+Inf`\n *   - `expm1(-Inf)` is `-1.0`\n *\n * @see [exp] function.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun expm1(x: Double): Double = nativeMath.expm1(x)\n\n/**\n * Computes the logarithm of the value [x] to the given [base].\n *\n * Special cases:\n *   - `log(x, b)` is `NaN` if either `x` or `b` are `NaN`\n *   - `log(x, b)` is `NaN` when `x < 0` or `b <= 0` or `b == 1.0`\n *   - `log(+Inf, +Inf)` is `NaN`\n *   - `log(+Inf, b)` is `+Inf` for `b > 1` and `-Inf` for `b < 1`\n *   - `log(0.0, b)` is `-Inf` for `b > 1` and `+Inf` for `b > 1`\n *\n * See also logarithm functions for common fixed bases: [ln], [log10] and [log2].\n */\n@SinceKotlin(\"1.2\")\npublic actual fun log(x: Double, base: Double): Double {\n    if (base <= 0.0 || base == 1.0) return Double.NaN\n    return nativeMath.log(x) / nativeMath.log(base)\n}\n\n/**\n * Computes the natural logarithm (base `E`) of the value [x].\n *\n * Special cases:\n *   - `ln(NaN)` is `NaN`\n *   - `ln(x)` is `NaN` when `x < 0.0`\n *   - `ln(+Inf)` is `+Inf`\n *   - `ln(0.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln(x: Double): Double = nativeMath.log(x)\n\n/**\n * Computes the common logarithm (base 10) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log10(x: Double): Double = nativeMath.log10(x)\n\n/**\n * Computes the binary logarithm (base 2) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log2(x: Double): Double = nativeMath.log2(x)\n\n/**\n * Computes `ln(x + 1)`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `ln1p(NaN)` is `NaN`\n *   - `ln1p(x)` is `NaN` where `x < -1.0`\n *   - `ln1p(-1.0)` is `-Inf`\n *   - `ln1p(+Inf)` is `+Inf`\n *\n * @see [ln] function\n * @see [expm1] function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln1p(x: Double): Double = nativeMath.log1p(x)\n\n/**\n * Rounds the given value [x] to an integer towards positive infinity.\n\n * @return the smallest double value that is greater than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `ceil(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ceil(x: Double): Double = nativeMath.ceil(x)\n\n/**\n * Rounds the given value [x] to an integer towards negative infinity.\n\n * @return the largest double value that is smaller than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `floor(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun floor(x: Double): Double = nativeMath.floor(x)\n\n/**\n * Rounds the given value [x] to an integer towards zero.\n *\n * @return the value [x] having its fractional part truncated.\n *\n * Special cases:\n *   - `truncate(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun truncate(x: Double): Double = nativeMath.trunc(x)\n\n/**\n * Rounds the given value [x] towards the closest integer with ties rounded towards even integer.\n *\n * Special cases:\n *   - `round(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun round(x: Double): Double {\n    if (x % 0.5 != 0.0) {\n        return nativeMath.round(x)\n    }\n    val floor = floor(x)\n    return if (floor % 2 == 0.0) floor else ceil(x)\n}\n\n/**\n * Returns the absolute value of the given value [x].\n *\n * Special cases:\n *   - `abs(NaN)` is `NaN`\n *\n * @see absoluteValue extension property for [Double]\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun abs(x: Double): Double = nativeMath.abs(x)\n\n/**\n * Returns the sign of the given value [x]:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `sign(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sign(x: Double): Double = nativeMath.sign(x)\n\n\n/**\n * Returns the smaller of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun min(a: Double, b: Double): Double = nativeMath.min(a, b)\n\n/**\n * Returns the greater of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun max(a: Double, b: Double): Double = nativeMath.max(a, b)\n\n// extensions\n\n/**\n * Raises this value to the power [x].\n *\n * Special cases:\n *   - `b.pow(0.0)` is `1.0`\n *   - `b.pow(1.0) == b`\n *   - `b.pow(NaN)` is `NaN`\n *   - `NaN.pow(x)` is `NaN` for `x != 0.0`\n *   - `b.pow(Inf)` is `NaN` for `abs(b) == 1.0`\n *   - `b.pow(x)` is `NaN` for `b < 0` and `x` is finite and not an integer\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Double.pow(x: Double): Double = nativeMath.pow(this, x)\n\n/**\n * Raises this value to the integer power [n].\n *\n * See the other overload of [pow] for details.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Double.pow(n: Int): Double = nativeMath.pow(this, n.toDouble())\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `NaN.absoluteValue` is `NaN`\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Double.absoluteValue: Double get() = nativeMath.abs(this)\n\n/**\n * Returns the sign of this value:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `NaN.sign` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Double.sign: Double get() = nativeMath.sign(this)\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Double.withSign(sign: Int): Double = this.withSign(sign.toDouble())\n\n/**\n * Returns the ulp (unit in the last place) of this value.\n *\n * An ulp is a positive distance between this value and the next nearest [Double] value larger in magnitude.\n *\n * Special Cases:\n *   - `NaN.ulp` is `NaN`\n *   - `x.ulp` is `+Inf` when `x` is `+Inf` or `-Inf`\n *   - `0.0.ulp` is `Double.MIN_VALUE`\n */\n@SinceKotlin(\"1.2\")\npublic actual val Double.ulp: Double get() = when {\n    this < 0 -> (-this).ulp\n    this.isNaN() || this == Double.POSITIVE_INFINITY -> this\n    this == Double.MAX_VALUE -> this - this.nextDown()\n    else -> this.nextUp() - this\n}\n\n/**\n * Returns the [Double] value nearest to this value in direction of positive infinity.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.nextUp(): Double = when {\n    this.isNaN() || this == Double.POSITIVE_INFINITY -> this\n    this == 0.0 -> Double.MIN_VALUE\n    else -> Double.fromBits(this.toRawBits() + if (this > 0) 1 else -1)\n}\n\n/**\n * Returns the [Double] value nearest to this value in direction of negative infinity.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.nextDown(): Double = when {\n    this.isNaN() || this == Double.NEGATIVE_INFINITY -> this\n    this == 0.0 -> -Double.MIN_VALUE\n    else -> Double.fromBits(this.toRawBits() + if (this > 0) -1 else 1)\n}\n\n\n/**\n * Returns the [Double] value nearest to this value in direction from this value towards the value [to].\n *\n * Special cases:\n *   - `x.nextTowards(y)` is `NaN` if either `x` or `y` are `NaN`\n *   - `x.nextTowards(x) == x`\n *\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.nextTowards(to: Double): Double = when {\n    this.isNaN() || to.isNaN() -> Double.NaN\n    to == this -> to\n    to > this -> this.nextUp()\n    else /* to < this */ -> this.nextDown()\n}\n\n\n/**\n * Rounds this [Double] value to the nearest integer and converts the result to [Int].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToInt() == Int.MAX_VALUE` when `x > Int.MAX_VALUE`\n *   - `x.roundToInt() == Int.MIN_VALUE` when `x < Int.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.roundToInt(): Int = when {\n    isNaN() -> throw IllegalArgumentException(\"Cannot round NaN value.\")\n    this > Int.MAX_VALUE -> Int.MAX_VALUE\n    this < Int.MIN_VALUE -> Int.MIN_VALUE\n    else -> nativeMath.round(this).toInt()\n}\n\n/**\n * Rounds this [Double] value to the nearest integer and converts the result to [Long].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToLong() == Long.MAX_VALUE` when `x > Long.MAX_VALUE`\n *   - `x.roundToLong() == Long.MIN_VALUE` when `x < Long.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.roundToLong(): Long = when {\n    isNaN() -> throw IllegalArgumentException(\"Cannot round NaN value.\")\n    this > Long.MAX_VALUE -> Long.MAX_VALUE\n    this < Long.MIN_VALUE -> Long.MIN_VALUE\n    else -> nativeMath.round(this).toLong()\n}\n\n// endregion\n\n\n\n// region ================ Float Math ========================================\n\n/** Computes the sine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `sin(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sin(x: Float): Float = nativeMath.sin(x.toDouble()).toFloat()\n\n/** Computes the cosine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `cos(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cos(x: Float): Float = nativeMath.cos(x.toDouble()).toFloat()\n\n/** Computes the tangent of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `tan(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tan(x: Float): Float = nativeMath.tan(x.toDouble()).toFloat()\n\n/**\n * Computes the arc sine of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *    - `asin(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asin(x: Float): Float = nativeMath.asin(x.toDouble()).toFloat()\n\n/**\n * Computes the arc cosine of the value [x];\n * the returned value is an angle in the range from `0.0` to `PI` radians.\n *\n * Special cases:\n *    - `acos(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acos(x: Float): Float = nativeMath.acos(x.toDouble()).toFloat()\n\n/**\n * Computes the arc tangent of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *   - `atan(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan(x: Float): Float = nativeMath.atan(x.toDouble()).toFloat()\n\n/**\n * Returns the angle `theta` of the polar coordinates `(r, theta)` that correspond\n * to the rectangular coordinates `(x, y)` by computing the arc tangent of the value [y] / [x];\n * the returned value is an angle in the range from `-PI` to `PI` radians.\n *\n * Special cases:\n *   - `atan2(0.0, 0.0)` is `0.0`\n *   - `atan2(0.0, x)` is  `0.0` for `x > 0` and `PI` for `x < 0`\n *   - `atan2(-0.0, x)` is `-0.0` for 'x > 0` and `-PI` for `x < 0`\n *   - `atan2(y, +Inf)` is `0.0` for `0 < y < +Inf` and `-0.0` for '-Inf < y < 0`\n *   - `atan2(y, -Inf)` is `PI` for `0 < y < +Inf` and `-PI` for `-Inf < y < 0`\n *   - `atan2(y, 0.0)` is `PI/2` for `y > 0` and `-PI/2` for `y < 0`\n *   - `atan2(+Inf, x)` is `PI/2` for finite `x`y\n *   - `atan2(-Inf, x)` is `-PI/2` for finite `x`\n *   - `atan2(NaN, x)` and `atan2(y, NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan2(y: Float, x: Float): Float = nativeMath.atan2(y.toDouble(), x.toDouble()).toFloat()\n\n/**\n * Computes the hyperbolic sine of the value [x].\n *\n * Special cases:\n *   - `sinh(NaN)` is `NaN`\n *   - `sinh(+Inf)` is `+Inf`\n *   - `sinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sinh(x: Float): Float = nativeMath.sinh(x.toDouble()).toFloat()\n\n/**\n * Computes the hyperbolic cosine of the value [x].\n *\n * Special cases:\n *   - `cosh(NaN)` is `NaN`\n *   - `cosh(+Inf|-Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cosh(x: Float): Float = nativeMath.cosh(x.toDouble()).toFloat()\n\n/**\n * Computes the hyperbolic tangent of the value [x].\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(+Inf)` is `1.0`\n *   - `tanh(-Inf)` is `-1.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tanh(x: Float): Float = nativeMath.tanh(x.toDouble()).toFloat()\n\n/**\n * Computes the inverse hyperbolic sine of the value [x].\n *\n * The returned value is `y` such that `sinh(y) == x`.\n *\n * Special cases:\n *   - `asinh(NaN)` is `NaN`\n *   - `asinh(+Inf)` is `+Inf`\n *   - `asinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asinh(x: Float): Float = nativeMath.asinh(x.toDouble()).toFloat()\n\n/**\n * Computes the inverse hyperbolic cosine of the value [x].\n *\n * The returned value is positive `y` such that `cosh(y) == x`.\n *\n * Special cases:\n *   - `acosh(NaN)` is `NaN`\n *   - `acosh(x)` is `NaN` when `x < 1`\n *   - `acosh(+Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acosh(x: Float): Float = nativeMath.acosh(x.toDouble()).toFloat()\n\n/**\n * Computes the inverse hyperbolic tangent of the value [x].\n *\n * The returned value is `y` such that `tanh(y) == x`.\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(x)` is `NaN` when `x > 1` or `x < -1`\n *   - `tanh(1.0)` is `+Inf`\n *   - `tanh(-1.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atanh(x: Float): Float = nativeMath.atanh(x.toDouble()).toFloat()\n\n/**\n * Computes `sqrt(x^2 + y^2)` without intermediate overflow or underflow.\n *\n * Special cases:\n *   - returns `+Inf` if any of arguments is infinite\n *   - returns `NaN` if any of arguments is `NaN` and the other is not infinite\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun hypot(x: Float, y: Float): Float = nativeMath.hypot(x.toDouble(), y.toDouble()).toFloat()\n\n/**\n * Computes the positive square root of the value [x].\n *\n * Special cases:\n *   - `sqrt(x)` is `NaN` when `x < 0` or `x` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sqrt(x: Float): Float = nativeMath.sqrt(x.toDouble()).toFloat()\n\n/**\n * Computes Euler's number `e` raised to the power of the value [x].\n *\n * Special cases:\n *   - `exp(NaN)` is `NaN`\n *   - `exp(+Inf)` is `+Inf`\n *   - `exp(-Inf)` is `0.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun exp(x: Float): Float = nativeMath.exp(x.toDouble()).toFloat()\n\n/**\n * Computes `exp(x) - 1`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `expm1(NaN)` is `NaN`\n *   - `expm1(+Inf)` is `+Inf`\n *   - `expm1(-Inf)` is `-1.0`\n *\n * @see [exp] function.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun expm1(x: Float): Float = nativeMath.expm1(x.toDouble()).toFloat()\n\n/**\n * Computes the logarithm of the value [x] to the given [base].\n *\n * Special cases:\n *   - `log(x, b)` is `NaN` if either `x` or `b` are `NaN`\n *   - `log(x, b)` is `NaN` when `x < 0` or `b <= 0` or `b == 1.0`\n *   - `log(+Inf, +Inf)` is `NaN`\n *   - `log(+Inf, b)` is `+Inf` for `b > 1` and `-Inf` for `b < 1`\n *   - `log(0.0, b)` is `-Inf` for `b > 1` and `+Inf` for `b > 1`\n *\n * See also logarithm functions for common fixed bases: [ln], [log10] and [log2].\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log(x: Float, base: Float): Float = log(x.toDouble(), base.toDouble()).toFloat()\n\n/**\n * Computes the natural logarithm (base `E`) of the value [x].\n *\n * Special cases:\n *   - `ln(NaN)` is `NaN`\n *   - `ln(x)` is `NaN` when `x < 0.0`\n *   - `ln(+Inf)` is `+Inf`\n *   - `ln(0.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln(x: Float): Float = nativeMath.log(x.toDouble()).toFloat()\n\n/**\n * Computes the common logarithm (base 10) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log10(x: Float): Float = nativeMath.log10(x.toDouble()).toFloat()\n\n/**\n * Computes the binary logarithm (base 2) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log2(x: Float): Float = nativeMath.log2(x.toDouble()).toFloat()\n\n/**\n * Computes `ln(a + 1)`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `ln1p(NaN)` is `NaN`\n *   - `ln1p(x)` is `NaN` where `x < -1.0`\n *   - `ln1p(-1.0)` is `-Inf`\n *   - `ln1p(+Inf)` is `+Inf`\n *\n * @see [ln] function\n * @see [expm1] function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln1p(x: Float): Float = nativeMath.log1p(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] to an integer towards positive infinity.\n\n * @return the smallest Float value that is greater than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `ceil(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ceil(x: Float): Float = nativeMath.ceil(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] to an integer towards negative infinity.\n\n * @return the largest Float value that is smaller than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `floor(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun floor(x: Float): Float = nativeMath.floor(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] to an integer towards zero.\n *\n * @return the value [x] having its fractional part truncated.\n *\n * Special cases:\n *   - `truncate(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun truncate(x: Float): Float = truncate(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] towards the closest integer with ties rounded towards even integer.\n *\n * Special cases:\n *   - `round(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun round(x: Float): Float = round(x.toDouble()).toFloat()\n\n\n/**\n * Returns the absolute value of the given value [x].\n *\n * Special cases:\n *   - `abs(NaN)` is `NaN`\n *\n * @see absoluteValue extension property for [Float]\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun abs(x: Float): Float = nativeMath.abs(x.toDouble()).toFloat()\n\n/**\n * Returns the sign of the given value [x]:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `sign(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sign(x: Float): Float = nativeMath.sign(x.toDouble()).toFloat()\n\n\n\n/**\n * Returns the smaller of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun min(a: Float, b: Float): Float = nativeMath.min(a, b)\n\n/**\n * Returns the greater of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun max(a: Float, b: Float): Float = nativeMath.max(a, b)\n\n// extensions\n\n\n/**\n * Raises this value to the power [x].\n *\n * Special cases:\n *   - `b.pow(0.0)` is `1.0`\n *   - `b.pow(1.0) == b`\n *   - `b.pow(NaN)` is `NaN`\n *   - `NaN.pow(x)` is `NaN` for `x != 0.0`\n *   - `b.pow(Inf)` is `NaN` for `abs(b) == 1.0`\n *   - `b.pow(x)` is `NaN` for `b < 0` and `x` is finite and not an integer\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.pow(x: Float): Float = nativeMath.pow(this.toDouble(), x.toDouble()).toFloat()\n\n/**\n * Raises this value to the integer power [n].\n *\n * See the other overload of [pow] for details.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.pow(n: Int): Float = nativeMath.pow(this.toDouble(), n.toDouble()).toFloat()\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `NaN.absoluteValue` is `NaN`\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Float.absoluteValue: Float get() = nativeMath.abs(this.toDouble()).toFloat()\n\n/**\n * Returns the sign of this value:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `NaN.sign` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Float.sign: Float get() = nativeMath.sign(this.toDouble()).toFloat()\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n *\n * If [sign] is `NaN` the sign of the result is undefined.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.withSign(sign: Float): Float = this.toDouble().withSign(sign.toDouble()).toFloat()\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.withSign(sign: Int): Float = this.toDouble().withSign(sign.toDouble()).toFloat()\n\n\n/**\n * Rounds this [Float] value to the nearest integer and converts the result to [Int].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToInt() == Int.MAX_VALUE` when `x > Int.MAX_VALUE`\n *   - `x.roundToInt() == Int.MIN_VALUE` when `x < Int.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.roundToInt(): Int = toDouble().roundToInt()\n\n/**\n * Rounds this [Float] value to the nearest integer and converts the result to [Long].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToLong() == Long.MAX_VALUE` when `x > Long.MAX_VALUE`\n *   - `x.roundToLong() == Long.MIN_VALUE` when `x < Long.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.roundToLong(): Long = toDouble().roundToLong()\n\n\n// endregion\n\n// region ================ Integer Math ========================================\n\n\n/**\n * Returns the absolute value of the given value [n].\n *\n * Special cases:\n *   - `abs(Int.MIN_VALUE)` is `Int.MIN_VALUE` due to an overflow\n *\n * @see absoluteValue extension property for [Int]\n */\n// TODO: remove manual 'or' when KT-19290 is fixed\n@SinceKotlin(\"1.2\")\npublic actual fun abs(n: Int): Int = if (n < 0) (-n or 0) else n\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun min(a: Int, b: Int): Int = nativeMath.min(a, b)\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun max(a: Int, b: Int): Int = nativeMath.max(a, b)\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `Int.MIN_VALUE.absoluteValue` is `Int.MIN_VALUE` due to an overflow\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Int.absoluteValue: Int get() = abs(this)\n\n/**\n * Returns the sign of this value:\n *   - `-1` if the value is negative,\n *   - `0` if the value is zero,\n *   - `1` if the value is positive\n */\n@SinceKotlin(\"1.2\")\npublic actual val Int.sign: Int get() = when {\n    this < 0 -> -1\n    this > 0 -> 1\n    else -> 0\n}\n\n\n\n/**\n * Returns the absolute value of the given value [n].\n *\n * Special cases:\n *   - `abs(Long.MIN_VALUE)` is `Long.MIN_VALUE` due to an overflow\n *\n * @see absoluteValue extension property for [Long]\n */\n@SinceKotlin(\"1.2\")\npublic actual fun abs(n: Long): Long = if (n < 0) -n else n\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.2\")\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun min(a: Long, b: Long): Long = if (a <= b) a else b\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.2\")\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun max(a: Long, b: Long): Long = if (a >= b) a else b\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `Long.MIN_VALUE.absoluteValue` is `Long.MIN_VALUE` due to an overflow\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Long.absoluteValue: Long get() = abs(this)\n\n/**\n * Returns the sign of this value:\n *   - `-1` if the value is negative,\n *   - `0` if the value is zero,\n *   - `1` if the value is positive\n */\n@SinceKotlin(\"1.2\")\npublic actual val Long.sign: Int get() = when {\n    this < 0 -> -1\n    this > 0 -> 1\n    else -> 0\n}\n\n\n// endregion\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StringsKt\")\n\npackage kotlin.text\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.random.*\n\n/**\n * Returns a character at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this char sequence.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun CharSequence.elementAt(index: Int): Char\n\n/**\n * Returns a character at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this char sequence.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.elementAtOrElse(index: Int, defaultValue: (Int) -> Char): Char {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns a character at the given [index] or `null` if the [index] is out of bounds of this char sequence.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.elementAtOrNull(index: Int): Char? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns the first character matching the given [predicate], or `null` if no such character was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.find(predicate: (Char) -> Boolean): Char? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the last character matching the given [predicate], or `null` if no such character was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.findLast(predicate: (Char) -> Boolean): Char? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns first character.\n * @throws [NoSuchElementException] if the char sequence is empty.\n */\npublic fun CharSequence.first(): Char {\n    if (isEmpty())\n        throw NoSuchElementException(\"Char sequence is empty.\")\n    return this[0]\n}\n\n/**\n * Returns the first character matching the given [predicate].\n * @throws [NoSuchElementException] if no such character is found.\n */\npublic inline fun CharSequence.first(predicate: (Char) -> Boolean): Char {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Char sequence contains no character matching the predicate.\")\n}\n\n/**\n * Returns the first non-null value produced by [transform] function being applied to characters of this char sequence in iteration order,\n * or throws [NoSuchElementException] if no non-null value was produced.\n * \n * @sample samples.collections.Collections.Transformations.firstNotNullOf\n */\n@SinceKotlin(\"1.5\")\n@kotlin.internal.InlineOnly\npublic inline fun <R : Any> CharSequence.firstNotNullOf(transform: (Char) -> R?): R {\n    return firstNotNullOfOrNull(transform) ?: throw NoSuchElementException(\"No element of the char sequence was transformed to a non-null value.\")\n}\n\n/**\n * Returns the first non-null value produced by [transform] function being applied to characters of this char sequence in iteration order,\n * or `null` if no non-null value was produced.\n * \n * @sample samples.collections.Collections.Transformations.firstNotNullOf\n */\n@SinceKotlin(\"1.5\")\n@kotlin.internal.InlineOnly\npublic inline fun <R : Any> CharSequence.firstNotNullOfOrNull(transform: (Char) -> R?): R? {\n    for (element in this) {\n        val result = transform(element)\n        if (result != null) {\n            return result\n        }\n    }\n    return null\n}\n\n/**\n * Returns the first character, or `null` if the char sequence is empty.\n */\npublic fun CharSequence.firstOrNull(): Char? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first character matching the given [predicate], or `null` if character was not found.\n */\npublic inline fun CharSequence.firstOrNull(predicate: (Char) -> Boolean): Char? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns a character at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this char sequence.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.getOrElse(index: Int, defaultValue: (Int) -> Char): Char {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns a character at the given [index] or `null` if the [index] is out of bounds of this char sequence.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun CharSequence.getOrNull(index: Int): Char? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns index of the first character matching the given [predicate], or -1 if the char sequence does not contain such character.\n */\npublic inline fun CharSequence.indexOfFirst(predicate: (Char) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last character matching the given [predicate], or -1 if the char sequence does not contain such character.\n */\npublic inline fun CharSequence.indexOfLast(predicate: (Char) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns the last character.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n * \n * @sample samples.text.Strings.last\n */\npublic fun CharSequence.last(): Char {\n    if (isEmpty())\n        throw NoSuchElementException(\"Char sequence is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last character matching the given [predicate].\n * \n * @throws NoSuchElementException if no such character is found.\n * \n * @sample samples.text.Strings.last\n */\npublic inline fun CharSequence.last(predicate: (Char) -> Boolean): Char {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Char sequence contains no character matching the predicate.\")\n}\n\n/**\n * Returns the last character, or `null` if the char sequence is empty.\n * \n * @sample samples.text.Strings.last\n */\npublic fun CharSequence.lastOrNull(): Char? {\n    return if (isEmpty()) null else this[length - 1]\n}\n\n/**\n * Returns the last character matching the given [predicate], or `null` if no such character was found.\n * \n * @sample samples.text.Strings.last\n */\npublic inline fun CharSequence.lastOrNull(predicate: (Char) -> Boolean): Char? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns a random character from this char sequence.\n * \n * @throws NoSuchElementException if this char sequence is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.random(): Char {\n    return random(Random)\n}\n\n/**\n * Returns a random character from this char sequence using the specified source of randomness.\n * \n * @throws NoSuchElementException if this char sequence is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun CharSequence.random(random: Random): Char {\n    if (isEmpty())\n        throw NoSuchElementException(\"Char sequence is empty.\")\n    return get(random.nextInt(length))\n}\n\n/**\n * Returns a random character from this char sequence, or `null` if this char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.randomOrNull(): Char? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random character from this char sequence using the specified source of randomness, or `null` if this char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun CharSequence.randomOrNull(random: Random): Char? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(length))\n}\n\n/**\n * Returns the single character, or throws an exception if the char sequence is empty or has more than one character.\n */\npublic fun CharSequence.single(): Char {\n    return when (length) {\n        0 -> throw NoSuchElementException(\"Char sequence is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Char sequence has more than one element.\")\n    }\n}\n\n/**\n * Returns the single character matching the given [predicate], or throws exception if there is no or more than one matching character.\n */\npublic inline fun CharSequence.single(predicate: (Char) -> Boolean): Char {\n    var single: Char? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Char sequence contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Char sequence contains no character matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Char\n}\n\n/**\n * Returns single character, or `null` if the char sequence is empty or has more than one character.\n */\npublic fun CharSequence.singleOrNull(): Char? {\n    return if (length == 1) this[0] else null\n}\n\n/**\n * Returns the single character matching the given [predicate], or `null` if character was not found or more than one character was found.\n */\npublic inline fun CharSequence.singleOrNull(predicate: (Char) -> Boolean): Char? {\n    var single: Char? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns a subsequence of this char sequence with the first [n] characters removed.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.drop\n */\npublic fun CharSequence.drop(n: Int): CharSequence {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    return subSequence(n.coerceAtMost(length), length)\n}\n\n/**\n * Returns a string with the first [n] characters removed.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.drop\n */\npublic fun String.drop(n: Int): String {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    return substring(n.coerceAtMost(length))\n}\n\n/**\n * Returns a subsequence of this char sequence with the last [n] characters removed.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.drop\n */\npublic fun CharSequence.dropLast(n: Int): CharSequence {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    return take((length - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a string with the last [n] characters removed.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.drop\n */\npublic fun String.dropLast(n: Int): String {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    return take((length - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a subsequence of this char sequence containing all characters except last characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.drop\n */\npublic inline fun CharSequence.dropLastWhile(predicate: (Char) -> Boolean): CharSequence {\n    for (index in lastIndex downTo 0)\n        if (!predicate(this[index]))\n            return subSequence(0, index + 1)\n    return \"\"\n}\n\n/**\n * Returns a string containing all characters except last characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.drop\n */\npublic inline fun String.dropLastWhile(predicate: (Char) -> Boolean): String {\n    for (index in lastIndex downTo 0)\n        if (!predicate(this[index]))\n            return substring(0, index + 1)\n    return \"\"\n}\n\n/**\n * Returns a subsequence of this char sequence containing all characters except first characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.drop\n */\npublic inline fun CharSequence.dropWhile(predicate: (Char) -> Boolean): CharSequence {\n    for (index in this.indices)\n        if (!predicate(this[index]))\n            return subSequence(index, length)\n    return \"\"\n}\n\n/**\n * Returns a string containing all characters except first characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.drop\n */\npublic inline fun String.dropWhile(predicate: (Char) -> Boolean): String {\n    for (index in this.indices)\n        if (!predicate(this[index]))\n            return substring(index)\n    return \"\"\n}\n\n/**\n * Returns a char sequence containing only those characters from the original char sequence that match the given [predicate].\n * \n * @sample samples.text.Strings.filter\n */\npublic inline fun CharSequence.filter(predicate: (Char) -> Boolean): CharSequence {\n    return filterTo(StringBuilder(), predicate)\n}\n\n/**\n * Returns a string containing only those characters from the original string that match the given [predicate].\n * \n * @sample samples.text.Strings.filter\n */\npublic inline fun String.filter(predicate: (Char) -> Boolean): String {\n    return filterTo(StringBuilder(), predicate).toString()\n}\n\n/**\n * Returns a char sequence containing only those characters from the original char sequence that match the given [predicate].\n * @param [predicate] function that takes the index of a character and the character itself\n * and returns the result of predicate evaluation on the character.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun CharSequence.filterIndexed(predicate: (index: Int, Char) -> Boolean): CharSequence {\n    return filterIndexedTo(StringBuilder(), predicate)\n}\n\n/**\n * Returns a string containing only those characters from the original string that match the given [predicate].\n * @param [predicate] function that takes the index of a character and the character itself\n * and returns the result of predicate evaluation on the character.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun String.filterIndexed(predicate: (index: Int, Char) -> Boolean): String {\n    return filterIndexedTo(StringBuilder(), predicate).toString()\n}\n\n/**\n * Appends all characters matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of a character and the character itself\n * and returns the result of predicate evaluation on the character.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <C : Appendable> CharSequence.filterIndexedTo(destination: C, predicate: (index: Int, Char) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.append(element)\n    }\n    return destination\n}\n\n/**\n * Returns a char sequence containing only those characters from the original char sequence that do not match the given [predicate].\n * \n * @sample samples.text.Strings.filterNot\n */\npublic inline fun CharSequence.filterNot(predicate: (Char) -> Boolean): CharSequence {\n    return filterNotTo(StringBuilder(), predicate)\n}\n\n/**\n * Returns a string containing only those characters from the original string that do not match the given [predicate].\n * \n * @sample samples.text.Strings.filterNot\n */\npublic inline fun String.filterNot(predicate: (Char) -> Boolean): String {\n    return filterNotTo(StringBuilder(), predicate).toString()\n}\n\n/**\n * Appends all characters not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : Appendable> CharSequence.filterNotTo(destination: C, predicate: (Char) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.append(element)\n    return destination\n}\n\n/**\n * Appends all characters matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : Appendable> CharSequence.filterTo(destination: C, predicate: (Char) -> Boolean): C {\n    for (index in 0 until length) {\n        val element = get(index)\n        if (predicate(element)) destination.append(element)\n    }\n    return destination\n}\n\n/**\n * Returns a char sequence containing characters of the original char sequence at the specified range of [indices].\n */\npublic fun CharSequence.slice(indices: IntRange): CharSequence {\n    if (indices.isEmpty()) return \"\"\n    return subSequence(indices)\n}\n\n/**\n * Returns a string containing characters of the original string at the specified range of [indices].\n */\npublic fun String.slice(indices: IntRange): String {\n    if (indices.isEmpty()) return \"\"\n    return substring(indices)\n}\n\n/**\n * Returns a char sequence containing characters of the original char sequence at specified [indices].\n */\npublic fun CharSequence.slice(indices: Iterable<Int>): CharSequence {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return \"\"\n    val result = StringBuilder(size)\n    for (i in indices) {\n        result.append(get(i))\n    }\n    return result\n}\n\n/**\n * Returns a string containing characters of the original string at specified [indices].\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.slice(indices: Iterable<Int>): String {\n    return (this as CharSequence).slice(indices).toString()\n}\n\n/**\n * Returns a subsequence of this char sequence containing the first [n] characters from this char sequence, or the entire char sequence if this char sequence is shorter.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.take\n */\npublic fun CharSequence.take(n: Int): CharSequence {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    return subSequence(0, n.coerceAtMost(length))\n}\n\n/**\n * Returns a string containing the first [n] characters from this string, or the entire string if this string is shorter.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.take\n */\npublic fun String.take(n: Int): String {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    return substring(0, n.coerceAtMost(length))\n}\n\n/**\n * Returns a subsequence of this char sequence containing the last [n] characters from this char sequence, or the entire char sequence if this char sequence is shorter.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.take\n */\npublic fun CharSequence.takeLast(n: Int): CharSequence {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    val length = length\n    return subSequence(length - n.coerceAtMost(length), length)\n}\n\n/**\n * Returns a string containing the last [n] characters from this string, or the entire string if this string is shorter.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.take\n */\npublic fun String.takeLast(n: Int): String {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    val length = length\n    return substring(length - n.coerceAtMost(length))\n}\n\n/**\n * Returns a subsequence of this char sequence containing last characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.take\n */\npublic inline fun CharSequence.takeLastWhile(predicate: (Char) -> Boolean): CharSequence {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return subSequence(index + 1, length)\n        }\n    }\n    return subSequence(0, length)\n}\n\n/**\n * Returns a string containing last characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.take\n */\npublic inline fun String.takeLastWhile(predicate: (Char) -> Boolean): String {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return substring(index + 1)\n        }\n    }\n    return this\n}\n\n/**\n * Returns a subsequence of this char sequence containing the first characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.take\n */\npublic inline fun CharSequence.takeWhile(predicate: (Char) -> Boolean): CharSequence {\n    for (index in 0 until length)\n        if (!predicate(get(index))) {\n            return subSequence(0, index)\n        }\n    return subSequence(0, length)\n}\n\n/**\n * Returns a string containing the first characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.take\n */\npublic inline fun String.takeWhile(predicate: (Char) -> Boolean): String {\n    for (index in 0 until length)\n        if (!predicate(get(index))) {\n            return substring(0, index)\n        }\n    return this\n}\n\n/**\n * Returns a char sequence with characters in reversed order.\n */\npublic fun CharSequence.reversed(): CharSequence {\n    return StringBuilder(this).reverse()\n}\n\n/**\n * Returns a string with characters in reversed order.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.reversed(): String {\n    return (this as CharSequence).reversed().toString()\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to characters of the given char sequence.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original char sequence.\n * \n * @sample samples.text.Strings.associate\n */\npublic inline fun <K, V> CharSequence.associate(transform: (Char) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(length).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing the characters from the given char sequence indexed by the key\n * returned from [keySelector] function applied to each character.\n * \n * If any two characters would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original char sequence.\n * \n * @sample samples.text.Strings.associateBy\n */\npublic inline fun <K> CharSequence.associateBy(keySelector: (Char) -> K): Map<K, Char> {\n    val capacity = mapCapacity(length).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Char>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to characters of the given char sequence.\n * \n * If any two characters would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original char sequence.\n * \n * @sample samples.text.Strings.associateByWithValueTransform\n */\npublic inline fun <K, V> CharSequence.associateBy(keySelector: (Char) -> K, valueTransform: (Char) -> V): Map<K, V> {\n    val capacity = mapCapacity(length).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each character of the given char sequence\n * and value is the character itself.\n * \n * If any two characters would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.text.Strings.associateByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Char>> CharSequence.associateByTo(destination: M, keySelector: (Char) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to characters of the given char sequence.\n * \n * If any two characters would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.text.Strings.associateByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> CharSequence.associateByTo(destination: M, keySelector: (Char) -> K, valueTransform: (Char) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each character of the given char sequence.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.text.Strings.associateTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> CharSequence.associateTo(destination: M, transform: (Char) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Returns a [Map] where keys are characters from the given char sequence and values are\n * produced by the [valueSelector] function applied to each character.\n * \n * If any two characters are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original char sequence.\n * \n * @sample samples.text.Strings.associateWith\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <V> CharSequence.associateWith(valueSelector: (Char) -> V): Map<Char, V> {\n    val result = LinkedHashMap<Char, V>(mapCapacity(length.coerceAtMost(128)).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each character of the given char sequence,\n * where key is the character itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two characters are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.text.Strings.associateWithTo\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <V, M : MutableMap<in Char, in V>> CharSequence.associateWithTo(destination: M, valueSelector: (Char) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Appends all characters to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Char>> CharSequence.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Returns a new [HashSet] of all characters.\n */\npublic fun CharSequence.toHashSet(): HashSet<Char> {\n    return toCollection(HashSet<Char>(mapCapacity(length.coerceAtMost(128))))\n}\n\n/**\n * Returns a [List] containing all characters.\n */\npublic fun CharSequence.toList(): List<Char> {\n    return when (length) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a new [MutableList] filled with all characters of this char sequence.\n */\npublic fun CharSequence.toMutableList(): MutableList<Char> {\n    return toCollection(ArrayList<Char>(length))\n}\n\n/**\n * Returns a [Set] of all characters.\n * \n * The returned set preserves the element iteration order of the original char sequence.\n */\npublic fun CharSequence.toSet(): Set<Char> {\n    return when (length) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Char>(mapCapacity(length.coerceAtMost(128))))\n    }\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each character of original char sequence.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> CharSequence.flatMap(transform: (Char) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each character\n * and its index in the original char sequence.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharSequence.flatMapIndexed(transform: (index: Int, Char) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each character\n * and its index in the original char sequence, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> CharSequence.flatMapIndexedTo(destination: C, transform: (index: Int, Char) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each character of original char sequence, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> CharSequence.flatMapTo(destination: C, transform: (Char) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Groups characters of the original char sequence by the key returned by the given [keySelector] function\n * applied to each character and returns a map where each group key is associated with a list of corresponding characters.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original char sequence.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> CharSequence.groupBy(keySelector: (Char) -> K): Map<K, List<Char>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Char>>(), keySelector)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each character of the original char sequence\n * by the key returned by the given [keySelector] function applied to the character\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original char sequence.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> CharSequence.groupBy(keySelector: (Char) -> K, valueTransform: (Char) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups characters of the original char sequence by the key returned by the given [keySelector] function\n * applied to each character and puts to the [destination] map each group key associated with a list of corresponding characters.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Char>>> CharSequence.groupByTo(destination: M, keySelector: (Char) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Char>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each character of the original char sequence\n * by the key returned by the given [keySelector] function applied to the character\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> CharSequence.groupByTo(destination: M, keySelector: (Char) -> K, valueTransform: (Char) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Creates a [Grouping] source from a char sequence to be used later with one of group-and-fold operations\n * using the specified [keySelector] function to extract a key from each character.\n * \n * @sample samples.collections.Grouping.groupingByEachCount\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <K> CharSequence.groupingBy(crossinline keySelector: (Char) -> K): Grouping<Char, K> {\n    return object : Grouping<Char, K> {\n        override fun sourceIterator(): Iterator<Char> = this@groupingBy.iterator()\n        override fun keyOf(element: Char): K = keySelector(element)\n    }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each character in the original char sequence.\n * \n * @sample samples.text.Strings.map\n */\npublic inline fun <R> CharSequence.map(transform: (Char) -> R): List<R> {\n    return mapTo(ArrayList<R>(length), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each character and its index in the original char sequence.\n * @param [transform] function that takes the index of a character and the character itself\n * and returns the result of the transform applied to the character.\n */\npublic inline fun <R> CharSequence.mapIndexed(transform: (index: Int, Char) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(length), transform)\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each character and its index in the original char sequence.\n * @param [transform] function that takes the index of a character and the character itself\n * and returns the result of the transform applied to the character.\n */\npublic inline fun <R : Any> CharSequence.mapIndexedNotNull(transform: (index: Int, Char) -> R?): List<R> {\n    return mapIndexedNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each character and its index in the original char sequence\n * and appends only the non-null results to the given [destination].\n * @param [transform] function that takes the index of a character and the character itself\n * and returns the result of the transform applied to the character.\n */\npublic inline fun <R : Any, C : MutableCollection<in R>> CharSequence.mapIndexedNotNullTo(destination: C, transform: (index: Int, Char) -> R?): C {\n    forEachIndexed { index, element -> transform(index, element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each character and its index in the original char sequence\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of a character and the character itself\n * and returns the result of the transform applied to the character.\n */\npublic inline fun <R, C : MutableCollection<in R>> CharSequence.mapIndexedTo(destination: C, transform: (index: Int, Char) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each character in the original char sequence.\n * \n * @sample samples.collections.Collections.Transformations.mapNotNull\n */\npublic inline fun <R : Any> CharSequence.mapNotNull(transform: (Char) -> R?): List<R> {\n    return mapNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each character in the original char sequence\n * and appends only the non-null results to the given [destination].\n */\npublic inline fun <R : Any, C : MutableCollection<in R>> CharSequence.mapNotNullTo(destination: C, transform: (Char) -> R?): C {\n    forEach { element -> transform(element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each character of the original char sequence\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> CharSequence.mapTo(destination: C, transform: (Char) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each character of the original char sequence\n * into an [IndexedValue] containing the index of that character and the character itself.\n */\npublic fun CharSequence.withIndex(): Iterable<IndexedValue<Char>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns `true` if all characters match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun CharSequence.all(predicate: (Char) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if char sequence has at least one character.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun CharSequence.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if at least one character matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun CharSequence.any(predicate: (Char) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns the length of this char sequence.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.count(): Int {\n    return length\n}\n\n/**\n * Returns the number of characters matching the given [predicate].\n */\npublic inline fun CharSequence.count(predicate: (Char) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each character.\n * \n * Returns the specified [initial] value if the char sequence is empty.\n * \n * @param [operation] function that takes current accumulator value and a character, and calculates the next accumulator value.\n */\npublic inline fun <R> CharSequence.fold(initial: R, operation: (acc: R, Char) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each character with its index in the original char sequence.\n * \n * Returns the specified [initial] value if the char sequence is empty.\n * \n * @param [operation] function that takes the index of a character, current accumulator value\n * and the character itself, and calculates the next accumulator value.\n */\npublic inline fun <R> CharSequence.foldIndexed(initial: R, operation: (index: Int, acc: R, Char) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each character and current accumulator value.\n * \n * Returns the specified [initial] value if the char sequence is empty.\n * \n * @param [operation] function that takes a character and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> CharSequence.foldRight(initial: R, operation: (Char, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each character with its index in the original char sequence and current accumulator value.\n * \n * Returns the specified [initial] value if the char sequence is empty.\n * \n * @param [operation] function that takes the index of a character, the character itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> CharSequence.foldRightIndexed(initial: R, operation: (index: Int, Char, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Performs the given [action] on each character.\n */\npublic inline fun CharSequence.forEach(action: (Char) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each character, providing sequential index with the character.\n * @param [action] function that takes the index of a character and the character itself\n * and performs the action on the character.\n */\npublic inline fun CharSequence.forEachIndexed(action: (index: Int, Char) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun CharSequence.max(): Char? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <R : Comparable<R>> CharSequence.maxBy(selector: (Char) -> R): Char? {\n    return maxByOrNull(selector)\n}\n\n/**\n * Returns the first character yielding the largest value of the given function or `null` if there are no characters.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> CharSequence.maxByOrNull(selector: (Char) -> R): Char? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each character in the char sequence.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.maxOf(selector: (Char) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each character in the char sequence.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.maxOf(selector: (Char) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each character in the char sequence.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> CharSequence.maxOf(selector: (Char) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each character in the char sequence or `null` if there are no characters.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.maxOfOrNull(selector: (Char) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each character in the char sequence or `null` if there are no characters.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.maxOfOrNull(selector: (Char) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each character in the char sequence or `null` if there are no characters.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> CharSequence.maxOfOrNull(selector: (Char) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each character in the char sequence.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharSequence.maxOfWith(comparator: Comparator<in R>, selector: (Char) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each character in the char sequence or `null` if there are no characters.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharSequence.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Char) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest character or `null` if there are no characters.\n */\n@SinceKotlin(\"1.4\")\npublic fun CharSequence.maxOrNull(): Char? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun CharSequence.maxWith(comparator: Comparator<in Char>): Char? {\n    return maxWithOrNull(comparator)\n}\n\n/**\n * Returns the first character having the largest value according to the provided [comparator] or `null` if there are no characters.\n */\n@SinceKotlin(\"1.4\")\npublic fun CharSequence.maxWithOrNull(comparator: Comparator<in Char>): Char? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun CharSequence.min(): Char? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <R : Comparable<R>> CharSequence.minBy(selector: (Char) -> R): Char? {\n    return minByOrNull(selector)\n}\n\n/**\n * Returns the first character yielding the smallest value of the given function or `null` if there are no characters.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> CharSequence.minByOrNull(selector: (Char) -> R): Char? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each character in the char sequence.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.minOf(selector: (Char) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each character in the char sequence.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.minOf(selector: (Char) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each character in the char sequence.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> CharSequence.minOf(selector: (Char) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each character in the char sequence or `null` if there are no characters.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.minOfOrNull(selector: (Char) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each character in the char sequence or `null` if there are no characters.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.minOfOrNull(selector: (Char) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each character in the char sequence or `null` if there are no characters.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> CharSequence.minOfOrNull(selector: (Char) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each character in the char sequence.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharSequence.minOfWith(comparator: Comparator<in R>, selector: (Char) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each character in the char sequence or `null` if there are no characters.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharSequence.minOfWithOrNull(comparator: Comparator<in R>, selector: (Char) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest character or `null` if there are no characters.\n */\n@SinceKotlin(\"1.4\")\npublic fun CharSequence.minOrNull(): Char? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun CharSequence.minWith(comparator: Comparator<in Char>): Char? {\n    return minWithOrNull(comparator)\n}\n\n/**\n * Returns the first character having the smallest value according to the provided [comparator] or `null` if there are no characters.\n */\n@SinceKotlin(\"1.4\")\npublic fun CharSequence.minWithOrNull(comparator: Comparator<in Char>): Char? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns `true` if the char sequence has no characters.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun CharSequence.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if no characters match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun CharSequence.none(predicate: (Char) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Performs the given [action] on each character and returns the char sequence itself afterwards.\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <S : CharSequence> S.onEach(action: (Char) -> Unit): S {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each character, providing sequential index with the character,\n * and returns the char sequence itself afterwards.\n * @param [action] function that takes the index of a character and the character itself\n * and performs the action on the character.\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <S : CharSequence> S.onEachIndexed(action: (index: Int, Char) -> Unit): S {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Accumulates value starting with the first character and applying [operation] from left to right\n * to current accumulator value and each character.\n * \n * Throws an exception if this char sequence is empty. If the char sequence can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and a character,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun CharSequence.reduce(operation: (acc: Char, Char) -> Char): Char {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty char sequence can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first character and applying [operation] from left to right\n * to current accumulator value and each character with its index in the original char sequence.\n * \n * Throws an exception if this char sequence is empty. If the char sequence can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of a character, current accumulator value and the character itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun CharSequence.reduceIndexed(operation: (index: Int, acc: Char, Char) -> Char): Char {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty char sequence can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first character and applying [operation] from left to right\n * to current accumulator value and each character with its index in the original char sequence.\n * \n * Returns `null` if the char sequence is empty.\n * \n * @param [operation] function that takes the index of a character, current accumulator value and the character itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun CharSequence.reduceIndexedOrNull(operation: (index: Int, acc: Char, Char) -> Char): Char? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first character and applying [operation] from left to right\n * to current accumulator value and each character.\n * \n * Returns `null` if the char sequence is empty.\n * \n * @param [operation] function that takes current accumulator value and a character,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun CharSequence.reduceOrNull(operation: (acc: Char, Char) -> Char): Char? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last character and applying [operation] from right to left\n * to each character and current accumulator value.\n * \n * Throws an exception if this char sequence is empty. If the char sequence can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes a character and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun CharSequence.reduceRight(operation: (Char, acc: Char) -> Char): Char {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty char sequence can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last character and applying [operation] from right to left\n * to each character with its index in the original char sequence and current accumulator value.\n * \n * Throws an exception if this char sequence is empty. If the char sequence can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of a character, the character itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun CharSequence.reduceRightIndexed(operation: (index: Int, Char, acc: Char) -> Char): Char {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty char sequence can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last character and applying [operation] from right to left\n * to each character with its index in the original char sequence and current accumulator value.\n * \n * Returns `null` if the char sequence is empty.\n * \n * @param [operation] function that takes the index of a character, the character itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun CharSequence.reduceRightIndexedOrNull(operation: (index: Int, Char, acc: Char) -> Char): Char? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last character and applying [operation] from right to left\n * to each character and current accumulator value.\n * \n * Returns `null` if the char sequence is empty.\n * \n * @param [operation] function that takes a character and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun CharSequence.reduceRightOrNull(operation: (Char, acc: Char) -> Char): Char? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each character and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and a character, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R> CharSequence.runningFold(initial: R, operation: (acc: R, Char) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(length + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each character, its index in the original char sequence and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of a character, current accumulator value\n * and the character itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R> CharSequence.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, Char) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(length + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each character and current accumulator value that starts with the first character of this char sequence.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and a character, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\npublic inline fun CharSequence.runningReduce(operation: (acc: Char, Char) -> Char): List<Char> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Char>(length).apply { add(accumulator) }\n    for (index in 1 until length) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each character, its index in the original char sequence and current accumulator value that starts with the first character of this char sequence.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of a character, current accumulator value\n * and the character itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\npublic inline fun CharSequence.runningReduceIndexed(operation: (index: Int, acc: Char, Char) -> Char): List<Char> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Char>(length).apply { add(accumulator) }\n    for (index in 1 until length) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each character and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and a character, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <R> CharSequence.scan(initial: R, operation: (acc: R, Char) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each character, its index in the original char sequence and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of a character, current accumulator value\n * and the character itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <R> CharSequence.scanIndexed(initial: R, operation: (index: Int, acc: R, Char) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each character in the char sequence.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun CharSequence.sumBy(selector: (Char) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each character in the char sequence.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun CharSequence.sumByDouble(selector: (Char) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each character in the char sequence.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.sumOf(selector: (Char) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each character in the char sequence.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.sumOf(selector: (Char) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each character in the char sequence.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.sumOf(selector: (Char) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each character in the char sequence.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.sumOf(selector: (Char) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each character in the char sequence.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.sumOf(selector: (Char) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Splits this char sequence into a list of strings each not exceeding the given [size].\n * \n * The last string in the resulting list may have fewer characters than the given [size].\n * \n * @param size the number of elements to take in each string, must be positive and can be greater than the number of elements in this char sequence.\n * \n * @sample samples.text.Strings.chunked\n */\n@SinceKotlin(\"1.2\")\npublic fun CharSequence.chunked(size: Int): List<String> {\n    return windowed(size, size, partialWindows = true)\n}\n\n/**\n * Splits this char sequence into several char sequences each not exceeding the given [size]\n * and applies the given [transform] function to an each.\n * \n * @return list of results of the [transform] applied to an each char sequence.\n * \n * Note that the char sequence passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * The last char sequence may have fewer characters than the given [size].\n * \n * @param size the number of elements to take in each char sequence, must be positive and can be greater than the number of elements in this char sequence.\n * \n * @sample samples.text.Strings.chunkedTransform\n */\n@SinceKotlin(\"1.2\")\npublic fun <R> CharSequence.chunked(size: Int, transform: (CharSequence) -> R): List<R> {\n    return windowed(size, size, partialWindows = true, transform = transform)\n}\n\n/**\n * Splits this char sequence into a sequence of strings each not exceeding the given [size].\n * \n * The last string in the resulting sequence may have fewer characters than the given [size].\n * \n * @param size the number of elements to take in each string, must be positive and can be greater than the number of elements in this char sequence.\n * \n * @sample samples.collections.Collections.Transformations.chunked\n */\n@SinceKotlin(\"1.2\")\npublic fun CharSequence.chunkedSequence(size: Int): Sequence<String> {\n    return chunkedSequence(size) { it.toString() }\n}\n\n/**\n * Splits this char sequence into several char sequences each not exceeding the given [size]\n * and applies the given [transform] function to an each.\n * \n * @return sequence of results of the [transform] applied to an each char sequence.\n * \n * Note that the char sequence passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * The last char sequence may have fewer characters than the given [size].\n * \n * @param size the number of elements to take in each char sequence, must be positive and can be greater than the number of elements in this char sequence.\n * \n * @sample samples.text.Strings.chunkedTransformToSequence\n */\n@SinceKotlin(\"1.2\")\npublic fun <R> CharSequence.chunkedSequence(size: Int, transform: (CharSequence) -> R): Sequence<R> {\n    return windowedSequence(size, size, partialWindows = true, transform = transform)\n}\n\n/**\n * Splits the original char sequence into pair of char sequences,\n * where *first* char sequence contains characters for which [predicate] yielded `true`,\n * while *second* char sequence contains characters for which [predicate] yielded `false`.\n * \n * @sample samples.text.Strings.partition\n */\npublic inline fun CharSequence.partition(predicate: (Char) -> Boolean): Pair<CharSequence, CharSequence> {\n    val first = StringBuilder()\n    val second = StringBuilder()\n    for (element in this) {\n        if (predicate(element)) {\n            first.append(element)\n        } else {\n            second.append(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original string into pair of strings,\n * where *first* string contains characters for which [predicate] yielded `true`,\n * while *second* string contains characters for which [predicate] yielded `false`.\n * \n * @sample samples.text.Strings.partition\n */\npublic inline fun String.partition(predicate: (Char) -> Boolean): Pair<String, String> {\n    val first = StringBuilder()\n    val second = StringBuilder()\n    for (element in this) {\n        if (predicate(element)) {\n            first.append(element)\n        } else {\n            second.append(element)\n        }\n    }\n    return Pair(first.toString(), second.toString())\n}\n\n/**\n * Returns a list of snapshots of the window of the given [size]\n * sliding along this char sequence with the given [step], where each\n * snapshot is a string.\n * \n * Several last strings may have fewer characters than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this char sequence.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.takeWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun CharSequence.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false): List<String> {\n    return windowed(size, step, partialWindows) { it.toString() }\n}\n\n/**\n * Returns a list of results of applying the given [transform] function to\n * an each char sequence representing a view over the window of the given [size]\n * sliding along this char sequence with the given [step].\n * \n * Note that the char sequence passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * Several last char sequences may have fewer characters than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this char sequence.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.averageWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <R> CharSequence.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false, transform: (CharSequence) -> R): List<R> {\n    checkWindowSizeStep(size, step)\n    val thisSize = this.length\n    val resultCapacity = thisSize / step + if (thisSize % step == 0) 0 else 1\n    val result = ArrayList<R>(resultCapacity)\n    var index = 0\n    while (index in 0 until thisSize) {\n        val end = index + size\n        val coercedEnd = if (end < 0 || end > thisSize) { if (partialWindows) thisSize else break } else end\n        result.add(transform(subSequence(index, coercedEnd)))\n        index += step\n    }\n    return result\n}\n\n/**\n * Returns a sequence of snapshots of the window of the given [size]\n * sliding along this char sequence with the given [step], where each\n * snapshot is a string.\n * \n * Several last strings may have fewer characters than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this char sequence.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.takeWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun CharSequence.windowedSequence(size: Int, step: Int = 1, partialWindows: Boolean = false): Sequence<String> {\n    return windowedSequence(size, step, partialWindows) { it.toString() }\n}\n\n/**\n * Returns a sequence of results of applying the given [transform] function to\n * an each char sequence representing a view over the window of the given [size]\n * sliding along this char sequence with the given [step].\n * \n * Note that the char sequence passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * Several last char sequences may have fewer characters than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this char sequence.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.averageWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <R> CharSequence.windowedSequence(size: Int, step: Int = 1, partialWindows: Boolean = false, transform: (CharSequence) -> R): Sequence<R> {\n    checkWindowSizeStep(size, step)\n    val windows = (if (partialWindows) indices else 0 until length - size + 1) step step\n    return windows.asSequence().map { index ->\n        val end = index + size\n        val coercedEnd = if (end < 0 || end > length) length else end\n        transform(subSequence(index, coercedEnd))\n    }\n}\n\n/**\n * Returns a list of pairs built from the characters of `this` and the [other] char sequences with the same index\n * The returned list has length of the shortest char sequence.\n * \n * @sample samples.text.Strings.zip\n */\npublic infix fun CharSequence.zip(other: CharSequence): List<Pair<Char, Char>> {\n    return zip(other) { c1, c2 -> c1 to c2 }\n}\n\n/**\n * Returns a list of values built from the characters of `this` and the [other] char sequences with the same index\n * using the provided [transform] function applied to each pair of characters.\n * The returned list has length of the shortest char sequence.\n * \n * @sample samples.text.Strings.zipWithTransform\n */\npublic inline fun <V> CharSequence.zip(other: CharSequence, transform: (a: Char, b: Char) -> V): List<V> {\n    val length = minOf(this.length, other.length)\n    val list = ArrayList<V>(length)\n    for (i in 0 until length) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs of each two adjacent characters in this char sequence.\n * \n * The returned list is empty if this char sequence contains less than two characters.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNext\n */\n@SinceKotlin(\"1.2\")\npublic fun CharSequence.zipWithNext(): List<Pair<Char, Char>> {\n    return zipWithNext { a, b -> a to b }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to an each pair of two adjacent characters in this char sequence.\n * \n * The returned list is empty if this char sequence contains less than two characters.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNextToFindDeltas\n */\n@SinceKotlin(\"1.2\")\npublic inline fun <R> CharSequence.zipWithNext(transform: (a: Char, b: Char) -> R): List<R> {\n    val size = length - 1\n    if (size < 1) return emptyList()\n    val result = ArrayList<R>(size)\n    for (index in 0 until size) {\n        result.add(transform(this[index], this[index + 1]))\n    }\n    return result\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original char sequence returning its characters when being iterated.\n */\npublic fun CharSequence.asIterable(): Iterable<Char> {\n    if (this is String && isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original char sequence returning its characters when being iterated.\n */\npublic fun CharSequence.asSequence(): Sequence<Char> {\n    if (this is String && isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n",null,null,"(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        define('kotlin', ['exports'], factory);\n    }\n    else if (typeof exports === 'object') {\n        factory(module.exports);\n    }\n    else {\n        root.kotlin = {};\n        factory(root.kotlin);\n    }\n}(this, function (Kotlin) {\n    var _ = Kotlin;\n\n    insertContent();\n}));\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors. \n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\nKotlin.isBooleanArray = function (a) {\n    return (Array.isArray(a) || a instanceof Int8Array) && a.$type$ === \"BooleanArray\"\n};\n\nKotlin.isByteArray = function (a) {\n    return a instanceof Int8Array && a.$type$ !== \"BooleanArray\"\n};\n\nKotlin.isShortArray = function (a) {\n    return a instanceof Int16Array\n};\n\nKotlin.isCharArray = function (a) {\n    return a instanceof Uint16Array && a.$type$ === \"CharArray\"\n};\n\nKotlin.isIntArray = function (a) {\n    return a instanceof Int32Array\n};\n\nKotlin.isFloatArray = function (a) {\n    return a instanceof Float32Array\n};\n\nKotlin.isDoubleArray = function (a) {\n    return a instanceof Float64Array\n};\n\nKotlin.isLongArray = function (a) {\n    return Array.isArray(a) && a.$type$ === \"LongArray\"\n};\n\nKotlin.isArray = function (a) {\n    return Array.isArray(a) && !a.$type$;\n};\n\nKotlin.isArrayish = function (a) {\n    return Array.isArray(a) || ArrayBuffer.isView(a)\n};\n\nKotlin.arrayToString = function (a) {\n    if (a === null) return \"null\"\n    var toString = Kotlin.isCharArray(a) ? String.fromCharCode : Kotlin.toString;\n    return \"[\" + Array.prototype.map.call(a, function(e) { return toString(e); }).join(\", \") + \"]\";\n};\n\nKotlin.arrayDeepToString = function (arr) {\n    return Kotlin.kotlin.collections.contentDeepToStringImpl(arr);\n};\n\nKotlin.arrayEquals = function (a, b) {\n    if (a === b) {\n        return true;\n    }\n    if (a === null || b === null || !Kotlin.isArrayish(b) || a.length !== b.length) {\n        return false;\n    }\n\n    for (var i = 0, n = a.length; i < n; i++) {\n        if (!Kotlin.equals(a[i], b[i])) {\n            return false;\n        }\n    }\n    return true;\n};\n\nKotlin.arrayDeepEquals = function (a, b) {\n    return Kotlin.kotlin.collections.contentDeepEqualsImpl(a, b);\n};\n\nKotlin.arrayHashCode = function (arr) {\n    if (arr === null) return 0\n    var result = 1;\n    for (var i = 0, n = arr.length; i < n; i++) {\n        result = ((31 * result | 0) + Kotlin.hashCode(arr[i])) | 0;\n    }\n    return result;\n};\n\nKotlin.arrayDeepHashCode = function (arr) {\n    return Kotlin.kotlin.collections.contentDeepHashCodeImpl(arr);\n};\n\nKotlin.primitiveArraySort = function (array) {\n    array.sort(Kotlin.doubleCompareTo)\n};\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors. \n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\nKotlin.getCallableRef = function(name, f) {\n    f.callableName = name;\n    return f;\n};\n\nKotlin.getPropertyCallableRef = function(name, paramCount, getter, setter) {\n    getter.get = getter;\n    getter.set = setter;\n    getter.callableName = name;\n    return getPropertyRefClass(getter, setter, propertyRefClassMetadataCache[paramCount]);\n};\n\nfunction getPropertyRefClass(obj, setter, cache) {\n    obj.$metadata$ = getPropertyRefMetadata(typeof setter === \"function\" ? cache.mutable : cache.immutable);\n    obj.constructor = obj;\n    return obj;\n}\n\nvar propertyRefClassMetadataCache = [\n    {\n        mutable: { value: null, implementedInterface: function () {\n            return Kotlin.kotlin.reflect.KMutableProperty0 }\n        },\n        immutable: { value: null, implementedInterface: function () {\n            return Kotlin.kotlin.reflect.KProperty0 }\n        }\n    },\n    {\n        mutable: { value: null, implementedInterface: function () {\n            return Kotlin.kotlin.reflect.KMutableProperty1 }\n        },\n        immutable: { value: null, implementedInterface: function () {\n            return Kotlin.kotlin.reflect.KProperty1 }\n        }\n    }\n];\n\nfunction getPropertyRefMetadata(cache) {\n    if (cache.value === null) {\n        cache.value = {\n            interfaces: [cache.implementedInterface()],\n            baseClass: null,\n            functions: {},\n            properties: {},\n            types: {},\n            staticMembers: {}\n        };\n    }\n    return cache.value;\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors. \n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\nKotlin.toShort = function (a) {\n    return (a & 0xFFFF) << 16 >> 16;\n};\n\nKotlin.toByte = function (a) {\n    return (a & 0xFF) << 24 >> 24;\n};\n\nKotlin.toChar = function (a) {\n    return a & 0xFFFF;\n};\n\nKotlin.numberToLong = function (a) {\n    return a instanceof Kotlin.Long ? a : Kotlin.Long.fromNumber(a);\n};\n\nKotlin.numberToInt = function (a) {\n    return a instanceof Kotlin.Long ? a.toInt() : Kotlin.doubleToInt(a);\n};\n\nKotlin.numberToShort = function (a) {\n    return Kotlin.toShort(Kotlin.numberToInt(a));\n};\n\nKotlin.numberToByte = function (a) {\n    return Kotlin.toByte(Kotlin.numberToInt(a));\n};\n\nKotlin.numberToDouble = function (a) {\n    return +a;\n};\n\nKotlin.numberToChar = function (a) {\n    return Kotlin.toChar(Kotlin.numberToInt(a));\n};\n\nKotlin.doubleToInt = function(a) {\n    if (a > 2147483647) return 2147483647;\n    if (a < -2147483648) return -2147483648;\n    return a | 0;\n};\n\nKotlin.toBoxedChar = function (a) {\n    if (a == null) return a;\n    if (a instanceof Kotlin.BoxedChar) return a;\n    return new Kotlin.BoxedChar(a);\n};\n\nKotlin.unboxChar = function(a) {\n    if (a == null) return a;\n    return Kotlin.toChar(a);\n};\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors. \n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\nKotlin.equals = function (obj1, obj2) {\n    if (obj1 == null) {\n        return obj2 == null;\n    }\n\n    if (obj2 == null) {\n        return false;\n    }\n\n    if (obj1 !== obj1) {\n        return obj2 !== obj2;\n    }\n\n    if (typeof obj1 === \"object\" && typeof obj1.equals === \"function\") {\n        return obj1.equals(obj2);\n    }\n\n    if (typeof obj1 === \"number\" && typeof obj2 === \"number\") {\n        return obj1 === obj2 && (obj1 !== 0 || 1 / obj1 === 1 / obj2)\n    }\n\n    return obj1 === obj2;\n};\n\nKotlin.hashCode = function (obj) {\n    if (obj == null) {\n        return 0;\n    }\n    var objType = typeof obj;\n    if (\"object\" === objType) {\n        return \"function\" === typeof obj.hashCode ? obj.hashCode() : getObjectHashCode(obj);\n    }\n    if (\"function\" === objType) {\n        return getObjectHashCode(obj);\n    }\n    if (\"number\" === objType) {\n        return Kotlin.numberHashCode(obj);\n    }\n    if (\"boolean\" === objType) {\n        return Number(obj)\n    }\n\n    var str = String(obj);\n    return getStringHashCode(str);\n};\n\n\nKotlin.toString = function (o) {\n    if (o == null) {\n        return \"null\";\n    }\n    else if (Kotlin.isArrayish(o)) {\n        return \"[...]\";\n    }\n    else {\n        return o.toString();\n    }\n};\n\n/** @const */\nvar POW_2_32 = 4294967296;\n// TODO: consider switching to Symbol type once we are on ES6.\n/** @const */\nvar OBJECT_HASH_CODE_PROPERTY_NAME = \"kotlinHashCodeValue$\";\n\nfunction getObjectHashCode(obj) {\n    if (!(OBJECT_HASH_CODE_PROPERTY_NAME in obj)) {\n        var hash = (Math.random() * POW_2_32) | 0; // Make 32-bit singed integer.\n        Object.defineProperty(obj, OBJECT_HASH_CODE_PROPERTY_NAME, { value:  hash, enumerable: false });\n    }\n    return obj[OBJECT_HASH_CODE_PROPERTY_NAME];\n}\n\nfunction getStringHashCode(str) {\n    var hash = 0;\n    for (var i = 0; i < str.length; i++) {\n        var code  = str.charCodeAt(i);\n        hash  = (hash * 31 + code) | 0; // Keep it 32-bit.\n    }\n    return hash;\n}\n\nKotlin.identityHashCode = getObjectHashCode;\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors. \n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\nKotlin.compareTo = function (a, b) {\n    var typeA = typeof a;\n    if (typeA === \"number\") {\n        if (typeof b === \"number\") {\n            return Kotlin.doubleCompareTo(a, b);\n        }\n        return Kotlin.primitiveCompareTo(a, b);\n    }\n    if (typeA === \"string\" || typeA === \"boolean\") {\n        return Kotlin.primitiveCompareTo(a, b);\n    }\n    return a.compareTo_11rb$(b);\n};\n\nKotlin.primitiveCompareTo = function (a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n};\n\nKotlin.doubleCompareTo = function (a, b) {\n    if (a < b) return -1;\n    if (a > b) return 1;\n\n    if (a === b) {\n        if (a !== 0) return 0;\n\n        var ia = 1 / a;\n        return ia === 1 / b ? 0 : (ia < 0 ? -1 : 1);\n    }\n\n    return a !== a ? (b !== b ? 0 : 1) : -1\n};\n\nKotlin.charInc = function (value) {\n    return Kotlin.toChar(value+1);\n};\n\nKotlin.charDec = function (value) {\n    return Kotlin.toChar(value-1);\n};\n\nKotlin.imul = Math.imul || imul;\n\nKotlin.imulEmulated = imul;\n\nfunction imul(a, b) {\n    return ((a & 0xffff0000) * (b & 0xffff) + (a & 0xffff) * (b | 0)) | 0;\n}\n\n(function() {\n    var buf = new ArrayBuffer(8);\n    var bufFloat64 = new Float64Array(buf);\n    var bufFloat32 = new Float32Array(buf);\n    var bufInt32 = new Int32Array(buf);\n    var lowIndex = 0;\n    var highIndex = 1;\n\n    bufFloat64[0] = -1; // bff00000_00000000\n    if (bufInt32[lowIndex] !== 0) {\n        lowIndex = 1;\n        highIndex = 0;\n    }\n\n    Kotlin.doubleToBits = function(value) {\n        return Kotlin.doubleToRawBits(isNaN(value) ? NaN : value);\n    };\n\n    Kotlin.doubleToRawBits = function(value) {\n        bufFloat64[0] = value;\n        return Kotlin.Long.fromBits(bufInt32[lowIndex], bufInt32[highIndex]);\n    };\n\n    Kotlin.doubleFromBits = function(value) {\n        bufInt32[lowIndex] = value.low_;\n        bufInt32[highIndex] = value.high_;\n        return bufFloat64[0];\n    };\n\n    Kotlin.floatToBits = function(value) {\n        return Kotlin.floatToRawBits(isNaN(value) ? NaN : value);\n    };\n\n    Kotlin.floatToRawBits = function(value) {\n        bufFloat32[0] = value;\n        return bufInt32[0];\n    };\n\n    Kotlin.floatFromBits = function(value) {\n        bufInt32[0] = value;\n        return bufFloat32[0];\n    };\n\n    // returns zero value for number with positive sign bit and non-zero value for number with negative sign bit.\n    Kotlin.doubleSignBit = function(value) {\n        bufFloat64[0] = value;\n        return bufInt32[highIndex] & 0x80000000;\n    };\n\n    Kotlin.numberHashCode = function(obj) {\n        if ((obj | 0) === obj) {\n            return obj | 0;\n        }\n        else {\n            bufFloat64[0] = obj;\n            return (bufInt32[highIndex] * 31 | 0) + bufInt32[lowIndex] | 0;\n        }\n    }\n})();\n\nKotlin.ensureNotNull = function(x) {\n    return x != null ? x : Kotlin.throwNPE();\n};\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\nif (typeof String.prototype.startsWith === \"undefined\") {\n    Object.defineProperty(String.prototype, \"startsWith\", {\n        value: function (searchString, position) {\n            position = position || 0;\n            return this.lastIndexOf(searchString, position) === position;\n        }\n    });\n}\nif (typeof String.prototype.endsWith === \"undefined\") {\n    Object.defineProperty(String.prototype, \"endsWith\", {\n        value: function (searchString, position) {\n            var subjectString = this.toString();\n            if (position === undefined || position > subjectString.length) {\n                position = subjectString.length;\n            }\n            position -= searchString.length;\n            var lastIndex = subjectString.indexOf(searchString, position);\n            return lastIndex !== -1 && lastIndex === position;\n        }\n    });\n}\n// ES6 Math polyfills\nif (typeof Math.sign === \"undefined\") {\n    Math.sign = function(x) {\n        x = +x; // convert to a number\n        if (x === 0 || isNaN(x)) {\n            return Number(x);\n        }\n        return x > 0 ? 1 : -1;\n    };\n}\nif (typeof Math.trunc === \"undefined\") {\n    Math.trunc = function(x) {\n        if (isNaN(x)) {\n            return NaN;\n        }\n        if (x > 0) {\n            return Math.floor(x);\n        }\n        return Math.ceil(x);\n    };\n}\n\n(function() {\n    var epsilon = 2.220446049250313E-16;\n    var taylor_2_bound = Math.sqrt(epsilon);\n    var taylor_n_bound = Math.sqrt(taylor_2_bound);\n    var upper_taylor_2_bound = 1/taylor_2_bound;\n    var upper_taylor_n_bound = 1/taylor_n_bound;\n\n    if (typeof Math.sinh === \"undefined\") {\n        Math.sinh = function(x) {\n            if (Math.abs(x) < taylor_n_bound) {\n                var result = x;\n                if (Math.abs(x) > taylor_2_bound) {\n                    result += (x * x * x) / 6;\n                }\n                return result;\n            } else {\n                var y = Math.exp(x);\n                var y1 = 1 / y;\n                if (!isFinite(y)) return Math.exp(x - Math.LN2);\n                if (!isFinite(y1)) return -Math.exp(-x - Math.LN2);\n                return (y - y1) / 2;\n            }\n        };\n    }\n    if (typeof Math.cosh === \"undefined\") {\n        Math.cosh = function(x) {\n            var y = Math.exp(x);\n            var y1 = 1 / y;\n            if (!isFinite(y) || !isFinite(y1)) return Math.exp(Math.abs(x) - Math.LN2);\n            return (y + y1) / 2;\n        };\n    }\n\n    if (typeof Math.tanh === \"undefined\") {\n        Math.tanh = function(x){\n            if (Math.abs(x) < taylor_n_bound) {\n                var result = x;\n                if (Math.abs(x) > taylor_2_bound) {\n                    result -= (x * x * x) / 3;\n                }\n                return result;\n            }\n            else {\n                var a = Math.exp(+x), b = Math.exp(-x);\n                return a === Infinity ? 1 : b === Infinity ? -1 : (a - b) / (a + b);\n            }\n        };\n    }\n\n    // Inverse hyperbolic function implementations derived from boost special math functions,\n    // Copyright Eric Ford & Hubert Holin 2001.\n\n    if (typeof Math.asinh === \"undefined\") {\n        var asinh = function(x) {\n            if (x >= +taylor_n_bound)\n            {\n                if (x > upper_taylor_n_bound)\n                {\n                    if (x > upper_taylor_2_bound)\n                    {\n                        // approximation by laurent series in 1/x at 0+ order from -1 to 0\n                        return Math.log(x) + Math.LN2;\n                    }\n                    else\n                    {\n                        // approximation by laurent series in 1/x at 0+ order from -1 to 1\n                        return Math.log(x * 2 + (1 / (x * 2)));\n                    }\n                }\n                else\n                {\n                    return Math.log(x + Math.sqrt(x * x + 1));\n                }\n            }\n            else if (x <= -taylor_n_bound)\n            {\n                return -asinh(-x);\n            }\n            else\n            {\n                // approximation by taylor series in x at 0 up to order 2\n                var result = x;\n                if (Math.abs(x) >= taylor_2_bound)\n                {\n                    var x3 = x * x * x;\n                    // approximation by taylor series in x at 0 up to order 4\n                    result -= x3 / 6;\n                }\n                return result;\n            }\n        };\n        Math.asinh = asinh;\n    }\n    if (typeof Math.acosh === \"undefined\") {\n        Math.acosh = function(x) {\n            if (x < 1)\n            {\n                return NaN;\n            }\n            else if (x - 1 >= taylor_n_bound)\n            {\n                if (x > upper_taylor_2_bound)\n                {\n                    // approximation by laurent series in 1/x at 0+ order from -1 to 0\n                    return Math.log(x) + Math.LN2;\n                }\n                else\n                {\n                    return Math.log(x + Math.sqrt(x * x - 1));\n                }\n            }\n            else\n            {\n                var y = Math.sqrt(x - 1);\n                // approximation by taylor series in y at 0 up to order 2\n                var result = y;\n                if (y >= taylor_2_bound)\n                {\n                    var y3 = y * y * y;\n                    // approximation by taylor series in y at 0 up to order 4\n                    result -= y3 / 12;\n                }\n\n                return Math.sqrt(2) * result;\n            }\n        };\n    }\n    if (typeof Math.atanh === \"undefined\") {\n        Math.atanh = function(x) {\n            if (Math.abs(x) < taylor_n_bound) {\n                var result = x;\n                if (Math.abs(x) > taylor_2_bound) {\n                    result += (x * x * x) / 3;\n                }\n                return result;\n            }\n            return Math.log((1 + x) / (1 - x)) / 2;\n        };\n    }\n    if (typeof Math.log1p === \"undefined\") {\n        Math.log1p = function(x) {\n            if (Math.abs(x) < taylor_n_bound) {\n                var x2 = x * x;\n                var x3 = x2 * x;\n                var x4 = x3 * x;\n                // approximation by taylor series in x at 0 up to order 4\n                return (-x4 / 4 + x3 / 3 - x2 / 2 + x);\n            }\n            return Math.log(x + 1);\n        };\n    }\n    if (typeof Math.expm1 === \"undefined\") {\n        Math.expm1 = function(x) {\n            if (Math.abs(x) < taylor_n_bound) {\n                var x2 = x * x;\n                var x3 = x2 * x;\n                var x4 = x3 * x;\n                // approximation by taylor series in x at 0 up to order 4\n                return (x4 / 24 + x3 / 6 + x2 / 2 + x);\n            }\n            return Math.exp(x) - 1;\n        };\n    }\n})();\nif (typeof Math.hypot === \"undefined\") {\n    Math.hypot = function() {\n        var y = 0;\n        var length = arguments.length;\n\n        for (var i = 0; i < length; i++) {\n            if (arguments[i] === Infinity || arguments[i] === -Infinity) {\n                return Infinity;\n            }\n            y += arguments[i] * arguments[i];\n        }\n        return Math.sqrt(y);\n    };\n}\nif (typeof Math.log10 === \"undefined\") {\n    Math.log10 = function(x) {\n        return Math.log(x) * Math.LOG10E;\n    };\n}\nif (typeof Math.log2 === \"undefined\") {\n    Math.log2 = function(x) {\n        return Math.log(x) * Math.LOG2E;\n    };\n}\nif (typeof Math.clz32 === \"undefined\") {\n    Math.clz32 = (function(log, LN2) {\n        return function(x) {\n            var asUint = x >>> 0;\n            if (asUint === 0) {\n                return 32;\n            }\n            return 31 - (log(asUint) / LN2 | 0) | 0; // the \"| 0\" acts like math.floor\n        };\n    })(Math.log, Math.LN2);\n}\n\n// For HtmlUnit and PhantomJs\nif (typeof ArrayBuffer.isView === \"undefined\") {\n    ArrayBuffer.isView = function(a) {\n        return a != null && a.__proto__ != null && a.__proto__.__proto__ === Int8Array.prototype.__proto__;\n    };\n}\n\nif (typeof Array.prototype.fill === \"undefined\") {\n    // Polyfill from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/fill#Polyfill\n    Object.defineProperty(Array.prototype, 'fill', {\n        value: function (value) {\n\n            // Steps 1-2.\n            if (this == null) {\n                throw new TypeError('this is null or not defined');\n            }\n\n            var O = Object(this);\n\n            // Steps 3-5.\n            var len = O.length >>> 0;\n\n            // Steps 6-7.\n            var start = arguments[1];\n            var relativeStart = start >> 0;\n\n            // Step 8.\n            var k = relativeStart < 0 ?\n                    Math.max(len + relativeStart, 0) :\n                    Math.min(relativeStart, len);\n\n            // Steps 9-10.\n            var end = arguments[2];\n            var relativeEnd = end === undefined ?\n                              len : end >> 0;\n\n            // Step 11.\n            var finalValue = relativeEnd < 0 ?\n                             Math.max(len + relativeEnd, 0) :\n                             Math.min(relativeEnd, len);\n\n            // Step 12.\n            while (k < finalValue) {\n                O[k] = value;\n                k++;\n            }\n\n            // Step 13.\n            return O;\n        }\n    });\n}\n\n(function() {\n    function normalizeOffset(offset, length) {\n        if (offset < 0) return Math.max(0, offset + length);\n        return Math.min(offset, length);\n    }\n    function typedArraySlice(begin, end) {\n        if (typeof end === \"undefined\") {\n            end = this.length;\n        }\n        begin = normalizeOffset(begin || 0, this.length);\n        end = Math.max(begin, normalizeOffset(end, this.length));\n        return new this.constructor(this.subarray(begin, end));\n    }\n\n    var arrays = [Int8Array, Int16Array, Uint16Array, Int32Array, Float32Array, Float64Array];\n    for (var i = 0; i < arrays.length; ++i) {\n        var TypedArray = arrays[i];\n        if (typeof TypedArray.prototype.fill === \"undefined\") {\n            Object.defineProperty(TypedArray.prototype, 'fill', {\n                value: Array.prototype.fill\n            });\n        }\n        if (typeof TypedArray.prototype.slice === \"undefined\") {\n            Object.defineProperty(TypedArray.prototype, 'slice', {\n                value: typedArraySlice\n            });\n        }\n    }\n\n    // Patch apply to work with TypedArrays if needed.\n    try {\n        (function() {}).apply(null, new Int32Array(0))\n    } catch (e) {\n        var apply = Function.prototype.apply;\n        Object.defineProperty(Function.prototype, 'apply', {\n            value: function(self, array) {\n                return apply.call(this, self, [].slice.call(array));\n            }\n        });\n    }\n\n\n    // Patch map to work with TypedArrays if needed.\n    for (var i = 0; i < arrays.length; ++i) {\n        var TypedArray = arrays[i];\n        if (typeof TypedArray.prototype.map === \"undefined\") {\n            Object.defineProperty(TypedArray.prototype, 'map', {\n                value: function(callback, self) {\n                    return [].slice.call(this).map(callback, self);\n                }\n            });\n        }\n    }\n\n    // Patch sort to work with TypedArrays if needed.\n    // TODO: consider to remove following function and replace it with `Kotlin.doubleCompareTo` (see misc.js)\n    var totalOrderComparator = function (a, b) {\n        if (a < b) return -1;\n        if (a > b) return 1;\n\n        if (a === b) {\n            if (a !== 0) return 0;\n\n            var ia = 1 / a;\n            return ia === 1 / b ? 0 : (ia < 0 ? -1 : 1);\n        }\n\n        return a !== a ? (b !== b ? 0 : 1) : -1\n    };\n\n    for (var i = 0; i < arrays.length; ++i) {\n        var TypedArray = arrays[i];\n        if (typeof TypedArray.prototype.sort === \"undefined\") {\n            Object.defineProperty(TypedArray.prototype, 'sort', {\n                value: function(compareFunction) {\n                    return Array.prototype.sort.call(this, compareFunction || totalOrderComparator);\n                }\n            });\n        }\n    }\n})();\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors. \n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n/**\n * @param {string} id\n * @param {Object} declaration\n */\nKotlin.defineModule = function (id, declaration) {\n};\n\nKotlin.defineInlineFunction = function(tag, fun) {\n    return fun;\n};\n\nKotlin.wrapFunction = function(fun) {\n    var f = function() {\n        f = fun();\n        return f.apply(this, arguments);\n    };\n    return function() {\n        return f.apply(this, arguments);\n    };\n};\n\nKotlin.isTypeOf = function(type) {\n    return function (object) {\n        return typeof object === type;\n    }\n};\n\nKotlin.isInstanceOf = function (klass) {\n    return function (object) {\n        return Kotlin.isType(object, klass);\n    }\n};\n\nKotlin.orNull = function (fn) {\n    return function (object) {\n        return object == null || fn(object);\n    }\n};\n\nKotlin.andPredicate = function (a, b) {\n    return function (object) {\n        return a(object) && b(object);\n    }\n};\n\nKotlin.kotlinModuleMetadata = function (abiVersion, moduleName, data) {\n};\n\nKotlin.suspendCall = function(value) {\n    return value;\n};\n\nKotlin.coroutineResult = function(qualifier) {\n    throwMarkerError();\n};\n\nKotlin.coroutineController = function(qualifier) {\n    throwMarkerError();\n};\n\nKotlin.coroutineReceiver = function(qualifier) {\n    throwMarkerError();\n};\n\nKotlin.setCoroutineResult = function(value, qualifier) {\n    throwMarkerError();\n};\n\nKotlin.getReifiedTypeParameterKType = function(typeParameter) {\n    throwMarkerError();\n};\n\nfunction throwMarkerError() {\n    throw new Error(\n        \"This marker function should never been called. \" +\n        \"Looks like compiler did not eliminate it properly. \" +\n        \"Please, report an issue if you caught this exception.\");\n}\n\nKotlin.getFunctionById = function(id, defaultValue) {\n    return function() {\n        return defaultValue;\n    }\n};","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors. \n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\nKotlin.Kind = {\n    CLASS: \"class\",\n    INTERFACE: \"interface\",\n    OBJECT: \"object\"\n};\n\nKotlin.callGetter = function (thisObject, klass, propertyName) {\n    var propertyDescriptor = Object.getOwnPropertyDescriptor(klass, propertyName);\n    if (propertyDescriptor != null && propertyDescriptor.get != null) {\n        return propertyDescriptor.get.call(thisObject);\n    }\n\n    propertyDescriptor = Object.getOwnPropertyDescriptor(thisObject, propertyName);\n    if (propertyDescriptor != null && \"value\" in propertyDescriptor) {\n        return thisObject[propertyName];\n    }\n\n    return Kotlin.callGetter(thisObject, Object.getPrototypeOf(klass), propertyName);\n};\n\nKotlin.callSetter = function (thisObject, klass, propertyName, value) {\n    var propertyDescriptor = Object.getOwnPropertyDescriptor(klass, propertyName);\n    if (propertyDescriptor != null && propertyDescriptor.set != null) {\n        propertyDescriptor.set.call(thisObject, value);\n        return;\n    }\n\n    propertyDescriptor = Object.getOwnPropertyDescriptor(thisObject, propertyName);\n    if (propertyDescriptor != null && \"value\" in propertyDescriptor) {\n        thisObject[propertyName] = value;\n        return\n    }\n\n    Kotlin.callSetter(thisObject, Object.getPrototypeOf(klass), propertyName, value);\n};\n\nfunction isInheritanceFromInterface(ctor, iface) {\n    if (ctor === iface) return true;\n\n    var metadata = ctor.$metadata$;\n    if (metadata != null) {\n        var interfaces = metadata.interfaces;\n        for (var i = 0; i < interfaces.length; i++) {\n            if (isInheritanceFromInterface(interfaces[i], iface)) {\n                return true;\n            }\n        }\n    }\n\n    var superPrototype = ctor.prototype != null ? Object.getPrototypeOf(ctor.prototype) : null;\n    var superConstructor = superPrototype != null ? superPrototype.constructor : null;\n    return superConstructor != null && isInheritanceFromInterface(superConstructor, iface);\n}\n\n/**\n *\n * @param {*} object\n * @param {Function|Object} klass\n * @returns {Boolean}\n */\nKotlin.isType = function (object, klass) {\n    if (klass === Object) {\n        switch (typeof object) {\n            case \"string\":\n            case \"number\":\n            case \"boolean\":\n            case \"function\":\n                return true;\n            default:\n                return object instanceof Object;\n        }\n    }\n\n    if (object == null || klass == null || (typeof object !== 'object' && typeof object !== 'function')) {\n        return false;\n    }\n\n    if (typeof klass === \"function\" && object instanceof klass) {\n        return true;\n    }\n\n    var proto = Object.getPrototypeOf(klass);\n    var constructor = proto != null ? proto.constructor : null;\n    if (constructor != null && \"$metadata$\" in constructor) {\n        var metadata = constructor.$metadata$;\n        if (metadata.kind === Kotlin.Kind.OBJECT) {\n            return object === klass;\n        }\n    }\n\n    var klassMetadata = klass.$metadata$;\n\n    // In WebKit (JavaScriptCore) for some interfaces from DOM typeof returns \"object\", nevertheless they can be used in RHS of instanceof\n    if (klassMetadata == null) {\n        return object instanceof klass;\n    }\n\n    if (klassMetadata.kind === Kotlin.Kind.INTERFACE && object.constructor != null) {\n        return isInheritanceFromInterface(object.constructor, klass);\n    }\n\n    return false;\n};\n\nKotlin.isNumber = function (a) {\n    return typeof a == \"number\" || a instanceof Kotlin.Long;\n};\n\nKotlin.isChar = function (value) {\n    return value instanceof Kotlin.BoxedChar\n};\n\nKotlin.isComparable = function (value) {\n    var type = typeof value;\n\n    return type === \"string\" ||\n           type === \"boolean\" ||\n           Kotlin.isNumber(value) ||\n           Kotlin.isType(value, Kotlin.kotlin.Comparable);\n};\n\nKotlin.isCharSequence = function (value) {\n    return typeof value === \"string\" || Kotlin.isType(value, Kotlin.kotlin.CharSequence);\n};","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors. \n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Copyright 2009 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\n/**\n * Constructs a 64-bit two's-complement integer, given its low and high 32-bit\n * values as *signed* integers.  See the from* functions below for more\n * convenient ways of constructing Longs.\n *\n * The internal representation of a long is the two given signed, 32-bit values.\n * We use 32-bit pieces because these are the size of integers on which\n * Javascript performs bit-operations.  For operations like addition and\n * multiplication, we split each number into 16-bit pieces, which can easily be\n * multiplied within Javascript's floating-point representation without overflow\n * or change in sign.\n *\n * In the algorithms below, we frequently reduce the negative case to the\n * positive case by negating the input(s) and then post-processing the result.\n * Note that we must ALWAYS check specially whether those values are MIN_VALUE\n * (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as\n * a positive number, it overflows back into a negative).  Not handling this\n * case would often result in infinite recursion.\n *\n * @param {number} low  The low (signed) 32 bits of the long.\n * @param {number} high  The high (signed) 32 bits of the long.\n * @constructor\n * @final\n */\nKotlin.Long = function(low, high) {\n  /**\n   * @type {number}\n   * @private\n   */\n  this.low_ = low | 0;  // force into 32 signed bits.\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this.high_ = high | 0;  // force into 32 signed bits.\n};\n\nKotlin.Long.$metadata$ = {\n    kind: \"class\",\n    simpleName: \"Long\",\n    interfaces:[]\n};\n\n\n// NOTE: Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the\n// from* methods on which they depend.\n\n\n/**\n * A cache of the Long representations of small integer values.\n * @type {!Object}\n * @private\n */\nKotlin.Long.IntCache_ = {};\n\n\n/**\n * Returns a Long representing the given (32-bit) integer value.\n * @param {number} value The 32-bit integer in question.\n * @return {!Kotlin.Long} The corresponding Long value.\n */\nKotlin.Long.fromInt = function(value) {\n  if (-128 <= value && value < 128) {\n    var cachedObj = Kotlin.Long.IntCache_[value];\n    if (cachedObj) {\n      return cachedObj;\n    }\n  }\n\n  var obj = new Kotlin.Long(value | 0, value < 0 ? -1 : 0);\n  if (-128 <= value && value < 128) {\n    Kotlin.Long.IntCache_[value] = obj;\n  }\n  return obj;\n};\n\n\n/**\n * Converts this number value to `Long`.\n * The fractional part, if any, is rounded down towards zero.\n * Returns zero if this `Double` value is `NaN`, `Long.MIN_VALUE` if it's less than `Long.MIN_VALUE`,\n * `Long.MAX_VALUE` if it's bigger than `Long.MAX_VALUE`.\n * @param {number} value The number in question.\n * @return {!Kotlin.Long} The corresponding Long value.\n */\nKotlin.Long.fromNumber = function(value) {\n  if (isNaN(value)) {\n    return Kotlin.Long.ZERO;\n  } else if (value <= -Kotlin.Long.TWO_PWR_63_DBL_) {\n    return Kotlin.Long.MIN_VALUE;\n  } else if (value + 1 >= Kotlin.Long.TWO_PWR_63_DBL_) {\n    return Kotlin.Long.MAX_VALUE;\n  } else if (value < 0) {\n    return Kotlin.Long.fromNumber(-value).negate();\n  } else {\n    return new Kotlin.Long(\n        (value % Kotlin.Long.TWO_PWR_32_DBL_) | 0,\n        (value / Kotlin.Long.TWO_PWR_32_DBL_) | 0);\n  }\n};\n\n\n/**\n * Returns a Long representing the 64-bit integer that comes by concatenating\n * the given high and low bits.  Each is assumed to use 32 bits.\n * @param {number} lowBits The low 32-bits.\n * @param {number} highBits The high 32-bits.\n * @return {!Kotlin.Long} The corresponding Long value.\n */\nKotlin.Long.fromBits = function(lowBits, highBits) {\n  return new Kotlin.Long(lowBits, highBits);\n};\n\n\n/**\n * Returns a Long representation of the given string, written using the given\n * radix.\n * @param {string} str The textual representation of the Long.\n * @param {number=} opt_radix The radix in which the text is written.\n * @return {!Kotlin.Long} The corresponding Long value.\n */\nKotlin.Long.fromString = function(str, opt_radix) {\n  if (str.length == 0) {\n    throw Error('number format error: empty string');\n  }\n\n  var radix = opt_radix || 10;\n  if (radix < 2 || 36 < radix) {\n    throw Error('radix out of range: ' + radix);\n  }\n\n  if (str.charAt(0) == '-') {\n    return Kotlin.Long.fromString(str.substring(1), radix).negate();\n  } else if (str.indexOf('-') >= 0) {\n    throw Error('number format error: interior \"-\" character: ' + str);\n  }\n\n  // Do several (8) digits each time through the loop, so as to\n  // minimize the calls to the very expensive emulated div.\n  var radixToPower = Kotlin.Long.fromNumber(Math.pow(radix, 8));\n\n  var result = Kotlin.Long.ZERO;\n  for (var i = 0; i < str.length; i += 8) {\n    var size = Math.min(8, str.length - i);\n    var value = parseInt(str.substring(i, i + size), radix);\n    if (size < 8) {\n      var power = Kotlin.Long.fromNumber(Math.pow(radix, size));\n      result = result.multiply(power).add(Kotlin.Long.fromNumber(value));\n    } else {\n      result = result.multiply(radixToPower);\n      result = result.add(Kotlin.Long.fromNumber(value));\n    }\n  }\n  return result;\n};\n\n\n// NOTE: the compiler should inline these constant values below and then remove\n// these variables, so there should be no runtime penalty for these.\n\n\n/**\n * Number used repeated below in calculations.  This must appear before the\n * first call to any from* function below.\n * @type {number}\n * @private\n */\nKotlin.Long.TWO_PWR_16_DBL_ = 1 << 16;\n\n\n/**\n * @type {number}\n * @private\n */\nKotlin.Long.TWO_PWR_24_DBL_ = 1 << 24;\n\n\n/**\n * @type {number}\n * @private\n */\nKotlin.Long.TWO_PWR_32_DBL_ =\n    Kotlin.Long.TWO_PWR_16_DBL_ * Kotlin.Long.TWO_PWR_16_DBL_;\n\n\n/**\n * @type {number}\n * @private\n */\nKotlin.Long.TWO_PWR_31_DBL_ =\n    Kotlin.Long.TWO_PWR_32_DBL_ / 2;\n\n\n/**\n * @type {number}\n * @private\n */\nKotlin.Long.TWO_PWR_48_DBL_ =\n    Kotlin.Long.TWO_PWR_32_DBL_ * Kotlin.Long.TWO_PWR_16_DBL_;\n\n\n/**\n * @type {number}\n * @private\n */\nKotlin.Long.TWO_PWR_64_DBL_ =\n    Kotlin.Long.TWO_PWR_32_DBL_ * Kotlin.Long.TWO_PWR_32_DBL_;\n\n\n/**\n * @type {number}\n * @private\n */\nKotlin.Long.TWO_PWR_63_DBL_ =\n    Kotlin.Long.TWO_PWR_64_DBL_ / 2;\n\n\n/** @type {!Kotlin.Long} */\nKotlin.Long.ZERO = Kotlin.Long.fromInt(0);\n\n\n/** @type {!Kotlin.Long} */\nKotlin.Long.ONE = Kotlin.Long.fromInt(1);\n\n\n/** @type {!Kotlin.Long} */\nKotlin.Long.NEG_ONE = Kotlin.Long.fromInt(-1);\n\n\n/** @type {!Kotlin.Long} */\nKotlin.Long.MAX_VALUE =\n    Kotlin.Long.fromBits(0xFFFFFFFF | 0, 0x7FFFFFFF | 0);\n\n\n/** @type {!Kotlin.Long} */\nKotlin.Long.MIN_VALUE = Kotlin.Long.fromBits(0, 0x80000000 | 0);\n\n\n/**\n * @type {!Kotlin.Long}\n * @private\n */\nKotlin.Long.TWO_PWR_24_ = Kotlin.Long.fromInt(1 << 24);\n\n\n/** @return {number} The value, assuming it is a 32-bit integer. */\nKotlin.Long.prototype.toInt = function() {\n  return this.low_;\n};\n\n\n/** @return {number} The closest floating-point representation to this value. */\nKotlin.Long.prototype.toNumber = function() {\n  return this.high_ * Kotlin.Long.TWO_PWR_32_DBL_ +\n         this.getLowBitsUnsigned();\n};\n\n/** @return {number} The 32-bit hashCode of this value. */\nKotlin.Long.prototype.hashCode = function() {\n  return this.high_ ^ this.low_;\n};\n\n/**\n * @param {number=} opt_radix The radix in which the text should be written.\n * @return {string} The textual representation of this value.\n * @override\n */\nKotlin.Long.prototype.toString = function(opt_radix) {\n  var radix = opt_radix || 10;\n  if (radix < 2 || 36 < radix) {\n    throw Error('radix out of range: ' + radix);\n  }\n\n  if (this.isZero()) {\n    return '0';\n  }\n\n  if (this.isNegative()) {\n    if (this.equalsLong(Kotlin.Long.MIN_VALUE)) {\n      // We need to change the Long value before it can be negated, so we remove\n      // the bottom-most digit in this base and then recurse to do the rest.\n      var radixLong = Kotlin.Long.fromNumber(radix);\n      var div = this.div(radixLong);\n      var rem = div.multiply(radixLong).subtract(this);\n      return div.toString(radix) + rem.toInt().toString(radix);\n    } else {\n      return '-' + this.negate().toString(radix);\n    }\n  }\n\n  // Do several (6) digits each time through the loop, so as to\n  // minimize the calls to the very expensive emulated div.\n  var radixToPower = Kotlin.Long.fromNumber(Math.pow(radix, 6));\n\n  var rem = this;\n  var result = '';\n  while (true) {\n    var remDiv = rem.div(radixToPower);\n    var intval = rem.subtract(remDiv.multiply(radixToPower)).toInt();\n    var digits = intval.toString(radix);\n\n    rem = remDiv;\n    if (rem.isZero()) {\n      return digits + result;\n    } else {\n      while (digits.length < 6) {\n        digits = '0' + digits;\n      }\n      result = '' + digits + result;\n    }\n  }\n};\n\n\n/** @return {number} The high 32-bits as a signed value. */\nKotlin.Long.prototype.getHighBits = function() {\n  return this.high_;\n};\n\n\n/** @return {number} The low 32-bits as a signed value. */\nKotlin.Long.prototype.getLowBits = function() {\n  return this.low_;\n};\n\n\n/** @return {number} The low 32-bits as an unsigned value. */\nKotlin.Long.prototype.getLowBitsUnsigned = function() {\n  return (this.low_ >= 0) ?\n      this.low_ : Kotlin.Long.TWO_PWR_32_DBL_ + this.low_;\n};\n\n\n/**\n * @return {number} Returns the number of bits needed to represent the absolute\n *     value of this Long.\n */\nKotlin.Long.prototype.getNumBitsAbs = function() {\n  if (this.isNegative()) {\n    if (this.equalsLong(Kotlin.Long.MIN_VALUE)) {\n      return 64;\n    } else {\n      return this.negate().getNumBitsAbs();\n    }\n  } else {\n    var val = this.high_ != 0 ? this.high_ : this.low_;\n    for (var bit = 31; bit > 0; bit--) {\n      if ((val & (1 << bit)) != 0) {\n        break;\n      }\n    }\n    return this.high_ != 0 ? bit + 33 : bit + 1;\n  }\n};\n\n\n/** @return {boolean} Whether this value is zero. */\nKotlin.Long.prototype.isZero = function() {\n  return this.high_ == 0 && this.low_ == 0;\n};\n\n\n/** @return {boolean} Whether this value is negative. */\nKotlin.Long.prototype.isNegative = function() {\n  return this.high_ < 0;\n};\n\n\n/** @return {boolean} Whether this value is odd. */\nKotlin.Long.prototype.isOdd = function() {\n  return (this.low_ & 1) == 1;\n};\n\n\n/**\n * @param {Kotlin.Long} other Long to compare against.\n * @return {boolean} Whether this Long equals the other.\n */\nKotlin.Long.prototype.equalsLong = function(other) {\n  return (this.high_ == other.high_) && (this.low_ == other.low_);\n};\n\n\n/**\n * @param {Kotlin.Long} other Long to compare against.\n * @return {boolean} Whether this Long does not equal the other.\n */\nKotlin.Long.prototype.notEqualsLong = function(other) {\n  return (this.high_ != other.high_) || (this.low_ != other.low_);\n};\n\n\n/**\n * @param {Kotlin.Long} other Long to compare against.\n * @return {boolean} Whether this Long is less than the other.\n */\nKotlin.Long.prototype.lessThan = function(other) {\n  return this.compare(other) < 0;\n};\n\n\n/**\n * @param {Kotlin.Long} other Long to compare against.\n * @return {boolean} Whether this Long is less than or equal to the other.\n */\nKotlin.Long.prototype.lessThanOrEqual = function(other) {\n  return this.compare(other) <= 0;\n};\n\n\n/**\n * @param {Kotlin.Long} other Long to compare against.\n * @return {boolean} Whether this Long is greater than the other.\n */\nKotlin.Long.prototype.greaterThan = function(other) {\n  return this.compare(other) > 0;\n};\n\n\n/**\n * @param {Kotlin.Long} other Long to compare against.\n * @return {boolean} Whether this Long is greater than or equal to the other.\n */\nKotlin.Long.prototype.greaterThanOrEqual = function(other) {\n  return this.compare(other) >= 0;\n};\n\n\n/**\n * Compares this Long with the given one.\n * @param {Kotlin.Long} other Long to compare against.\n * @return {number} 0 if they are the same, 1 if the this is greater, and -1\n *     if the given one is greater.\n */\nKotlin.Long.prototype.compare = function(other) {\n  if (this.equalsLong(other)) {\n    return 0;\n  }\n\n  var thisNeg = this.isNegative();\n  var otherNeg = other.isNegative();\n  if (thisNeg && !otherNeg) {\n    return -1;\n  }\n  if (!thisNeg && otherNeg) {\n    return 1;\n  }\n\n  // at this point, the signs are the same, so subtraction will not overflow\n  if (this.subtract(other).isNegative()) {\n    return -1;\n  } else {\n    return 1;\n  }\n};\n\n\n/** @return {!Kotlin.Long} The negation of this value. */\nKotlin.Long.prototype.negate = function() {\n  if (this.equalsLong(Kotlin.Long.MIN_VALUE)) {\n    return Kotlin.Long.MIN_VALUE;\n  } else {\n    return this.not().add(Kotlin.Long.ONE);\n  }\n};\n\n\n/**\n * Returns the sum of this and the given Long.\n * @param {Kotlin.Long} other Long to add to this one.\n * @return {!Kotlin.Long} The sum of this and the given Long.\n */\nKotlin.Long.prototype.add = function(other) {\n  // Divide each number into 4 chunks of 16 bits, and then sum the chunks.\n\n  var a48 = this.high_ >>> 16;\n  var a32 = this.high_ & 0xFFFF;\n  var a16 = this.low_ >>> 16;\n  var a00 = this.low_ & 0xFFFF;\n\n  var b48 = other.high_ >>> 16;\n  var b32 = other.high_ & 0xFFFF;\n  var b16 = other.low_ >>> 16;\n  var b00 = other.low_ & 0xFFFF;\n\n  var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\n  c00 += a00 + b00;\n  c16 += c00 >>> 16;\n  c00 &= 0xFFFF;\n  c16 += a16 + b16;\n  c32 += c16 >>> 16;\n  c16 &= 0xFFFF;\n  c32 += a32 + b32;\n  c48 += c32 >>> 16;\n  c32 &= 0xFFFF;\n  c48 += a48 + b48;\n  c48 &= 0xFFFF;\n  return Kotlin.Long.fromBits((c16 << 16) | c00, (c48 << 16) | c32);\n};\n\n\n/**\n * Returns the difference of this and the given Long.\n * @param {Kotlin.Long} other Long to subtract from this.\n * @return {!Kotlin.Long} The difference of this and the given Long.\n */\nKotlin.Long.prototype.subtract = function(other) {\n  return this.add(other.negate());\n};\n\n\n/**\n * Returns the product of this and the given long.\n * @param {Kotlin.Long} other Long to multiply with this.\n * @return {!Kotlin.Long} The product of this and the other.\n */\nKotlin.Long.prototype.multiply = function(other) {\n  if (this.isZero()) {\n    return Kotlin.Long.ZERO;\n  } else if (other.isZero()) {\n    return Kotlin.Long.ZERO;\n  }\n\n  if (this.equalsLong(Kotlin.Long.MIN_VALUE)) {\n    return other.isOdd() ? Kotlin.Long.MIN_VALUE : Kotlin.Long.ZERO;\n  } else if (other.equalsLong(Kotlin.Long.MIN_VALUE)) {\n    return this.isOdd() ? Kotlin.Long.MIN_VALUE : Kotlin.Long.ZERO;\n  }\n\n  if (this.isNegative()) {\n    if (other.isNegative()) {\n      return this.negate().multiply(other.negate());\n    } else {\n      return this.negate().multiply(other).negate();\n    }\n  } else if (other.isNegative()) {\n    return this.multiply(other.negate()).negate();\n  }\n\n  // If both longs are small, use float multiplication\n  if (this.lessThan(Kotlin.Long.TWO_PWR_24_) &&\n      other.lessThan(Kotlin.Long.TWO_PWR_24_)) {\n    return Kotlin.Long.fromNumber(this.toNumber() * other.toNumber());\n  }\n\n  // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.\n  // We can skip products that would overflow.\n\n  var a48 = this.high_ >>> 16;\n  var a32 = this.high_ & 0xFFFF;\n  var a16 = this.low_ >>> 16;\n  var a00 = this.low_ & 0xFFFF;\n\n  var b48 = other.high_ >>> 16;\n  var b32 = other.high_ & 0xFFFF;\n  var b16 = other.low_ >>> 16;\n  var b00 = other.low_ & 0xFFFF;\n\n  var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\n  c00 += a00 * b00;\n  c16 += c00 >>> 16;\n  c00 &= 0xFFFF;\n  c16 += a16 * b00;\n  c32 += c16 >>> 16;\n  c16 &= 0xFFFF;\n  c16 += a00 * b16;\n  c32 += c16 >>> 16;\n  c16 &= 0xFFFF;\n  c32 += a32 * b00;\n  c48 += c32 >>> 16;\n  c32 &= 0xFFFF;\n  c32 += a16 * b16;\n  c48 += c32 >>> 16;\n  c32 &= 0xFFFF;\n  c32 += a00 * b32;\n  c48 += c32 >>> 16;\n  c32 &= 0xFFFF;\n  c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;\n  c48 &= 0xFFFF;\n  return Kotlin.Long.fromBits((c16 << 16) | c00, (c48 << 16) | c32);\n};\n\n\n/**\n * Returns this Long divided by the given one.\n * @param {Kotlin.Long} other Long by which to divide.\n * @return {!Kotlin.Long} This Long divided by the given one.\n */\nKotlin.Long.prototype.div = function(other) {\n  if (other.isZero()) {\n    throw Error('division by zero');\n  } else if (this.isZero()) {\n    return Kotlin.Long.ZERO;\n  }\n\n  if (this.equalsLong(Kotlin.Long.MIN_VALUE)) {\n    if (other.equalsLong(Kotlin.Long.ONE) ||\n        other.equalsLong(Kotlin.Long.NEG_ONE)) {\n      return Kotlin.Long.MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE\n    } else if (other.equalsLong(Kotlin.Long.MIN_VALUE)) {\n      return Kotlin.Long.ONE;\n    } else {\n      // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.\n      var halfThis = this.shiftRight(1);\n      var approx = halfThis.div(other).shiftLeft(1);\n      if (approx.equalsLong(Kotlin.Long.ZERO)) {\n        return other.isNegative() ? Kotlin.Long.ONE : Kotlin.Long.NEG_ONE;\n      } else {\n        var rem = this.subtract(other.multiply(approx));\n        var result = approx.add(rem.div(other));\n        return result;\n      }\n    }\n  } else if (other.equalsLong(Kotlin.Long.MIN_VALUE)) {\n    return Kotlin.Long.ZERO;\n  }\n\n  if (this.isNegative()) {\n    if (other.isNegative()) {\n      return this.negate().div(other.negate());\n    } else {\n      return this.negate().div(other).negate();\n    }\n  } else if (other.isNegative()) {\n    return this.div(other.negate()).negate();\n  }\n\n  // Repeat the following until the remainder is less than other:  find a\n  // floating-point that approximates remainder / other *from below*, add this\n  // into the result, and subtract it from the remainder.  It is critical that\n  // the approximate value is less than or equal to the real value so that the\n  // remainder never becomes negative.\n  var res = Kotlin.Long.ZERO;\n  var rem = this;\n  while (rem.greaterThanOrEqual(other)) {\n    // Approximate the result of division. This may be a little greater or\n    // smaller than the actual value.\n    var approx = Math.max(1, Math.floor(rem.toNumber() / other.toNumber()));\n\n    // We will tweak the approximate result by changing it in the 48-th digit or\n    // the smallest non-fractional digit, whichever is larger.\n    var log2 = Math.ceil(Math.log(approx) / Math.LN2);\n    var delta = (log2 <= 48) ? 1 : Math.pow(2, log2 - 48);\n\n    // Decrease the approximation until it is smaller than the remainder.  Note\n    // that if it is too large, the product overflows and is negative.\n    var approxRes = Kotlin.Long.fromNumber(approx);\n    var approxRem = approxRes.multiply(other);\n    while (approxRem.isNegative() || approxRem.greaterThan(rem)) {\n      approx -= delta;\n      approxRes = Kotlin.Long.fromNumber(approx);\n      approxRem = approxRes.multiply(other);\n    }\n\n    // We know the answer can't be zero... and actually, zero would cause\n    // infinite recursion since we would make no progress.\n    if (approxRes.isZero()) {\n      approxRes = Kotlin.Long.ONE;\n    }\n\n    res = res.add(approxRes);\n    rem = rem.subtract(approxRem);\n  }\n  return res;\n};\n\n\n/**\n * Returns this Long modulo the given one.\n * @param {Kotlin.Long} other Long by which to mod.\n * @return {!Kotlin.Long} This Long modulo the given one.\n */\nKotlin.Long.prototype.modulo = function(other) {\n  return this.subtract(this.div(other).multiply(other));\n};\n\n\n/** @return {!Kotlin.Long} The bitwise-NOT of this value. */\nKotlin.Long.prototype.not = function() {\n  return Kotlin.Long.fromBits(~this.low_, ~this.high_);\n};\n\n\n/**\n * Returns the bitwise-AND of this Long and the given one.\n * @param {Kotlin.Long} other The Long with which to AND.\n * @return {!Kotlin.Long} The bitwise-AND of this and the other.\n */\nKotlin.Long.prototype.and = function(other) {\n  return Kotlin.Long.fromBits(this.low_ & other.low_,\n                                 this.high_ & other.high_);\n};\n\n\n/**\n * Returns the bitwise-OR of this Long and the given one.\n * @param {Kotlin.Long} other The Long with which to OR.\n * @return {!Kotlin.Long} The bitwise-OR of this and the other.\n */\nKotlin.Long.prototype.or = function(other) {\n  return Kotlin.Long.fromBits(this.low_ | other.low_,\n                                 this.high_ | other.high_);\n};\n\n\n/**\n * Returns the bitwise-XOR of this Long and the given one.\n * @param {Kotlin.Long} other The Long with which to XOR.\n * @return {!Kotlin.Long} The bitwise-XOR of this and the other.\n */\nKotlin.Long.prototype.xor = function(other) {\n  return Kotlin.Long.fromBits(this.low_ ^ other.low_,\n                                 this.high_ ^ other.high_);\n};\n\n\n/**\n * Returns this Long with bits shifted to the left by the given amount.\n * @param {number} numBits The number of bits by which to shift.\n * @return {!Kotlin.Long} This shifted to the left by the given amount.\n */\nKotlin.Long.prototype.shiftLeft = function(numBits) {\n  numBits &= 63;\n  if (numBits == 0) {\n    return this;\n  } else {\n    var low = this.low_;\n    if (numBits < 32) {\n      var high = this.high_;\n      return Kotlin.Long.fromBits(\n          low << numBits,\n          (high << numBits) | (low >>> (32 - numBits)));\n    } else {\n      return Kotlin.Long.fromBits(0, low << (numBits - 32));\n    }\n  }\n};\n\n\n/**\n * Returns this Long with bits shifted to the right by the given amount.\n * @param {number} numBits The number of bits by which to shift.\n * @return {!Kotlin.Long} This shifted to the right by the given amount.\n */\nKotlin.Long.prototype.shiftRight = function(numBits) {\n  numBits &= 63;\n  if (numBits == 0) {\n    return this;\n  } else {\n    var high = this.high_;\n    if (numBits < 32) {\n      var low = this.low_;\n      return Kotlin.Long.fromBits(\n          (low >>> numBits) | (high << (32 - numBits)),\n          high >> numBits);\n    } else {\n      return Kotlin.Long.fromBits(\n          high >> (numBits - 32),\n          high >= 0 ? 0 : -1);\n    }\n  }\n};\n\n\n/**\n * Returns this Long with bits shifted to the right by the given amount, with\n * zeros placed into the new leading bits.\n * @param {number} numBits The number of bits by which to shift.\n * @return {!Kotlin.Long} This shifted to the right by the given amount, with\n *     zeros placed into the new leading bits.\n */\nKotlin.Long.prototype.shiftRightUnsigned = function(numBits) {\n  numBits &= 63;\n  if (numBits == 0) {\n    return this;\n  } else {\n    var high = this.high_;\n    if (numBits < 32) {\n      var low = this.low_;\n      return Kotlin.Long.fromBits(\n          (low >>> numBits) | (high << (32 - numBits)),\n          high >>> numBits);\n    } else if (numBits == 32) {\n      return Kotlin.Long.fromBits(high, 0);\n    } else {\n      return Kotlin.Long.fromBits(high >>> (numBits - 32), 0);\n    }\n  }\n};\n\n// Support for Kotlin\nKotlin.Long.prototype.equals = function (other) {\n    return other instanceof Kotlin.Long && this.equalsLong(other);\n};\n\nKotlin.Long.prototype.compareTo_11rb$ = Kotlin.Long.prototype.compare;\n\nKotlin.Long.prototype.inc = function() {\n    return this.add(Kotlin.Long.ONE);\n};\n\nKotlin.Long.prototype.dec = function() {\n    return this.add(Kotlin.Long.NEG_ONE);\n};\n\nKotlin.Long.prototype.valueOf = function() {\n    return this.toNumber();\n};\n\nKotlin.Long.prototype.unaryPlus = function() {\n    return this;\n};\n\nKotlin.Long.prototype.unaryMinus = Kotlin.Long.prototype.negate;\nKotlin.Long.prototype.inv = Kotlin.Long.prototype.not;\n\nKotlin.Long.prototype.rangeTo = function (other) {\n    return new Kotlin.kotlin.ranges.LongRange(this, other);\n};","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// a package is omitted to get declarations directly under the module\n\n@PublishedApi\nexternal internal fun <T> Array(size: Int): Array<T>\n\n@JsName(\"newArray\")\nfun <T> newArray(size: Int, initValue: T) = fillArrayVal(Array<T>(size), initValue)\n\n@JsName(\"newArrayF\")\ninline fun <T> arrayWithFun(size: Int, init: (Int) -> T) = fillArrayFun(Array<T>(size), init)\n\n@JsName(\"fillArray\")\ninline fun <T> fillArrayFun(array: Array<T>, init: (Int) -> T): Array<T> {\n    for (i in 0..array.size - 1) {\n        array[i] = init(i)\n    }\n    return array\n}\n\n@JsName(\"booleanArray\")\nfun booleanArray(size: Int, init: dynamic): Array<Boolean> {\n    val result: dynamic = Array<Boolean>(size)\n    result.`$type$` = \"BooleanArray\"\n    return when (init) {\n        null, true -> fillArrayVal(result, false)\n        false -> result\n        else -> fillArrayFun<Boolean>(result, init)\n    }\n}\n\n@JsName(\"booleanArrayF\")\ninline fun booleanArrayWithFun(size: Int, init: (Int) -> Boolean): Array<Boolean> = fillArrayFun(booleanArray(size, false), init)\n\n@JsName(\"charArray\")\n@Suppress(\"UNUSED_PARAMETER\")\nfun charArray(size: Int, init: dynamic): Array<Char> {\n    val result = js(\"new Uint16Array(size)\")\n    result.`$type$` = \"CharArray\"\n    return when (init) {\n        null, true, false -> result // For consistency\n        else -> fillArrayFun<Char>(result, init)\n    }\n}\n\n@JsName(\"charArrayF\")\ninline fun charArrayWithFun(size: Int, init: (Int) -> Char): Array<Char> {\n    val array = charArray(size, null)\n    for (i in 0..array.size - 1) {\n        @Suppress(\"UNUSED_VARIABLE\") // used in js block\n        val value = init(i)\n        js(\"array[i] = value;\")\n    }\n    return array\n}\n\n@JsName(\"untypedCharArrayF\")\ninline fun untypedCharArrayWithFun(size: Int, init: (Int) -> Char): Array<Char> {\n    val array = Array<Char>(size)\n    for (i in 0..array.size - 1) {\n        @Suppress(\"UNUSED_VARIABLE\") // used in js block\n        val value = init(i)\n        js(\"array[i] = value;\")\n    }\n    return array\n}\n\n@JsName(\"longArray\")\nfun longArray(size: Int, init: dynamic): Array<Long> {\n    val result: dynamic = Array<Long>(size)\n    result.`$type$` = \"LongArray\"\n    return when (init) {\n        null, true -> fillArrayVal(result, 0L)\n        false -> result\n        else -> fillArrayFun<Long>(result, init)\n    }\n}\n\n@JsName(\"longArrayF\")\ninline fun longArrayWithFun(size: Int, init: (Int) -> Long): Array<Long> = fillArrayFun(longArray(size, false), init)\n\nprivate fun <T> fillArrayVal(array: Array<T>, initValue: T): Array<T> {\n    for (i in 0..array.size - 1) {\n        array[i] = initValue\n    }\n    return array\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin\n\npublic class Enum<T : Enum<T>> : Comparable<Enum<T>> {\n    @JsName(\"name$\") private var _name: String = \"\"\n    @JsName(\"ordinal$\") private var _ordinal: Int = 0\n\n    val name: String\n        get() = _name\n\n    val ordinal: Int\n        get() = _ordinal\n\n    override fun compareTo(other: Enum<T>) = ordinal.compareTo(other.ordinal)\n\n    override fun equals(other: Any?) = this === other\n\n    override fun hashCode(): Int = js(\"Kotlin.identityHashCode\")(this)\n\n    override fun toString() = name\n\n    companion object\n}",null,"/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"ArraysKt\")\n\npackage kotlin.collections\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.random.*\nimport kotlin.ranges.contains\nimport kotlin.ranges.reversed\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> Array<out T>.component1(): T {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ByteArray.component1(): Byte {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ShortArray.component1(): Short {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun IntArray.component1(): Int {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun LongArray.component1(): Long {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun FloatArray.component1(): Float {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun DoubleArray.component1(): Double {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun BooleanArray.component1(): Boolean {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharArray.component1(): Char {\n    return get(0)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> Array<out T>.component2(): T {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ByteArray.component2(): Byte {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ShortArray.component2(): Short {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun IntArray.component2(): Int {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun LongArray.component2(): Long {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun FloatArray.component2(): Float {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun DoubleArray.component2(): Double {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun BooleanArray.component2(): Boolean {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharArray.component2(): Char {\n    return get(1)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> Array<out T>.component3(): T {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ByteArray.component3(): Byte {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ShortArray.component3(): Short {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun IntArray.component3(): Int {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun LongArray.component3(): Long {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun FloatArray.component3(): Float {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun DoubleArray.component3(): Double {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun BooleanArray.component3(): Boolean {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharArray.component3(): Char {\n    return get(2)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> Array<out T>.component4(): T {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ByteArray.component4(): Byte {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ShortArray.component4(): Short {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun IntArray.component4(): Int {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun LongArray.component4(): Long {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun FloatArray.component4(): Float {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun DoubleArray.component4(): Double {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun BooleanArray.component4(): Boolean {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharArray.component4(): Char {\n    return get(3)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> Array<out T>.component5(): T {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ByteArray.component5(): Byte {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ShortArray.component5(): Short {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun IntArray.component5(): Int {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun LongArray.component5(): Long {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun FloatArray.component5(): Float {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun DoubleArray.component5(): Double {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun BooleanArray.component5(): Boolean {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharArray.component5(): Char {\n    return get(4)\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun <@kotlin.internal.OnlyInputTypes T> Array<out T>.contains(element: T): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun ByteArray.contains(element: Byte): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun ShortArray.contains(element: Short): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun IntArray.contains(element: Int): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun LongArray.contains(element: Long): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\n@Deprecated(\"The function has unclear behavior when searching for NaN or zero values and will be removed soon. Use 'any { it == element }' instead to continue using this behavior, or '.asList().contains(element: T)' to get the same search behavior as in a list.\", ReplaceWith(\"any { it == element }\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@Suppress(\"DEPRECATION\")\npublic operator fun FloatArray.contains(element: Float): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\n@Deprecated(\"The function has unclear behavior when searching for NaN or zero values and will be removed soon. Use 'any { it == element }' instead to continue using this behavior, or '.asList().contains(element: T)' to get the same search behavior as in a list.\", ReplaceWith(\"any { it == element }\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@Suppress(\"DEPRECATION\")\npublic operator fun DoubleArray.contains(element: Double): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun BooleanArray.contains(element: Boolean): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun CharArray.contains(element: Char): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun <T> Array<out T>.elementAt(index: Int): T\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun ByteArray.elementAt(index: Int): Byte\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun ShortArray.elementAt(index: Int): Short\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun IntArray.elementAt(index: Int): Int\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun LongArray.elementAt(index: Int): Long\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun FloatArray.elementAt(index: Int): Float\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun DoubleArray.elementAt(index: Int): Double\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun BooleanArray.elementAt(index: Int): Boolean\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun CharArray.elementAt(index: Int): Char\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Byte): Byte {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Short): Short {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Int): Int {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Long): Long {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Float): Float {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Double): Double {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Boolean): Boolean {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Char): Char {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.elementAtOrNull(index: Int): T? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.elementAtOrNull(index: Int): Byte? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.elementAtOrNull(index: Int): Short? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.elementAtOrNull(index: Int): Int? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.elementAtOrNull(index: Int): Long? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.elementAtOrNull(index: Int): Float? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.elementAtOrNull(index: Int): Double? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.elementAtOrNull(index: Int): Boolean? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.elementAtOrNull(index: Int): Char? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.find(predicate: (T) -> Boolean): T? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.find(predicate: (Byte) -> Boolean): Byte? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.find(predicate: (Short) -> Boolean): Short? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.find(predicate: (Int) -> Boolean): Int? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.find(predicate: (Long) -> Boolean): Long? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.find(predicate: (Float) -> Boolean): Float? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.find(predicate: (Double) -> Boolean): Double? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.find(predicate: (Boolean) -> Boolean): Boolean? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.find(predicate: (Char) -> Boolean): Char? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.findLast(predicate: (Byte) -> Boolean): Byte? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.findLast(predicate: (Short) -> Boolean): Short? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.findLast(predicate: (Int) -> Boolean): Int? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.findLast(predicate: (Long) -> Boolean): Long? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.findLast(predicate: (Float) -> Boolean): Float? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.findLast(predicate: (Double) -> Boolean): Double? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.findLast(predicate: (Boolean) -> Boolean): Boolean? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.findLast(predicate: (Char) -> Boolean): Char? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun <T> Array<out T>.first(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun ByteArray.first(): Byte {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun ShortArray.first(): Short {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun IntArray.first(): Int {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun LongArray.first(): Long {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun FloatArray.first(): Float {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun DoubleArray.first(): Double {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun BooleanArray.first(): Boolean {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun CharArray.first(): Char {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun <T> Array<out T>.first(predicate: (T) -> Boolean): T {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun ByteArray.first(predicate: (Byte) -> Boolean): Byte {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun ShortArray.first(predicate: (Short) -> Boolean): Short {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun IntArray.first(predicate: (Int) -> Boolean): Int {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun LongArray.first(predicate: (Long) -> Boolean): Long {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun FloatArray.first(predicate: (Float) -> Boolean): Float {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun DoubleArray.first(predicate: (Double) -> Boolean): Double {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun BooleanArray.first(predicate: (Boolean) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun CharArray.first(predicate: (Char) -> Boolean): Char {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first non-null value produced by [transform] function being applied to elements of this array in iteration order,\n * or throws [NoSuchElementException] if no non-null value was produced.\n * \n * @sample samples.collections.Collections.Transformations.firstNotNullOf\n */\n@SinceKotlin(\"1.5\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Any> Array<out T>.firstNotNullOf(transform: (T) -> R?): R {\n    return firstNotNullOfOrNull(transform) ?: throw NoSuchElementException(\"No element of the array was transformed to a non-null value.\")\n}\n\n/**\n * Returns the first non-null value produced by [transform] function being applied to elements of this array in iteration order,\n * or `null` if no non-null value was produced.\n * \n * @sample samples.collections.Collections.Transformations.firstNotNullOf\n */\n@SinceKotlin(\"1.5\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Any> Array<out T>.firstNotNullOfOrNull(transform: (T) -> R?): R? {\n    for (element in this) {\n        val result = transform(element)\n        if (result != null) {\n            return result\n        }\n    }\n    return null\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun <T> Array<out T>.firstOrNull(): T? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun ByteArray.firstOrNull(): Byte? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun ShortArray.firstOrNull(): Short? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun IntArray.firstOrNull(): Int? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun LongArray.firstOrNull(): Long? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun FloatArray.firstOrNull(): Float? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun DoubleArray.firstOrNull(): Double? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun BooleanArray.firstOrNull(): Boolean? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun CharArray.firstOrNull(): Char? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun <T> Array<out T>.firstOrNull(predicate: (T) -> Boolean): T? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun ByteArray.firstOrNull(predicate: (Byte) -> Boolean): Byte? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun ShortArray.firstOrNull(predicate: (Short) -> Boolean): Short? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun IntArray.firstOrNull(predicate: (Int) -> Boolean): Int? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun LongArray.firstOrNull(predicate: (Long) -> Boolean): Long? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun FloatArray.firstOrNull(predicate: (Float) -> Boolean): Float? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun DoubleArray.firstOrNull(predicate: (Double) -> Boolean): Double? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun BooleanArray.firstOrNull(predicate: (Boolean) -> Boolean): Boolean? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun CharArray.firstOrNull(predicate: (Char) -> Boolean): Char? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.getOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.getOrElse(index: Int, defaultValue: (Int) -> Byte): Byte {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.getOrElse(index: Int, defaultValue: (Int) -> Short): Short {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.getOrElse(index: Int, defaultValue: (Int) -> Int): Int {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.getOrElse(index: Int, defaultValue: (Int) -> Long): Long {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.getOrElse(index: Int, defaultValue: (Int) -> Float): Float {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.getOrElse(index: Int, defaultValue: (Int) -> Double): Double {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.getOrElse(index: Int, defaultValue: (Int) -> Boolean): Boolean {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.getOrElse(index: Int, defaultValue: (Int) -> Char): Char {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun <T> Array<out T>.getOrNull(index: Int): T? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun ByteArray.getOrNull(index: Int): Byte? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun ShortArray.getOrNull(index: Int): Short? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun IntArray.getOrNull(index: Int): Int? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun LongArray.getOrNull(index: Int): Long? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun FloatArray.getOrNull(index: Int): Float? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun DoubleArray.getOrNull(index: Int): Double? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun BooleanArray.getOrNull(index: Int): Boolean? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun CharArray.getOrNull(index: Int): Char? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Array<out T>.indexOf(element: T): Int {\n    if (element == null) {\n        for (index in indices) {\n            if (this[index] == null) {\n                return index\n            }\n        }\n    } else {\n        for (index in indices) {\n            if (element == this[index]) {\n                return index\n            }\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun ByteArray.indexOf(element: Byte): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun ShortArray.indexOf(element: Short): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun IntArray.indexOf(element: Int): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun LongArray.indexOf(element: Long): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\n@Deprecated(\"The function has unclear behavior when searching for NaN or zero values and will be removed soon. Use 'indexOfFirst { it == element }' instead to continue using this behavior, or '.asList().indexOf(element: T)' to get the same search behavior as in a list.\", ReplaceWith(\"indexOfFirst { it == element }\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun FloatArray.indexOf(element: Float): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\n@Deprecated(\"The function has unclear behavior when searching for NaN or zero values and will be removed soon. Use 'indexOfFirst { it == element }' instead to continue using this behavior, or '.asList().indexOf(element: T)' to get the same search behavior as in a list.\", ReplaceWith(\"indexOfFirst { it == element }\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun DoubleArray.indexOf(element: Double): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun BooleanArray.indexOf(element: Boolean): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun CharArray.indexOf(element: Char): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun <T> Array<out T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun ByteArray.indexOfFirst(predicate: (Byte) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun ShortArray.indexOfFirst(predicate: (Short) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun IntArray.indexOfFirst(predicate: (Int) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun LongArray.indexOfFirst(predicate: (Long) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun FloatArray.indexOfFirst(predicate: (Float) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun DoubleArray.indexOfFirst(predicate: (Double) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun BooleanArray.indexOfFirst(predicate: (Boolean) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun CharArray.indexOfFirst(predicate: (Char) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun <T> Array<out T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun ByteArray.indexOfLast(predicate: (Byte) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun ShortArray.indexOfLast(predicate: (Short) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun IntArray.indexOfLast(predicate: (Int) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun LongArray.indexOfLast(predicate: (Long) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun FloatArray.indexOfLast(predicate: (Float) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun DoubleArray.indexOfLast(predicate: (Double) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun BooleanArray.indexOfLast(predicate: (Boolean) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun CharArray.indexOfLast(predicate: (Char) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> Array<out T>.last(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun ByteArray.last(): Byte {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun ShortArray.last(): Short {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun IntArray.last(): Int {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun LongArray.last(): Long {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun FloatArray.last(): Float {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun DoubleArray.last(): Double {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun BooleanArray.last(): Boolean {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun CharArray.last(): Char {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> Array<out T>.last(predicate: (T) -> Boolean): T {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun ByteArray.last(predicate: (Byte) -> Boolean): Byte {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun ShortArray.last(predicate: (Short) -> Boolean): Short {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun IntArray.last(predicate: (Int) -> Boolean): Int {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun LongArray.last(predicate: (Long) -> Boolean): Long {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun FloatArray.last(predicate: (Float) -> Boolean): Float {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun DoubleArray.last(predicate: (Double) -> Boolean): Double {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun BooleanArray.last(predicate: (Boolean) -> Boolean): Boolean {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun CharArray.last(predicate: (Char) -> Boolean): Char {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Array<out T>.lastIndexOf(element: T): Int {\n    if (element == null) {\n        for (index in indices.reversed()) {\n            if (this[index] == null) {\n                return index\n            }\n        }\n    } else {\n        for (index in indices.reversed()) {\n            if (element == this[index]) {\n                return index\n            }\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun ByteArray.lastIndexOf(element: Byte): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun ShortArray.lastIndexOf(element: Short): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun IntArray.lastIndexOf(element: Int): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun LongArray.lastIndexOf(element: Long): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\n@Deprecated(\"The function has unclear behavior when searching for NaN or zero values and will be removed soon. Use 'indexOfLast { it == element }' instead to continue using this behavior, or '.asList().lastIndexOf(element: T)' to get the same search behavior as in a list.\", ReplaceWith(\"indexOfLast { it == element }\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun FloatArray.lastIndexOf(element: Float): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\n@Deprecated(\"The function has unclear behavior when searching for NaN or zero values and will be removed soon. Use 'indexOfLast { it == element }' instead to continue using this behavior, or '.asList().lastIndexOf(element: T)' to get the same search behavior as in a list.\", ReplaceWith(\"indexOfLast { it == element }\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun DoubleArray.lastIndexOf(element: Double): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun BooleanArray.lastIndexOf(element: Boolean): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun CharArray.lastIndexOf(element: Char): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> Array<out T>.lastOrNull(): T? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun ByteArray.lastOrNull(): Byte? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun ShortArray.lastOrNull(): Short? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun IntArray.lastOrNull(): Int? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun LongArray.lastOrNull(): Long? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun FloatArray.lastOrNull(): Float? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun DoubleArray.lastOrNull(): Double? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun BooleanArray.lastOrNull(): Boolean? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun CharArray.lastOrNull(): Char? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> Array<out T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun ByteArray.lastOrNull(predicate: (Byte) -> Boolean): Byte? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun ShortArray.lastOrNull(predicate: (Short) -> Boolean): Short? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun IntArray.lastOrNull(predicate: (Int) -> Boolean): Int? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun LongArray.lastOrNull(predicate: (Long) -> Boolean): Long? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun FloatArray.lastOrNull(predicate: (Float) -> Boolean): Float? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun DoubleArray.lastOrNull(predicate: (Double) -> Boolean): Double? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun BooleanArray.lastOrNull(predicate: (Boolean) -> Boolean): Boolean? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun CharArray.lastOrNull(predicate: (Char) -> Boolean): Char? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.random(): T {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.random(): Byte {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.random(): Short {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.random(): Int {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.random(): Long {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.random(): Float {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.random(): Double {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.random(): Boolean {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.random(): Char {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> Array<out T>.random(random: Random): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun ByteArray.random(random: Random): Byte {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun ShortArray.random(random: Random): Short {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun IntArray.random(random: Random): Int {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun LongArray.random(random: Random): Long {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun FloatArray.random(random: Random): Float {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun DoubleArray.random(random: Random): Double {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun BooleanArray.random(random: Random): Boolean {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun CharArray.random(random: Random): Char {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.randomOrNull(): T? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.randomOrNull(): Byte? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.randomOrNull(): Short? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.randomOrNull(): Int? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.randomOrNull(): Long? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.randomOrNull(): Float? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.randomOrNull(): Double? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.randomOrNull(): Boolean? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.randomOrNull(): Char? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <T> Array<out T>.randomOrNull(random: Random): T? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun ByteArray.randomOrNull(random: Random): Byte? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun ShortArray.randomOrNull(random: Random): Short? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun IntArray.randomOrNull(random: Random): Int? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun LongArray.randomOrNull(random: Random): Long? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun FloatArray.randomOrNull(random: Random): Float? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun DoubleArray.randomOrNull(random: Random): Double? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun BooleanArray.randomOrNull(random: Random): Boolean? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun CharArray.randomOrNull(random: Random): Char? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun <T> Array<out T>.single(): T {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun ByteArray.single(): Byte {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun ShortArray.single(): Short {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun IntArray.single(): Int {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun LongArray.single(): Long {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun FloatArray.single(): Float {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun DoubleArray.single(): Double {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun BooleanArray.single(): Boolean {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun CharArray.single(): Char {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun <T> Array<out T>.single(predicate: (T) -> Boolean): T {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as T\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun ByteArray.single(predicate: (Byte) -> Boolean): Byte {\n    var single: Byte? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Byte\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun ShortArray.single(predicate: (Short) -> Boolean): Short {\n    var single: Short? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Short\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun IntArray.single(predicate: (Int) -> Boolean): Int {\n    var single: Int? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Int\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun LongArray.single(predicate: (Long) -> Boolean): Long {\n    var single: Long? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Long\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun FloatArray.single(predicate: (Float) -> Boolean): Float {\n    var single: Float? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Float\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun DoubleArray.single(predicate: (Double) -> Boolean): Double {\n    var single: Double? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Double\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun BooleanArray.single(predicate: (Boolean) -> Boolean): Boolean {\n    var single: Boolean? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Boolean\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun CharArray.single(predicate: (Char) -> Boolean): Char {\n    var single: Char? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Char\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun <T> Array<out T>.singleOrNull(): T? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun ByteArray.singleOrNull(): Byte? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun ShortArray.singleOrNull(): Short? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun IntArray.singleOrNull(): Int? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun LongArray.singleOrNull(): Long? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun FloatArray.singleOrNull(): Float? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun DoubleArray.singleOrNull(): Double? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun BooleanArray.singleOrNull(): Boolean? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun CharArray.singleOrNull(): Char? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun <T> Array<out T>.singleOrNull(predicate: (T) -> Boolean): T? {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun ByteArray.singleOrNull(predicate: (Byte) -> Boolean): Byte? {\n    var single: Byte? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun ShortArray.singleOrNull(predicate: (Short) -> Boolean): Short? {\n    var single: Short? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun IntArray.singleOrNull(predicate: (Int) -> Boolean): Int? {\n    var single: Int? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun LongArray.singleOrNull(predicate: (Long) -> Boolean): Long? {\n    var single: Long? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun FloatArray.singleOrNull(predicate: (Float) -> Boolean): Float? {\n    var single: Float? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun DoubleArray.singleOrNull(predicate: (Double) -> Boolean): Double? {\n    var single: Double? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun BooleanArray.singleOrNull(predicate: (Boolean) -> Boolean): Boolean? {\n    var single: Boolean? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun CharArray.singleOrNull(predicate: (Char) -> Boolean): Char? {\n    var single: Char? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> Array<out T>.drop(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun ByteArray.drop(n: Int): List<Byte> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun ShortArray.drop(n: Int): List<Short> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun IntArray.drop(n: Int): List<Int> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun LongArray.drop(n: Int): List<Long> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun FloatArray.drop(n: Int): List<Float> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun DoubleArray.drop(n: Int): List<Double> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun BooleanArray.drop(n: Int): List<Boolean> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun CharArray.drop(n: Int): List<Char> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> Array<out T>.dropLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun ByteArray.dropLast(n: Int): List<Byte> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun ShortArray.dropLast(n: Int): List<Short> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun IntArray.dropLast(n: Int): List<Int> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun LongArray.dropLast(n: Int): List<Long> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun FloatArray.dropLast(n: Int): List<Float> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun DoubleArray.dropLast(n: Int): List<Double> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun BooleanArray.dropLast(n: Int): List<Boolean> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun CharArray.dropLast(n: Int): List<Char> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> Array<out T>.dropLastWhile(predicate: (T) -> Boolean): List<T> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun ByteArray.dropLastWhile(predicate: (Byte) -> Boolean): List<Byte> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun ShortArray.dropLastWhile(predicate: (Short) -> Boolean): List<Short> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun IntArray.dropLastWhile(predicate: (Int) -> Boolean): List<Int> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun LongArray.dropLastWhile(predicate: (Long) -> Boolean): List<Long> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun FloatArray.dropLastWhile(predicate: (Float) -> Boolean): List<Float> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun DoubleArray.dropLastWhile(predicate: (Double) -> Boolean): List<Double> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun BooleanArray.dropLastWhile(predicate: (Boolean) -> Boolean): List<Boolean> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun CharArray.dropLastWhile(predicate: (Char) -> Boolean): List<Char> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> Array<out T>.dropWhile(predicate: (T) -> Boolean): List<T> {\n    var yielding = false\n    val list = ArrayList<T>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun ByteArray.dropWhile(predicate: (Byte) -> Boolean): List<Byte> {\n    var yielding = false\n    val list = ArrayList<Byte>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun ShortArray.dropWhile(predicate: (Short) -> Boolean): List<Short> {\n    var yielding = false\n    val list = ArrayList<Short>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun IntArray.dropWhile(predicate: (Int) -> Boolean): List<Int> {\n    var yielding = false\n    val list = ArrayList<Int>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun LongArray.dropWhile(predicate: (Long) -> Boolean): List<Long> {\n    var yielding = false\n    val list = ArrayList<Long>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun FloatArray.dropWhile(predicate: (Float) -> Boolean): List<Float> {\n    var yielding = false\n    val list = ArrayList<Float>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun DoubleArray.dropWhile(predicate: (Double) -> Boolean): List<Double> {\n    var yielding = false\n    val list = ArrayList<Double>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun BooleanArray.dropWhile(predicate: (Boolean) -> Boolean): List<Boolean> {\n    var yielding = false\n    val list = ArrayList<Boolean>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun CharArray.dropWhile(predicate: (Char) -> Boolean): List<Char> {\n    var yielding = false\n    val list = ArrayList<Char>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun <T> Array<out T>.filter(predicate: (T) -> Boolean): List<T> {\n    return filterTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun ByteArray.filter(predicate: (Byte) -> Boolean): List<Byte> {\n    return filterTo(ArrayList<Byte>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun ShortArray.filter(predicate: (Short) -> Boolean): List<Short> {\n    return filterTo(ArrayList<Short>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun IntArray.filter(predicate: (Int) -> Boolean): List<Int> {\n    return filterTo(ArrayList<Int>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun LongArray.filter(predicate: (Long) -> Boolean): List<Long> {\n    return filterTo(ArrayList<Long>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun FloatArray.filter(predicate: (Float) -> Boolean): List<Float> {\n    return filterTo(ArrayList<Float>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun DoubleArray.filter(predicate: (Double) -> Boolean): List<Double> {\n    return filterTo(ArrayList<Double>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun BooleanArray.filter(predicate: (Boolean) -> Boolean): List<Boolean> {\n    return filterTo(ArrayList<Boolean>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun CharArray.filter(predicate: (Char) -> Boolean): List<Char> {\n    return filterTo(ArrayList<Char>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun <T> Array<out T>.filterIndexed(predicate: (index: Int, T) -> Boolean): List<T> {\n    return filterIndexedTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun ByteArray.filterIndexed(predicate: (index: Int, Byte) -> Boolean): List<Byte> {\n    return filterIndexedTo(ArrayList<Byte>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun ShortArray.filterIndexed(predicate: (index: Int, Short) -> Boolean): List<Short> {\n    return filterIndexedTo(ArrayList<Short>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun IntArray.filterIndexed(predicate: (index: Int, Int) -> Boolean): List<Int> {\n    return filterIndexedTo(ArrayList<Int>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun LongArray.filterIndexed(predicate: (index: Int, Long) -> Boolean): List<Long> {\n    return filterIndexedTo(ArrayList<Long>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun FloatArray.filterIndexed(predicate: (index: Int, Float) -> Boolean): List<Float> {\n    return filterIndexedTo(ArrayList<Float>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun DoubleArray.filterIndexed(predicate: (index: Int, Double) -> Boolean): List<Double> {\n    return filterIndexedTo(ArrayList<Double>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun BooleanArray.filterIndexed(predicate: (index: Int, Boolean) -> Boolean): List<Boolean> {\n    return filterIndexedTo(ArrayList<Boolean>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun CharArray.filterIndexed(predicate: (index: Int, Char) -> Boolean): List<Char> {\n    return filterIndexedTo(ArrayList<Char>(), predicate)\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Array<out T>.filterIndexedTo(destination: C, predicate: (index: Int, T) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <C : MutableCollection<in Byte>> ByteArray.filterIndexedTo(destination: C, predicate: (index: Int, Byte) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <C : MutableCollection<in Short>> ShortArray.filterIndexedTo(destination: C, predicate: (index: Int, Short) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <C : MutableCollection<in Int>> IntArray.filterIndexedTo(destination: C, predicate: (index: Int, Int) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <C : MutableCollection<in Long>> LongArray.filterIndexedTo(destination: C, predicate: (index: Int, Long) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <C : MutableCollection<in Float>> FloatArray.filterIndexedTo(destination: C, predicate: (index: Int, Float) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <C : MutableCollection<in Double>> DoubleArray.filterIndexedTo(destination: C, predicate: (index: Int, Double) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <C : MutableCollection<in Boolean>> BooleanArray.filterIndexedTo(destination: C, predicate: (index: Int, Boolean) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <C : MutableCollection<in Char>> CharArray.filterIndexedTo(destination: C, predicate: (index: Int, Char) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Returns a list containing all elements that are instances of specified type parameter R.\n * \n * @sample samples.collections.Collections.Filtering.filterIsInstance\n */\npublic inline fun <reified R> Array<*>.filterIsInstance(): List<@kotlin.internal.NoInfer R> {\n    return filterIsInstanceTo(ArrayList<R>())\n}\n\n/**\n * Appends all elements that are instances of specified type parameter R to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterIsInstanceTo\n */\npublic inline fun <reified R, C : MutableCollection<in R>> Array<*>.filterIsInstanceTo(destination: C): C {\n    for (element in this) if (element is R) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun <T> Array<out T>.filterNot(predicate: (T) -> Boolean): List<T> {\n    return filterNotTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun ByteArray.filterNot(predicate: (Byte) -> Boolean): List<Byte> {\n    return filterNotTo(ArrayList<Byte>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun ShortArray.filterNot(predicate: (Short) -> Boolean): List<Short> {\n    return filterNotTo(ArrayList<Short>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun IntArray.filterNot(predicate: (Int) -> Boolean): List<Int> {\n    return filterNotTo(ArrayList<Int>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun LongArray.filterNot(predicate: (Long) -> Boolean): List<Long> {\n    return filterNotTo(ArrayList<Long>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun FloatArray.filterNot(predicate: (Float) -> Boolean): List<Float> {\n    return filterNotTo(ArrayList<Float>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun DoubleArray.filterNot(predicate: (Double) -> Boolean): List<Double> {\n    return filterNotTo(ArrayList<Double>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun BooleanArray.filterNot(predicate: (Boolean) -> Boolean): List<Boolean> {\n    return filterNotTo(ArrayList<Boolean>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun CharArray.filterNot(predicate: (Char) -> Boolean): List<Char> {\n    return filterNotTo(ArrayList<Char>(), predicate)\n}\n\n/**\n * Returns a list containing all elements that are not `null`.\n * \n * @sample samples.collections.Collections.Filtering.filterNotNull\n */\npublic fun <T : Any> Array<out T?>.filterNotNull(): List<T> {\n    return filterNotNullTo(ArrayList<T>())\n}\n\n/**\n * Appends all elements that are not `null` to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterNotNullTo\n */\npublic fun <C : MutableCollection<in T>, T : Any> Array<out T?>.filterNotNullTo(destination: C): C {\n    for (element in this) if (element != null) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Array<out T>.filterNotTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Byte>> ByteArray.filterNotTo(destination: C, predicate: (Byte) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Short>> ShortArray.filterNotTo(destination: C, predicate: (Short) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Int>> IntArray.filterNotTo(destination: C, predicate: (Int) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Long>> LongArray.filterNotTo(destination: C, predicate: (Long) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Float>> FloatArray.filterNotTo(destination: C, predicate: (Float) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Double>> DoubleArray.filterNotTo(destination: C, predicate: (Double) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Boolean>> BooleanArray.filterNotTo(destination: C, predicate: (Boolean) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Char>> CharArray.filterNotTo(destination: C, predicate: (Char) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Array<out T>.filterTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Byte>> ByteArray.filterTo(destination: C, predicate: (Byte) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Short>> ShortArray.filterTo(destination: C, predicate: (Short) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Int>> IntArray.filterTo(destination: C, predicate: (Int) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Long>> LongArray.filterTo(destination: C, predicate: (Long) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Float>> FloatArray.filterTo(destination: C, predicate: (Float) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Double>> DoubleArray.filterTo(destination: C, predicate: (Double) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Boolean>> BooleanArray.filterTo(destination: C, predicate: (Boolean) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Char>> CharArray.filterTo(destination: C, predicate: (Char) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun <T> Array<out T>.slice(indices: IntRange): List<T> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun ByteArray.slice(indices: IntRange): List<Byte> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun ShortArray.slice(indices: IntRange): List<Short> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun IntArray.slice(indices: IntRange): List<Int> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun LongArray.slice(indices: IntRange): List<Long> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun FloatArray.slice(indices: IntRange): List<Float> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun DoubleArray.slice(indices: IntRange): List<Double> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun BooleanArray.slice(indices: IntRange): List<Boolean> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun CharArray.slice(indices: IntRange): List<Char> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun <T> Array<out T>.slice(indices: Iterable<Int>): List<T> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<T>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun ByteArray.slice(indices: Iterable<Int>): List<Byte> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Byte>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun ShortArray.slice(indices: Iterable<Int>): List<Short> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Short>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun IntArray.slice(indices: Iterable<Int>): List<Int> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Int>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun LongArray.slice(indices: Iterable<Int>): List<Long> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Long>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun FloatArray.slice(indices: Iterable<Int>): List<Float> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Float>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun DoubleArray.slice(indices: Iterable<Int>): List<Double> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Double>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun BooleanArray.slice(indices: Iterable<Int>): List<Boolean> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Boolean>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun CharArray.slice(indices: Iterable<Int>): List<Char> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Char>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun <T> Array<T>.sliceArray(indices: Collection<Int>): Array<T> {\n    val result = arrayOfNulls(this, indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun ByteArray.sliceArray(indices: Collection<Int>): ByteArray {\n    val result = ByteArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun ShortArray.sliceArray(indices: Collection<Int>): ShortArray {\n    val result = ShortArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun IntArray.sliceArray(indices: Collection<Int>): IntArray {\n    val result = IntArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun LongArray.sliceArray(indices: Collection<Int>): LongArray {\n    val result = LongArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun FloatArray.sliceArray(indices: Collection<Int>): FloatArray {\n    val result = FloatArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun DoubleArray.sliceArray(indices: Collection<Int>): DoubleArray {\n    val result = DoubleArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun BooleanArray.sliceArray(indices: Collection<Int>): BooleanArray {\n    val result = BooleanArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun CharArray.sliceArray(indices: Collection<Int>): CharArray {\n    val result = CharArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun <T> Array<T>.sliceArray(indices: IntRange): Array<T> {\n    if (indices.isEmpty()) return copyOfRange(0, 0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun ByteArray.sliceArray(indices: IntRange): ByteArray {\n    if (indices.isEmpty()) return ByteArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun ShortArray.sliceArray(indices: IntRange): ShortArray {\n    if (indices.isEmpty()) return ShortArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun IntArray.sliceArray(indices: IntRange): IntArray {\n    if (indices.isEmpty()) return IntArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun LongArray.sliceArray(indices: IntRange): LongArray {\n    if (indices.isEmpty()) return LongArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun FloatArray.sliceArray(indices: IntRange): FloatArray {\n    if (indices.isEmpty()) return FloatArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun DoubleArray.sliceArray(indices: IntRange): DoubleArray {\n    if (indices.isEmpty()) return DoubleArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun BooleanArray.sliceArray(indices: IntRange): BooleanArray {\n    if (indices.isEmpty()) return BooleanArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun CharArray.sliceArray(indices: IntRange): CharArray {\n    if (indices.isEmpty()) return CharArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> Array<out T>.take(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<T>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun ByteArray.take(n: Int): List<Byte> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Byte>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun ShortArray.take(n: Int): List<Short> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Short>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun IntArray.take(n: Int): List<Int> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Int>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun LongArray.take(n: Int): List<Long> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Long>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun FloatArray.take(n: Int): List<Float> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Float>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun DoubleArray.take(n: Int): List<Double> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Double>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun BooleanArray.take(n: Int): List<Boolean> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Boolean>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun CharArray.take(n: Int): List<Char> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Char>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> Array<out T>.takeLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<T>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun ByteArray.takeLast(n: Int): List<Byte> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Byte>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun ShortArray.takeLast(n: Int): List<Short> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Short>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun IntArray.takeLast(n: Int): List<Int> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Int>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun LongArray.takeLast(n: Int): List<Long> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Long>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun FloatArray.takeLast(n: Int): List<Float> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Float>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun DoubleArray.takeLast(n: Int): List<Double> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Double>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun BooleanArray.takeLast(n: Int): List<Boolean> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Boolean>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun CharArray.takeLast(n: Int): List<Char> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Char>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> Array<out T>.takeLastWhile(predicate: (T) -> Boolean): List<T> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun ByteArray.takeLastWhile(predicate: (Byte) -> Boolean): List<Byte> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun ShortArray.takeLastWhile(predicate: (Short) -> Boolean): List<Short> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun IntArray.takeLastWhile(predicate: (Int) -> Boolean): List<Int> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun LongArray.takeLastWhile(predicate: (Long) -> Boolean): List<Long> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun FloatArray.takeLastWhile(predicate: (Float) -> Boolean): List<Float> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun DoubleArray.takeLastWhile(predicate: (Double) -> Boolean): List<Double> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun BooleanArray.takeLastWhile(predicate: (Boolean) -> Boolean): List<Boolean> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun CharArray.takeLastWhile(predicate: (Char) -> Boolean): List<Char> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> Array<out T>.takeWhile(predicate: (T) -> Boolean): List<T> {\n    val list = ArrayList<T>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun ByteArray.takeWhile(predicate: (Byte) -> Boolean): List<Byte> {\n    val list = ArrayList<Byte>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun ShortArray.takeWhile(predicate: (Short) -> Boolean): List<Short> {\n    val list = ArrayList<Short>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun IntArray.takeWhile(predicate: (Int) -> Boolean): List<Int> {\n    val list = ArrayList<Int>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun LongArray.takeWhile(predicate: (Long) -> Boolean): List<Long> {\n    val list = ArrayList<Long>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun FloatArray.takeWhile(predicate: (Float) -> Boolean): List<Float> {\n    val list = ArrayList<Float>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun DoubleArray.takeWhile(predicate: (Double) -> Boolean): List<Double> {\n    val list = ArrayList<Double>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun BooleanArray.takeWhile(predicate: (Boolean) -> Boolean): List<Boolean> {\n    val list = ArrayList<Boolean>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun CharArray.takeWhile(predicate: (Char) -> Boolean): List<Char> {\n    val list = ArrayList<Char>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun <T> Array<T>.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun ByteArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun ShortArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun IntArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun LongArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun FloatArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun DoubleArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun BooleanArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun CharArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Array<T>.reverse(fromIndex: Int, toIndex: Int): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val midPoint = (fromIndex + toIndex) / 2\n    if (fromIndex == midPoint) return\n    var reverseIndex = toIndex - 1\n    for (index in fromIndex until midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun ByteArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val midPoint = (fromIndex + toIndex) / 2\n    if (fromIndex == midPoint) return\n    var reverseIndex = toIndex - 1\n    for (index in fromIndex until midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun ShortArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val midPoint = (fromIndex + toIndex) / 2\n    if (fromIndex == midPoint) return\n    var reverseIndex = toIndex - 1\n    for (index in fromIndex until midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun IntArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val midPoint = (fromIndex + toIndex) / 2\n    if (fromIndex == midPoint) return\n    var reverseIndex = toIndex - 1\n    for (index in fromIndex until midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun LongArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val midPoint = (fromIndex + toIndex) / 2\n    if (fromIndex == midPoint) return\n    var reverseIndex = toIndex - 1\n    for (index in fromIndex until midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun FloatArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val midPoint = (fromIndex + toIndex) / 2\n    if (fromIndex == midPoint) return\n    var reverseIndex = toIndex - 1\n    for (index in fromIndex until midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun DoubleArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val midPoint = (fromIndex + toIndex) / 2\n    if (fromIndex == midPoint) return\n    var reverseIndex = toIndex - 1\n    for (index in fromIndex until midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun BooleanArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val midPoint = (fromIndex + toIndex) / 2\n    if (fromIndex == midPoint) return\n    var reverseIndex = toIndex - 1\n    for (index in fromIndex until midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun CharArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val midPoint = (fromIndex + toIndex) / 2\n    if (fromIndex == midPoint) return\n    var reverseIndex = toIndex - 1\n    for (index in fromIndex until midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun <T> Array<out T>.reversed(): List<T> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun ByteArray.reversed(): List<Byte> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun ShortArray.reversed(): List<Short> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun IntArray.reversed(): List<Int> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun LongArray.reversed(): List<Long> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun FloatArray.reversed(): List<Float> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun DoubleArray.reversed(): List<Double> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun BooleanArray.reversed(): List<Boolean> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun CharArray.reversed(): List<Char> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun <T> Array<T>.reversedArray(): Array<T> {\n    if (isEmpty()) return this\n    val result = arrayOfNulls(this, size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun ByteArray.reversedArray(): ByteArray {\n    if (isEmpty()) return this\n    val result = ByteArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun ShortArray.reversedArray(): ShortArray {\n    if (isEmpty()) return this\n    val result = ShortArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun IntArray.reversedArray(): IntArray {\n    if (isEmpty()) return this\n    val result = IntArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun LongArray.reversedArray(): LongArray {\n    if (isEmpty()) return this\n    val result = LongArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun FloatArray.reversedArray(): FloatArray {\n    if (isEmpty()) return this\n    val result = FloatArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun DoubleArray.reversedArray(): DoubleArray {\n    if (isEmpty()) return this\n    val result = DoubleArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun BooleanArray.reversedArray(): BooleanArray {\n    if (isEmpty()) return this\n    val result = BooleanArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun CharArray.reversedArray(): CharArray {\n    if (isEmpty()) return this\n    val result = CharArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Array<T>.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\npublic fun ByteArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\npublic fun ShortArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\npublic fun IntArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\npublic fun LongArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\npublic fun FloatArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\npublic fun DoubleArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\npublic fun BooleanArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\npublic fun CharArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Array<T>.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\npublic fun ByteArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\npublic fun ShortArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\npublic fun IntArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\npublic fun LongArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\npublic fun FloatArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\npublic fun DoubleArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\npublic fun BooleanArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\npublic fun CharArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Sorts elements in the array in-place according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> Array<out T>.sortBy(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareBy(selector))\n}\n\n/**\n * Sorts elements in the array in-place descending according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> Array<out T>.sortByDescending(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareByDescending(selector))\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Array<out T>.sortDescending(): Unit {\n    sortWith(reverseOrder())\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun ByteArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun ShortArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun IntArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun LongArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun FloatArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun DoubleArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun CharArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Array<out T>.sorted(): List<T> {\n    return sortedArray().asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun ByteArray.sorted(): List<Byte> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun ShortArray.sorted(): List<Short> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun IntArray.sorted(): List<Int> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun LongArray.sorted(): List<Long> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun FloatArray.sorted(): List<Float> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun DoubleArray.sorted(): List<Double> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun CharArray.sorted(): List<Char> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Array<T>.sortedArray(): Array<T> {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun ByteArray.sortedArray(): ByteArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun ShortArray.sortedArray(): ShortArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun IntArray.sortedArray(): IntArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun LongArray.sortedArray(): LongArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun FloatArray.sortedArray(): FloatArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun DoubleArray.sortedArray(): DoubleArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun CharArray.sortedArray(): CharArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Array<T>.sortedArrayDescending(): Array<T> {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortWith(reverseOrder()) }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun ByteArray.sortedArrayDescending(): ByteArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun ShortArray.sortedArrayDescending(): ShortArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun IntArray.sortedArrayDescending(): IntArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun LongArray.sortedArrayDescending(): LongArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun FloatArray.sortedArrayDescending(): FloatArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun DoubleArray.sortedArrayDescending(): DoubleArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun CharArray.sortedArrayDescending(): CharArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according the specified [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T> Array<out T>.sortedArrayWith(comparator: Comparator<in T>): Array<out T> {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortWith(comparator) }\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <T, R : Comparable<R>> Array<out T>.sortedBy(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <R : Comparable<R>> ByteArray.sortedBy(crossinline selector: (Byte) -> R?): List<Byte> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <R : Comparable<R>> ShortArray.sortedBy(crossinline selector: (Short) -> R?): List<Short> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <R : Comparable<R>> IntArray.sortedBy(crossinline selector: (Int) -> R?): List<Int> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <R : Comparable<R>> LongArray.sortedBy(crossinline selector: (Long) -> R?): List<Long> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <R : Comparable<R>> FloatArray.sortedBy(crossinline selector: (Float) -> R?): List<Float> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <R : Comparable<R>> DoubleArray.sortedBy(crossinline selector: (Double) -> R?): List<Double> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <R : Comparable<R>> BooleanArray.sortedBy(crossinline selector: (Boolean) -> R?): List<Boolean> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <R : Comparable<R>> CharArray.sortedBy(crossinline selector: (Char) -> R?): List<Char> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> Array<out T>.sortedByDescending(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> ByteArray.sortedByDescending(crossinline selector: (Byte) -> R?): List<Byte> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> ShortArray.sortedByDescending(crossinline selector: (Short) -> R?): List<Short> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> IntArray.sortedByDescending(crossinline selector: (Int) -> R?): List<Int> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> LongArray.sortedByDescending(crossinline selector: (Long) -> R?): List<Long> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> FloatArray.sortedByDescending(crossinline selector: (Float) -> R?): List<Float> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> DoubleArray.sortedByDescending(crossinline selector: (Double) -> R?): List<Double> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> BooleanArray.sortedByDescending(crossinline selector: (Boolean) -> R?): List<Boolean> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> CharArray.sortedByDescending(crossinline selector: (Char) -> R?): List<Char> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Array<out T>.sortedDescending(): List<T> {\n    return sortedWith(reverseOrder())\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun ByteArray.sortedDescending(): List<Byte> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun ShortArray.sortedDescending(): List<Short> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun IntArray.sortedDescending(): List<Int> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun LongArray.sortedDescending(): List<Long> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun FloatArray.sortedDescending(): List<Float> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun DoubleArray.sortedDescending(): List<Double> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun CharArray.sortedDescending(): List<Char> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T> Array<out T>.sortedWith(comparator: Comparator<in T>): List<T> {\n    return sortedArrayWith(comparator).asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun ByteArray.sortedWith(comparator: Comparator<in Byte>): List<Byte> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun ShortArray.sortedWith(comparator: Comparator<in Short>): List<Short> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun IntArray.sortedWith(comparator: Comparator<in Int>): List<Int> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun LongArray.sortedWith(comparator: Comparator<in Long>): List<Long> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun FloatArray.sortedWith(comparator: Comparator<in Float>): List<Float> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun DoubleArray.sortedWith(comparator: Comparator<in Double>): List<Double> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun BooleanArray.sortedWith(comparator: Comparator<in Boolean>): List<Boolean> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun CharArray.sortedWith(comparator: Comparator<in Char>): List<Char> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun <T> Array<out T>.asList(): List<T>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun ByteArray.asList(): List<Byte>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun ShortArray.asList(): List<Short>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun IntArray.asList(): List<Int>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun LongArray.asList(): List<Long>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun FloatArray.asList(): List<Float>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun DoubleArray.asList(): List<Double>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun BooleanArray.asList(): List<Boolean>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun CharArray.asList(): List<Char>\n\n/**\n * Returns `true` if the two specified arrays are *deeply* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * If two corresponding elements are nested arrays, they are also compared deeply.\n * If any of arrays contains itself on any nesting level the behavior is undefined.\n * \n * The elements of other types are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.LowPriorityInOverloadResolution\npublic expect infix fun <T> Array<out T>.contentDeepEquals(other: Array<out T>): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *deeply* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The specified arrays are also considered deeply equal if both are `null`.\n * \n * If two corresponding elements are nested arrays, they are also compared deeply.\n * If any of arrays contains itself on any nesting level the behavior is undefined.\n * \n * The elements of other types are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun <T> Array<out T>?.contentDeepEquals(other: Array<out T>?): Boolean\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n * Nested arrays are treated as lists too.\n * \n * If any of arrays contains itself on any nesting level the behavior is undefined.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.LowPriorityInOverloadResolution\npublic expect fun <T> Array<out T>.contentDeepHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n * Nested arrays are treated as lists too.\n * \n * If any of arrays contains itself on any nesting level the behavior is undefined.\n */\n@SinceKotlin(\"1.4\")\npublic expect fun <T> Array<out T>?.contentDeepHashCode(): Int\n\n/**\n * Returns a string representation of the contents of this array as if it is a [List].\n * Nested arrays are treated as lists too.\n * \n * If any of arrays contains itself on any nesting level that reference\n * is rendered as `\"[...]\"` to prevent recursion.\n * \n * @sample samples.collections.Arrays.ContentOperations.contentDeepToString\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.LowPriorityInOverloadResolution\npublic expect fun <T> Array<out T>.contentDeepToString(): String\n\n/**\n * Returns a string representation of the contents of this array as if it is a [List].\n * Nested arrays are treated as lists too.\n * \n * If any of arrays contains itself on any nesting level that reference\n * is rendered as `\"[...]\"` to prevent recursion.\n * \n * @sample samples.collections.Arrays.ContentOperations.contentDeepToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun <T> Array<out T>?.contentDeepToString(): String\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect infix fun <T> Array<out T>.contentEquals(other: Array<out T>): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect infix fun ByteArray.contentEquals(other: ByteArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect infix fun ShortArray.contentEquals(other: ShortArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect infix fun IntArray.contentEquals(other: IntArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect infix fun LongArray.contentEquals(other: LongArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect infix fun FloatArray.contentEquals(other: FloatArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect infix fun DoubleArray.contentEquals(other: DoubleArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect infix fun BooleanArray.contentEquals(other: BooleanArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect infix fun CharArray.contentEquals(other: CharArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun <T> Array<out T>?.contentEquals(other: Array<out T>?): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun ByteArray?.contentEquals(other: ByteArray?): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun ShortArray?.contentEquals(other: ShortArray?): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun IntArray?.contentEquals(other: IntArray?): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun LongArray?.contentEquals(other: LongArray?): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun FloatArray?.contentEquals(other: FloatArray?): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun DoubleArray?.contentEquals(other: DoubleArray?): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun BooleanArray?.contentEquals(other: BooleanArray?): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun CharArray?.contentEquals(other: CharArray?): Boolean\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun <T> Array<out T>.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun ByteArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun ShortArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun IntArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun LongArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun FloatArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun DoubleArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun BooleanArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun CharArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\npublic expect fun <T> Array<out T>?.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\npublic expect fun ByteArray?.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\npublic expect fun ShortArray?.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\npublic expect fun IntArray?.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\npublic expect fun LongArray?.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\npublic expect fun FloatArray?.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\npublic expect fun DoubleArray?.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\npublic expect fun BooleanArray?.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\npublic expect fun CharArray?.contentHashCode(): Int\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun <T> Array<out T>.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun ByteArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun ShortArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun IntArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun LongArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun FloatArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun DoubleArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun BooleanArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun CharArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun <T> Array<out T>?.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun ByteArray?.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun ShortArray?.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun IntArray?.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun LongArray?.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun FloatArray?.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun DoubleArray?.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun BooleanArray?.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun CharArray?.contentToString(): String\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun <T> Array<out T>.copyInto(destination: Array<T>, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): Array<T>\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun ByteArray.copyInto(destination: ByteArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): ByteArray\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun ShortArray.copyInto(destination: ShortArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): ShortArray\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun IntArray.copyInto(destination: IntArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): IntArray\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun LongArray.copyInto(destination: LongArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): LongArray\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun FloatArray.copyInto(destination: FloatArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): FloatArray\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun DoubleArray.copyInto(destination: DoubleArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): DoubleArray\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun BooleanArray.copyInto(destination: BooleanArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): BooleanArray\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun CharArray.copyInto(destination: CharArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): CharArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect fun <T> Array<T>.copyOf(): Array<T>\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun ByteArray.copyOf(): ByteArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun ShortArray.copyOf(): ShortArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun IntArray.copyOf(): IntArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun LongArray.copyOf(): LongArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun FloatArray.copyOf(): FloatArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun DoubleArray.copyOf(): DoubleArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun BooleanArray.copyOf(): BooleanArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun CharArray.copyOf(): CharArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun ByteArray.copyOf(newSize: Int): ByteArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun ShortArray.copyOf(newSize: Int): ShortArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun IntArray.copyOf(newSize: Int): IntArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun LongArray.copyOf(newSize: Int): LongArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun FloatArray.copyOf(newSize: Int): FloatArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun DoubleArray.copyOf(newSize: Int): DoubleArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with `false` values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with `false` values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun BooleanArray.copyOf(newSize: Int): BooleanArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with null char (`\\u0000`) values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with null char (`\\u0000`) values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun CharArray.copyOf(newSize: Int): CharArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with `null` values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with `null` values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizingCopyOf\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect fun <T> Array<T>.copyOf(newSize: Int): Array<T?>\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect fun <T> Array<T>.copyOfRange(fromIndex: Int, toIndex: Int): Array<T>\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic expect fun ByteArray.copyOfRange(fromIndex: Int, toIndex: Int): ByteArray\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic expect fun ShortArray.copyOfRange(fromIndex: Int, toIndex: Int): ShortArray\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic expect fun IntArray.copyOfRange(fromIndex: Int, toIndex: Int): IntArray\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic expect fun LongArray.copyOfRange(fromIndex: Int, toIndex: Int): LongArray\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic expect fun FloatArray.copyOfRange(fromIndex: Int, toIndex: Int): FloatArray\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic expect fun DoubleArray.copyOfRange(fromIndex: Int, toIndex: Int): DoubleArray\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic expect fun BooleanArray.copyOfRange(fromIndex: Int, toIndex: Int): BooleanArray\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic expect fun CharArray.copyOfRange(fromIndex: Int, toIndex: Int): CharArray\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun <T> Array<T>.fill(element: T, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun ByteArray.fill(element: Byte, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun ShortArray.fill(element: Short, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun IntArray.fill(element: Int, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun LongArray.fill(element: Long, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun FloatArray.fill(element: Float, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun DoubleArray.fill(element: Double, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun BooleanArray.fill(element: Boolean, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun CharArray.fill(element: Char, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val <T> Array<out T>.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val ByteArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val ShortArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val IntArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val LongArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val FloatArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val DoubleArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val BooleanArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val CharArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns the last valid index for the array.\n */\npublic val <T> Array<out T>.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val ByteArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val ShortArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val IntArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val LongArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val FloatArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val DoubleArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val BooleanArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val CharArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect operator fun <T> Array<T>.plus(element: T): Array<T>\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun ByteArray.plus(element: Byte): ByteArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun ShortArray.plus(element: Short): ShortArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun IntArray.plus(element: Int): IntArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun LongArray.plus(element: Long): LongArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun FloatArray.plus(element: Float): FloatArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun DoubleArray.plus(element: Double): DoubleArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun BooleanArray.plus(element: Boolean): BooleanArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun CharArray.plus(element: Char): CharArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect operator fun <T> Array<T>.plus(elements: Collection<T>): Array<T>\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun ByteArray.plus(elements: Collection<Byte>): ByteArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun ShortArray.plus(elements: Collection<Short>): ShortArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun IntArray.plus(elements: Collection<Int>): IntArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun LongArray.plus(elements: Collection<Long>): LongArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun FloatArray.plus(elements: Collection<Float>): FloatArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun DoubleArray.plus(elements: Collection<Double>): DoubleArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun BooleanArray.plus(elements: Collection<Boolean>): BooleanArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun CharArray.plus(elements: Collection<Char>): CharArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect operator fun <T> Array<T>.plus(elements: Array<out T>): Array<T>\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun ByteArray.plus(elements: ByteArray): ByteArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun ShortArray.plus(elements: ShortArray): ShortArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun IntArray.plus(elements: IntArray): IntArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun LongArray.plus(elements: LongArray): LongArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun FloatArray.plus(elements: FloatArray): FloatArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun DoubleArray.plus(elements: DoubleArray): DoubleArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun BooleanArray.plus(elements: BooleanArray): BooleanArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun CharArray.plus(elements: CharArray): CharArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect fun <T> Array<T>.plusElement(element: T): Array<T>\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\npublic expect fun IntArray.sort(): Unit\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\npublic expect fun LongArray.sort(): Unit\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\npublic expect fun ByteArray.sort(): Unit\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\npublic expect fun ShortArray.sort(): Unit\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\npublic expect fun DoubleArray.sort(): Unit\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\npublic expect fun FloatArray.sort(): Unit\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\npublic expect fun CharArray.sort(): Unit\n\n/**\n * Sorts the array in-place according to the natural order of its elements.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n * \n * @sample samples.collections.Arrays.Sorting.sortArrayOfComparable\n */\npublic expect fun <T : Comparable<T>> Array<out T>.sort(): Unit\n\n/**\n * Sorts a range in the array in-place.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArrayOfComparable\n */\n@SinceKotlin(\"1.4\")\npublic expect fun <T : Comparable<T>> Array<out T>.sort(fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\npublic expect fun ByteArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\npublic expect fun ShortArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\npublic expect fun IntArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\npublic expect fun LongArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\npublic expect fun FloatArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\npublic expect fun DoubleArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\npublic expect fun CharArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Comparable<T>> Array<out T>.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sortWith(reverseOrder(), fromIndex, toIndex)\n}\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun ByteArray.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sort(fromIndex, toIndex)\n    reverse(fromIndex, toIndex)\n}\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun ShortArray.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sort(fromIndex, toIndex)\n    reverse(fromIndex, toIndex)\n}\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun IntArray.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sort(fromIndex, toIndex)\n    reverse(fromIndex, toIndex)\n}\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun LongArray.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sort(fromIndex, toIndex)\n    reverse(fromIndex, toIndex)\n}\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun FloatArray.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sort(fromIndex, toIndex)\n    reverse(fromIndex, toIndex)\n}\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun DoubleArray.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sort(fromIndex, toIndex)\n    reverse(fromIndex, toIndex)\n}\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun CharArray.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sort(fromIndex, toIndex)\n    reverse(fromIndex, toIndex)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic expect fun <T> Array<out T>.sortWith(comparator: Comparator<in T>): Unit\n\n/**\n * Sorts a range in the array in-place with the given [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic expect fun <T> Array<out T>.sortWith(comparator: Comparator<in T>, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Returns an array of Boolean containing all of the elements of this generic array.\n */\npublic fun Array<out Boolean>.toBooleanArray(): BooleanArray {\n    return BooleanArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of Byte containing all of the elements of this generic array.\n */\npublic fun Array<out Byte>.toByteArray(): ByteArray {\n    return ByteArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of Char containing all of the elements of this generic array.\n */\npublic fun Array<out Char>.toCharArray(): CharArray {\n    return CharArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of Double containing all of the elements of this generic array.\n */\npublic fun Array<out Double>.toDoubleArray(): DoubleArray {\n    return DoubleArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of Float containing all of the elements of this generic array.\n */\npublic fun Array<out Float>.toFloatArray(): FloatArray {\n    return FloatArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of Int containing all of the elements of this generic array.\n */\npublic fun Array<out Int>.toIntArray(): IntArray {\n    return IntArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of Long containing all of the elements of this generic array.\n */\npublic fun Array<out Long>.toLongArray(): LongArray {\n    return LongArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of Short containing all of the elements of this generic array.\n */\npublic fun Array<out Short>.toShortArray(): ShortArray {\n    return ShortArray(size) { index -> this[index] }\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun ByteArray.toTypedArray(): Array<Byte>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun ShortArray.toTypedArray(): Array<Short>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun IntArray.toTypedArray(): Array<Int>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun LongArray.toTypedArray(): Array<Long>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun FloatArray.toTypedArray(): Array<Float>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun DoubleArray.toTypedArray(): Array<Double>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun BooleanArray.toTypedArray(): Array<Boolean>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun CharArray.toTypedArray(): Array<Char>\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <T, K, V> Array<out T>.associate(transform: (T) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <K, V> ByteArray.associate(transform: (Byte) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <K, V> ShortArray.associate(transform: (Short) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <K, V> IntArray.associate(transform: (Int) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <K, V> LongArray.associate(transform: (Long) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <K, V> FloatArray.associate(transform: (Float) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <K, V> DoubleArray.associate(transform: (Double) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <K, V> BooleanArray.associate(transform: (Boolean) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <K, V> CharArray.associate(transform: (Char) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <T, K> Array<out T>.associateBy(keySelector: (T) -> K): Map<K, T> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, T>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <K> ByteArray.associateBy(keySelector: (Byte) -> K): Map<K, Byte> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Byte>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <K> ShortArray.associateBy(keySelector: (Short) -> K): Map<K, Short> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Short>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <K> IntArray.associateBy(keySelector: (Int) -> K): Map<K, Int> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Int>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <K> LongArray.associateBy(keySelector: (Long) -> K): Map<K, Long> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Long>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <K> FloatArray.associateBy(keySelector: (Float) -> K): Map<K, Float> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Float>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <K> DoubleArray.associateBy(keySelector: (Double) -> K): Map<K, Double> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Double>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <K> BooleanArray.associateBy(keySelector: (Boolean) -> K): Map<K, Boolean> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Boolean>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <K> CharArray.associateBy(keySelector: (Char) -> K): Map<K, Char> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Char>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <T, K, V> Array<out T>.associateBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <K, V> ByteArray.associateBy(keySelector: (Byte) -> K, valueTransform: (Byte) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <K, V> ShortArray.associateBy(keySelector: (Short) -> K, valueTransform: (Short) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <K, V> IntArray.associateBy(keySelector: (Int) -> K, valueTransform: (Int) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <K, V> LongArray.associateBy(keySelector: (Long) -> K, valueTransform: (Long) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <K, V> FloatArray.associateBy(keySelector: (Float) -> K, valueTransform: (Float) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <K, V> DoubleArray.associateBy(keySelector: (Double) -> K, valueTransform: (Double) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <K, V> BooleanArray.associateBy(keySelector: (Boolean) -> K, valueTransform: (Boolean) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <K, V> CharArray.associateBy(keySelector: (Char) -> K, valueTransform: (Char) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <T, K, M : MutableMap<in K, in T>> Array<out T>.associateByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Byte>> ByteArray.associateByTo(destination: M, keySelector: (Byte) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Short>> ShortArray.associateByTo(destination: M, keySelector: (Short) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Int>> IntArray.associateByTo(destination: M, keySelector: (Int) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Long>> LongArray.associateByTo(destination: M, keySelector: (Long) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Float>> FloatArray.associateByTo(destination: M, keySelector: (Float) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Double>> DoubleArray.associateByTo(destination: M, keySelector: (Double) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Boolean>> BooleanArray.associateByTo(destination: M, keySelector: (Boolean) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Char>> CharArray.associateByTo(destination: M, keySelector: (Char) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Array<out T>.associateByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> ByteArray.associateByTo(destination: M, keySelector: (Byte) -> K, valueTransform: (Byte) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> ShortArray.associateByTo(destination: M, keySelector: (Short) -> K, valueTransform: (Short) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> IntArray.associateByTo(destination: M, keySelector: (Int) -> K, valueTransform: (Int) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> LongArray.associateByTo(destination: M, keySelector: (Long) -> K, valueTransform: (Long) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> FloatArray.associateByTo(destination: M, keySelector: (Float) -> K, valueTransform: (Float) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> DoubleArray.associateByTo(destination: M, keySelector: (Double) -> K, valueTransform: (Double) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> BooleanArray.associateByTo(destination: M, keySelector: (Boolean) -> K, valueTransform: (Boolean) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> CharArray.associateByTo(destination: M, keySelector: (Char) -> K, valueTransform: (Char) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Array<out T>.associateTo(destination: M, transform: (T) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> ByteArray.associateTo(destination: M, transform: (Byte) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> ShortArray.associateTo(destination: M, transform: (Short) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> IntArray.associateTo(destination: M, transform: (Int) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> LongArray.associateTo(destination: M, transform: (Long) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> FloatArray.associateTo(destination: M, transform: (Float) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> DoubleArray.associateTo(destination: M, transform: (Double) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> BooleanArray.associateTo(destination: M, transform: (Boolean) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> CharArray.associateTo(destination: M, transform: (Char) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <K, V> Array<out K>.associateWith(valueSelector: (K) -> V): Map<K, V> {\n    val result = LinkedHashMap<K, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V> ByteArray.associateWith(valueSelector: (Byte) -> V): Map<Byte, V> {\n    val result = LinkedHashMap<Byte, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V> ShortArray.associateWith(valueSelector: (Short) -> V): Map<Short, V> {\n    val result = LinkedHashMap<Short, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V> IntArray.associateWith(valueSelector: (Int) -> V): Map<Int, V> {\n    val result = LinkedHashMap<Int, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V> LongArray.associateWith(valueSelector: (Long) -> V): Map<Long, V> {\n    val result = LinkedHashMap<Long, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V> FloatArray.associateWith(valueSelector: (Float) -> V): Map<Float, V> {\n    val result = LinkedHashMap<Float, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V> DoubleArray.associateWith(valueSelector: (Double) -> V): Map<Double, V> {\n    val result = LinkedHashMap<Double, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V> BooleanArray.associateWith(valueSelector: (Boolean) -> V): Map<Boolean, V> {\n    val result = LinkedHashMap<Boolean, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V> CharArray.associateWith(valueSelector: (Char) -> V): Map<Char, V> {\n    val result = LinkedHashMap<Char, V>(mapCapacity(size.coerceAtMost(128)).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <K, V, M : MutableMap<in K, in V>> Array<out K>.associateWithTo(destination: M, valueSelector: (K) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in Byte, in V>> ByteArray.associateWithTo(destination: M, valueSelector: (Byte) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in Short, in V>> ShortArray.associateWithTo(destination: M, valueSelector: (Short) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in Int, in V>> IntArray.associateWithTo(destination: M, valueSelector: (Int) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in Long, in V>> LongArray.associateWithTo(destination: M, valueSelector: (Long) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in Float, in V>> FloatArray.associateWithTo(destination: M, valueSelector: (Float) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in Double, in V>> DoubleArray.associateWithTo(destination: M, valueSelector: (Double) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in Boolean, in V>> BooleanArray.associateWithTo(destination: M, valueSelector: (Boolean) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in Char, in V>> CharArray.associateWithTo(destination: M, valueSelector: (Char) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <T, C : MutableCollection<in T>> Array<out T>.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Byte>> ByteArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Short>> ShortArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Int>> IntArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Long>> LongArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Float>> FloatArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Double>> DoubleArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Boolean>> BooleanArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Char>> CharArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun <T> Array<out T>.toHashSet(): HashSet<T> {\n    return toCollection(HashSet<T>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun ByteArray.toHashSet(): HashSet<Byte> {\n    return toCollection(HashSet<Byte>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun ShortArray.toHashSet(): HashSet<Short> {\n    return toCollection(HashSet<Short>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun IntArray.toHashSet(): HashSet<Int> {\n    return toCollection(HashSet<Int>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun LongArray.toHashSet(): HashSet<Long> {\n    return toCollection(HashSet<Long>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun FloatArray.toHashSet(): HashSet<Float> {\n    return toCollection(HashSet<Float>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun DoubleArray.toHashSet(): HashSet<Double> {\n    return toCollection(HashSet<Double>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun BooleanArray.toHashSet(): HashSet<Boolean> {\n    return toCollection(HashSet<Boolean>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun CharArray.toHashSet(): HashSet<Char> {\n    return toCollection(HashSet<Char>(mapCapacity(size.coerceAtMost(128))))\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun <T> Array<out T>.toList(): List<T> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun ByteArray.toList(): List<Byte> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun ShortArray.toList(): List<Short> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun IntArray.toList(): List<Int> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun LongArray.toList(): List<Long> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun FloatArray.toList(): List<Float> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun DoubleArray.toList(): List<Double> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun BooleanArray.toList(): List<Boolean> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun CharArray.toList(): List<Char> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this array.\n */\npublic fun <T> Array<out T>.toMutableList(): MutableList<T> {\n    return ArrayList(this.asCollection())\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this array.\n */\npublic fun ByteArray.toMutableList(): MutableList<Byte> {\n    val list = ArrayList<Byte>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this array.\n */\npublic fun ShortArray.toMutableList(): MutableList<Short> {\n    val list = ArrayList<Short>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this array.\n */\npublic fun IntArray.toMutableList(): MutableList<Int> {\n    val list = ArrayList<Int>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this array.\n */\npublic fun LongArray.toMutableList(): MutableList<Long> {\n    val list = ArrayList<Long>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this array.\n */\npublic fun FloatArray.toMutableList(): MutableList<Float> {\n    val list = ArrayList<Float>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this array.\n */\npublic fun DoubleArray.toMutableList(): MutableList<Double> {\n    val list = ArrayList<Double>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this array.\n */\npublic fun BooleanArray.toMutableList(): MutableList<Boolean> {\n    val list = ArrayList<Boolean>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this array.\n */\npublic fun CharArray.toMutableList(): MutableList<Char> {\n    val list = ArrayList<Char>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun <T> Array<out T>.toSet(): Set<T> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<T>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun ByteArray.toSet(): Set<Byte> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Byte>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun ShortArray.toSet(): Set<Short> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Short>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun IntArray.toSet(): Set<Int> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Int>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun LongArray.toSet(): Set<Long> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Long>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun FloatArray.toSet(): Set<Float> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Float>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun DoubleArray.toSet(): Set<Double> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Double>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun BooleanArray.toSet(): Set<Boolean> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Boolean>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun CharArray.toSet(): Set<Char> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Char>(mapCapacity(size.coerceAtMost(128))))\n    }\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <T, R> Array<out T>.flatMap(transform: (T) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> ByteArray.flatMap(transform: (Byte) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> ShortArray.flatMap(transform: (Short) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> IntArray.flatMap(transform: (Int) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> LongArray.flatMap(transform: (Long) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> FloatArray.flatMap(transform: (Float) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> DoubleArray.flatMap(transform: (Double) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> BooleanArray.flatMap(transform: (Boolean) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> CharArray.flatMap(transform: (Char) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapSequence\")\npublic inline fun <T, R> Array<out T>.flatMap(transform: (T) -> Sequence<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Array<out T>.flatMapIndexed(transform: (index: Int, T) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> ByteArray.flatMapIndexed(transform: (index: Int, Byte) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> ShortArray.flatMapIndexed(transform: (index: Int, Short) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> IntArray.flatMapIndexed(transform: (index: Int, Int) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> LongArray.flatMapIndexed(transform: (index: Int, Long) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> FloatArray.flatMapIndexed(transform: (index: Int, Float) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> DoubleArray.flatMapIndexed(transform: (index: Int, Double) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> BooleanArray.flatMapIndexed(transform: (index: Int, Boolean) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharArray.flatMapIndexed(transform: (index: Int, Char) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedSequence\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Array<out T>.flatMapIndexed(transform: (index: Int, T) -> Sequence<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R, C : MutableCollection<in R>> Array<out T>.flatMapIndexedTo(destination: C, transform: (index: Int, T) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> ByteArray.flatMapIndexedTo(destination: C, transform: (index: Int, Byte) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> ShortArray.flatMapIndexedTo(destination: C, transform: (index: Int, Short) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> IntArray.flatMapIndexedTo(destination: C, transform: (index: Int, Int) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> LongArray.flatMapIndexedTo(destination: C, transform: (index: Int, Long) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> FloatArray.flatMapIndexedTo(destination: C, transform: (index: Int, Float) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> DoubleArray.flatMapIndexedTo(destination: C, transform: (index: Int, Double) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> BooleanArray.flatMapIndexedTo(destination: C, transform: (index: Int, Boolean) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> CharArray.flatMapIndexedTo(destination: C, transform: (index: Int, Char) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedSequenceTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R, C : MutableCollection<in R>> Array<out T>.flatMapIndexedTo(destination: C, transform: (index: Int, T) -> Sequence<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Array<out T>.flatMapTo(destination: C, transform: (T) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> ByteArray.flatMapTo(destination: C, transform: (Byte) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> ShortArray.flatMapTo(destination: C, transform: (Short) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> IntArray.flatMapTo(destination: C, transform: (Int) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> LongArray.flatMapTo(destination: C, transform: (Long) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> FloatArray.flatMapTo(destination: C, transform: (Float) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> DoubleArray.flatMapTo(destination: C, transform: (Double) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> BooleanArray.flatMapTo(destination: C, transform: (Boolean) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> CharArray.flatMapTo(destination: C, transform: (Char) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapSequenceTo\")\npublic inline fun <T, R, C : MutableCollection<in R>> Array<out T>.flatMapTo(destination: C, transform: (T) -> Sequence<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K> Array<out T>.groupBy(keySelector: (T) -> K): Map<K, List<T>> {\n    return groupByTo(LinkedHashMap<K, MutableList<T>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> ByteArray.groupBy(keySelector: (Byte) -> K): Map<K, List<Byte>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Byte>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> ShortArray.groupBy(keySelector: (Short) -> K): Map<K, List<Short>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Short>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> IntArray.groupBy(keySelector: (Int) -> K): Map<K, List<Int>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Int>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> LongArray.groupBy(keySelector: (Long) -> K): Map<K, List<Long>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Long>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> FloatArray.groupBy(keySelector: (Float) -> K): Map<K, List<Float>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Float>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> DoubleArray.groupBy(keySelector: (Double) -> K): Map<K, List<Double>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Double>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> BooleanArray.groupBy(keySelector: (Boolean) -> K): Map<K, List<Boolean>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Boolean>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> CharArray.groupBy(keySelector: (Char) -> K): Map<K, List<Char>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Char>>(), keySelector)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V> Array<out T>.groupBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> ByteArray.groupBy(keySelector: (Byte) -> K, valueTransform: (Byte) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> ShortArray.groupBy(keySelector: (Short) -> K, valueTransform: (Short) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> IntArray.groupBy(keySelector: (Int) -> K, valueTransform: (Int) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> LongArray.groupBy(keySelector: (Long) -> K, valueTransform: (Long) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> FloatArray.groupBy(keySelector: (Float) -> K, valueTransform: (Float) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> DoubleArray.groupBy(keySelector: (Double) -> K, valueTransform: (Double) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> BooleanArray.groupBy(keySelector: (Boolean) -> K, valueTransform: (Boolean) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> CharArray.groupBy(keySelector: (Char) -> K, valueTransform: (Char) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K, M : MutableMap<in K, MutableList<T>>> Array<out T>.groupByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<T>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Byte>>> ByteArray.groupByTo(destination: M, keySelector: (Byte) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Byte>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Short>>> ShortArray.groupByTo(destination: M, keySelector: (Short) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Short>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Int>>> IntArray.groupByTo(destination: M, keySelector: (Int) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Int>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Long>>> LongArray.groupByTo(destination: M, keySelector: (Long) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Long>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Float>>> FloatArray.groupByTo(destination: M, keySelector: (Float) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Float>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Double>>> DoubleArray.groupByTo(destination: M, keySelector: (Double) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Double>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Boolean>>> BooleanArray.groupByTo(destination: M, keySelector: (Boolean) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Boolean>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Char>>> CharArray.groupByTo(destination: M, keySelector: (Char) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Char>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V, M : MutableMap<in K, MutableList<V>>> Array<out T>.groupByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> ByteArray.groupByTo(destination: M, keySelector: (Byte) -> K, valueTransform: (Byte) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> ShortArray.groupByTo(destination: M, keySelector: (Short) -> K, valueTransform: (Short) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> IntArray.groupByTo(destination: M, keySelector: (Int) -> K, valueTransform: (Int) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> LongArray.groupByTo(destination: M, keySelector: (Long) -> K, valueTransform: (Long) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> FloatArray.groupByTo(destination: M, keySelector: (Float) -> K, valueTransform: (Float) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> DoubleArray.groupByTo(destination: M, keySelector: (Double) -> K, valueTransform: (Double) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> BooleanArray.groupByTo(destination: M, keySelector: (Boolean) -> K, valueTransform: (Boolean) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> CharArray.groupByTo(destination: M, keySelector: (Char) -> K, valueTransform: (Char) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Creates a [Grouping] source from an array to be used later with one of group-and-fold operations\n * using the specified [keySelector] function to extract a key from each element.\n * \n * @sample samples.collections.Grouping.groupingByEachCount\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, K> Array<out T>.groupingBy(crossinline keySelector: (T) -> K): Grouping<T, K> {\n    return object : Grouping<T, K> {\n        override fun sourceIterator(): Iterator<T> = this@groupingBy.iterator()\n        override fun keyOf(element: T): K = keySelector(element)\n    }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <T, R> Array<out T>.map(transform: (T) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> ByteArray.map(transform: (Byte) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> ShortArray.map(transform: (Short) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> IntArray.map(transform: (Int) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> LongArray.map(transform: (Long) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> FloatArray.map(transform: (Float) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> DoubleArray.map(transform: (Double) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> BooleanArray.map(transform: (Boolean) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> CharArray.map(transform: (Char) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R> Array<out T>.mapIndexed(transform: (index: Int, T) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> ByteArray.mapIndexed(transform: (index: Int, Byte) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> ShortArray.mapIndexed(transform: (index: Int, Short) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> IntArray.mapIndexed(transform: (index: Int, Int) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> LongArray.mapIndexed(transform: (index: Int, Long) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> FloatArray.mapIndexed(transform: (index: Int, Float) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> DoubleArray.mapIndexed(transform: (index: Int, Double) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> BooleanArray.mapIndexed(transform: (index: Int, Boolean) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> CharArray.mapIndexed(transform: (index: Int, Char) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any> Array<out T>.mapIndexedNotNull(transform: (index: Int, T) -> R?): List<R> {\n    return mapIndexedNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends only the non-null results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Array<out T>.mapIndexedNotNullTo(destination: C, transform: (index: Int, T) -> R?): C {\n    forEachIndexed { index, element -> transform(index, element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Array<out T>.mapIndexedTo(destination: C, transform: (index: Int, T) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> ByteArray.mapIndexedTo(destination: C, transform: (index: Int, Byte) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> ShortArray.mapIndexedTo(destination: C, transform: (index: Int, Short) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> IntArray.mapIndexedTo(destination: C, transform: (index: Int, Int) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> LongArray.mapIndexedTo(destination: C, transform: (index: Int, Long) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> FloatArray.mapIndexedTo(destination: C, transform: (index: Int, Float) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> DoubleArray.mapIndexedTo(destination: C, transform: (index: Int, Double) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> BooleanArray.mapIndexedTo(destination: C, transform: (index: Int, Boolean) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> CharArray.mapIndexedTo(destination: C, transform: (index: Int, Char) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.mapNotNull\n */\npublic inline fun <T, R : Any> Array<out T>.mapNotNull(transform: (T) -> R?): List<R> {\n    return mapNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element in the original array\n * and appends only the non-null results to the given [destination].\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Array<out T>.mapNotNullTo(destination: C, transform: (T) -> R?): C {\n    forEach { element -> transform(element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Array<out T>.mapTo(destination: C, transform: (T) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> ByteArray.mapTo(destination: C, transform: (Byte) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> ShortArray.mapTo(destination: C, transform: (Short) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> IntArray.mapTo(destination: C, transform: (Int) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> LongArray.mapTo(destination: C, transform: (Long) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> FloatArray.mapTo(destination: C, transform: (Float) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> DoubleArray.mapTo(destination: C, transform: (Double) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> BooleanArray.mapTo(destination: C, transform: (Boolean) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> CharArray.mapTo(destination: C, transform: (Char) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun <T> Array<out T>.withIndex(): Iterable<IndexedValue<T>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun ByteArray.withIndex(): Iterable<IndexedValue<Byte>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun ShortArray.withIndex(): Iterable<IndexedValue<Short>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun IntArray.withIndex(): Iterable<IndexedValue<Int>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun LongArray.withIndex(): Iterable<IndexedValue<Long>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun FloatArray.withIndex(): Iterable<IndexedValue<Float>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun DoubleArray.withIndex(): Iterable<IndexedValue<Double>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun BooleanArray.withIndex(): Iterable<IndexedValue<Boolean>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun CharArray.withIndex(): Iterable<IndexedValue<Char>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * Among equal elements of the given array, only the first one will be present in the resulting list.\n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun <T> Array<out T>.distinct(): List<T> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun ByteArray.distinct(): List<Byte> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun ShortArray.distinct(): List<Short> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun IntArray.distinct(): List<Int> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun LongArray.distinct(): List<Long> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun FloatArray.distinct(): List<Float> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun DoubleArray.distinct(): List<Double> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun BooleanArray.distinct(): List<Boolean> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun CharArray.distinct(): List<Char> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * Among elements of the given array with equal keys, only the first one will be present in the resulting list.\n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <T, K> Array<out T>.distinctBy(selector: (T) -> K): List<T> {\n    val set = HashSet<K>()\n    val list = ArrayList<T>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <K> ByteArray.distinctBy(selector: (Byte) -> K): List<Byte> {\n    val set = HashSet<K>()\n    val list = ArrayList<Byte>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <K> ShortArray.distinctBy(selector: (Short) -> K): List<Short> {\n    val set = HashSet<K>()\n    val list = ArrayList<Short>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <K> IntArray.distinctBy(selector: (Int) -> K): List<Int> {\n    val set = HashSet<K>()\n    val list = ArrayList<Int>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <K> LongArray.distinctBy(selector: (Long) -> K): List<Long> {\n    val set = HashSet<K>()\n    val list = ArrayList<Long>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <K> FloatArray.distinctBy(selector: (Float) -> K): List<Float> {\n    val set = HashSet<K>()\n    val list = ArrayList<Float>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <K> DoubleArray.distinctBy(selector: (Double) -> K): List<Double> {\n    val set = HashSet<K>()\n    val list = ArrayList<Double>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <K> BooleanArray.distinctBy(selector: (Boolean) -> K): List<Boolean> {\n    val set = HashSet<K>()\n    val list = ArrayList<Boolean>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <K> CharArray.distinctBy(selector: (Char) -> K): List<Char> {\n    val set = HashSet<K>()\n    val list = ArrayList<Char>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun <T> Array<out T>.intersect(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun ByteArray.intersect(other: Iterable<Byte>): Set<Byte> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun ShortArray.intersect(other: Iterable<Short>): Set<Short> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun IntArray.intersect(other: Iterable<Int>): Set<Int> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun LongArray.intersect(other: Iterable<Long>): Set<Long> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun FloatArray.intersect(other: Iterable<Float>): Set<Float> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun DoubleArray.intersect(other: Iterable<Double>): Set<Double> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun BooleanArray.intersect(other: Iterable<Boolean>): Set<Boolean> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun CharArray.intersect(other: Iterable<Char>): Set<Char> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun <T> Array<out T>.subtract(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun ByteArray.subtract(other: Iterable<Byte>): Set<Byte> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun ShortArray.subtract(other: Iterable<Short>): Set<Short> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun IntArray.subtract(other: Iterable<Int>): Set<Int> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun LongArray.subtract(other: Iterable<Long>): Set<Long> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun FloatArray.subtract(other: Iterable<Float>): Set<Float> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun DoubleArray.subtract(other: Iterable<Double>): Set<Double> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun BooleanArray.subtract(other: Iterable<Boolean>): Set<Boolean> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun CharArray.subtract(other: Iterable<Char>): Set<Char> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun <T> Array<out T>.toMutableSet(): MutableSet<T> {\n    return toCollection(LinkedHashSet<T>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun ByteArray.toMutableSet(): MutableSet<Byte> {\n    return toCollection(LinkedHashSet<Byte>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun ShortArray.toMutableSet(): MutableSet<Short> {\n    return toCollection(LinkedHashSet<Short>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun IntArray.toMutableSet(): MutableSet<Int> {\n    return toCollection(LinkedHashSet<Int>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun LongArray.toMutableSet(): MutableSet<Long> {\n    return toCollection(LinkedHashSet<Long>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun FloatArray.toMutableSet(): MutableSet<Float> {\n    return toCollection(LinkedHashSet<Float>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun DoubleArray.toMutableSet(): MutableSet<Double> {\n    return toCollection(LinkedHashSet<Double>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun BooleanArray.toMutableSet(): MutableSet<Boolean> {\n    return toCollection(LinkedHashSet<Boolean>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun CharArray.toMutableSet(): MutableSet<Char> {\n    return toCollection(LinkedHashSet<Char>(mapCapacity(size.coerceAtMost(128))))\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun <T> Array<out T>.union(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun ByteArray.union(other: Iterable<Byte>): Set<Byte> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun ShortArray.union(other: Iterable<Short>): Set<Short> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun IntArray.union(other: Iterable<Int>): Set<Int> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun LongArray.union(other: Iterable<Long>): Set<Long> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun FloatArray.union(other: Iterable<Float>): Set<Float> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun DoubleArray.union(other: Iterable<Double>): Set<Double> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun BooleanArray.union(other: Iterable<Boolean>): Set<Boolean> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun CharArray.union(other: Iterable<Char>): Set<Char> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun <T> Array<out T>.all(predicate: (T) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun ByteArray.all(predicate: (Byte) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun ShortArray.all(predicate: (Short) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun IntArray.all(predicate: (Int) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun LongArray.all(predicate: (Long) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun FloatArray.all(predicate: (Float) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun DoubleArray.all(predicate: (Double) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun BooleanArray.all(predicate: (Boolean) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun CharArray.all(predicate: (Char) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun <T> Array<out T>.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun ByteArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun ShortArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun IntArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun LongArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun FloatArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun DoubleArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun BooleanArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun CharArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun <T> Array<out T>.any(predicate: (T) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun ByteArray.any(predicate: (Byte) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun ShortArray.any(predicate: (Short) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun IntArray.any(predicate: (Int) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun LongArray.any(predicate: (Long) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun FloatArray.any(predicate: (Float) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun DoubleArray.any(predicate: (Double) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun BooleanArray.any(predicate: (Boolean) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun CharArray.any(predicate: (Char) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun <T> Array<out T>.count(predicate: (T) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun ByteArray.count(predicate: (Byte) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun ShortArray.count(predicate: (Short) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun IntArray.count(predicate: (Int) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun LongArray.count(predicate: (Long) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun FloatArray.count(predicate: (Float) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun DoubleArray.count(predicate: (Double) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun BooleanArray.count(predicate: (Boolean) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun CharArray.count(predicate: (Char) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Array<out T>.fold(initial: R, operation: (acc: R, T) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <R> ByteArray.fold(initial: R, operation: (acc: R, Byte) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <R> ShortArray.fold(initial: R, operation: (acc: R, Short) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <R> IntArray.fold(initial: R, operation: (acc: R, Int) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <R> LongArray.fold(initial: R, operation: (acc: R, Long) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <R> FloatArray.fold(initial: R, operation: (acc: R, Float) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <R> DoubleArray.fold(initial: R, operation: (acc: R, Double) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <R> BooleanArray.fold(initial: R, operation: (acc: R, Boolean) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <R> CharArray.fold(initial: R, operation: (acc: R, Char) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Array<out T>.foldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> ByteArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Byte) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> ShortArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Short) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> IntArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Int) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> LongArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Long) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> FloatArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Float) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> DoubleArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Double) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> BooleanArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Boolean) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> CharArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Char) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Array<out T>.foldRight(initial: R, operation: (T, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> ByteArray.foldRight(initial: R, operation: (Byte, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> ShortArray.foldRight(initial: R, operation: (Short, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> IntArray.foldRight(initial: R, operation: (Int, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> LongArray.foldRight(initial: R, operation: (Long, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> FloatArray.foldRight(initial: R, operation: (Float, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> DoubleArray.foldRight(initial: R, operation: (Double, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> BooleanArray.foldRight(initial: R, operation: (Boolean, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> CharArray.foldRight(initial: R, operation: (Char, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Array<out T>.foldRightIndexed(initial: R, operation: (index: Int, T, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> ByteArray.foldRightIndexed(initial: R, operation: (index: Int, Byte, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> ShortArray.foldRightIndexed(initial: R, operation: (index: Int, Short, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> IntArray.foldRightIndexed(initial: R, operation: (index: Int, Int, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> LongArray.foldRightIndexed(initial: R, operation: (index: Int, Long, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> FloatArray.foldRightIndexed(initial: R, operation: (index: Int, Float, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> DoubleArray.foldRightIndexed(initial: R, operation: (index: Int, Double, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> BooleanArray.foldRightIndexed(initial: R, operation: (index: Int, Boolean, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> CharArray.foldRightIndexed(initial: R, operation: (index: Int, Char, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun <T> Array<out T>.forEach(action: (T) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun ByteArray.forEach(action: (Byte) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun ShortArray.forEach(action: (Short) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun IntArray.forEach(action: (Int) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun LongArray.forEach(action: (Long) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun FloatArray.forEach(action: (Float) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun DoubleArray.forEach(action: (Double) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun BooleanArray.forEach(action: (Boolean) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun CharArray.forEach(action: (Char) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun <T> Array<out T>.forEachIndexed(action: (index: Int, T) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun ByteArray.forEachIndexed(action: (index: Int, Byte) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun ShortArray.forEachIndexed(action: (index: Int, Short) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun IntArray.forEachIndexed(action: (index: Int, Int) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun LongArray.forEachIndexed(action: (index: Int, Long) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun FloatArray.forEachIndexed(action: (index: Int, Float) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun DoubleArray.forEachIndexed(action: (index: Int, Double) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun BooleanArray.forEachIndexed(action: (index: Int, Boolean) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun CharArray.forEachIndexed(action: (index: Int, Char) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\n@SinceKotlin(\"1.1\")\npublic fun Array<out Double>.max(): Double? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\n@SinceKotlin(\"1.1\")\npublic fun Array<out Float>.max(): Float? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun <T : Comparable<T>> Array<out T>.max(): T? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun ByteArray.max(): Byte? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun ShortArray.max(): Short? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun IntArray.max(): Int? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun LongArray.max(): Long? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun FloatArray.max(): Float? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun DoubleArray.max(): Double? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun CharArray.max(): Char? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <T, R : Comparable<R>> Array<out T>.maxBy(selector: (T) -> R): T? {\n    return maxByOrNull(selector)\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <R : Comparable<R>> ByteArray.maxBy(selector: (Byte) -> R): Byte? {\n    return maxByOrNull(selector)\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <R : Comparable<R>> ShortArray.maxBy(selector: (Short) -> R): Short? {\n    return maxByOrNull(selector)\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <R : Comparable<R>> IntArray.maxBy(selector: (Int) -> R): Int? {\n    return maxByOrNull(selector)\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <R : Comparable<R>> LongArray.maxBy(selector: (Long) -> R): Long? {\n    return maxByOrNull(selector)\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <R : Comparable<R>> FloatArray.maxBy(selector: (Float) -> R): Float? {\n    return maxByOrNull(selector)\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <R : Comparable<R>> DoubleArray.maxBy(selector: (Double) -> R): Double? {\n    return maxByOrNull(selector)\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <R : Comparable<R>> BooleanArray.maxBy(selector: (Boolean) -> R): Boolean? {\n    return maxByOrNull(selector)\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <R : Comparable<R>> CharArray.maxBy(selector: (Char) -> R): Char? {\n    return maxByOrNull(selector)\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R : Comparable<R>> Array<out T>.maxByOrNull(selector: (T) -> R): T? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> ByteArray.maxByOrNull(selector: (Byte) -> R): Byte? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> ShortArray.maxByOrNull(selector: (Short) -> R): Short? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> IntArray.maxByOrNull(selector: (Int) -> R): Int? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> LongArray.maxByOrNull(selector: (Long) -> R): Long? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> FloatArray.maxByOrNull(selector: (Float) -> R): Float? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> DoubleArray.maxByOrNull(selector: (Double) -> R): Double? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> BooleanArray.maxByOrNull(selector: (Boolean) -> R): Boolean? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> CharArray.maxByOrNull(selector: (Char) -> R): Char? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.maxOf(selector: (T) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.maxOf(selector: (Byte) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.maxOf(selector: (Short) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.maxOf(selector: (Int) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.maxOf(selector: (Long) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.maxOf(selector: (Float) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.maxOf(selector: (Double) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.maxOf(selector: (Boolean) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.maxOf(selector: (Char) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.maxOf(selector: (T) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.maxOf(selector: (Byte) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.maxOf(selector: (Short) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.maxOf(selector: (Int) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.maxOf(selector: (Long) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.maxOf(selector: (Float) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.maxOf(selector: (Double) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.maxOf(selector: (Boolean) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.maxOf(selector: (Char) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Array<out T>.maxOf(selector: (T) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ByteArray.maxOf(selector: (Byte) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ShortArray.maxOf(selector: (Short) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> IntArray.maxOf(selector: (Int) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> LongArray.maxOf(selector: (Long) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> FloatArray.maxOf(selector: (Float) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> DoubleArray.maxOf(selector: (Double) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> BooleanArray.maxOf(selector: (Boolean) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> CharArray.maxOf(selector: (Char) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.maxOfOrNull(selector: (T) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.maxOfOrNull(selector: (Byte) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.maxOfOrNull(selector: (Short) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.maxOfOrNull(selector: (Int) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.maxOfOrNull(selector: (Long) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.maxOfOrNull(selector: (Float) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.maxOfOrNull(selector: (Double) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.maxOfOrNull(selector: (Boolean) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.maxOfOrNull(selector: (Char) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.maxOfOrNull(selector: (T) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.maxOfOrNull(selector: (Byte) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.maxOfOrNull(selector: (Short) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.maxOfOrNull(selector: (Int) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.maxOfOrNull(selector: (Long) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.maxOfOrNull(selector: (Float) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.maxOfOrNull(selector: (Double) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.maxOfOrNull(selector: (Boolean) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.maxOfOrNull(selector: (Char) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Array<out T>.maxOfOrNull(selector: (T) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ByteArray.maxOfOrNull(selector: (Byte) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ShortArray.maxOfOrNull(selector: (Short) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> IntArray.maxOfOrNull(selector: (Int) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> LongArray.maxOfOrNull(selector: (Long) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> FloatArray.maxOfOrNull(selector: (Float) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> DoubleArray.maxOfOrNull(selector: (Double) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> BooleanArray.maxOfOrNull(selector: (Boolean) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> CharArray.maxOfOrNull(selector: (Char) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Array<out T>.maxOfWith(comparator: Comparator<in R>, selector: (T) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> ByteArray.maxOfWith(comparator: Comparator<in R>, selector: (Byte) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> ShortArray.maxOfWith(comparator: Comparator<in R>, selector: (Short) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> IntArray.maxOfWith(comparator: Comparator<in R>, selector: (Int) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> LongArray.maxOfWith(comparator: Comparator<in R>, selector: (Long) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> FloatArray.maxOfWith(comparator: Comparator<in R>, selector: (Float) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> DoubleArray.maxOfWith(comparator: Comparator<in R>, selector: (Double) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> BooleanArray.maxOfWith(comparator: Comparator<in R>, selector: (Boolean) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharArray.maxOfWith(comparator: Comparator<in R>, selector: (Char) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Array<out T>.maxOfWithOrNull(comparator: Comparator<in R>, selector: (T) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> ByteArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Byte) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> ShortArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Short) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> IntArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Int) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> LongArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Long) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> FloatArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Float) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> DoubleArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Double) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> BooleanArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Boolean) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Char) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Array<out Double>.maxOrNull(): Double? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Array<out Float>.maxOrNull(): Float? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Comparable<T>> Array<out T>.maxOrNull(): T? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun ByteArray.maxOrNull(): Byte? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun ShortArray.maxOrNull(): Short? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun IntArray.maxOrNull(): Int? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun LongArray.maxOrNull(): Long? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun FloatArray.maxOrNull(): Float? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun DoubleArray.maxOrNull(): Double? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun CharArray.maxOrNull(): Char? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun <T> Array<out T>.maxWith(comparator: Comparator<in T>): T? {\n    return maxWithOrNull(comparator)\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun ByteArray.maxWith(comparator: Comparator<in Byte>): Byte? {\n    return maxWithOrNull(comparator)\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun ShortArray.maxWith(comparator: Comparator<in Short>): Short? {\n    return maxWithOrNull(comparator)\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun IntArray.maxWith(comparator: Comparator<in Int>): Int? {\n    return maxWithOrNull(comparator)\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun LongArray.maxWith(comparator: Comparator<in Long>): Long? {\n    return maxWithOrNull(comparator)\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun FloatArray.maxWith(comparator: Comparator<in Float>): Float? {\n    return maxWithOrNull(comparator)\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun DoubleArray.maxWith(comparator: Comparator<in Double>): Double? {\n    return maxWithOrNull(comparator)\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun BooleanArray.maxWith(comparator: Comparator<in Boolean>): Boolean? {\n    return maxWithOrNull(comparator)\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun CharArray.maxWith(comparator: Comparator<in Char>): Char? {\n    return maxWithOrNull(comparator)\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Array<out T>.maxWithOrNull(comparator: Comparator<in T>): T? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun ByteArray.maxWithOrNull(comparator: Comparator<in Byte>): Byte? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun ShortArray.maxWithOrNull(comparator: Comparator<in Short>): Short? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun IntArray.maxWithOrNull(comparator: Comparator<in Int>): Int? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun LongArray.maxWithOrNull(comparator: Comparator<in Long>): Long? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun FloatArray.maxWithOrNull(comparator: Comparator<in Float>): Float? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun DoubleArray.maxWithOrNull(comparator: Comparator<in Double>): Double? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun BooleanArray.maxWithOrNull(comparator: Comparator<in Boolean>): Boolean? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun CharArray.maxWithOrNull(comparator: Comparator<in Char>): Char? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\n@SinceKotlin(\"1.1\")\npublic fun Array<out Double>.min(): Double? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\n@SinceKotlin(\"1.1\")\npublic fun Array<out Float>.min(): Float? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun <T : Comparable<T>> Array<out T>.min(): T? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun ByteArray.min(): Byte? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun ShortArray.min(): Short? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun IntArray.min(): Int? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun LongArray.min(): Long? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun FloatArray.min(): Float? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun DoubleArray.min(): Double? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun CharArray.min(): Char? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <T, R : Comparable<R>> Array<out T>.minBy(selector: (T) -> R): T? {\n    return minByOrNull(selector)\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <R : Comparable<R>> ByteArray.minBy(selector: (Byte) -> R): Byte? {\n    return minByOrNull(selector)\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <R : Comparable<R>> ShortArray.minBy(selector: (Short) -> R): Short? {\n    return minByOrNull(selector)\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <R : Comparable<R>> IntArray.minBy(selector: (Int) -> R): Int? {\n    return minByOrNull(selector)\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <R : Comparable<R>> LongArray.minBy(selector: (Long) -> R): Long? {\n    return minByOrNull(selector)\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <R : Comparable<R>> FloatArray.minBy(selector: (Float) -> R): Float? {\n    return minByOrNull(selector)\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <R : Comparable<R>> DoubleArray.minBy(selector: (Double) -> R): Double? {\n    return minByOrNull(selector)\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <R : Comparable<R>> BooleanArray.minBy(selector: (Boolean) -> R): Boolean? {\n    return minByOrNull(selector)\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <R : Comparable<R>> CharArray.minBy(selector: (Char) -> R): Char? {\n    return minByOrNull(selector)\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R : Comparable<R>> Array<out T>.minByOrNull(selector: (T) -> R): T? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> ByteArray.minByOrNull(selector: (Byte) -> R): Byte? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> ShortArray.minByOrNull(selector: (Short) -> R): Short? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> IntArray.minByOrNull(selector: (Int) -> R): Int? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> LongArray.minByOrNull(selector: (Long) -> R): Long? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> FloatArray.minByOrNull(selector: (Float) -> R): Float? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> DoubleArray.minByOrNull(selector: (Double) -> R): Double? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> BooleanArray.minByOrNull(selector: (Boolean) -> R): Boolean? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> CharArray.minByOrNull(selector: (Char) -> R): Char? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.minOf(selector: (T) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.minOf(selector: (Byte) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.minOf(selector: (Short) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.minOf(selector: (Int) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.minOf(selector: (Long) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.minOf(selector: (Float) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.minOf(selector: (Double) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.minOf(selector: (Boolean) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.minOf(selector: (Char) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.minOf(selector: (T) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.minOf(selector: (Byte) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.minOf(selector: (Short) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.minOf(selector: (Int) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.minOf(selector: (Long) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.minOf(selector: (Float) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.minOf(selector: (Double) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.minOf(selector: (Boolean) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.minOf(selector: (Char) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Array<out T>.minOf(selector: (T) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ByteArray.minOf(selector: (Byte) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ShortArray.minOf(selector: (Short) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> IntArray.minOf(selector: (Int) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> LongArray.minOf(selector: (Long) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> FloatArray.minOf(selector: (Float) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> DoubleArray.minOf(selector: (Double) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> BooleanArray.minOf(selector: (Boolean) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> CharArray.minOf(selector: (Char) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.minOfOrNull(selector: (T) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.minOfOrNull(selector: (Byte) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.minOfOrNull(selector: (Short) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.minOfOrNull(selector: (Int) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.minOfOrNull(selector: (Long) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.minOfOrNull(selector: (Float) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.minOfOrNull(selector: (Double) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.minOfOrNull(selector: (Boolean) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.minOfOrNull(selector: (Char) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.minOfOrNull(selector: (T) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.minOfOrNull(selector: (Byte) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.minOfOrNull(selector: (Short) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.minOfOrNull(selector: (Int) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.minOfOrNull(selector: (Long) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.minOfOrNull(selector: (Float) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.minOfOrNull(selector: (Double) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.minOfOrNull(selector: (Boolean) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.minOfOrNull(selector: (Char) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Array<out T>.minOfOrNull(selector: (T) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ByteArray.minOfOrNull(selector: (Byte) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ShortArray.minOfOrNull(selector: (Short) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> IntArray.minOfOrNull(selector: (Int) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> LongArray.minOfOrNull(selector: (Long) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> FloatArray.minOfOrNull(selector: (Float) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> DoubleArray.minOfOrNull(selector: (Double) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> BooleanArray.minOfOrNull(selector: (Boolean) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> CharArray.minOfOrNull(selector: (Char) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Array<out T>.minOfWith(comparator: Comparator<in R>, selector: (T) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> ByteArray.minOfWith(comparator: Comparator<in R>, selector: (Byte) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> ShortArray.minOfWith(comparator: Comparator<in R>, selector: (Short) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> IntArray.minOfWith(comparator: Comparator<in R>, selector: (Int) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> LongArray.minOfWith(comparator: Comparator<in R>, selector: (Long) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> FloatArray.minOfWith(comparator: Comparator<in R>, selector: (Float) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> DoubleArray.minOfWith(comparator: Comparator<in R>, selector: (Double) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> BooleanArray.minOfWith(comparator: Comparator<in R>, selector: (Boolean) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharArray.minOfWith(comparator: Comparator<in R>, selector: (Char) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Array<out T>.minOfWithOrNull(comparator: Comparator<in R>, selector: (T) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> ByteArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (Byte) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> ShortArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (Short) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> IntArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (Int) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> LongArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (Long) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> FloatArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (Float) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> DoubleArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (Double) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> BooleanArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (Boolean) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (Char) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Array<out Double>.minOrNull(): Double? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Array<out Float>.minOrNull(): Float? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Comparable<T>> Array<out T>.minOrNull(): T? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun ByteArray.minOrNull(): Byte? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun ShortArray.minOrNull(): Short? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun IntArray.minOrNull(): Int? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun LongArray.minOrNull(): Long? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun FloatArray.minOrNull(): Float? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun DoubleArray.minOrNull(): Double? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun CharArray.minOrNull(): Char? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun <T> Array<out T>.minWith(comparator: Comparator<in T>): T? {\n    return minWithOrNull(comparator)\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun ByteArray.minWith(comparator: Comparator<in Byte>): Byte? {\n    return minWithOrNull(comparator)\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun ShortArray.minWith(comparator: Comparator<in Short>): Short? {\n    return minWithOrNull(comparator)\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun IntArray.minWith(comparator: Comparator<in Int>): Int? {\n    return minWithOrNull(comparator)\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun LongArray.minWith(comparator: Comparator<in Long>): Long? {\n    return minWithOrNull(comparator)\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun FloatArray.minWith(comparator: Comparator<in Float>): Float? {\n    return minWithOrNull(comparator)\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun DoubleArray.minWith(comparator: Comparator<in Double>): Double? {\n    return minWithOrNull(comparator)\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun BooleanArray.minWith(comparator: Comparator<in Boolean>): Boolean? {\n    return minWithOrNull(comparator)\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun CharArray.minWith(comparator: Comparator<in Char>): Char? {\n    return minWithOrNull(comparator)\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Array<out T>.minWithOrNull(comparator: Comparator<in T>): T? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun ByteArray.minWithOrNull(comparator: Comparator<in Byte>): Byte? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun ShortArray.minWithOrNull(comparator: Comparator<in Short>): Short? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun IntArray.minWithOrNull(comparator: Comparator<in Int>): Int? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun LongArray.minWithOrNull(comparator: Comparator<in Long>): Long? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun FloatArray.minWithOrNull(comparator: Comparator<in Float>): Float? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun DoubleArray.minWithOrNull(comparator: Comparator<in Double>): Double? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun BooleanArray.minWithOrNull(comparator: Comparator<in Boolean>): Boolean? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun CharArray.minWithOrNull(comparator: Comparator<in Char>): Char? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun <T> Array<out T>.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun ByteArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun ShortArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun IntArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun LongArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun FloatArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun DoubleArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun BooleanArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun CharArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun <T> Array<out T>.none(predicate: (T) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun ByteArray.none(predicate: (Byte) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun ShortArray.none(predicate: (Short) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun IntArray.none(predicate: (Int) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun LongArray.none(predicate: (Long) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun FloatArray.none(predicate: (Float) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun DoubleArray.none(predicate: (Double) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun BooleanArray.none(predicate: (Boolean) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun CharArray.none(predicate: (Char) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.onEach(action: (T) -> Unit): Array<out T> {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.onEach(action: (Byte) -> Unit): ByteArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.onEach(action: (Short) -> Unit): ShortArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.onEach(action: (Int) -> Unit): IntArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.onEach(action: (Long) -> Unit): LongArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.onEach(action: (Float) -> Unit): FloatArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.onEach(action: (Double) -> Unit): DoubleArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.onEach(action: (Boolean) -> Unit): BooleanArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.onEach(action: (Char) -> Unit): CharArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.onEachIndexed(action: (index: Int, T) -> Unit): Array<out T> {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.onEachIndexed(action: (index: Int, Byte) -> Unit): ByteArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.onEachIndexed(action: (index: Int, Short) -> Unit): ShortArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.onEachIndexed(action: (index: Int, Int) -> Unit): IntArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.onEachIndexed(action: (index: Int, Long) -> Unit): LongArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.onEachIndexed(action: (index: Int, Float) -> Unit): FloatArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.onEachIndexed(action: (index: Int, Double) -> Unit): DoubleArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.onEachIndexed(action: (index: Int, Boolean) -> Unit): BooleanArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.onEachIndexed(action: (index: Int, Char) -> Unit): CharArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun <S, T : S> Array<out T>.reduce(operation: (acc: S, T) -> S): S {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator: S = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun ByteArray.reduce(operation: (acc: Byte, Byte) -> Byte): Byte {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun ShortArray.reduce(operation: (acc: Short, Short) -> Short): Short {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun IntArray.reduce(operation: (acc: Int, Int) -> Int): Int {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun LongArray.reduce(operation: (acc: Long, Long) -> Long): Long {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun FloatArray.reduce(operation: (acc: Float, Float) -> Float): Float {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun DoubleArray.reduce(operation: (acc: Double, Double) -> Double): Double {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun BooleanArray.reduce(operation: (acc: Boolean, Boolean) -> Boolean): Boolean {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun CharArray.reduce(operation: (acc: Char, Char) -> Char): Char {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun <S, T : S> Array<out T>.reduceIndexed(operation: (index: Int, acc: S, T) -> S): S {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator: S = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun ByteArray.reduceIndexed(operation: (index: Int, acc: Byte, Byte) -> Byte): Byte {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun ShortArray.reduceIndexed(operation: (index: Int, acc: Short, Short) -> Short): Short {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun IntArray.reduceIndexed(operation: (index: Int, acc: Int, Int) -> Int): Int {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun LongArray.reduceIndexed(operation: (index: Int, acc: Long, Long) -> Long): Long {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun FloatArray.reduceIndexed(operation: (index: Int, acc: Float, Float) -> Float): Float {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun DoubleArray.reduceIndexed(operation: (index: Int, acc: Double, Double) -> Double): Double {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun BooleanArray.reduceIndexed(operation: (index: Int, acc: Boolean, Boolean) -> Boolean): Boolean {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun CharArray.reduceIndexed(operation: (index: Int, acc: Char, Char) -> Char): Char {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <S, T : S> Array<out T>.reduceIndexedOrNull(operation: (index: Int, acc: S, T) -> S): S? {\n    if (isEmpty())\n        return null\n    var accumulator: S = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun ByteArray.reduceIndexedOrNull(operation: (index: Int, acc: Byte, Byte) -> Byte): Byte? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun ShortArray.reduceIndexedOrNull(operation: (index: Int, acc: Short, Short) -> Short): Short? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun IntArray.reduceIndexedOrNull(operation: (index: Int, acc: Int, Int) -> Int): Int? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun LongArray.reduceIndexedOrNull(operation: (index: Int, acc: Long, Long) -> Long): Long? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun FloatArray.reduceIndexedOrNull(operation: (index: Int, acc: Float, Float) -> Float): Float? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun DoubleArray.reduceIndexedOrNull(operation: (index: Int, acc: Double, Double) -> Double): Double? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun BooleanArray.reduceIndexedOrNull(operation: (index: Int, acc: Boolean, Boolean) -> Boolean): Boolean? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun CharArray.reduceIndexedOrNull(operation: (index: Int, acc: Char, Char) -> Char): Char? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <S, T : S> Array<out T>.reduceOrNull(operation: (acc: S, T) -> S): S? {\n    if (isEmpty())\n        return null\n    var accumulator: S = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun ByteArray.reduceOrNull(operation: (acc: Byte, Byte) -> Byte): Byte? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun ShortArray.reduceOrNull(operation: (acc: Short, Short) -> Short): Short? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun IntArray.reduceOrNull(operation: (acc: Int, Int) -> Int): Int? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun LongArray.reduceOrNull(operation: (acc: Long, Long) -> Long): Long? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun FloatArray.reduceOrNull(operation: (acc: Float, Float) -> Float): Float? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun DoubleArray.reduceOrNull(operation: (acc: Double, Double) -> Double): Double? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun BooleanArray.reduceOrNull(operation: (acc: Boolean, Boolean) -> Boolean): Boolean? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun CharArray.reduceOrNull(operation: (acc: Char, Char) -> Char): Char? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun <S, T : S> Array<out T>.reduceRight(operation: (T, acc: S) -> S): S {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator: S = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun ByteArray.reduceRight(operation: (Byte, acc: Byte) -> Byte): Byte {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun ShortArray.reduceRight(operation: (Short, acc: Short) -> Short): Short {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun IntArray.reduceRight(operation: (Int, acc: Int) -> Int): Int {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun LongArray.reduceRight(operation: (Long, acc: Long) -> Long): Long {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun FloatArray.reduceRight(operation: (Float, acc: Float) -> Float): Float {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun DoubleArray.reduceRight(operation: (Double, acc: Double) -> Double): Double {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun BooleanArray.reduceRight(operation: (Boolean, acc: Boolean) -> Boolean): Boolean {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun CharArray.reduceRight(operation: (Char, acc: Char) -> Char): Char {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun <S, T : S> Array<out T>.reduceRightIndexed(operation: (index: Int, T, acc: S) -> S): S {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator: S = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun ByteArray.reduceRightIndexed(operation: (index: Int, Byte, acc: Byte) -> Byte): Byte {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun ShortArray.reduceRightIndexed(operation: (index: Int, Short, acc: Short) -> Short): Short {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun IntArray.reduceRightIndexed(operation: (index: Int, Int, acc: Int) -> Int): Int {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun LongArray.reduceRightIndexed(operation: (index: Int, Long, acc: Long) -> Long): Long {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun FloatArray.reduceRightIndexed(operation: (index: Int, Float, acc: Float) -> Float): Float {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun DoubleArray.reduceRightIndexed(operation: (index: Int, Double, acc: Double) -> Double): Double {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun BooleanArray.reduceRightIndexed(operation: (index: Int, Boolean, acc: Boolean) -> Boolean): Boolean {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun CharArray.reduceRightIndexed(operation: (index: Int, Char, acc: Char) -> Char): Char {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <S, T : S> Array<out T>.reduceRightIndexedOrNull(operation: (index: Int, T, acc: S) -> S): S? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator: S = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun ByteArray.reduceRightIndexedOrNull(operation: (index: Int, Byte, acc: Byte) -> Byte): Byte? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun ShortArray.reduceRightIndexedOrNull(operation: (index: Int, Short, acc: Short) -> Short): Short? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun IntArray.reduceRightIndexedOrNull(operation: (index: Int, Int, acc: Int) -> Int): Int? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun LongArray.reduceRightIndexedOrNull(operation: (index: Int, Long, acc: Long) -> Long): Long? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun FloatArray.reduceRightIndexedOrNull(operation: (index: Int, Float, acc: Float) -> Float): Float? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun DoubleArray.reduceRightIndexedOrNull(operation: (index: Int, Double, acc: Double) -> Double): Double? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun BooleanArray.reduceRightIndexedOrNull(operation: (index: Int, Boolean, acc: Boolean) -> Boolean): Boolean? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun CharArray.reduceRightIndexedOrNull(operation: (index: Int, Char, acc: Char) -> Char): Char? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <S, T : S> Array<out T>.reduceRightOrNull(operation: (T, acc: S) -> S): S? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator: S = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun ByteArray.reduceRightOrNull(operation: (Byte, acc: Byte) -> Byte): Byte? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun ShortArray.reduceRightOrNull(operation: (Short, acc: Short) -> Short): Short? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun IntArray.reduceRightOrNull(operation: (Int, acc: Int) -> Int): Int? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun LongArray.reduceRightOrNull(operation: (Long, acc: Long) -> Long): Long? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun FloatArray.reduceRightOrNull(operation: (Float, acc: Float) -> Float): Float? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun DoubleArray.reduceRightOrNull(operation: (Double, acc: Double) -> Double): Double? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun BooleanArray.reduceRightOrNull(operation: (Boolean, acc: Boolean) -> Boolean): Boolean? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun CharArray.reduceRightOrNull(operation: (Char, acc: Char) -> Char): Char? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R> Array<out T>.runningFold(initial: R, operation: (acc: R, T) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> ByteArray.runningFold(initial: R, operation: (acc: R, Byte) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> ShortArray.runningFold(initial: R, operation: (acc: R, Short) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> IntArray.runningFold(initial: R, operation: (acc: R, Int) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> LongArray.runningFold(initial: R, operation: (acc: R, Long) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> FloatArray.runningFold(initial: R, operation: (acc: R, Float) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> DoubleArray.runningFold(initial: R, operation: (acc: R, Double) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> BooleanArray.runningFold(initial: R, operation: (acc: R, Boolean) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharArray.runningFold(initial: R, operation: (acc: R, Char) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R> Array<out T>.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> ByteArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, Byte) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> ShortArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, Short) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> IntArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, Int) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> LongArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, Long) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> FloatArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, Float) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> DoubleArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, Double) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> BooleanArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, Boolean) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, Char) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and the element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <S, T : S> Array<out T>.runningReduce(operation: (acc: S, T) -> S): List<S> {\n    if (isEmpty()) return emptyList()\n    var accumulator: S = this[0]\n    val result = ArrayList<S>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.runningReduce(operation: (acc: Byte, Byte) -> Byte): List<Byte> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Byte>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.runningReduce(operation: (acc: Short, Short) -> Short): List<Short> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Short>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.runningReduce(operation: (acc: Int, Int) -> Int): List<Int> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Int>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.runningReduce(operation: (acc: Long, Long) -> Long): List<Long> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Long>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.runningReduce(operation: (acc: Float, Float) -> Float): List<Float> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Float>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.runningReduce(operation: (acc: Double, Double) -> Double): List<Double> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Double>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.runningReduce(operation: (acc: Boolean, Boolean) -> Boolean): List<Boolean> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Boolean>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.runningReduce(operation: (acc: Char, Char) -> Char): List<Char> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Char>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <S, T : S> Array<out T>.runningReduceIndexed(operation: (index: Int, acc: S, T) -> S): List<S> {\n    if (isEmpty()) return emptyList()\n    var accumulator: S = this[0]\n    val result = ArrayList<S>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.runningReduceIndexed(operation: (index: Int, acc: Byte, Byte) -> Byte): List<Byte> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Byte>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.runningReduceIndexed(operation: (index: Int, acc: Short, Short) -> Short): List<Short> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Short>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.runningReduceIndexed(operation: (index: Int, acc: Int, Int) -> Int): List<Int> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Int>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.runningReduceIndexed(operation: (index: Int, acc: Long, Long) -> Long): List<Long> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Long>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.runningReduceIndexed(operation: (index: Int, acc: Float, Float) -> Float): List<Float> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Float>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.runningReduceIndexed(operation: (index: Int, acc: Double, Double) -> Double): List<Double> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Double>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.runningReduceIndexed(operation: (index: Int, acc: Boolean, Boolean) -> Boolean): List<Boolean> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Boolean>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.runningReduceIndexed(operation: (index: Int, acc: Char, Char) -> Char): List<Char> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Char>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <T, R> Array<out T>.scan(initial: R, operation: (acc: R, T) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> ByteArray.scan(initial: R, operation: (acc: R, Byte) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> ShortArray.scan(initial: R, operation: (acc: R, Short) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> IntArray.scan(initial: R, operation: (acc: R, Int) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> LongArray.scan(initial: R, operation: (acc: R, Long) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> FloatArray.scan(initial: R, operation: (acc: R, Float) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> DoubleArray.scan(initial: R, operation: (acc: R, Double) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> BooleanArray.scan(initial: R, operation: (acc: R, Boolean) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharArray.scan(initial: R, operation: (acc: R, Char) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <T, R> Array<out T>.scanIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> ByteArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Byte) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> ShortArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Short) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> IntArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Int) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> LongArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Long) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> FloatArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Float) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> DoubleArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Double) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> BooleanArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Boolean) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Char) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun <T> Array<out T>.sumBy(selector: (T) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun ByteArray.sumBy(selector: (Byte) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun ShortArray.sumBy(selector: (Short) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun IntArray.sumBy(selector: (Int) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun LongArray.sumBy(selector: (Long) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun FloatArray.sumBy(selector: (Float) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun DoubleArray.sumBy(selector: (Double) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun BooleanArray.sumBy(selector: (Boolean) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun CharArray.sumBy(selector: (Char) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun <T> Array<out T>.sumByDouble(selector: (T) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun ByteArray.sumByDouble(selector: (Byte) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun ShortArray.sumByDouble(selector: (Short) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun IntArray.sumByDouble(selector: (Int) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun LongArray.sumByDouble(selector: (Long) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun FloatArray.sumByDouble(selector: (Float) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun DoubleArray.sumByDouble(selector: (Double) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun BooleanArray.sumByDouble(selector: (Boolean) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun CharArray.sumByDouble(selector: (Char) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.sumOf(selector: (T) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.sumOf(selector: (Byte) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.sumOf(selector: (Short) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.sumOf(selector: (Int) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.sumOf(selector: (Long) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.sumOf(selector: (Float) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.sumOf(selector: (Double) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.sumOf(selector: (Boolean) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.sumOf(selector: (Char) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.sumOf(selector: (T) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.sumOf(selector: (Byte) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.sumOf(selector: (Short) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.sumOf(selector: (Int) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.sumOf(selector: (Long) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.sumOf(selector: (Float) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.sumOf(selector: (Double) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.sumOf(selector: (Boolean) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.sumOf(selector: (Char) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.sumOf(selector: (T) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.sumOf(selector: (Byte) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.sumOf(selector: (Short) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.sumOf(selector: (Int) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.sumOf(selector: (Long) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.sumOf(selector: (Float) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.sumOf(selector: (Double) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.sumOf(selector: (Boolean) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.sumOf(selector: (Char) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.sumOf(selector: (T) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.sumOf(selector: (Byte) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.sumOf(selector: (Short) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.sumOf(selector: (Int) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.sumOf(selector: (Long) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.sumOf(selector: (Float) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.sumOf(selector: (Double) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.sumOf(selector: (Boolean) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.sumOf(selector: (Char) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.sumOf(selector: (T) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.sumOf(selector: (Byte) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.sumOf(selector: (Short) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.sumOf(selector: (Int) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.sumOf(selector: (Long) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.sumOf(selector: (Float) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.sumOf(selector: (Double) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.sumOf(selector: (Boolean) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.sumOf(selector: (Char) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n */\npublic fun <T : Any> Array<T?>.requireNoNulls(): Array<T> {\n    for (element in this) {\n        if (element == null) {\n            throw IllegalArgumentException(\"null element found in $this.\")\n        }\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return this as Array<T>\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun <T> Array<out T>.partition(predicate: (T) -> Boolean): Pair<List<T>, List<T>> {\n    val first = ArrayList<T>()\n    val second = ArrayList<T>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun ByteArray.partition(predicate: (Byte) -> Boolean): Pair<List<Byte>, List<Byte>> {\n    val first = ArrayList<Byte>()\n    val second = ArrayList<Byte>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun ShortArray.partition(predicate: (Short) -> Boolean): Pair<List<Short>, List<Short>> {\n    val first = ArrayList<Short>()\n    val second = ArrayList<Short>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun IntArray.partition(predicate: (Int) -> Boolean): Pair<List<Int>, List<Int>> {\n    val first = ArrayList<Int>()\n    val second = ArrayList<Int>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun LongArray.partition(predicate: (Long) -> Boolean): Pair<List<Long>, List<Long>> {\n    val first = ArrayList<Long>()\n    val second = ArrayList<Long>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun FloatArray.partition(predicate: (Float) -> Boolean): Pair<List<Float>, List<Float>> {\n    val first = ArrayList<Float>()\n    val second = ArrayList<Float>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun DoubleArray.partition(predicate: (Double) -> Boolean): Pair<List<Double>, List<Double>> {\n    val first = ArrayList<Double>()\n    val second = ArrayList<Double>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun BooleanArray.partition(predicate: (Boolean) -> Boolean): Pair<List<Boolean>, List<Boolean>> {\n    val first = ArrayList<Boolean>()\n    val second = ArrayList<Boolean>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun CharArray.partition(predicate: (Char) -> Boolean): Pair<List<Char>, List<Char>> {\n    val first = ArrayList<Char>()\n    val second = ArrayList<Char>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Array<out T>.zip(other: Array<out R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> ByteArray.zip(other: Array<out R>): List<Pair<Byte, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> ShortArray.zip(other: Array<out R>): List<Pair<Short, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> IntArray.zip(other: Array<out R>): List<Pair<Int, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> LongArray.zip(other: Array<out R>): List<Pair<Long, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> FloatArray.zip(other: Array<out R>): List<Pair<Float, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> DoubleArray.zip(other: Array<out R>): List<Pair<Double, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> BooleanArray.zip(other: Array<out R>): List<Pair<Boolean, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> CharArray.zip(other: Array<out R>): List<Pair<Char, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Array<out T>.zip(other: Array<out R>, transform: (a: T, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> ByteArray.zip(other: Array<out R>, transform: (a: Byte, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> ShortArray.zip(other: Array<out R>, transform: (a: Short, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> IntArray.zip(other: Array<out R>, transform: (a: Int, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> LongArray.zip(other: Array<out R>, transform: (a: Long, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> FloatArray.zip(other: Array<out R>, transform: (a: Float, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> DoubleArray.zip(other: Array<out R>, transform: (a: Double, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> BooleanArray.zip(other: Array<out R>, transform: (a: Boolean, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> CharArray.zip(other: Array<out R>, transform: (a: Char, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Array<out T>.zip(other: Iterable<R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> ByteArray.zip(other: Iterable<R>): List<Pair<Byte, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> ShortArray.zip(other: Iterable<R>): List<Pair<Short, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> IntArray.zip(other: Iterable<R>): List<Pair<Int, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> LongArray.zip(other: Iterable<R>): List<Pair<Long, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> FloatArray.zip(other: Iterable<R>): List<Pair<Float, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> DoubleArray.zip(other: Iterable<R>): List<Pair<Double, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> BooleanArray.zip(other: Iterable<R>): List<Pair<Boolean, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> CharArray.zip(other: Iterable<R>): List<Pair<Char, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Array<out T>.zip(other: Iterable<R>, transform: (a: T, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> ByteArray.zip(other: Iterable<R>, transform: (a: Byte, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> ShortArray.zip(other: Iterable<R>, transform: (a: Short, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> IntArray.zip(other: Iterable<R>, transform: (a: Int, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> LongArray.zip(other: Iterable<R>, transform: (a: Long, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> FloatArray.zip(other: Iterable<R>, transform: (a: Float, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> DoubleArray.zip(other: Iterable<R>, transform: (a: Double, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> BooleanArray.zip(other: Iterable<R>, transform: (a: Boolean, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> CharArray.zip(other: Iterable<R>, transform: (a: Char, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun ByteArray.zip(other: ByteArray): List<Pair<Byte, Byte>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun ShortArray.zip(other: ShortArray): List<Pair<Short, Short>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun IntArray.zip(other: IntArray): List<Pair<Int, Int>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun LongArray.zip(other: LongArray): List<Pair<Long, Long>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun FloatArray.zip(other: FloatArray): List<Pair<Float, Float>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun DoubleArray.zip(other: DoubleArray): List<Pair<Double, Double>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun BooleanArray.zip(other: BooleanArray): List<Pair<Boolean, Boolean>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun CharArray.zip(other: CharArray): List<Pair<Char, Char>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> ByteArray.zip(other: ByteArray, transform: (a: Byte, b: Byte) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> ShortArray.zip(other: ShortArray, transform: (a: Short, b: Short) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> IntArray.zip(other: IntArray, transform: (a: Int, b: Int) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> LongArray.zip(other: LongArray, transform: (a: Long, b: Long) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> FloatArray.zip(other: FloatArray, transform: (a: Float, b: Float) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> DoubleArray.zip(other: DoubleArray, transform: (a: Double, b: Double) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> BooleanArray.zip(other: BooleanArray, transform: (a: Boolean, b: Boolean) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> CharArray.zip(other: CharArray, transform: (a: Char, b: Char) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <T, A : Appendable> Array<out T>.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            buffer.appendElement(element, transform)\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> ByteArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Byte) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> ShortArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Short) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> IntArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Int) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> LongArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Long) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> FloatArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Float) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> DoubleArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Double) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> BooleanArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Boolean) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> CharArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Char) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element)\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun <T> Array<out T>.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun ByteArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Byte) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun ShortArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Short) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun IntArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Int) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun LongArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Long) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun FloatArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Float) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun DoubleArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Double) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun BooleanArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Boolean) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun CharArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Char) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun <T> Array<out T>.asIterable(): Iterable<T> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun ByteArray.asIterable(): Iterable<Byte> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun ShortArray.asIterable(): Iterable<Short> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun IntArray.asIterable(): Iterable<Int> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun LongArray.asIterable(): Iterable<Long> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun FloatArray.asIterable(): Iterable<Float> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun DoubleArray.asIterable(): Iterable<Double> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun BooleanArray.asIterable(): Iterable<Boolean> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun CharArray.asIterable(): Iterable<Char> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun <T> Array<out T>.asSequence(): Sequence<T> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun ByteArray.asSequence(): Sequence<Byte> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun ShortArray.asSequence(): Sequence<Short> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun IntArray.asSequence(): Sequence<Int> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun LongArray.asSequence(): Sequence<Long> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun FloatArray.asSequence(): Sequence<Float> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun DoubleArray.asSequence(): Sequence<Double> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun BooleanArray.asSequence(): Sequence<Boolean> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun CharArray.asSequence(): Sequence<Char> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Returns an average value of elements in the array.\n */\n@kotlin.jvm.JvmName(\"averageOfByte\")\npublic fun Array<out Byte>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\n@kotlin.jvm.JvmName(\"averageOfShort\")\npublic fun Array<out Short>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\n@kotlin.jvm.JvmName(\"averageOfInt\")\npublic fun Array<out Int>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\n@kotlin.jvm.JvmName(\"averageOfLong\")\npublic fun Array<out Long>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\n@kotlin.jvm.JvmName(\"averageOfFloat\")\npublic fun Array<out Float>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\n@kotlin.jvm.JvmName(\"averageOfDouble\")\npublic fun Array<out Double>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\npublic fun ByteArray.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\npublic fun ShortArray.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\npublic fun IntArray.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\npublic fun LongArray.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\npublic fun FloatArray.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\npublic fun DoubleArray.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfByte\")\npublic fun Array<out Byte>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfShort\")\npublic fun Array<out Short>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfInt\")\npublic fun Array<out Int>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfLong\")\npublic fun Array<out Long>.sum(): Long {\n    var sum: Long = 0L\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfFloat\")\npublic fun Array<out Float>.sum(): Float {\n    var sum: Float = 0.0f\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfDouble\")\npublic fun Array<out Double>.sum(): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\npublic fun ByteArray.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\npublic fun ShortArray.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\npublic fun IntArray.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\npublic fun LongArray.sum(): Long {\n    var sum: Long = 0L\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\npublic fun FloatArray.sum(): Float {\n    var sum: Float = 0.0f\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\npublic fun DoubleArray.sum(): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"RangesKt\")\n\npackage kotlin.ranges\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.random.*\n\n/**\n * Returns a random element from this range.\n * \n * @throws IllegalArgumentException if this range is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun IntRange.random(): Int {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this range.\n * \n * @throws IllegalArgumentException if this range is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun LongRange.random(): Long {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this range.\n * \n * @throws IllegalArgumentException if this range is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun CharRange.random(): Char {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this range using the specified source of randomness.\n * \n * @throws IllegalArgumentException if this range is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun IntRange.random(random: Random): Int {\n    try {\n        return random.nextInt(this)\n    } catch(e: IllegalArgumentException) {\n        throw NoSuchElementException(e.message)\n    }\n}\n\n/**\n * Returns a random element from this range using the specified source of randomness.\n * \n * @throws IllegalArgumentException if this range is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun LongRange.random(random: Random): Long {\n    try {\n        return random.nextLong(this)\n    } catch(e: IllegalArgumentException) {\n        throw NoSuchElementException(e.message)\n    }\n}\n\n/**\n * Returns a random element from this range using the specified source of randomness.\n * \n * @throws IllegalArgumentException if this range is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun CharRange.random(random: Random): Char {\n    try {\n        return random.nextInt(first.code, last.code + 1).toChar()\n    } catch(e: IllegalArgumentException) {\n        throw NoSuchElementException(e.message)\n    }\n}\n\n/**\n * Returns a random element from this range, or `null` if this range is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun IntRange.randomOrNull(): Int? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this range, or `null` if this range is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun LongRange.randomOrNull(): Long? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this range, or `null` if this range is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun CharRange.randomOrNull(): Char? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this range using the specified source of randomness, or `null` if this range is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun IntRange.randomOrNull(random: Random): Int? {\n    if (isEmpty())\n        return null\n    return random.nextInt(this)\n}\n\n/**\n * Returns a random element from this range using the specified source of randomness, or `null` if this range is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun LongRange.randomOrNull(random: Random): Long? {\n    if (isEmpty())\n        return null\n    return random.nextLong(this)\n}\n\n/**\n * Returns a random element from this range using the specified source of randomness, or `null` if this range is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun CharRange.randomOrNull(random: Random): Char? {\n    if (isEmpty())\n        return null\n    return random.nextInt(first.code, last.code + 1).toChar()\n}\n\n/**\n * Returns `true` if this range contains the specified [element].\n * \n * Always returns `false` if the [element] is `null`.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline operator fun IntRange.contains(element: Int?): Boolean {\n    return element != null && contains(element)\n}\n\n/**\n * Returns `true` if this range contains the specified [element].\n * \n * Always returns `false` if the [element] is `null`.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline operator fun LongRange.contains(element: Long?): Boolean {\n    return element != null && contains(element)\n}\n\n/**\n * Returns `true` if this range contains the specified [element].\n * \n * Always returns `false` if the [element] is `null`.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline operator fun CharRange.contains(element: Char?): Boolean {\n    return element != null && contains(element)\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"intRangeContains\")\npublic operator fun ClosedRange<Int>.contains(value: Byte): Boolean {\n    return contains(value.toInt())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"longRangeContains\")\npublic operator fun ClosedRange<Long>.contains(value: Byte): Boolean {\n    return contains(value.toLong())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"shortRangeContains\")\npublic operator fun ClosedRange<Short>.contains(value: Byte): Boolean {\n    return contains(value.toShort())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"doubleRangeContains\")\npublic operator fun ClosedRange<Double>.contains(value: Byte): Boolean {\n    return contains(value.toDouble())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"floatRangeContains\")\npublic operator fun ClosedRange<Float>.contains(value: Byte): Boolean {\n    return contains(value.toFloat())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"intRangeContains\")\npublic operator fun ClosedRange<Int>.contains(value: Double): Boolean {\n    return value.toIntExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"longRangeContains\")\npublic operator fun ClosedRange<Long>.contains(value: Double): Boolean {\n    return value.toLongExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"byteRangeContains\")\npublic operator fun ClosedRange<Byte>.contains(value: Double): Boolean {\n    return value.toByteExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"shortRangeContains\")\npublic operator fun ClosedRange<Short>.contains(value: Double): Boolean {\n    return value.toShortExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"floatRangeContains\")\npublic operator fun ClosedRange<Float>.contains(value: Double): Boolean {\n    return contains(value.toFloat())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"intRangeContains\")\npublic operator fun ClosedRange<Int>.contains(value: Float): Boolean {\n    return value.toIntExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"longRangeContains\")\npublic operator fun ClosedRange<Long>.contains(value: Float): Boolean {\n    return value.toLongExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"byteRangeContains\")\npublic operator fun ClosedRange<Byte>.contains(value: Float): Boolean {\n    return value.toByteExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"shortRangeContains\")\npublic operator fun ClosedRange<Short>.contains(value: Float): Boolean {\n    return value.toShortExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"doubleRangeContains\")\npublic operator fun ClosedRange<Double>.contains(value: Float): Boolean {\n    return contains(value.toDouble())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"longRangeContains\")\npublic operator fun ClosedRange<Long>.contains(value: Int): Boolean {\n    return contains(value.toLong())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"byteRangeContains\")\npublic operator fun ClosedRange<Byte>.contains(value: Int): Boolean {\n    return value.toByteExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"shortRangeContains\")\npublic operator fun ClosedRange<Short>.contains(value: Int): Boolean {\n    return value.toShortExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"doubleRangeContains\")\npublic operator fun ClosedRange<Double>.contains(value: Int): Boolean {\n    return contains(value.toDouble())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"floatRangeContains\")\npublic operator fun ClosedRange<Float>.contains(value: Int): Boolean {\n    return contains(value.toFloat())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"intRangeContains\")\npublic operator fun ClosedRange<Int>.contains(value: Long): Boolean {\n    return value.toIntExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"byteRangeContains\")\npublic operator fun ClosedRange<Byte>.contains(value: Long): Boolean {\n    return value.toByteExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"shortRangeContains\")\npublic operator fun ClosedRange<Short>.contains(value: Long): Boolean {\n    return value.toShortExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"doubleRangeContains\")\npublic operator fun ClosedRange<Double>.contains(value: Long): Boolean {\n    return contains(value.toDouble())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"floatRangeContains\")\npublic operator fun ClosedRange<Float>.contains(value: Long): Boolean {\n    return contains(value.toFloat())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"intRangeContains\")\npublic operator fun ClosedRange<Int>.contains(value: Short): Boolean {\n    return contains(value.toInt())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"longRangeContains\")\npublic operator fun ClosedRange<Long>.contains(value: Short): Boolean {\n    return contains(value.toLong())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"byteRangeContains\")\npublic operator fun ClosedRange<Byte>.contains(value: Short): Boolean {\n    return value.toByteExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"doubleRangeContains\")\npublic operator fun ClosedRange<Double>.contains(value: Short): Boolean {\n    return contains(value.toDouble())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"floatRangeContains\")\npublic operator fun ClosedRange<Float>.contains(value: Short): Boolean {\n    return contains(value.toFloat())\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Int.downTo(to: Byte): IntProgression {\n    return IntProgression.fromClosedRange(this, to.toInt(), -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Long.downTo(to: Byte): LongProgression {\n    return LongProgression.fromClosedRange(this, to.toLong(), -1L)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Byte.downTo(to: Byte): IntProgression {\n    return IntProgression.fromClosedRange(this.toInt(), to.toInt(), -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Short.downTo(to: Byte): IntProgression {\n    return IntProgression.fromClosedRange(this.toInt(), to.toInt(), -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Char.downTo(to: Char): CharProgression {\n    return CharProgression.fromClosedRange(this, to, -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Int.downTo(to: Int): IntProgression {\n    return IntProgression.fromClosedRange(this, to, -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Long.downTo(to: Int): LongProgression {\n    return LongProgression.fromClosedRange(this, to.toLong(), -1L)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Byte.downTo(to: Int): IntProgression {\n    return IntProgression.fromClosedRange(this.toInt(), to, -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Short.downTo(to: Int): IntProgression {\n    return IntProgression.fromClosedRange(this.toInt(), to, -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Int.downTo(to: Long): LongProgression {\n    return LongProgression.fromClosedRange(this.toLong(), to, -1L)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Long.downTo(to: Long): LongProgression {\n    return LongProgression.fromClosedRange(this, to, -1L)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Byte.downTo(to: Long): LongProgression {\n    return LongProgression.fromClosedRange(this.toLong(), to, -1L)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Short.downTo(to: Long): LongProgression {\n    return LongProgression.fromClosedRange(this.toLong(), to, -1L)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Int.downTo(to: Short): IntProgression {\n    return IntProgression.fromClosedRange(this, to.toInt(), -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Long.downTo(to: Short): LongProgression {\n    return LongProgression.fromClosedRange(this, to.toLong(), -1L)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Byte.downTo(to: Short): IntProgression {\n    return IntProgression.fromClosedRange(this.toInt(), to.toInt(), -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Short.downTo(to: Short): IntProgression {\n    return IntProgression.fromClosedRange(this.toInt(), to.toInt(), -1)\n}\n\n/**\n * Returns a progression that goes over the same range in the opposite direction with the same step.\n */\npublic fun IntProgression.reversed(): IntProgression {\n    return IntProgression.fromClosedRange(last, first, -step)\n}\n\n/**\n * Returns a progression that goes over the same range in the opposite direction with the same step.\n */\npublic fun LongProgression.reversed(): LongProgression {\n    return LongProgression.fromClosedRange(last, first, -step)\n}\n\n/**\n * Returns a progression that goes over the same range in the opposite direction with the same step.\n */\npublic fun CharProgression.reversed(): CharProgression {\n    return CharProgression.fromClosedRange(last, first, -step)\n}\n\n/**\n * Returns a progression that goes over the same range with the given step.\n */\npublic infix fun IntProgression.step(step: Int): IntProgression {\n    checkStepIsPositive(step > 0, step)\n    return IntProgression.fromClosedRange(first, last, if (this.step > 0) step else -step)\n}\n\n/**\n * Returns a progression that goes over the same range with the given step.\n */\npublic infix fun LongProgression.step(step: Long): LongProgression {\n    checkStepIsPositive(step > 0, step)\n    return LongProgression.fromClosedRange(first, last, if (this.step > 0) step else -step)\n}\n\n/**\n * Returns a progression that goes over the same range with the given step.\n */\npublic infix fun CharProgression.step(step: Int): CharProgression {\n    checkStepIsPositive(step > 0, step)\n    return CharProgression.fromClosedRange(first, last, if (this.step > 0) step else -step)\n}\n\ninternal fun Int.toByteExactOrNull(): Byte? {\n    return if (this in Byte.MIN_VALUE.toInt()..Byte.MAX_VALUE.toInt()) this.toByte() else null\n}\n\ninternal fun Long.toByteExactOrNull(): Byte? {\n    return if (this in Byte.MIN_VALUE.toLong()..Byte.MAX_VALUE.toLong()) this.toByte() else null\n}\n\ninternal fun Short.toByteExactOrNull(): Byte? {\n    return if (this in Byte.MIN_VALUE.toShort()..Byte.MAX_VALUE.toShort()) this.toByte() else null\n}\n\ninternal fun Double.toByteExactOrNull(): Byte? {\n    return if (this in Byte.MIN_VALUE.toDouble()..Byte.MAX_VALUE.toDouble()) this.toInt().toByte() else null\n}\n\ninternal fun Float.toByteExactOrNull(): Byte? {\n    return if (this in Byte.MIN_VALUE.toFloat()..Byte.MAX_VALUE.toFloat()) this.toInt().toByte() else null\n}\n\ninternal fun Long.toIntExactOrNull(): Int? {\n    return if (this in Int.MIN_VALUE.toLong()..Int.MAX_VALUE.toLong()) this.toInt() else null\n}\n\ninternal fun Double.toIntExactOrNull(): Int? {\n    return if (this in Int.MIN_VALUE.toDouble()..Int.MAX_VALUE.toDouble()) this.toInt() else null\n}\n\ninternal fun Float.toIntExactOrNull(): Int? {\n    return if (this in Int.MIN_VALUE.toFloat()..Int.MAX_VALUE.toFloat()) this.toInt() else null\n}\n\ninternal fun Double.toLongExactOrNull(): Long? {\n    return if (this in Long.MIN_VALUE.toDouble()..Long.MAX_VALUE.toDouble()) this.toLong() else null\n}\n\ninternal fun Float.toLongExactOrNull(): Long? {\n    return if (this in Long.MIN_VALUE.toFloat()..Long.MAX_VALUE.toFloat()) this.toLong() else null\n}\n\ninternal fun Int.toShortExactOrNull(): Short? {\n    return if (this in Short.MIN_VALUE.toInt()..Short.MAX_VALUE.toInt()) this.toShort() else null\n}\n\ninternal fun Long.toShortExactOrNull(): Short? {\n    return if (this in Short.MIN_VALUE.toLong()..Short.MAX_VALUE.toLong()) this.toShort() else null\n}\n\ninternal fun Double.toShortExactOrNull(): Short? {\n    return if (this in Short.MIN_VALUE.toDouble()..Short.MAX_VALUE.toDouble()) this.toInt().toShort() else null\n}\n\ninternal fun Float.toShortExactOrNull(): Short? {\n    return if (this in Short.MIN_VALUE.toFloat()..Short.MAX_VALUE.toFloat()) this.toInt().toShort() else null\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Int.until(to: Byte): IntRange {\n    return this .. (to.toInt() - 1).toInt()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Long.until(to: Byte): LongRange {\n    return this .. (to.toLong() - 1).toLong()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Byte.until(to: Byte): IntRange {\n    return this.toInt() .. (to.toInt() - 1).toInt()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Short.until(to: Byte): IntRange {\n    return this.toInt() .. (to.toInt() - 1).toInt()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Char.until(to: Char): CharRange {\n    if (to <= '\\u0000') return CharRange.EMPTY\n    return this .. (to - 1).toChar()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Int.until(to: Int): IntRange {\n    if (to <= Int.MIN_VALUE) return IntRange.EMPTY\n    return this .. (to - 1).toInt()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Long.until(to: Int): LongRange {\n    return this .. (to.toLong() - 1).toLong()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Byte.until(to: Int): IntRange {\n    if (to <= Int.MIN_VALUE) return IntRange.EMPTY\n    return this.toInt() .. (to - 1).toInt()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Short.until(to: Int): IntRange {\n    if (to <= Int.MIN_VALUE) return IntRange.EMPTY\n    return this.toInt() .. (to - 1).toInt()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Int.until(to: Long): LongRange {\n    if (to <= Long.MIN_VALUE) return LongRange.EMPTY\n    return this.toLong() .. (to - 1).toLong()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Long.until(to: Long): LongRange {\n    if (to <= Long.MIN_VALUE) return LongRange.EMPTY\n    return this .. (to - 1).toLong()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Byte.until(to: Long): LongRange {\n    if (to <= Long.MIN_VALUE) return LongRange.EMPTY\n    return this.toLong() .. (to - 1).toLong()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Short.until(to: Long): LongRange {\n    if (to <= Long.MIN_VALUE) return LongRange.EMPTY\n    return this.toLong() .. (to - 1).toLong()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Int.until(to: Short): IntRange {\n    return this .. (to.toInt() - 1).toInt()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Long.until(to: Short): LongRange {\n    return this .. (to.toLong() - 1).toLong()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Byte.until(to: Short): IntRange {\n    return this.toInt() .. (to.toInt() - 1).toInt()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Short.until(to: Short): IntRange {\n    return this.toInt() .. (to.toInt() - 1).toInt()\n}\n\n/**\n * Ensures that this value is not less than the specified [minimumValue].\n * \n * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtLeastComparable\n */\npublic fun <T : Comparable<T>> T.coerceAtLeast(minimumValue: T): T {\n    return if (this < minimumValue) minimumValue else this\n}\n\n/**\n * Ensures that this value is not less than the specified [minimumValue].\n * \n * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtLeast\n */\npublic fun Byte.coerceAtLeast(minimumValue: Byte): Byte {\n    return if (this < minimumValue) minimumValue else this\n}\n\n/**\n * Ensures that this value is not less than the specified [minimumValue].\n * \n * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtLeast\n */\npublic fun Short.coerceAtLeast(minimumValue: Short): Short {\n    return if (this < minimumValue) minimumValue else this\n}\n\n/**\n * Ensures that this value is not less than the specified [minimumValue].\n * \n * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtLeast\n */\npublic fun Int.coerceAtLeast(minimumValue: Int): Int {\n    return if (this < minimumValue) minimumValue else this\n}\n\n/**\n * Ensures that this value is not less than the specified [minimumValue].\n * \n * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtLeast\n */\npublic fun Long.coerceAtLeast(minimumValue: Long): Long {\n    return if (this < minimumValue) minimumValue else this\n}\n\n/**\n * Ensures that this value is not less than the specified [minimumValue].\n * \n * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtLeast\n */\npublic fun Float.coerceAtLeast(minimumValue: Float): Float {\n    return if (this < minimumValue) minimumValue else this\n}\n\n/**\n * Ensures that this value is not less than the specified [minimumValue].\n * \n * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtLeast\n */\npublic fun Double.coerceAtLeast(minimumValue: Double): Double {\n    return if (this < minimumValue) minimumValue else this\n}\n\n/**\n * Ensures that this value is not greater than the specified [maximumValue].\n * \n * @return this value if it's less than or equal to the [maximumValue] or the [maximumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtMostComparable\n */\npublic fun <T : Comparable<T>> T.coerceAtMost(maximumValue: T): T {\n    return if (this > maximumValue) maximumValue else this\n}\n\n/**\n * Ensures that this value is not greater than the specified [maximumValue].\n * \n * @return this value if it's less than or equal to the [maximumValue] or the [maximumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtMost\n */\npublic fun Byte.coerceAtMost(maximumValue: Byte): Byte {\n    return if (this > maximumValue) maximumValue else this\n}\n\n/**\n * Ensures that this value is not greater than the specified [maximumValue].\n * \n * @return this value if it's less than or equal to the [maximumValue] or the [maximumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtMost\n */\npublic fun Short.coerceAtMost(maximumValue: Short): Short {\n    return if (this > maximumValue) maximumValue else this\n}\n\n/**\n * Ensures that this value is not greater than the specified [maximumValue].\n * \n * @return this value if it's less than or equal to the [maximumValue] or the [maximumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtMost\n */\npublic fun Int.coerceAtMost(maximumValue: Int): Int {\n    return if (this > maximumValue) maximumValue else this\n}\n\n/**\n * Ensures that this value is not greater than the specified [maximumValue].\n * \n * @return this value if it's less than or equal to the [maximumValue] or the [maximumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtMost\n */\npublic fun Long.coerceAtMost(maximumValue: Long): Long {\n    return if (this > maximumValue) maximumValue else this\n}\n\n/**\n * Ensures that this value is not greater than the specified [maximumValue].\n * \n * @return this value if it's less than or equal to the [maximumValue] or the [maximumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtMost\n */\npublic fun Float.coerceAtMost(maximumValue: Float): Float {\n    return if (this > maximumValue) maximumValue else this\n}\n\n/**\n * Ensures that this value is not greater than the specified [maximumValue].\n * \n * @return this value if it's less than or equal to the [maximumValue] or the [maximumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtMost\n */\npublic fun Double.coerceAtMost(maximumValue: Double): Double {\n    return if (this > maximumValue) maximumValue else this\n}\n\n/**\n * Ensures that this value lies in the specified range [minimumValue]..[maximumValue].\n * \n * @return this value if it's in the range, or [minimumValue] if this value is less than [minimumValue], or [maximumValue] if this value is greater than [maximumValue].\n * \n * @sample samples.comparisons.ComparableOps.coerceInComparable\n */\npublic fun <T : Comparable<T>> T.coerceIn(minimumValue: T?, maximumValue: T?): T {\n    if (minimumValue !== null && maximumValue !== null) {\n        if (minimumValue > maximumValue) throw IllegalArgumentException(\"Cannot coerce value to an empty range: maximum $maximumValue is less than minimum $minimumValue.\")\n        if (this < minimumValue) return minimumValue\n        if (this > maximumValue) return maximumValue\n    }\n    else {\n        if (minimumValue !== null && this < minimumValue) return minimumValue\n        if (maximumValue !== null && this > maximumValue) return maximumValue\n    }\n    return this\n}\n\n/**\n * Ensures that this value lies in the specified range [minimumValue]..[maximumValue].\n * \n * @return this value if it's in the range, or [minimumValue] if this value is less than [minimumValue], or [maximumValue] if this value is greater than [maximumValue].\n * \n * @sample samples.comparisons.ComparableOps.coerceIn\n */\npublic fun Byte.coerceIn(minimumValue: Byte, maximumValue: Byte): Byte {\n    if (minimumValue > maximumValue) throw IllegalArgumentException(\"Cannot coerce value to an empty range: maximum $maximumValue is less than minimum $minimumValue.\")\n    if (this < minimumValue) return minimumValue\n    if (this > maximumValue) return maximumValue\n    return this\n}\n\n/**\n * Ensures that this value lies in the specified range [minimumValue]..[maximumValue].\n * \n * @return this value if it's in the range, or [minimumValue] if this value is less than [minimumValue], or [maximumValue] if this value is greater than [maximumValue].\n * \n * @sample samples.comparisons.ComparableOps.coerceIn\n */\npublic fun Short.coerceIn(minimumValue: Short, maximumValue: Short): Short {\n    if (minimumValue > maximumValue) throw IllegalArgumentException(\"Cannot coerce value to an empty range: maximum $maximumValue is less than minimum $minimumValue.\")\n    if (this < minimumValue) return minimumValue\n    if (this > maximumValue) return maximumValue\n    return this\n}\n\n/**\n * Ensures that this value lies in the specified range [minimumValue]..[maximumValue].\n * \n * @return this value if it's in the range, or [minimumValue] if this value is less than [minimumValue], or [maximumValue] if this value is greater than [maximumValue].\n * \n * @sample samples.comparisons.ComparableOps.coerceIn\n */\npublic fun Int.coerceIn(minimumValue: Int, maximumValue: Int): Int {\n    if (minimumValue > maximumValue) throw IllegalArgumentException(\"Cannot coerce value to an empty range: maximum $maximumValue is less than minimum $minimumValue.\")\n    if (this < minimumValue) return minimumValue\n    if (this > maximumValue) return maximumValue\n    return this\n}\n\n/**\n * Ensures that this value lies in the specified range [minimumValue]..[maximumValue].\n * \n * @return this value if it's in the range, or [minimumValue] if this value is less than [minimumValue], or [maximumValue] if this value is greater than [maximumValue].\n * \n * @sample samples.comparisons.ComparableOps.coerceIn\n */\npublic fun Long.coerceIn(minimumValue: Long, maximumValue: Long): Long {\n    if (minimumValue > maximumValue) throw IllegalArgumentException(\"Cannot coerce value to an empty range: maximum $maximumValue is less than minimum $minimumValue.\")\n    if (this < minimumValue) return minimumValue\n    if (this > maximumValue) return maximumValue\n    return this\n}\n\n/**\n * Ensures that this value lies in the specified range [minimumValue]..[maximumValue].\n * \n * @return this value if it's in the range, or [minimumValue] if this value is less than [minimumValue], or [maximumValue] if this value is greater than [maximumValue].\n * \n * @sample samples.comparisons.ComparableOps.coerceIn\n */\npublic fun Float.coerceIn(minimumValue: Float, maximumValue: Float): Float {\n    if (minimumValue > maximumValue) throw IllegalArgumentException(\"Cannot coerce value to an empty range: maximum $maximumValue is less than minimum $minimumValue.\")\n    if (this < minimumValue) return minimumValue\n    if (this > maximumValue) return maximumValue\n    return this\n}\n\n/**\n * Ensures that this value lies in the specified range [minimumValue]..[maximumValue].\n * \n * @return this value if it's in the range, or [minimumValue] if this value is less than [minimumValue], or [maximumValue] if this value is greater than [maximumValue].\n * \n * @sample samples.comparisons.ComparableOps.coerceIn\n */\npublic fun Double.coerceIn(minimumValue: Double, maximumValue: Double): Double {\n    if (minimumValue > maximumValue) throw IllegalArgumentException(\"Cannot coerce value to an empty range: maximum $maximumValue is less than minimum $minimumValue.\")\n    if (this < minimumValue) return minimumValue\n    if (this > maximumValue) return maximumValue\n    return this\n}\n\n/**\n * Ensures that this value lies in the specified [range].\n * \n * @return this value if it's in the [range], or `range.start` if this value is less than `range.start`, or `range.endInclusive` if this value is greater than `range.endInclusive`.\n * \n * @sample samples.comparisons.ComparableOps.coerceInFloatingPointRange\n */\n@SinceKotlin(\"1.1\")\npublic fun <T : Comparable<T>> T.coerceIn(range: ClosedFloatingPointRange<T>): T {\n    if (range.isEmpty()) throw IllegalArgumentException(\"Cannot coerce value to an empty range: $range.\")\n    return when {\n        // this < start equiv to this <= start && !(this >= start)\n        range.lessThanOrEquals(this, range.start) && !range.lessThanOrEquals(range.start, this) -> range.start\n        // this > end equiv to this >= end && !(this <= end)\n        range.lessThanOrEquals(range.endInclusive, this) && !range.lessThanOrEquals(this, range.endInclusive) -> range.endInclusive\n        else -> this\n    }\n}\n\n/**\n * Ensures that this value lies in the specified [range].\n * \n * @return this value if it's in the [range], or `range.start` if this value is less than `range.start`, or `range.endInclusive` if this value is greater than `range.endInclusive`.\n * \n * @sample samples.comparisons.ComparableOps.coerceInComparable\n */\npublic fun <T : Comparable<T>> T.coerceIn(range: ClosedRange<T>): T {\n    if (range is ClosedFloatingPointRange) {\n        return this.coerceIn<T>(range)\n    }\n    if (range.isEmpty()) throw IllegalArgumentException(\"Cannot coerce value to an empty range: $range.\")\n    return when {\n        this < range.start -> range.start\n        this > range.endInclusive -> range.endInclusive\n        else -> this\n    }\n}\n\n/**\n * Ensures that this value lies in the specified [range].\n * \n * @return this value if it's in the [range], or `range.start` if this value is less than `range.start`, or `range.endInclusive` if this value is greater than `range.endInclusive`.\n * \n * @sample samples.comparisons.ComparableOps.coerceIn\n */\npublic fun Int.coerceIn(range: ClosedRange<Int>): Int {\n    if (range is ClosedFloatingPointRange) {\n        return this.coerceIn<Int>(range)\n    }\n    if (range.isEmpty()) throw IllegalArgumentException(\"Cannot coerce value to an empty range: $range.\")\n    return when {\n        this < range.start -> range.start\n        this > range.endInclusive -> range.endInclusive\n        else -> this\n    }\n}\n\n/**\n * Ensures that this value lies in the specified [range].\n * \n * @return this value if it's in the [range], or `range.start` if this value is less than `range.start`, or `range.endInclusive` if this value is greater than `range.endInclusive`.\n * \n * @sample samples.comparisons.ComparableOps.coerceIn\n */\npublic fun Long.coerceIn(range: ClosedRange<Long>): Long {\n    if (range is ClosedFloatingPointRange) {\n        return this.coerceIn<Long>(range)\n    }\n    if (range.isEmpty()) throw IllegalArgumentException(\"Cannot coerce value to an empty range: $range.\")\n    return when {\n        this < range.start -> range.start\n        this > range.endInclusive -> range.endInclusive\n        else -> this\n    }\n}\n\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin\n\nimport kotlin.experimental.*\nimport kotlin.jvm.*\n\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@JvmInline\npublic value class UByte @PublishedApi internal constructor(@PublishedApi internal val data: Byte) : Comparable<UByte> {\n\n    companion object {\n        /**\n         * A constant holding the minimum value an instance of UByte can have.\n         */\n        public const val MIN_VALUE: UByte = UByte(0)\n\n        /**\n         * A constant holding the maximum value an instance of UByte can have.\n         */\n        public const val MAX_VALUE: UByte = UByte(-1)\n\n        /**\n         * The number of bytes used to represent an instance of UByte in a binary form.\n         */\n        public const val SIZE_BYTES: Int = 1\n\n        /**\n         * The number of bits used to represent an instance of UByte in a binary form.\n         */\n        public const val SIZE_BITS: Int = 8\n    }\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    @Suppress(\"OVERRIDE_BY_INLINE\")\n    public override inline operator fun compareTo(other: UByte): Int = this.toInt().compareTo(other.toInt())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UShort): Int = this.toInt().compareTo(other.toInt())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UInt): Int = this.toUInt().compareTo(other)\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: ULong): Int = this.toULong().compareTo(other)\n\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UByte): UInt = this.toUInt().plus(other.toUInt())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UShort): UInt = this.toUInt().plus(other.toUInt())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UInt): UInt = this.toUInt().plus(other)\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: ULong): ULong = this.toULong().plus(other)\n\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UByte): UInt = this.toUInt().minus(other.toUInt())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UShort): UInt = this.toUInt().minus(other.toUInt())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UInt): UInt = this.toUInt().minus(other)\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: ULong): ULong = this.toULong().minus(other)\n\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UByte): UInt = this.toUInt().times(other.toUInt())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UShort): UInt = this.toUInt().times(other.toUInt())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UInt): UInt = this.toUInt().times(other)\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: ULong): ULong = this.toULong().times(other)\n\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UByte): UInt = this.toUInt().div(other.toUInt())\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UShort): UInt = this.toUInt().div(other.toUInt())\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UInt): UInt = this.toUInt().div(other)\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: ULong): ULong = this.toULong().div(other)\n\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UByte): UInt = this.toUInt().rem(other.toUInt())\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UShort): UInt = this.toUInt().rem(other.toUInt())\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UInt): UInt = this.toUInt().rem(other)\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: ULong): ULong = this.toULong().rem(other)\n\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: UByte): UInt = this.toUInt().floorDiv(other.toUInt())\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: UShort): UInt = this.toUInt().floorDiv(other.toUInt())\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: UInt): UInt = this.toUInt().floorDiv(other)\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: ULong): ULong = this.toULong().floorDiv(other)\n\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: UByte): UByte = this.toUInt().mod(other.toUInt()).toUByte()\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: UShort): UShort = this.toUInt().mod(other.toUInt()).toUShort()\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: UInt): UInt = this.toUInt().mod(other)\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: ULong): ULong = this.toULong().mod(other)\n\n    /** Increments this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun inc(): UByte = UByte(data.inc())\n    /** Decrements this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun dec(): UByte = UByte(data.dec())\n\n    /** Creates a range from this value to the specified [other] value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rangeTo(other: UByte): UIntRange = UIntRange(this.toUInt(), other.toUInt())\n\n    /** Performs a bitwise AND operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun and(other: UByte): UByte = UByte(this.data and other.data)\n    /** Performs a bitwise OR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun or(other: UByte): UByte = UByte(this.data or other.data)\n    /** Performs a bitwise XOR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun xor(other: UByte): UByte = UByte(this.data xor other.data)\n    /** Inverts the bits in this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun inv(): UByte = UByte(data.inv())\n\n    /**\n     * Converts this [UByte] value to [Byte].\n     *\n     * If this value is less than or equals to [Byte.MAX_VALUE], the resulting `Byte` value represents\n     * the same numerical value as this `UByte`. Otherwise the result is negative.\n     *\n     * The resulting `Byte` value has the same binary representation as this `UByte` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toByte(): Byte = data\n    /**\n     * Converts this [UByte] value to [Short].\n     *\n     * The resulting `Short` value represents the same numerical value as this `UByte`.\n     *\n     * The least significant 8 bits of the resulting `Short` value are the same as the bits of this `UByte` value,\n     * whereas the most significant 8 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toShort(): Short = data.toShort() and 0xFF\n    /**\n     * Converts this [UByte] value to [Int].\n     *\n     * The resulting `Int` value represents the same numerical value as this `UByte`.\n     *\n     * The least significant 8 bits of the resulting `Int` value are the same as the bits of this `UByte` value,\n     * whereas the most significant 24 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toInt(): Int = data.toInt() and 0xFF\n    /**\n     * Converts this [UByte] value to [Long].\n     *\n     * The resulting `Long` value represents the same numerical value as this `UByte`.\n     *\n     * The least significant 8 bits of the resulting `Long` value are the same as the bits of this `UByte` value,\n     * whereas the most significant 56 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toLong(): Long = data.toLong() and 0xFF\n\n    /** Returns this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun toUByte(): UByte = this\n    /**\n     * Converts this [UByte] value to [UShort].\n     *\n     * The resulting `UShort` value represents the same numerical value as this `UByte`.\n     *\n     * The least significant 8 bits of the resulting `UShort` value are the same as the bits of this `UByte` value,\n     * whereas the most significant 8 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUShort(): UShort = UShort(data.toShort() and 0xFF)\n    /**\n     * Converts this [UByte] value to [UInt].\n     *\n     * The resulting `UInt` value represents the same numerical value as this `UByte`.\n     *\n     * The least significant 8 bits of the resulting `UInt` value are the same as the bits of this `UByte` value,\n     * whereas the most significant 24 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUInt(): UInt = UInt(data.toInt() and 0xFF)\n    /**\n     * Converts this [UByte] value to [ULong].\n     *\n     * The resulting `ULong` value represents the same numerical value as this `UByte`.\n     *\n     * The least significant 8 bits of the resulting `ULong` value are the same as the bits of this `UByte` value,\n     * whereas the most significant 56 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toULong(): ULong = ULong(data.toLong() and 0xFF)\n\n    /**\n     * Converts this [UByte] value to [Float].\n     *\n     * The resulting `Float` value represents the same numerical value as this `UByte`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toFloat(): Float = this.toInt().toFloat()\n    /**\n     * Converts this [UByte] value to [Double].\n     *\n     * The resulting `Double` value represents the same numerical value as this `UByte`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toDouble(): Double = this.toInt().toDouble()\n\n    public override fun toString(): String = toInt().toString()\n\n}\n\n/**\n * Converts this [Byte] value to [UByte].\n *\n * If this value is positive, the resulting `UByte` value represents the same numerical value as this `Byte`.\n *\n * The resulting `UByte` value has the same binary representation as this `Byte` value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Byte.toUByte(): UByte = UByte(this)\n/**\n * Converts this [Short] value to [UByte].\n *\n * If this value is positive and less than or equals to [UByte.MAX_VALUE], the resulting `UByte` value represents\n * the same numerical value as this `Short`.\n *\n * The resulting `UByte` value is represented by the least significant 8 bits of this `Short` value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Short.toUByte(): UByte = UByte(this.toByte())\n/**\n * Converts this [Int] value to [UByte].\n *\n * If this value is positive and less than or equals to [UByte.MAX_VALUE], the resulting `UByte` value represents\n * the same numerical value as this `Int`.\n *\n * The resulting `UByte` value is represented by the least significant 8 bits of this `Int` value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Int.toUByte(): UByte = UByte(this.toByte())\n/**\n * Converts this [Long] value to [UByte].\n *\n * If this value is positive and less than or equals to [UByte.MAX_VALUE], the resulting `UByte` value represents\n * the same numerical value as this `Long`.\n *\n * The resulting `UByte` value is represented by the least significant 8 bits of this `Long` value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Long.toUByte(): UByte = UByte(this.toByte())\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin\n\nimport kotlin.experimental.*\nimport kotlin.jvm.*\n\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@JvmInline\npublic value class UInt @PublishedApi internal constructor(@PublishedApi internal val data: Int) : Comparable<UInt> {\n\n    companion object {\n        /**\n         * A constant holding the minimum value an instance of UInt can have.\n         */\n        public const val MIN_VALUE: UInt = UInt(0)\n\n        /**\n         * A constant holding the maximum value an instance of UInt can have.\n         */\n        public const val MAX_VALUE: UInt = UInt(-1)\n\n        /**\n         * The number of bytes used to represent an instance of UInt in a binary form.\n         */\n        public const val SIZE_BYTES: Int = 4\n\n        /**\n         * The number of bits used to represent an instance of UInt in a binary form.\n         */\n        public const val SIZE_BITS: Int = 32\n    }\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UByte): Int = this.compareTo(other.toUInt())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UShort): Int = this.compareTo(other.toUInt())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    @Suppress(\"OVERRIDE_BY_INLINE\")\n    public override inline operator fun compareTo(other: UInt): Int = uintCompare(this.data, other.data)\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: ULong): Int = this.toULong().compareTo(other)\n\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UByte): UInt = this.plus(other.toUInt())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UShort): UInt = this.plus(other.toUInt())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UInt): UInt = UInt(this.data.plus(other.data))\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: ULong): ULong = this.toULong().plus(other)\n\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UByte): UInt = this.minus(other.toUInt())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UShort): UInt = this.minus(other.toUInt())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UInt): UInt = UInt(this.data.minus(other.data))\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: ULong): ULong = this.toULong().minus(other)\n\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UByte): UInt = this.times(other.toUInt())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UShort): UInt = this.times(other.toUInt())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UInt): UInt = UInt(this.data.times(other.data))\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: ULong): ULong = this.toULong().times(other)\n\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UByte): UInt = this.div(other.toUInt())\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UShort): UInt = this.div(other.toUInt())\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UInt): UInt = uintDivide(this, other)\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: ULong): ULong = this.toULong().div(other)\n\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UByte): UInt = this.rem(other.toUInt())\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UShort): UInt = this.rem(other.toUInt())\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UInt): UInt = uintRemainder(this, other)\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: ULong): ULong = this.toULong().rem(other)\n\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: UByte): UInt = this.floorDiv(other.toUInt())\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: UShort): UInt = this.floorDiv(other.toUInt())\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: UInt): UInt = div(other)\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: ULong): ULong = this.toULong().floorDiv(other)\n\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: UByte): UByte = this.mod(other.toUInt()).toUByte()\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: UShort): UShort = this.mod(other.toUInt()).toUShort()\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: UInt): UInt = rem(other)\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: ULong): ULong = this.toULong().mod(other)\n\n    /** Increments this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun inc(): UInt = UInt(data.inc())\n    /** Decrements this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun dec(): UInt = UInt(data.dec())\n\n    /** Creates a range from this value to the specified [other] value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rangeTo(other: UInt): UIntRange = UIntRange(this, other)\n\n    /**\n     * Shifts this value left by the [bitCount] number of bits.\n     *\n     * Note that only the five lowest-order bits of the [bitCount] are used as the shift distance.\n     * The shift distance actually used is therefore always in the range `0..31`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline infix fun shl(bitCount: Int): UInt = UInt(data shl bitCount)\n\n    /**\n     * Shifts this value right by the [bitCount] number of bits, filling the leftmost bits with zeros.\n     *\n     * Note that only the five lowest-order bits of the [bitCount] are used as the shift distance.\n     * The shift distance actually used is therefore always in the range `0..31`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline infix fun shr(bitCount: Int): UInt = UInt(data ushr bitCount)\n\n    /** Performs a bitwise AND operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun and(other: UInt): UInt = UInt(this.data and other.data)\n    /** Performs a bitwise OR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun or(other: UInt): UInt = UInt(this.data or other.data)\n    /** Performs a bitwise XOR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun xor(other: UInt): UInt = UInt(this.data xor other.data)\n    /** Inverts the bits in this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun inv(): UInt = UInt(data.inv())\n\n    /**\n     * Converts this [UInt] value to [Byte].\n     *\n     * If this value is less than or equals to [Byte.MAX_VALUE], the resulting `Byte` value represents\n     * the same numerical value as this `UInt`.\n     *\n     * The resulting `Byte` value is represented by the least significant 8 bits of this `UInt` value.\n     * Note that the resulting `Byte` value may be negative.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toByte(): Byte = data.toByte()\n    /**\n     * Converts this [UInt] value to [Short].\n     *\n     * If this value is less than or equals to [Short.MAX_VALUE], the resulting `Short` value represents\n     * the same numerical value as this `UInt`.\n     *\n     * The resulting `Short` value is represented by the least significant 16 bits of this `UInt` value.\n     * Note that the resulting `Short` value may be negative.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toShort(): Short = data.toShort()\n    /**\n     * Converts this [UInt] value to [Int].\n     *\n     * If this value is less than or equals to [Int.MAX_VALUE], the resulting `Int` value represents\n     * the same numerical value as this `UInt`. Otherwise the result is negative.\n     *\n     * The resulting `Int` value has the same binary representation as this `UInt` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toInt(): Int = data\n    /**\n     * Converts this [UInt] value to [Long].\n     *\n     * The resulting `Long` value represents the same numerical value as this `UInt`.\n     *\n     * The least significant 32 bits of the resulting `Long` value are the same as the bits of this `UInt` value,\n     * whereas the most significant 32 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toLong(): Long = data.toLong() and 0xFFFF_FFFF\n\n    /**\n     * Converts this [UInt] value to [UByte].\n     *\n     * If this value is less than or equals to [UByte.MAX_VALUE], the resulting `UByte` value represents\n     * the same numerical value as this `UInt`.\n     *\n     * The resulting `UByte` value is represented by the least significant 8 bits of this `UInt` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUByte(): UByte = data.toUByte()\n    /**\n     * Converts this [UInt] value to [UShort].\n     *\n     * If this value is less than or equals to [UShort.MAX_VALUE], the resulting `UShort` value represents\n     * the same numerical value as this `UInt`.\n     *\n     * The resulting `UShort` value is represented by the least significant 16 bits of this `UInt` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUShort(): UShort = data.toUShort()\n    /** Returns this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun toUInt(): UInt = this\n    /**\n     * Converts this [UInt] value to [ULong].\n     *\n     * The resulting `ULong` value represents the same numerical value as this `UInt`.\n     *\n     * The least significant 32 bits of the resulting `ULong` value are the same as the bits of this `UInt` value,\n     * whereas the most significant 32 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toULong(): ULong = ULong(data.toLong() and 0xFFFF_FFFF)\n\n    /**\n     * Converts this [UInt] value to [Float].\n     *\n     * The resulting value is the closest `Float` to this `UInt` value.\n     * In case when this `UInt` value is exactly between two `Float`s,\n     * the one with zero at least significant bit of mantissa is selected.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toFloat(): Float = this.toDouble().toFloat()\n    /**\n     * Converts this [UInt] value to [Double].\n     *\n     * The resulting `Double` value represents the same numerical value as this `UInt`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toDouble(): Double = uintToDouble(data)\n\n    public override fun toString(): String = toLong().toString()\n\n}\n\n/**\n * Converts this [Byte] value to [UInt].\n *\n * If this value is positive, the resulting `UInt` value represents the same numerical value as this `Byte`.\n *\n * The least significant 8 bits of the resulting `UInt` value are the same as the bits of this `Byte` value,\n * whereas the most significant 24 bits are filled with the sign bit of this value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Byte.toUInt(): UInt = UInt(this.toInt())\n/**\n * Converts this [Short] value to [UInt].\n *\n * If this value is positive, the resulting `UInt` value represents the same numerical value as this `Short`.\n *\n * The least significant 16 bits of the resulting `UInt` value are the same as the bits of this `Short` value,\n * whereas the most significant 16 bits are filled with the sign bit of this value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Short.toUInt(): UInt = UInt(this.toInt())\n/**\n * Converts this [Int] value to [UInt].\n *\n * If this value is positive, the resulting `UInt` value represents the same numerical value as this `Int`.\n *\n * The resulting `UInt` value has the same binary representation as this `Int` value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Int.toUInt(): UInt = UInt(this)\n/**\n * Converts this [Long] value to [UInt].\n *\n * If this value is positive and less than or equals to [UInt.MAX_VALUE], the resulting `UInt` value represents\n * the same numerical value as this `Long`.\n *\n * The resulting `UInt` value is represented by the least significant 32 bits of this `Long` value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Long.toUInt(): UInt = UInt(this.toInt())\n\n/**\n * Converts this [Float] value to [UInt].\n *\n * The fractional part, if any, is rounded down towards zero.\n * Returns zero if this `Float` value is negative or `NaN`, [UInt.MAX_VALUE] if it's bigger than `UInt.MAX_VALUE`.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Float.toUInt(): UInt = doubleToUInt(this.toDouble())\n/**\n * Converts this [Double] value to [UInt].\n *\n * The fractional part, if any, is rounded down towards zero.\n * Returns zero if this `Double` value is negative or `NaN`, [UInt.MAX_VALUE] if it's bigger than `UInt.MAX_VALUE`.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Double.toUInt(): UInt = doubleToUInt(this)\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin\n\nimport kotlin.experimental.*\nimport kotlin.jvm.*\n\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@JvmInline\npublic value class UShort @PublishedApi internal constructor(@PublishedApi internal val data: Short) : Comparable<UShort> {\n\n    companion object {\n        /**\n         * A constant holding the minimum value an instance of UShort can have.\n         */\n        public const val MIN_VALUE: UShort = UShort(0)\n\n        /**\n         * A constant holding the maximum value an instance of UShort can have.\n         */\n        public const val MAX_VALUE: UShort = UShort(-1)\n\n        /**\n         * The number of bytes used to represent an instance of UShort in a binary form.\n         */\n        public const val SIZE_BYTES: Int = 2\n\n        /**\n         * The number of bits used to represent an instance of UShort in a binary form.\n         */\n        public const val SIZE_BITS: Int = 16\n    }\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UByte): Int = this.toInt().compareTo(other.toInt())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    @Suppress(\"OVERRIDE_BY_INLINE\")\n    public override inline operator fun compareTo(other: UShort): Int = this.toInt().compareTo(other.toInt())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UInt): Int = this.toUInt().compareTo(other)\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: ULong): Int = this.toULong().compareTo(other)\n\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UByte): UInt = this.toUInt().plus(other.toUInt())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UShort): UInt = this.toUInt().plus(other.toUInt())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UInt): UInt = this.toUInt().plus(other)\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: ULong): ULong = this.toULong().plus(other)\n\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UByte): UInt = this.toUInt().minus(other.toUInt())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UShort): UInt = this.toUInt().minus(other.toUInt())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UInt): UInt = this.toUInt().minus(other)\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: ULong): ULong = this.toULong().minus(other)\n\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UByte): UInt = this.toUInt().times(other.toUInt())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UShort): UInt = this.toUInt().times(other.toUInt())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UInt): UInt = this.toUInt().times(other)\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: ULong): ULong = this.toULong().times(other)\n\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UByte): UInt = this.toUInt().div(other.toUInt())\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UShort): UInt = this.toUInt().div(other.toUInt())\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UInt): UInt = this.toUInt().div(other)\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: ULong): ULong = this.toULong().div(other)\n\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UByte): UInt = this.toUInt().rem(other.toUInt())\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UShort): UInt = this.toUInt().rem(other.toUInt())\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UInt): UInt = this.toUInt().rem(other)\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: ULong): ULong = this.toULong().rem(other)\n\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: UByte): UInt = this.toUInt().floorDiv(other.toUInt())\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: UShort): UInt = this.toUInt().floorDiv(other.toUInt())\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: UInt): UInt = this.toUInt().floorDiv(other)\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: ULong): ULong = this.toULong().floorDiv(other)\n\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: UByte): UByte = this.toUInt().mod(other.toUInt()).toUByte()\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: UShort): UShort = this.toUInt().mod(other.toUInt()).toUShort()\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: UInt): UInt = this.toUInt().mod(other)\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: ULong): ULong = this.toULong().mod(other)\n\n    /** Increments this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun inc(): UShort = UShort(data.inc())\n    /** Decrements this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun dec(): UShort = UShort(data.dec())\n\n    /** Creates a range from this value to the specified [other] value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rangeTo(other: UShort): UIntRange = UIntRange(this.toUInt(), other.toUInt())\n\n    /** Performs a bitwise AND operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun and(other: UShort): UShort = UShort(this.data and other.data)\n    /** Performs a bitwise OR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun or(other: UShort): UShort = UShort(this.data or other.data)\n    /** Performs a bitwise XOR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun xor(other: UShort): UShort = UShort(this.data xor other.data)\n    /** Inverts the bits in this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun inv(): UShort = UShort(data.inv())\n\n    /**\n     * Converts this [UShort] value to [Byte].\n     *\n     * If this value is less than or equals to [Byte.MAX_VALUE], the resulting `Byte` value represents\n     * the same numerical value as this `UShort`.\n     *\n     * The resulting `Byte` value is represented by the least significant 8 bits of this `UShort` value.\n     * Note that the resulting `Byte` value may be negative.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toByte(): Byte = data.toByte()\n    /**\n     * Converts this [UShort] value to [Short].\n     *\n     * If this value is less than or equals to [Short.MAX_VALUE], the resulting `Short` value represents\n     * the same numerical value as this `UShort`. Otherwise the result is negative.\n     *\n     * The resulting `Short` value has the same binary representation as this `UShort` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toShort(): Short = data\n    /**\n     * Converts this [UShort] value to [Int].\n     *\n     * The resulting `Int` value represents the same numerical value as this `UShort`.\n     *\n     * The least significant 16 bits of the resulting `Int` value are the same as the bits of this `UShort` value,\n     * whereas the most significant 16 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toInt(): Int = data.toInt() and 0xFFFF\n    /**\n     * Converts this [UShort] value to [Long].\n     *\n     * The resulting `Long` value represents the same numerical value as this `UShort`.\n     *\n     * The least significant 16 bits of the resulting `Long` value are the same as the bits of this `UShort` value,\n     * whereas the most significant 48 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toLong(): Long = data.toLong() and 0xFFFF\n\n    /**\n     * Converts this [UShort] value to [UByte].\n     *\n     * If this value is less than or equals to [UByte.MAX_VALUE], the resulting `UByte` value represents\n     * the same numerical value as this `UShort`.\n     *\n     * The resulting `UByte` value is represented by the least significant 8 bits of this `UShort` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUByte(): UByte = data.toUByte()\n    /** Returns this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun toUShort(): UShort = this\n    /**\n     * Converts this [UShort] value to [UInt].\n     *\n     * The resulting `UInt` value represents the same numerical value as this `UShort`.\n     *\n     * The least significant 16 bits of the resulting `UInt` value are the same as the bits of this `UShort` value,\n     * whereas the most significant 16 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUInt(): UInt = UInt(data.toInt() and 0xFFFF)\n    /**\n     * Converts this [UShort] value to [ULong].\n     *\n     * The resulting `ULong` value represents the same numerical value as this `UShort`.\n     *\n     * The least significant 16 bits of the resulting `ULong` value are the same as the bits of this `UShort` value,\n     * whereas the most significant 48 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toULong(): ULong = ULong(data.toLong() and 0xFFFF)\n\n    /**\n     * Converts this [UShort] value to [Float].\n     *\n     * The resulting `Float` value represents the same numerical value as this `UShort`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toFloat(): Float = this.toInt().toFloat()\n    /**\n     * Converts this [UShort] value to [Double].\n     *\n     * The resulting `Double` value represents the same numerical value as this `UShort`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toDouble(): Double = this.toInt().toDouble()\n\n    public override fun toString(): String = toInt().toString()\n\n}\n\n/**\n * Converts this [Byte] value to [UShort].\n *\n * If this value is positive, the resulting `UShort` value represents the same numerical value as this `Byte`.\n *\n * The least significant 8 bits of the resulting `UShort` value are the same as the bits of this `Byte` value,\n * whereas the most significant 8 bits are filled with the sign bit of this value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Byte.toUShort(): UShort = UShort(this.toShort())\n/**\n * Converts this [Short] value to [UShort].\n *\n * If this value is positive, the resulting `UShort` value represents the same numerical value as this `Short`.\n *\n * The resulting `UShort` value has the same binary representation as this `Short` value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Short.toUShort(): UShort = UShort(this)\n/**\n * Converts this [Int] value to [UShort].\n *\n * If this value is positive and less than or equals to [UShort.MAX_VALUE], the resulting `UShort` value represents\n * the same numerical value as this `Int`.\n *\n * The resulting `UShort` value is represented by the least significant 16 bits of this `Int` value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Int.toUShort(): UShort = UShort(this.toShort())\n/**\n * Converts this [Long] value to [UShort].\n *\n * If this value is positive and less than or equals to [UShort.MAX_VALUE], the resulting `UShort` value represents\n * the same numerical value as this `Long`.\n *\n * The resulting `UShort` value is represented by the least significant 16 bits of this `Long` value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Long.toUShort(): UShort = UShort(this.toShort())\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin.ranges\n\n/**\n * A range of values of type `Char`.\n */\npublic class CharRange(start: Char, endInclusive: Char) : CharProgression(start, endInclusive, 1), ClosedRange<Char> {\n    override val start: Char get() = first\n    override val endInclusive: Char get() = last\n\n    override fun contains(value: Char): Boolean = first <= value && value <= last\n\n    /** \n     * Checks whether the range is empty.\n     *\n     * The range is empty if its start value is greater than the end value.\n     */\n    override fun isEmpty(): Boolean = first > last\n\n    override fun equals(other: Any?): Boolean =\n        other is CharRange && (isEmpty() && other.isEmpty() ||\n        first == other.first && last == other.last)\n\n    override fun hashCode(): Int =\n        if (isEmpty()) -1 else (31 * first.code + last.code)\n\n    override fun toString(): String = \"$first..$last\"\n\n    companion object {\n        /** An empty range of values of type Char. */\n        public val EMPTY: CharRange = CharRange(1.toChar(), 0.toChar())\n    }\n}\n\n/**\n * A range of values of type `Int`.\n */\npublic class IntRange(start: Int, endInclusive: Int) : IntProgression(start, endInclusive, 1), ClosedRange<Int> {\n    override val start: Int get() = first\n    override val endInclusive: Int get() = last\n\n    override fun contains(value: Int): Boolean = first <= value && value <= last\n\n    /** \n     * Checks whether the range is empty.\n     *\n     * The range is empty if its start value is greater than the end value.\n     */\n    override fun isEmpty(): Boolean = first > last\n\n    override fun equals(other: Any?): Boolean =\n        other is IntRange && (isEmpty() && other.isEmpty() ||\n        first == other.first && last == other.last)\n\n    override fun hashCode(): Int =\n        if (isEmpty()) -1 else (31 * first + last)\n\n    override fun toString(): String = \"$first..$last\"\n\n    companion object {\n        /** An empty range of values of type Int. */\n        public val EMPTY: IntRange = IntRange(1, 0)\n    }\n}\n\n/**\n * A range of values of type `Long`.\n */\npublic class LongRange(start: Long, endInclusive: Long) : LongProgression(start, endInclusive, 1), ClosedRange<Long> {\n    override val start: Long get() = first\n    override val endInclusive: Long get() = last\n\n    override fun contains(value: Long): Boolean = first <= value && value <= last\n\n    /** \n     * Checks whether the range is empty.\n     *\n     * The range is empty if its start value is greater than the end value.\n     */\n    override fun isEmpty(): Boolean = first > last\n\n    override fun equals(other: Any?): Boolean =\n        other is LongRange && (isEmpty() && other.isEmpty() ||\n        first == other.first && last == other.last)\n\n    override fun hashCode(): Int =\n        if (isEmpty()) -1 else (31 * (first xor (first ushr 32)) + (last xor (last ushr 32))).toInt()\n\n    override fun toString(): String = \"$first..$last\"\n\n    companion object {\n        /** An empty range of values of type Long. */\n        public val EMPTY: LongRange = LongRange(1, 0)\n    }\n}\n\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n@file:OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n\npackage kotlin.collections\n\nimport kotlin.contracts.*\nimport kotlin.random.Random\n\ninternal object EmptyIterator : ListIterator<Nothing> {\n    override fun hasNext(): Boolean = false\n    override fun hasPrevious(): Boolean = false\n    override fun nextIndex(): Int = 0\n    override fun previousIndex(): Int = -1\n    override fun next(): Nothing = throw NoSuchElementException()\n    override fun previous(): Nothing = throw NoSuchElementException()\n}\n\ninternal object EmptyList : List<Nothing>, Serializable, RandomAccess {\n    private const val serialVersionUID: Long = -7390468764508069838L\n\n    override fun equals(other: Any?): Boolean = other is List<*> && other.isEmpty()\n    override fun hashCode(): Int = 1\n    override fun toString(): String = \"[]\"\n\n    override val size: Int get() = 0\n    override fun isEmpty(): Boolean = true\n    override fun contains(element: Nothing): Boolean = false\n    override fun containsAll(elements: Collection<Nothing>): Boolean = elements.isEmpty()\n\n    override fun get(index: Int): Nothing = throw IndexOutOfBoundsException(\"Empty list doesn't contain element at index $index.\")\n    override fun indexOf(element: Nothing): Int = -1\n    override fun lastIndexOf(element: Nothing): Int = -1\n\n    override fun iterator(): Iterator<Nothing> = EmptyIterator\n    override fun listIterator(): ListIterator<Nothing> = EmptyIterator\n    override fun listIterator(index: Int): ListIterator<Nothing> {\n        if (index != 0) throw IndexOutOfBoundsException(\"Index: $index\")\n        return EmptyIterator\n    }\n\n    override fun subList(fromIndex: Int, toIndex: Int): List<Nothing> {\n        if (fromIndex == 0 && toIndex == 0) return this\n        throw IndexOutOfBoundsException(\"fromIndex: $fromIndex, toIndex: $toIndex\")\n    }\n\n    private fun readResolve(): Any = EmptyList\n}\n\ninternal fun <T> Array<out T>.asCollection(): Collection<T> = ArrayAsCollection(this, isVarargs = false)\n\nprivate class ArrayAsCollection<T>(val values: Array<out T>, val isVarargs: Boolean) : Collection<T> {\n    override val size: Int get() = values.size\n    override fun isEmpty(): Boolean = values.isEmpty()\n    override fun contains(element: T): Boolean = values.contains(element)\n    override fun containsAll(elements: Collection<T>): Boolean = elements.all { contains(it) }\n    override fun iterator(): Iterator<T> = values.iterator()\n    // override hidden toArray implementation to prevent copying of values array\n    public fun toArray(): Array<out Any?> = values.copyToArrayOfAny(isVarargs)\n}\n\n/**\n * Returns an empty read-only list.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.emptyReadOnlyList\n */\npublic fun <T> emptyList(): List<T> = EmptyList\n\n/**\n * Returns a new read-only list of given elements.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.readOnlyList\n */\npublic fun <T> listOf(vararg elements: T): List<T> = if (elements.size > 0) elements.asList() else emptyList()\n\n/**\n * Returns an empty read-only list.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.emptyReadOnlyList\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> listOf(): List<T> = emptyList()\n\n/**\n * Returns an empty new [MutableList].\n * @sample samples.collections.Collections.Lists.emptyMutableList\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> mutableListOf(): MutableList<T> = ArrayList()\n\n/**\n * Returns an empty new [ArrayList].\n * @sample samples.collections.Collections.Lists.emptyArrayList\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> arrayListOf(): ArrayList<T> = ArrayList()\n\n/**\n * Returns a new [MutableList] with the given elements.\n * @sample samples.collections.Collections.Lists.mutableList\n */\npublic fun <T> mutableListOf(vararg elements: T): MutableList<T> =\n    if (elements.size == 0) ArrayList() else ArrayList(ArrayAsCollection(elements, isVarargs = true))\n\n/**\n * Returns a new [ArrayList] with the given elements.\n * @sample samples.collections.Collections.Lists.arrayList\n */\npublic fun <T> arrayListOf(vararg elements: T): ArrayList<T> =\n    if (elements.size == 0) ArrayList() else ArrayList(ArrayAsCollection(elements, isVarargs = true))\n\n/**\n * Returns a new read-only list either of single given element, if it is not null, or empty list if the element is null. The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.listOfNotNull\n */\npublic fun <T : Any> listOfNotNull(element: T?): List<T> = if (element != null) listOf(element) else emptyList()\n\n/**\n * Returns a new read-only list only of those given elements, that are not null.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.listOfNotNull\n */\npublic fun <T : Any> listOfNotNull(vararg elements: T?): List<T> = elements.filterNotNull()\n\n/**\n * Creates a new read-only list with the specified [size], where each element is calculated by calling the specified\n * [init] function.\n *\n * The function [init] is called for each list element sequentially starting from the first one.\n * It should return the value for a list element given its index.\n *\n * @sample samples.collections.Collections.Lists.readOnlyListFromInitializer\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> List(size: Int, init: (index: Int) -> T): List<T> = MutableList(size, init)\n\n/**\n * Creates a new mutable list with the specified [size], where each element is calculated by calling the specified\n * [init] function.\n *\n * The function [init] is called for each list element sequentially starting from the first one.\n * It should return the value for a list element given its index.\n *\n * @sample samples.collections.Collections.Lists.mutableListFromInitializer\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> MutableList(size: Int, init: (index: Int) -> T): MutableList<T> {\n    val list = ArrayList<T>(size)\n    repeat(size) { index -> list.add(init(index)) }\n    return list\n}\n\n/**\n * Builds a new read-only [List] by populating a [MutableList] using the given [builderAction]\n * and returning a read-only list with the same elements.\n *\n * The list passed as a receiver to the [builderAction] is valid only inside that function.\n * Using it outside of the function produces an unspecified behavior.\n *\n * @sample samples.collections.Builders.Lists.buildListSample\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun <E> buildList(@BuilderInference builderAction: MutableList<E>.() -> Unit): List<E> {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return buildListInternal(builderAction)\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal expect inline fun <E> buildListInternal(builderAction: MutableList<E>.() -> Unit): List<E>\n\n/**\n * Builds a new read-only [List] by populating a [MutableList] using the given [builderAction]\n * and returning a read-only list with the same elements.\n *\n * The list passed as a receiver to the [builderAction] is valid only inside that function.\n * Using it outside of the function produces an unspecified behavior.\n *\n * [capacity] is used to hint the expected number of elements added in the [builderAction].\n *\n * @throws IllegalArgumentException if the given [capacity] is negative.\n *\n * @sample samples.collections.Builders.Lists.buildListSampleWithCapacity\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun <E> buildList(capacity: Int, @BuilderInference builderAction: MutableList<E>.() -> Unit): List<E> {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return buildListInternal(capacity, builderAction)\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal expect inline fun <E> buildListInternal(capacity: Int, builderAction: MutableList<E>.() -> Unit): List<E>\n\n/**\n * Returns an [IntRange] of the valid indices for this collection.\n * @sample samples.collections.Collections.Collections.indicesOfCollection\n */\npublic val Collection<*>.indices: IntRange\n    get() = 0..size - 1\n\n/**\n * Returns the index of the last item in the list or -1 if the list is empty.\n *\n * @sample samples.collections.Collections.Lists.lastIndexOfList\n */\npublic val <T> List<T>.lastIndex: Int\n    get() = this.size - 1\n\n/**\n * Returns `true` if the collection is not empty.\n * @sample samples.collections.Collections.Collections.collectionIsNotEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.isNotEmpty(): Boolean = !isEmpty()\n\n/**\n * Returns `true` if this nullable collection is either null or empty.\n * @sample samples.collections.Collections.Collections.collectionIsNullOrEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>?.isNullOrEmpty(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrEmpty != null)\n    }\n\n    return this == null || this.isEmpty()\n}\n\n/**\n * Returns this Collection if it's not `null` and the empty list otherwise.\n * @sample samples.collections.Collections.Collections.collectionOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>?.orEmpty(): Collection<T> = this ?: emptyList()\n\n/**\n * Returns this List if it's not `null` and the empty list otherwise.\n * @sample samples.collections.Collections.Lists.listOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>?.orEmpty(): List<T> = this ?: emptyList()\n\n/**\n * Returns this collection if it's not empty\n * or the result of calling [defaultValue] function if the collection is empty.\n *\n * @sample samples.collections.Collections.Collections.collectionIfEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <C, R> C.ifEmpty(defaultValue: () -> R): R where C : Collection<*>, C : R =\n    if (isEmpty()) defaultValue() else this\n\n\n/**\n * Checks if all elements in the specified collection are contained in this collection.\n *\n * Allows to overcome type-safety restriction of `containsAll` that requires to pass a collection of type `Collection<E>`.\n * @sample samples.collections.Collections.Collections.collectionContainsAll\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes T> Collection<T>.containsAll(elements: Collection<T>): Boolean = this.containsAll(elements)\n\n\n/**\n * Returns a new list with the elements of this list randomly shuffled\n * using the specified [random] instance as the source of randomness.\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> Iterable<T>.shuffled(random: Random): List<T> = toMutableList().apply { shuffle(random) }\n\n\ninternal fun <T> List<T>.optimizeReadOnlyList() = when (size) {\n    0 -> emptyList()\n    1 -> listOf(this[0])\n    else -> this\n}\n\n/**\n * Searches this list or its range for the provided [element] using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the Comparable natural ordering of its elements,\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements equal to the specified [element], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchOnComparable\n * @sample samples.collections.Collections.Lists.binarySearchWithBoundaries\n */\npublic fun <T : Comparable<T>> List<T?>.binarySearch(element: T?, fromIndex: Int = 0, toIndex: Int = size): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = compareValues(midVal, element)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Searches this list or its range for the provided [element] using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the specified [comparator],\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements equal to the specified [element], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted according to the specified [comparator].\n * @sample samples.collections.Collections.Lists.binarySearchWithComparator\n */\npublic fun <T> List<T>.binarySearch(element: T, comparator: Comparator<in T>, fromIndex: Int = 0, toIndex: Int = size): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = comparator.compare(midVal, element)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Searches this list or its range for an element having the key returned by the specified [selector] function\n * equal to the provided [key] value using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the Comparable natural ordering of keys of its elements.\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements with the specified [key], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element with the specified [key], if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchByKey\n */\npublic inline fun <T, K : Comparable<K>> List<T>.binarySearchBy(\n    key: K?,\n    fromIndex: Int = 0,\n    toIndex: Int = size,\n    crossinline selector: (T) -> K?\n): Int =\n    binarySearch(fromIndex, toIndex) { compareValues(selector(it), key) }\n\n// do not introduce this overload --- too rare\n//public fun <T, K> List<T>.binarySearchBy(key: K, comparator: Comparator<K>, fromIndex: Int = 0, toIndex: Int = size(), selector: (T) -> K): Int =\n//        binarySearch(fromIndex, toIndex) { comparator.compare(selector(it), key) }\n\n\n/**\n * Searches this list or its range for an element for which the given [comparison] function returns zero using the binary search algorithm.\n *\n * The list is expected to be sorted so that the signs of the [comparison] function's return values ascend on the list elements,\n * i.e. negative values come before zero and zeroes come before positive values.\n * Otherwise, the result is undefined.\n *\n * If the list contains multiple elements for which [comparison] returns zero, there is no guarantee which one will be found.\n *\n * @param comparison function that returns zero when called on the list element being searched.\n * On the elements coming before the target element, the function must return negative values;\n * on the elements coming after the target element, the function must return positive values.\n *\n * @return the index of the found element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchWithComparisonFunction\n */\npublic fun <T> List<T>.binarySearch(fromIndex: Int = 0, toIndex: Int = size, comparison: (T) -> Int): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = comparison(midVal)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Checks that `from` and `to` are in\n * the range of [0..size] and throws an appropriate exception, if they aren't.\n */\nprivate fun rangeCheck(size: Int, fromIndex: Int, toIndex: Int) {\n    when {\n        fromIndex > toIndex -> throw IllegalArgumentException(\"fromIndex ($fromIndex) is greater than toIndex ($toIndex).\")\n        fromIndex < 0 -> throw IndexOutOfBoundsException(\"fromIndex ($fromIndex) is less than zero.\")\n        toIndex > size -> throw IndexOutOfBoundsException(\"toIndex ($toIndex) is greater than size ($size).\")\n    }\n}\n\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal expect fun checkIndexOverflow(index: Int): Int\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal expect fun checkCountOverflow(count: Int): Int\n\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun throwIndexOverflow() { throw ArithmeticException(\"Index overflow has happened.\") }\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun throwCountOverflow() { throw ArithmeticException(\"Count overflow has happened.\") }\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"MapsKt\")\n@file:OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n\npackage kotlin.collections\n\nimport kotlin.contracts.*\n\nprivate object EmptyMap : Map<Any?, Nothing>, Serializable {\n    private const val serialVersionUID: Long = 8246714829545688274\n\n    override fun equals(other: Any?): Boolean = other is Map<*, *> && other.isEmpty()\n    override fun hashCode(): Int = 0\n    override fun toString(): String = \"{}\"\n\n    override val size: Int get() = 0\n    override fun isEmpty(): Boolean = true\n\n    override fun containsKey(key: Any?): Boolean = false\n    override fun containsValue(value: Nothing): Boolean = false\n    override fun get(key: Any?): Nothing? = null\n    override val entries: Set<Map.Entry<Any?, Nothing>> get() = EmptySet\n    override val keys: Set<Any?> get() = EmptySet\n    override val values: Collection<Nothing> get() = EmptyList\n\n    private fun readResolve(): Any = EmptyMap\n}\n\n/**\n * Returns an empty read-only map of specified type.\n *\n * The returned map is serializable (JVM).\n * @sample samples.collections.Maps.Instantiation.emptyReadOnlyMap\n */\npublic fun <K, V> emptyMap(): Map<K, V> = @Suppress(\"UNCHECKED_CAST\") (EmptyMap as Map<K, V>)\n\n/**\n * Returns a new read-only map with the specified contents, given as a list of pairs\n * where the first value is the key and the second is the value.\n *\n * If multiple pairs have the same key, the resulting map will contain the value from the last of those pairs.\n *\n * Entries of the map are iterated in the order they were specified.\n *\n * The returned map is serializable (JVM).\n *\n * @sample samples.collections.Maps.Instantiation.mapFromPairs\n */\npublic fun <K, V> mapOf(vararg pairs: Pair<K, V>): Map<K, V> =\n    if (pairs.size > 0) pairs.toMap(LinkedHashMap(mapCapacity(pairs.size))) else emptyMap()\n\n/**\n * Returns an empty read-only map.\n *\n * The returned map is serializable (JVM).\n * @sample samples.collections.Maps.Instantiation.emptyReadOnlyMap\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> mapOf(): Map<K, V> = emptyMap()\n\n/**\n * Returns an empty new [MutableMap].\n *\n * The returned map preserves the entry iteration order.\n * @sample samples.collections.Maps.Instantiation.emptyMutableMap\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> mutableMapOf(): MutableMap<K, V> = LinkedHashMap()\n\n/**\n * Returns a new [MutableMap] with the specified contents, given as a list of pairs\n * where the first component is the key and the second is the value.\n *\n * If multiple pairs have the same key, the resulting map will contain the value from the last of those pairs.\n *\n * Entries of the map are iterated in the order they were specified.\n *\n * @sample samples.collections.Maps.Instantiation.mutableMapFromPairs\n * @sample samples.collections.Maps.Instantiation.emptyMutableMap\n */\npublic fun <K, V> mutableMapOf(vararg pairs: Pair<K, V>): MutableMap<K, V> =\n    LinkedHashMap<K, V>(mapCapacity(pairs.size)).apply { putAll(pairs) }\n\n/**\n * Returns an empty new [HashMap].\n *\n * @sample samples.collections.Maps.Instantiation.emptyHashMap\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> hashMapOf(): HashMap<K, V> = HashMap<K, V>()\n\n/**\n * Returns a new [HashMap] with the specified contents, given as a list of pairs\n * where the first component is the key and the second is the value.\n *\n * @sample samples.collections.Maps.Instantiation.hashMapFromPairs\n */\npublic fun <K, V> hashMapOf(vararg pairs: Pair<K, V>): HashMap<K, V> = HashMap<K, V>(mapCapacity(pairs.size)).apply { putAll(pairs) }\n\n/**\n * Returns an empty new [LinkedHashMap].\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> linkedMapOf(): LinkedHashMap<K, V> = LinkedHashMap<K, V>()\n\n/**\n * Returns a new [LinkedHashMap] with the specified contents, given as a list of pairs\n * where the first component is the key and the second is the value.\n *\n * If multiple pairs have the same key, the resulting map will contain the value from the last of those pairs.\n *\n * Entries of the map are iterated in the order they were specified.\n *\n * @sample samples.collections.Maps.Instantiation.linkedMapFromPairs\n */\npublic fun <K, V> linkedMapOf(vararg pairs: Pair<K, V>): LinkedHashMap<K, V> = pairs.toMap(LinkedHashMap(mapCapacity(pairs.size)))\n\n/**\n * Builds a new read-only [Map] by populating a [MutableMap] using the given [builderAction]\n * and returning a read-only map with the same key-value pairs.\n *\n * The map passed as a receiver to the [builderAction] is valid only inside that function.\n * Using it outside of the function produces an unspecified behavior.\n *\n * Entries of the map are iterated in the order they were added by the [builderAction].\n *\n * @sample samples.collections.Builders.Maps.buildMapSample\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> buildMap(@BuilderInference builderAction: MutableMap<K, V>.() -> Unit): Map<K, V> {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return buildMapInternal(builderAction)\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal expect inline fun <K, V> buildMapInternal(builderAction: MutableMap<K, V>.() -> Unit): Map<K, V>\n\n/**\n * Builds a new read-only [Map] by populating a [MutableMap] using the given [builderAction]\n * and returning a read-only map with the same key-value pairs.\n *\n * The map passed as a receiver to the [builderAction] is valid only inside that function.\n * Using it outside of the function produces an unspecified behavior.\n *\n * [capacity] is used to hint the expected number of pairs added in the [builderAction].\n *\n * Entries of the map are iterated in the order they were added by the [builderAction].\n *\n * @throws IllegalArgumentException if the given [capacity] is negative.\n *\n * @sample samples.collections.Builders.Maps.buildMapSample\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> buildMap(capacity: Int, @BuilderInference builderAction: MutableMap<K, V>.() -> Unit): Map<K, V> {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return buildMapInternal(capacity, builderAction)\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal expect inline fun <K, V> buildMapInternal(capacity: Int, builderAction: MutableMap<K, V>.() -> Unit): Map<K, V>\n\n/**\n * Calculate the initial capacity of a map.\n */\n@PublishedApi\ninternal expect fun mapCapacity(expectedSize: Int): Int\n\n/**\n * Returns `true` if this map is not empty.\n * @sample samples.collections.Maps.Usage.mapIsNotEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.isNotEmpty(): Boolean = !isEmpty()\n\n/**\n * Returns `true` if this nullable map is either null or empty.\n * @sample samples.collections.Maps.Usage.mapIsNullOrEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>?.isNullOrEmpty(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrEmpty != null)\n    }\n\n    return this == null || isEmpty()\n}\n\n/**\n * Returns the [Map] if its not `null`, or the empty [Map] otherwise.\n *\n * @sample samples.collections.Maps.Usage.mapOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<K, V>?.orEmpty(): Map<K, V> = this ?: emptyMap()\n\n/**\n * Returns this map if it's not empty\n * or the result of calling [defaultValue] function if the map is empty.\n *\n * @sample samples.collections.Maps.Usage.mapIfEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <M, R> M.ifEmpty(defaultValue: () -> R): R where M : Map<*, *>, M : R =\n    if (isEmpty()) defaultValue() else this\n\n/**\n * Checks if the map contains the given key.\n *\n * This method allows to use the `x in map` syntax for checking whether an object is contained in the map.\n *\n * @sample samples.collections.Maps.Usage.containsKey\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <@kotlin.internal.OnlyInputTypes K, V> Map<out K, V>.contains(key: K): Boolean = containsKey(key)\n\n/**\n * Returns the value corresponding to the given [key], or `null` if such a key is not present in the map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <@kotlin.internal.OnlyInputTypes K, V> Map<out K, V>.get(key: K): V? =\n    @Suppress(\"UNCHECKED_CAST\") (this as Map<K, V>).get(key)\n\n/**\n * Allows to use the index operator for storing values in a mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.set(key: K, value: V): Unit {\n    put(key, value)\n}\n\n/**\n * Returns `true` if the map contains the specified [key].\n *\n * Allows to overcome type-safety restriction of `containsKey` that requires to pass a key of type `K`.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes K> Map<out K, *>.containsKey(key: K): Boolean =\n    @Suppress(\"UNCHECKED_CAST\") (this as Map<K, *>).containsKey(key)\n\n/**\n * Returns `true` if the map maps one or more keys to the specified [value].\n *\n * Allows to overcome type-safety restriction of `containsValue` that requires to pass a value of type `V`.\n *\n * @sample samples.collections.Maps.Usage.containsValue\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\n@kotlin.internal.InlineOnly\npublic inline fun <K, @kotlin.internal.OnlyInputTypes V> Map<K, V>.containsValue(value: V): Boolean = this.containsValue(value)\n\n\n/**\n * Removes the specified key and its corresponding value from this map.\n *\n * @return the previous value associated with the key, or `null` if the key was not present in the map.\n\n * Allows to overcome type-safety restriction of `remove` that requires to pass a key of type `K`.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes K, V> MutableMap<out K, V>.remove(key: K): V? =\n    @Suppress(\"UNCHECKED_CAST\") (this as MutableMap<K, V>).remove(key)\n\n/**\n * Returns the key component of the map entry.\n *\n * This method allows to use destructuring declarations when working with maps, for example:\n * ```\n * for ((key, value) in map) {\n *     // do something with the key and the value\n * }\n * ```\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> Map.Entry<K, V>.component1(): K = key\n\n/**\n * Returns the value component of the map entry.\n *\n * This method allows to use destructuring declarations when working with maps, for example:\n * ```\n * for ((key, value) in map) {\n *     // do something with the key and the value\n * }\n * ```\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> Map.Entry<K, V>.component2(): V = value\n\n/**\n * Converts entry to [Pair] with key being first component and value being second.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map.Entry<K, V>.toPair(): Pair<K, V> = Pair(key, value)\n\n/**\n * Returns the value for the given key, or the result of the [defaultValue] function if there was no entry for the given key.\n *\n * @sample samples.collections.Maps.Usage.getOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<K, V>.getOrElse(key: K, defaultValue: () -> V): V = get(key) ?: defaultValue()\n\n\ninternal inline fun <K, V> Map<K, V>.getOrElseNullable(key: K, defaultValue: () -> V): V {\n    val value = get(key)\n    if (value == null && !containsKey(key)) {\n        return defaultValue()\n    } else {\n        @Suppress(\"UNCHECKED_CAST\")\n        return value as V\n    }\n}\n\n/**\n * Returns the value for the given [key] or throws an exception if there is no such key in the map.\n *\n * If the map was created by [withDefault], resorts to its `defaultValue` provider function\n * instead of throwing an exception.\n *\n * @throws NoSuchElementException when the map doesn't contain a value for the specified key and\n * no implicit default value was provided for that map.\n */\n@SinceKotlin(\"1.1\")\npublic fun <K, V> Map<K, V>.getValue(key: K): V = getOrImplicitDefault(key)\n\n/**\n * Returns the value for the given key. If the key is not found in the map, calls the [defaultValue] function,\n * puts its result into the map under the given key and returns it.\n *\n * Note that the operation is not guaranteed to be atomic if the map is being modified concurrently.\n *\n * @sample samples.collections.Maps.Usage.getOrPut\n */\npublic inline fun <K, V> MutableMap<K, V>.getOrPut(key: K, defaultValue: () -> V): V {\n    val value = get(key)\n    return if (value == null) {\n        val answer = defaultValue()\n        put(key, answer)\n        answer\n    } else {\n        value\n    }\n}\n\n/**\n * Returns an [Iterator] over the entries in the [Map].\n *\n * @sample samples.collections.Maps.Usage.forOverEntries\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> Map<out K, V>.iterator(): Iterator<Map.Entry<K, V>> = entries.iterator()\n\n/**\n * Returns a [MutableIterator] over the mutable entries in the [MutableMap].\n *\n */\n@kotlin.jvm.JvmName(\"mutableIterator\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.iterator(): MutableIterator<MutableMap.MutableEntry<K, V>> = entries.iterator()\n\n/**\n * Populates the given [destination] map with entries having the keys of this map and the values obtained\n * by applying the [transform] function to each entry in this [Map].\n */\npublic inline fun <K, V, R, M : MutableMap<in K, in R>> Map<out K, V>.mapValuesTo(destination: M, transform: (Map.Entry<K, V>) -> R): M {\n    return entries.associateByTo(destination, { it.key }, transform)\n}\n\n/**\n * Populates the given [destination] map with entries having the keys obtained\n * by applying the [transform] function to each entry in this [Map] and the values of this map.\n *\n * In case if any two entries are mapped to the equal keys, the value of the latter one will overwrite\n * the value associated with the former one.\n */\npublic inline fun <K, V, R, M : MutableMap<in R, in V>> Map<out K, V>.mapKeysTo(destination: M, transform: (Map.Entry<K, V>) -> R): M {\n    return entries.associateByTo(destination, transform, { it.value })\n}\n\n/**\n * Puts all the given [pairs] into this [MutableMap] with the first component in the pair being the key and the second the value.\n */\npublic fun <K, V> MutableMap<in K, in V>.putAll(pairs: Array<out Pair<K, V>>): Unit {\n    for ((key, value) in pairs) {\n        put(key, value)\n    }\n}\n\n/**\n * Puts all the elements of the given collection into this [MutableMap] with the first component in the pair being the key and the second the value.\n */\npublic fun <K, V> MutableMap<in K, in V>.putAll(pairs: Iterable<Pair<K, V>>): Unit {\n    for ((key, value) in pairs) {\n        put(key, value)\n    }\n}\n\n/**\n * Puts all the elements of the given sequence into this [MutableMap] with the first component in the pair being the key and the second the value.\n */\npublic fun <K, V> MutableMap<in K, in V>.putAll(pairs: Sequence<Pair<K, V>>): Unit {\n    for ((key, value) in pairs) {\n        put(key, value)\n    }\n}\n\n/**\n * Returns a new map with entries having the keys of this map and the values obtained by applying the [transform]\n * function to each entry in this [Map].\n *\n * The returned map preserves the entry iteration order of the original map.\n *\n * @sample samples.collections.Maps.Transformations.mapValues\n */\npublic inline fun <K, V, R> Map<out K, V>.mapValues(transform: (Map.Entry<K, V>) -> R): Map<K, R> {\n    return mapValuesTo(LinkedHashMap<K, R>(mapCapacity(size)), transform) // .optimizeReadOnlyMap()\n}\n\n/**\n * Returns a new Map with entries having the keys obtained by applying the [transform] function to each entry in this\n * [Map] and the values of this map.\n *\n * In case if any two entries are mapped to the equal keys, the value of the latter one will overwrite\n * the value associated with the former one.\n *\n * The returned map preserves the entry iteration order of the original map.\n *\n * @sample samples.collections.Maps.Transformations.mapKeys\n */\npublic inline fun <K, V, R> Map<out K, V>.mapKeys(transform: (Map.Entry<K, V>) -> R): Map<R, V> {\n    return mapKeysTo(LinkedHashMap<R, V>(mapCapacity(size)), transform) // .optimizeReadOnlyMap()\n}\n\n/**\n * Returns a map containing all key-value pairs with keys matching the given [predicate].\n *\n * The returned map preserves the entry iteration order of the original map.\n * @sample samples.collections.Maps.Filtering.filterKeys\n */\npublic inline fun <K, V> Map<out K, V>.filterKeys(predicate: (K) -> Boolean): Map<K, V> {\n    val result = LinkedHashMap<K, V>()\n    for (entry in this) {\n        if (predicate(entry.key)) {\n            result.put(entry.key, entry.value)\n        }\n    }\n    return result\n}\n\n/**\n * Returns a map containing all key-value pairs with values matching the given [predicate].\n *\n * The returned map preserves the entry iteration order of the original map.\n *  @sample samples.collections.Maps.Filtering.filterValues\n */\npublic inline fun <K, V> Map<out K, V>.filterValues(predicate: (V) -> Boolean): Map<K, V> {\n    val result = LinkedHashMap<K, V>()\n    for (entry in this) {\n        if (predicate(entry.value)) {\n            result.put(entry.key, entry.value)\n        }\n    }\n    return result\n}\n\n\n/**\n * Appends all entries matching the given [predicate] into the mutable map given as [destination] parameter.\n *\n * @return the destination map.\n * @sample samples.collections.Maps.Filtering.filterTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> Map<out K, V>.filterTo(destination: M, predicate: (Map.Entry<K, V>) -> Boolean): M {\n    for (element in this) {\n        if (predicate(element)) {\n            destination.put(element.key, element.value)\n        }\n    }\n    return destination\n}\n\n/**\n * Returns a new map containing all key-value pairs matching the given [predicate].\n *\n * The returned map preserves the entry iteration order of the original map.\n * @sample samples.collections.Maps.Filtering.filter\n */\npublic inline fun <K, V> Map<out K, V>.filter(predicate: (Map.Entry<K, V>) -> Boolean): Map<K, V> {\n    return filterTo(LinkedHashMap<K, V>(), predicate)\n}\n\n/**\n * Appends all entries not matching the given [predicate] into the given [destination].\n *\n * @return the destination map.\n * @sample samples.collections.Maps.Filtering.filterNotTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> Map<out K, V>.filterNotTo(destination: M, predicate: (Map.Entry<K, V>) -> Boolean): M {\n    for (element in this) {\n        if (!predicate(element)) {\n            destination.put(element.key, element.value)\n        }\n    }\n    return destination\n}\n\n/**\n * Returns a new map containing all key-value pairs not matching the given [predicate].\n *\n * The returned map preserves the entry iteration order of the original map.\n * @sample samples.collections.Maps.Filtering.filterNot\n */\npublic inline fun <K, V> Map<out K, V>.filterNot(predicate: (Map.Entry<K, V>) -> Boolean): Map<K, V> {\n    return filterNotTo(LinkedHashMap<K, V>(), predicate)\n}\n\n/**\n * Returns a new map containing all key-value pairs from the given collection of pairs.\n *\n * The returned map preserves the entry iteration order of the original collection.\n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic fun <K, V> Iterable<Pair<K, V>>.toMap(): Map<K, V> {\n    if (this is Collection) {\n        return when (size) {\n            0 -> emptyMap()\n            1 -> mapOf(if (this is List) this[0] else iterator().next())\n            else -> toMap(LinkedHashMap<K, V>(mapCapacity(size)))\n        }\n    }\n    return toMap(LinkedHashMap<K, V>()).optimizeReadOnlyMap()\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs from the given collection of pairs.\n */\npublic fun <K, V, M : MutableMap<in K, in V>> Iterable<Pair<K, V>>.toMap(destination: M): M =\n    destination.apply { putAll(this@toMap) }\n\n/**\n * Returns a new map containing all key-value pairs from the given array of pairs.\n *\n * The returned map preserves the entry iteration order of the original array.\n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic fun <K, V> Array<out Pair<K, V>>.toMap(): Map<K, V> = when (size) {\n    0 -> emptyMap()\n    1 -> mapOf(this[0])\n    else -> toMap(LinkedHashMap<K, V>(mapCapacity(size)))\n}\n\n/**\n *  Populates and returns the [destination] mutable map with key-value pairs from the given array of pairs.\n */\npublic fun <K, V, M : MutableMap<in K, in V>> Array<out Pair<K, V>>.toMap(destination: M): M =\n    destination.apply { putAll(this@toMap) }\n\n/**\n * Returns a new map containing all key-value pairs from the given sequence of pairs.\n *\n * The returned map preserves the entry iteration order of the original sequence.\n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic fun <K, V> Sequence<Pair<K, V>>.toMap(): Map<K, V> = toMap(LinkedHashMap<K, V>()).optimizeReadOnlyMap()\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs from the given sequence of pairs.\n */\npublic fun <K, V, M : MutableMap<in K, in V>> Sequence<Pair<K, V>>.toMap(destination: M): M =\n    destination.apply { putAll(this@toMap) }\n\n/**\n * Returns a new read-only map containing all key-value pairs from the original map.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic fun <K, V> Map<out K, V>.toMap(): Map<K, V> = when (size) {\n    0 -> emptyMap()\n    1 -> toSingletonMap()\n    else -> toMutableMap()\n}\n\n/**\n * Returns a new mutable map containing all key-value pairs from the original map.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic fun <K, V> Map<out K, V>.toMutableMap(): MutableMap<K, V> = LinkedHashMap(this)\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs from the given map.\n */\n@SinceKotlin(\"1.1\")\npublic fun <K, V, M : MutableMap<in K, in V>> Map<out K, V>.toMap(destination: M): M =\n    destination.apply { putAll(this@toMap) }\n\n/**\n * Creates a new read-only map by replacing or adding an entry to this map from a given key-value [pair].\n *\n * The returned map preserves the entry iteration order of the original map.\n * The [pair] is iterated in the end if it has a unique key.\n */\npublic operator fun <K, V> Map<out K, V>.plus(pair: Pair<K, V>): Map<K, V> =\n    if (this.isEmpty()) mapOf(pair) else LinkedHashMap(this).apply { put(pair.first, pair.second) }\n\n/**\n * Creates a new read-only map by replacing or adding entries to this map from a given collection of key-value [pairs].\n *\n * The returned map preserves the entry iteration order of the original map.\n * Those [pairs] with unique keys are iterated in the end in the order of [pairs] collection.\n */\npublic operator fun <K, V> Map<out K, V>.plus(pairs: Iterable<Pair<K, V>>): Map<K, V> =\n    if (this.isEmpty()) pairs.toMap() else LinkedHashMap(this).apply { putAll(pairs) }\n\n/**\n * Creates a new read-only map by replacing or adding entries to this map from a given array of key-value [pairs].\n *\n * The returned map preserves the entry iteration order of the original map.\n * Those [pairs] with unique keys are iterated in the end in the order of [pairs] array.\n */\npublic operator fun <K, V> Map<out K, V>.plus(pairs: Array<out Pair<K, V>>): Map<K, V> =\n    if (this.isEmpty()) pairs.toMap() else LinkedHashMap(this).apply { putAll(pairs) }\n\n/**\n * Creates a new read-only map by replacing or adding entries to this map from a given sequence of key-value [pairs].\n *\n * The returned map preserves the entry iteration order of the original map.\n * Those [pairs] with unique keys are iterated in the end in the order of [pairs] sequence.\n */\npublic operator fun <K, V> Map<out K, V>.plus(pairs: Sequence<Pair<K, V>>): Map<K, V> =\n    LinkedHashMap(this).apply { putAll(pairs) }.optimizeReadOnlyMap()\n\n/**\n * Creates a new read-only map by replacing or adding entries to this map from another [map].\n *\n * The returned map preserves the entry iteration order of the original map.\n * Those entries of another [map] that are missing in this map are iterated in the end in the order of that [map].\n */\npublic operator fun <K, V> Map<out K, V>.plus(map: Map<out K, V>): Map<K, V> =\n    LinkedHashMap(this).apply { putAll(map) }\n\n\n/**\n * Appends or replaces the given [pair] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pair: Pair<K, V>) {\n    put(pair.first, pair.second)\n}\n\n/**\n * Appends or replaces all pairs from the given collection of [pairs] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pairs: Iterable<Pair<K, V>>) {\n    putAll(pairs)\n}\n\n/**\n * Appends or replaces all pairs from the given array of [pairs] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pairs: Array<out Pair<K, V>>) {\n    putAll(pairs)\n}\n\n/**\n * Appends or replaces all pairs from the given sequence of [pairs] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pairs: Sequence<Pair<K, V>>) {\n    putAll(pairs)\n}\n\n/**\n * Appends or replaces all entries from the given [map] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(map: Map<K, V>) {\n    putAll(map)\n}\n\n/**\n * Returns a map containing all entries of the original map except the entry with the given [key].\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic operator fun <K, V> Map<out K, V>.minus(key: K): Map<K, V> =\n    this.toMutableMap().apply { minusAssign(key) }.optimizeReadOnlyMap()\n\n/**\n * Returns a map containing all entries of the original map except those entries\n * the keys of which are contained in the given [keys] collection.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic operator fun <K, V> Map<out K, V>.minus(keys: Iterable<K>): Map<K, V> =\n    this.toMutableMap().apply { minusAssign(keys) }.optimizeReadOnlyMap()\n\n/**\n * Returns a map containing all entries of the original map except those entries\n * the keys of which are contained in the given [keys] array.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic operator fun <K, V> Map<out K, V>.minus(keys: Array<out K>): Map<K, V> =\n    this.toMutableMap().apply { minusAssign(keys) }.optimizeReadOnlyMap()\n\n/**\n * Returns a map containing all entries of the original map except those entries\n * the keys of which are contained in the given [keys] sequence.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic operator fun <K, V> Map<out K, V>.minus(keys: Sequence<K>): Map<K, V> =\n    this.toMutableMap().apply { minusAssign(keys) }.optimizeReadOnlyMap()\n\n/**\n * Removes the entry with the given [key] from this mutable map.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(key: K) {\n    remove(key)\n}\n\n/**\n * Removes all entries the keys of which are contained in the given [keys] collection from this mutable map.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(keys: Iterable<K>) {\n    this.keys.removeAll(keys)\n}\n\n/**\n * Removes all entries the keys of which are contained in the given [keys] array from this mutable map.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(keys: Array<out K>) {\n    this.keys.removeAll(keys)\n}\n\n/**\n * Removes all entries from the keys of which are contained in the given [keys] sequence from this mutable map.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(keys: Sequence<K>) {\n    this.keys.removeAll(keys)\n}\n\n\n// do not expose for now @PublishedApi\ninternal fun <K, V> Map<K, V>.optimizeReadOnlyMap() = when (size) {\n    0 -> emptyMap()\n    1 -> toSingletonMapOrSelf()\n    else -> this\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"SetsKt\")\n@file:OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n\npackage kotlin.collections\n\nimport kotlin.contracts.*\n\ninternal object EmptySet : Set<Nothing>, Serializable {\n    private const val serialVersionUID: Long = 3406603774387020532\n\n    override fun equals(other: Any?): Boolean = other is Set<*> && other.isEmpty()\n    override fun hashCode(): Int = 0\n    override fun toString(): String = \"[]\"\n\n    override val size: Int get() = 0\n    override fun isEmpty(): Boolean = true\n    override fun contains(element: Nothing): Boolean = false\n    override fun containsAll(elements: Collection<Nothing>): Boolean = elements.isEmpty()\n\n    override fun iterator(): Iterator<Nothing> = EmptyIterator\n\n    private fun readResolve(): Any = EmptySet\n}\n\n\n/**\n * Returns an empty read-only set.  The returned set is serializable (JVM).\n * @sample samples.collections.Collections.Sets.emptyReadOnlySet\n */\npublic fun <T> emptySet(): Set<T> = EmptySet\n\n/**\n * Returns a new read-only set with the given elements.\n * Elements of the set are iterated in the order they were specified.\n * The returned set is serializable (JVM).\n * @sample samples.collections.Collections.Sets.readOnlySet\n */\npublic fun <T> setOf(vararg elements: T): Set<T> = if (elements.size > 0) elements.toSet() else emptySet()\n\n/**\n * Returns an empty read-only set.  The returned set is serializable (JVM).\n * @sample samples.collections.Collections.Sets.emptyReadOnlySet\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> setOf(): Set<T> = emptySet()\n\n/**\n * Returns an empty new [MutableSet].\n *\n * The returned set preserves the element iteration order.\n * @sample samples.collections.Collections.Sets.emptyMutableSet\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> mutableSetOf(): MutableSet<T> = LinkedHashSet()\n\n/**\n * Returns a new [MutableSet] with the given elements.\n * Elements of the set are iterated in the order they were specified.\n * @sample samples.collections.Collections.Sets.mutableSet\n */\npublic fun <T> mutableSetOf(vararg elements: T): MutableSet<T> = elements.toCollection(LinkedHashSet(mapCapacity(elements.size)))\n\n/** Returns an empty new [HashSet]. */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> hashSetOf(): HashSet<T> = HashSet()\n\n/** Returns a new [HashSet] with the given elements. */\npublic fun <T> hashSetOf(vararg elements: T): HashSet<T> = elements.toCollection(HashSet(mapCapacity(elements.size)))\n\n/**\n * Returns an empty new [LinkedHashSet].\n * @sample samples.collections.Collections.Sets.emptyLinkedHashSet\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> linkedSetOf(): LinkedHashSet<T> = LinkedHashSet()\n\n/**\n * Returns a new [LinkedHashSet] with the given elements.\n * Elements of the set are iterated in the order they were specified.\n * @sample samples.collections.Collections.Sets.linkedHashSet\n */\npublic fun <T> linkedSetOf(vararg elements: T): LinkedHashSet<T> = elements.toCollection(LinkedHashSet(mapCapacity(elements.size)))\n\n/**\n * Returns a new read-only set either with single given element, if it is not null, or empty set if the element is null.\n * The returned set is serializable (JVM).\n * @sample samples.collections.Collections.Sets.setOfNotNull\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Any> setOfNotNull(element: T?): Set<T> = if (element != null) setOf(element) else emptySet()\n\n/**\n * Returns a new read-only set only with those given elements, that are not null.\n * Elements of the set are iterated in the order they were specified.\n * The returned set is serializable (JVM).\n * @sample samples.collections.Collections.Sets.setOfNotNull\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Any> setOfNotNull(vararg elements: T?): Set<T> {\n    return elements.filterNotNullTo(LinkedHashSet())\n}\n\n/**\n * Builds a new read-only [Set] by populating a [MutableSet] using the given [builderAction]\n * and returning a read-only set with the same elements.\n *\n * The set passed as a receiver to the [builderAction] is valid only inside that function.\n * Using it outside of the function produces an unspecified behavior.\n *\n * Elements of the set are iterated in the order they were added by the [builderAction].\n *\n * @sample samples.collections.Builders.Sets.buildSetSample\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun <E> buildSet(@BuilderInference builderAction: MutableSet<E>.() -> Unit): Set<E> {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return buildSetInternal(builderAction)\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal expect inline fun <E> buildSetInternal(builderAction: MutableSet<E>.() -> Unit): Set<E>\n\n/**\n * Builds a new read-only [Set] by populating a [MutableSet] using the given [builderAction]\n * and returning a read-only set with the same elements.\n *\n * The set passed as a receiver to the [builderAction] is valid only inside that function.\n * Using it outside of the function produces an unspecified behavior.\n *\n * [capacity] is used to hint the expected number of elements added in the [builderAction].\n *\n * Elements of the set are iterated in the order they were added by the [builderAction].\n *\n * @throws IllegalArgumentException if the given [capacity] is negative.\n *\n * @sample samples.collections.Builders.Sets.buildSetSample\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline fun <E> buildSet(capacity: Int, @BuilderInference builderAction: MutableSet<E>.() -> Unit): Set<E> {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return buildSetInternal(capacity, builderAction)\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal expect inline fun <E> buildSetInternal(capacity: Int, builderAction: MutableSet<E>.() -> Unit): Set<E>\n\n\n/** Returns this Set if it's not `null` and the empty set otherwise. */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Set<T>?.orEmpty(): Set<T> = this ?: emptySet()\n\ninternal fun <T> Set<T>.optimizeReadOnlySet() = when (size) {\n    0 -> emptySet()\n    1 -> setOf(iterator().next())\n    else -> this\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StringsKt\")\n@file:Suppress(\"PLATFORM_CLASS_MAPPED_TO_KOTLIN\")\n\npackage kotlin.text\n\n/**\n * Parses the string as a signed [Byte] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n */\n@SinceKotlin(\"1.1\")\npublic fun String.toByteOrNull(): Byte? = toByteOrNull(radix = 10)\n\n/**\n * Parses the string as a signed [Byte] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\n@SinceKotlin(\"1.1\")\npublic fun String.toByteOrNull(radix: Int): Byte? {\n    val int = this.toIntOrNull(radix) ?: return null\n    if (int < Byte.MIN_VALUE || int > Byte.MAX_VALUE) return null\n    return int.toByte()\n}\n\n/**\n * Parses the string as a [Short] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n */\n@SinceKotlin(\"1.1\")\npublic fun String.toShortOrNull(): Short? = toShortOrNull(radix = 10)\n\n/**\n * Parses the string as a [Short] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\n@SinceKotlin(\"1.1\")\npublic fun String.toShortOrNull(radix: Int): Short? {\n    val int = this.toIntOrNull(radix) ?: return null\n    if (int < Short.MIN_VALUE || int > Short.MAX_VALUE) return null\n    return int.toShort()\n}\n\n/**\n * Parses the string as an [Int] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n */\n@SinceKotlin(\"1.1\")\npublic fun String.toIntOrNull(): Int? = toIntOrNull(radix = 10)\n\n/**\n * Parses the string as an [Int] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\n@SinceKotlin(\"1.1\")\npublic fun String.toIntOrNull(radix: Int): Int? {\n    checkRadix(radix)\n\n    val length = this.length\n    if (length == 0) return null\n\n    val start: Int\n    val isNegative: Boolean\n    val limit: Int\n\n    val firstChar = this[0]\n    if (firstChar < '0') {  // Possible leading sign\n        if (length == 1) return null  // non-digit (possible sign) only, no digits after\n\n        start = 1\n\n        if (firstChar == '-') {\n            isNegative = true\n            limit = Int.MIN_VALUE\n        } else if (firstChar == '+') {\n            isNegative = false\n            limit = -Int.MAX_VALUE\n        } else\n            return null\n    } else {\n        start = 0\n        isNegative = false\n        limit = -Int.MAX_VALUE\n    }\n\n\n    val limitForMaxRadix = (-Int.MAX_VALUE) / 36\n\n    var limitBeforeMul = limitForMaxRadix\n    var result = 0\n    for (i in start until length) {\n        val digit = digitOf(this[i], radix)\n\n        if (digit < 0) return null\n        if (result < limitBeforeMul) {\n            if (limitBeforeMul == limitForMaxRadix) {\n                limitBeforeMul = limit / radix\n\n                if (result < limitBeforeMul) {\n                    return null\n                }\n            } else {\n                return null\n            }\n        }\n\n        result *= radix\n\n        if (result < limit + digit) return null\n\n        result -= digit\n    }\n\n    return if (isNegative) result else -result\n}\n\n/**\n * Parses the string as a [Long] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n */\n@SinceKotlin(\"1.1\")\npublic fun String.toLongOrNull(): Long? = toLongOrNull(radix = 10)\n\n/**\n * Parses the string as a [Long] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\n@SinceKotlin(\"1.1\")\npublic fun String.toLongOrNull(radix: Int): Long? {\n    checkRadix(radix)\n\n    val length = this.length\n    if (length == 0) return null\n\n    val start: Int\n    val isNegative: Boolean\n    val limit: Long\n\n    val firstChar = this[0]\n    if (firstChar < '0') {  // Possible leading sign\n        if (length == 1) return null  // non-digit (possible sign) only, no digits after\n\n        start = 1\n\n        if (firstChar == '-') {\n            isNegative = true\n            limit = Long.MIN_VALUE\n        } else if (firstChar == '+') {\n            isNegative = false\n            limit = -Long.MAX_VALUE\n        } else\n            return null\n    } else {\n        start = 0\n        isNegative = false\n        limit = -Long.MAX_VALUE\n    }\n\n\n    val limitForMaxRadix = (-Long.MAX_VALUE) / 36\n\n    var limitBeforeMul = limitForMaxRadix\n    var result = 0L\n    for (i in start until length) {\n        val digit = digitOf(this[i], radix)\n\n        if (digit < 0) return null\n        if (result < limitBeforeMul) {\n            if (limitBeforeMul == limitForMaxRadix) {\n                limitBeforeMul = limit / radix\n\n                if (result < limitBeforeMul) {\n                    return null\n                }\n            } else {\n                return null\n            }\n        }\n\n        result *= radix\n\n        if (result < limit + digit) return null\n\n        result -= digit\n    }\n\n    return if (isNegative) result else -result\n}\n\n\ninternal fun numberFormatError(input: String): Nothing = throw NumberFormatException(\"Invalid number format: '$input'\")\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.time\n\nimport kotlin.contracts.*\nimport kotlin.jvm.JvmInline\nimport kotlin.math.abs\nimport kotlin.math.roundToInt\nimport kotlin.math.sign\n\n/**\n * Represents the amount of time one instant of time is away from another instant.\n *\n * A negative duration is possible in a situation when the second instant is earlier than the first one.\n * An infinite duration value [Duration.INFINITE] can be used to represent infinite timeouts.\n *\n * The type can store duration values up to ±146 years with nanosecond precision,\n * and up to ±146 million years with millisecond precision.\n *\n * To construct a duration, use either the extension function [toDuration] available on [Int], [Long], and [Double] numeric types,\n * or the `Duration` companion object functions [Duration.hours], [Duration.minutes], [Duration.seconds], and so on,\n * taking [Int], [Long], or [Double] numbers as parameters.\n *\n * To get the value of this duration expressed in a particular [duration units][DurationUnit]\n * use the functions [toInt], [toLong], and [toDouble]\n * or the properties [inWholeHours], [inWholeMinutes], [inWholeSeconds], [inWholeNanoseconds], and so on.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@JvmInline\npublic value class Duration internal constructor(private val rawValue: Long) : Comparable<Duration> {\n\n    private val value: Long get() = rawValue shr 1\n    private inline val unitDiscriminator: Int get() = rawValue.toInt() and 1\n    private fun isInNanos() = unitDiscriminator == 0\n    private fun isInMillis() = unitDiscriminator == 1\n    private val storageUnit get() = if (isInNanos()) DurationUnit.NANOSECONDS else DurationUnit.MILLISECONDS\n\n    init {\n        // TODO: disable assertions in final version\n        if (isInNanos()) {\n            if (value !in -MAX_NANOS..MAX_NANOS) throw AssertionError(\"$value ns is out of nanoseconds range\")\n        } else {\n            if (value !in -MAX_MILLIS..MAX_MILLIS) throw AssertionError(\"$value ms is out of milliseconds range\")\n            if (value in -MAX_NANOS_IN_MILLIS..MAX_NANOS_IN_MILLIS) throw AssertionError(\"$value ms is denormalized\")\n        }\n    }\n\n    companion object {\n        /** The duration equal to exactly 0 seconds. */\n        public val ZERO: Duration = Duration(0L)\n\n        /** The duration whose value is positive infinity. It is useful for representing timeouts that should never expire. */\n        public val INFINITE: Duration = durationOfMillis(MAX_MILLIS)\n        internal val NEG_INFINITE: Duration = durationOfMillis(-MAX_MILLIS)\n\n        /** Converts the given time duration [value] expressed in the specified [sourceUnit] into the specified [targetUnit]. */\n        public fun convert(value: Double, sourceUnit: DurationUnit, targetUnit: DurationUnit): Double =\n            convertDurationUnit(value, sourceUnit, targetUnit)\n\n        /** Returns a [Duration] representing the specified [value] number of nanoseconds. */\n        @SinceKotlin(\"1.5\")\n        public fun nanoseconds(value: Int): Duration = value.toDuration(DurationUnit.NANOSECONDS)\n\n        /** Returns a [Duration] representing the specified [value] number of nanoseconds. */\n        @SinceKotlin(\"1.5\")\n        public fun nanoseconds(value: Long): Duration = value.toDuration(DurationUnit.NANOSECONDS)\n\n        /**\n         * Returns a [Duration] representing the specified [value] number of nanoseconds.\n         *\n         * @throws IllegalArgumentException if the provided `Double` [value] is `NaN`.\n         */\n        @SinceKotlin(\"1.5\")\n        public fun nanoseconds(value: Double): Duration = value.toDuration(DurationUnit.NANOSECONDS)\n\n        /** Returns a [Duration] representing the specified [value] number of microseconds. */\n        @SinceKotlin(\"1.5\")\n        public fun microseconds(value: Int): Duration = value.toDuration(DurationUnit.MICROSECONDS)\n\n        /** Returns a [Duration] representing the specified [value] number of microseconds. */\n        @SinceKotlin(\"1.5\")\n        public fun microseconds(value: Long): Duration = value.toDuration(DurationUnit.MICROSECONDS)\n\n        /**\n         * Returns a [Duration] representing the specified [value] number of microseconds.\n         *\n         * @throws IllegalArgumentException if the provided `Double` [value] is `NaN`.\n         */\n        @SinceKotlin(\"1.5\")\n        public fun microseconds(value: Double): Duration = value.toDuration(DurationUnit.MICROSECONDS)\n\n        /** Returns a [Duration] representing the specified [value] number of milliseconds. */\n        @SinceKotlin(\"1.5\")\n        public fun milliseconds(value: Int): Duration = value.toDuration(DurationUnit.MILLISECONDS)\n\n        /** Returns a [Duration] representing the specified [value] number of milliseconds. */\n        @SinceKotlin(\"1.5\")\n        public fun milliseconds(value: Long): Duration = value.toDuration(DurationUnit.MILLISECONDS)\n\n        /**\n         * Returns a [Duration] representing the specified [value] number of milliseconds.\n         *\n         * @throws IllegalArgumentException if the provided `Double` [value] is `NaN`.\n         */\n        @SinceKotlin(\"1.5\")\n        public fun milliseconds(value: Double): Duration = value.toDuration(DurationUnit.MILLISECONDS)\n\n        /** Returns a [Duration] representing the specified [value] number of seconds. */\n        @SinceKotlin(\"1.5\")\n        public fun seconds(value: Int): Duration = value.toDuration(DurationUnit.SECONDS)\n\n        /** Returns a [Duration] representing the specified [value] number of seconds. */\n        @SinceKotlin(\"1.5\")\n        public fun seconds(value: Long): Duration = value.toDuration(DurationUnit.SECONDS)\n\n        /**\n         * Returns a [Duration] representing the specified [value] number of seconds.\n         *\n         * @throws IllegalArgumentException if the provided `Double` [value] is `NaN`.\n         */\n        @SinceKotlin(\"1.5\")\n        public fun seconds(value: Double): Duration = value.toDuration(DurationUnit.SECONDS)\n\n        /** Returns a [Duration] representing the specified [value] number of minutes. */\n        @SinceKotlin(\"1.5\")\n        public fun minutes(value: Int): Duration = value.toDuration(DurationUnit.MINUTES)\n\n        /** Returns a [Duration] representing the specified [value] number of minutes. */\n        @SinceKotlin(\"1.5\")\n        public fun minutes(value: Long): Duration = value.toDuration(DurationUnit.MINUTES)\n\n        /**\n         * Returns a [Duration] representing the specified [value] number of minutes.\n         *\n         * @throws IllegalArgumentException if the provided `Double` [value] is `NaN`.\n         */\n        @SinceKotlin(\"1.5\")\n        public fun minutes(value: Double): Duration = value.toDuration(DurationUnit.MINUTES)\n\n        /** Returns a [Duration] representing the specified [value] number of hours. */\n        @SinceKotlin(\"1.5\")\n        public fun hours(value: Int): Duration = value.toDuration(DurationUnit.HOURS)\n\n        /** Returns a [Duration] representing the specified [value] number of hours. */\n        @SinceKotlin(\"1.5\")\n        public fun hours(value: Long): Duration = value.toDuration(DurationUnit.HOURS)\n\n        /**\n         * Returns a [Duration] representing the specified [value] number of hours.\n         *\n         * @throws IllegalArgumentException if the provided `Double` [value] is `NaN`.\n         */\n        @SinceKotlin(\"1.5\")\n        public fun hours(value: Double): Duration = value.toDuration(DurationUnit.HOURS)\n\n        /** Returns a [Duration] representing the specified [value] number of days. */\n        @SinceKotlin(\"1.5\")\n        public fun days(value: Int): Duration = value.toDuration(DurationUnit.DAYS)\n\n        /** Returns a [Duration] representing the specified [value] number of days. */\n        @SinceKotlin(\"1.5\")\n        public fun days(value: Long): Duration = value.toDuration(DurationUnit.DAYS)\n\n        /**\n         * Returns a [Duration] representing the specified [value] number of days.\n         *\n         * @throws IllegalArgumentException if the provided `Double` [value] is `NaN`.\n         */\n        @SinceKotlin(\"1.5\")\n        public fun days(value: Double): Duration = value.toDuration(DurationUnit.DAYS)\n\n    }\n\n    // arithmetic operators\n\n    /** Returns the negative of this value. */\n    public operator fun unaryMinus(): Duration = durationOf(-value, unitDiscriminator)\n\n    /**\n     * Returns a duration whose value is the sum of this and [other] duration values.\n     *\n     * @throws IllegalArgumentException if the operation results in an undefined value for the given arguments,\n     * e.g. when adding infinite durations of different sign.\n     */\n    public operator fun plus(other: Duration): Duration {\n        when {\n            this.isInfinite() -> {\n                if (other.isFinite() || (this.rawValue xor other.rawValue >= 0))\n                    return this\n                else\n                    throw IllegalArgumentException(\"Summing infinite durations of different signs yields an undefined result.\")\n            }\n            other.isInfinite() -> return other\n        }\n\n        return when {\n            this.unitDiscriminator == other.unitDiscriminator -> {\n                val result = this.value + other.value // never overflows long, but can overflow long63\n                when {\n                    isInNanos() ->\n                        durationOfNanosNormalized(result)\n                    else ->\n                        durationOfMillisNormalized(result)\n                }\n            }\n            this.isInMillis() ->\n                addValuesMixedRanges(this.value, other.value)\n            else ->\n                addValuesMixedRanges(other.value, this.value)\n        }\n    }\n\n    private fun addValuesMixedRanges(thisMillis: Long, otherNanos: Long): Duration {\n        val otherMillis = nanosToMillis(otherNanos)\n        val resultMillis = thisMillis + otherMillis\n        return if (resultMillis in -MAX_NANOS_IN_MILLIS..MAX_NANOS_IN_MILLIS) {\n            val otherNanoRemainder = otherNanos - millisToNanos(otherMillis)\n            durationOfNanos(millisToNanos(resultMillis) + otherNanoRemainder)\n        } else {\n            durationOfMillis(resultMillis.coerceIn(-MAX_MILLIS, MAX_MILLIS))\n        }\n    }\n\n    /**\n     * Returns a duration whose value is the difference between this and [other] duration values.\n     *\n     * @throws IllegalArgumentException if the operation results in an undefined value for the given arguments,\n     * e.g. when subtracting infinite durations of the same sign.\n     */\n    public operator fun minus(other: Duration): Duration = this + (-other)\n\n    /**\n     * Returns a duration whose value is this duration value multiplied by the given [scale] number.\n     *\n     * @throws IllegalArgumentException if the operation results in an undefined value for the given arguments,\n     * e.g. when multiplying an infinite duration by zero.\n     */\n    public operator fun times(scale: Int): Duration {\n        if (isInfinite()) {\n            return when {\n                scale == 0 -> throw IllegalArgumentException(\"Multiplying infinite duration by zero yields an undefined result.\")\n                scale > 0 -> this\n                else -> -this\n            }\n        }\n        if (scale == 0) return ZERO\n\n        val value = value\n        val result = value * scale\n        return if (isInNanos()) {\n            if (value in (MAX_NANOS / Int.MIN_VALUE)..(-MAX_NANOS / Int.MIN_VALUE)) {\n                // can't overflow nanos range for any scale\n                durationOfNanos(result)\n            } else {\n                if (result / scale == value) {\n                    durationOfNanosNormalized(result)\n                } else {\n                    val millis = nanosToMillis(value)\n                    val remNanos = value - millisToNanos(millis)\n                    val resultMillis = millis * scale\n                    val totalMillis = resultMillis + nanosToMillis(remNanos * scale)\n                    if (resultMillis / scale == millis && totalMillis xor resultMillis >= 0) {\n                        durationOfMillis(totalMillis.coerceIn(-MAX_MILLIS..MAX_MILLIS))\n                    } else {\n                        if (value.sign * scale.sign > 0) INFINITE else NEG_INFINITE\n                    }\n                }\n            }\n        } else {\n            if (result / scale == value) {\n                durationOfMillis(result.coerceIn(-MAX_MILLIS..MAX_MILLIS))\n            } else {\n                if (value.sign * scale.sign > 0) INFINITE else NEG_INFINITE\n            }\n        }\n    }\n\n    /**\n     * Returns a duration whose value is this duration value multiplied by the given [scale] number.\n     *\n     * @throws IllegalArgumentException if the operation results in an undefined value for the given arguments,\n     * e.g. when multiplying an infinite duration by zero.\n     */\n    public operator fun times(scale: Double): Duration {\n        val intScale = scale.roundToInt()\n        if (intScale.toDouble() == scale) {\n            return times(intScale)\n        }\n\n        val unit = storageUnit\n        val result = toDouble(unit) * scale\n        return result.toDuration(unit)\n    }\n\n    /**\n     * Returns a duration whose value is this duration value divided by the given [scale] number.\n     *\n     * @throws IllegalArgumentException if the operation results in an undefined value for the given arguments,\n     * e.g. when dividing zero duration by zero.\n     */\n    public operator fun div(scale: Int): Duration {\n        if (scale == 0) {\n            return when {\n                isPositive() -> INFINITE\n                isNegative() -> NEG_INFINITE\n                else -> throw IllegalArgumentException(\"Dividing zero duration by zero yields an undefined result.\")\n            }\n        }\n        if (isInNanos()) {\n            return durationOfNanos(value / scale)\n        } else {\n            if (isInfinite())\n                return this * scale.sign\n\n            val result = value / scale\n\n            if (result in -MAX_NANOS_IN_MILLIS..MAX_NANOS_IN_MILLIS) {\n                val rem = millisToNanos(value - (result * scale)) / scale\n                return durationOfNanos(millisToNanos(result) + rem)\n            }\n            return durationOfMillis(result)\n        }\n    }\n\n    /**\n     * Returns a duration whose value is this duration value divided by the given [scale] number.\n     *\n     * @throws IllegalArgumentException if the operation results in an undefined value for the given arguments,\n     * e.g. when dividing an infinite duration by infinity or zero duration by zero.\n     */\n    public operator fun div(scale: Double): Duration {\n        val intScale = scale.roundToInt()\n        if (intScale.toDouble() == scale && intScale != 0) {\n            return div(intScale)\n        }\n\n        val unit = storageUnit\n        val result = toDouble(unit) / scale\n        return result.toDuration(unit)\n    }\n\n    /** Returns a number that is the ratio of this and [other] duration values. */\n    public operator fun div(other: Duration): Double {\n        val coarserUnit = maxOf(this.storageUnit, other.storageUnit)\n        return this.toDouble(coarserUnit) / other.toDouble(coarserUnit)\n    }\n\n    /** Returns true, if the duration value is less than zero. */\n    public fun isNegative(): Boolean = rawValue < 0\n\n    /** Returns true, if the duration value is greater than zero. */\n    public fun isPositive(): Boolean = rawValue > 0\n\n    /** Returns true, if the duration value is infinite. */\n    public fun isInfinite(): Boolean = rawValue == INFINITE.rawValue || rawValue == NEG_INFINITE.rawValue\n\n    /** Returns true, if the duration value is finite. */\n    public fun isFinite(): Boolean = !isInfinite()\n\n    /** Returns the absolute value of this value. The returned value is always non-negative. */\n    public val absoluteValue: Duration get() = if (isNegative()) -this else this\n\n    override fun compareTo(other: Duration): Int {\n        val compareBits = this.rawValue xor other.rawValue\n        if (compareBits < 0 || compareBits.toInt() and 1 == 0) // different signs or same sign/same range\n            return this.rawValue.compareTo(other.rawValue)\n        // same sign/different ranges\n        val r = this.unitDiscriminator - other.unitDiscriminator // compare ranges\n        return if (isNegative()) -r else r\n    }\n\n\n    // splitting to components\n\n    /**\n     * Splits this duration into days, hours, minutes, seconds, and nanoseconds and executes the given [action] with these components.\n     * The result of [action] is returned as the result of this function.\n     *\n     * - `nanoseconds` represents the whole number of nanoseconds in this duration, and its absolute value is less than 1_000_000_000;\n     * - `seconds` represents the whole number of seconds in this duration, and its absolute value is less than 60;\n     * - `minutes` represents the whole number of minutes in this duration, and its absolute value is less than 60;\n     * - `hours` represents the whole number of hours in this duration, and its absolute value is less than 24;\n     * - `days` represents the whole number of days in this duration.\n     *   If the value doesn't fit in [Int] range, i.e. it's greater than [Int.MAX_VALUE] or less than [Int.MIN_VALUE],\n     *   it is coerced into that range.\n     */\n    public inline fun <T> toComponents(action: (days: Int, hours: Int, minutes: Int, seconds: Int, nanoseconds: Int) -> T): T {\n        contract { callsInPlace(action, InvocationKind.EXACTLY_ONCE) }\n        return action(toInt(DurationUnit.DAYS), hoursComponent, minutesComponent, secondsComponent, nanosecondsComponent)\n    }\n\n    /**\n     * Splits this duration into hours, minutes, seconds, and nanoseconds and executes the given [action] with these components.\n     * The result of [action] is returned as the result of this function.\n     *\n     * - `nanoseconds` represents the whole number of nanoseconds in this duration, and its absolute value is less than 1_000_000_000;\n     * - `seconds` represents the whole number of seconds in this duration, and its absolute value is less than 60;\n     * - `minutes` represents the whole number of minutes in this duration, and its absolute value is less than 60;\n     * - `hours` represents the whole number of hours in this duration.\n     *   If the value doesn't fit in [Int] range, i.e. it's greater than [Int.MAX_VALUE] or less than [Int.MIN_VALUE],\n     *   it is coerced into that range.\n     */\n    public inline fun <T> toComponents(action: (hours: Int, minutes: Int, seconds: Int, nanoseconds: Int) -> T): T {\n        contract { callsInPlace(action, InvocationKind.EXACTLY_ONCE) }\n        return action(toInt(DurationUnit.HOURS), minutesComponent, secondsComponent, nanosecondsComponent)\n    }\n\n    /**\n     * Splits this duration into minutes, seconds, and nanoseconds and executes the given [action] with these components.\n     * The result of [action] is returned as the result of this function.\n     *\n     * - `nanoseconds` represents the whole number of nanoseconds in this duration, and its absolute value is less than 1_000_000_000;\n     * - `seconds` represents the whole number of seconds in this duration, and its absolute value is less than 60;\n     * - `minutes` represents the whole number of minutes in this duration.\n     *   If the value doesn't fit in [Int] range, i.e. it's greater than [Int.MAX_VALUE] or less than [Int.MIN_VALUE],\n     *   it is coerced into that range.\n     */\n    public inline fun <T> toComponents(action: (minutes: Int, seconds: Int, nanoseconds: Int) -> T): T {\n        contract { callsInPlace(action, InvocationKind.EXACTLY_ONCE) }\n        return action(toInt(DurationUnit.MINUTES), secondsComponent, nanosecondsComponent)\n    }\n\n    /**\n     * Splits this duration into seconds, and nanoseconds and executes the given [action] with these components.\n     * The result of [action] is returned as the result of this function.\n     *\n     * - `nanoseconds` represents the whole number of nanoseconds in this duration, and its absolute value is less than 1_000_000_000;\n     * - `seconds` represents the whole number of seconds in this duration.\n     *   If the value doesn't fit in [Long] range, i.e. it's greater than [Long.MAX_VALUE] or less than [Long.MIN_VALUE],\n     *   it is coerced into that range.\n     */\n    public inline fun <T> toComponents(action: (seconds: Long, nanoseconds: Int) -> T): T {\n        contract { callsInPlace(action, InvocationKind.EXACTLY_ONCE) }\n        return action(inWholeSeconds, nanosecondsComponent)\n    }\n\n    @PublishedApi\n    internal val hoursComponent: Int\n        get() = if (isInfinite()) 0 else (inWholeHours % 24).toInt()\n\n    @PublishedApi\n    internal val minutesComponent: Int\n        get() = if (isInfinite()) 0 else (inWholeMinutes % 60).toInt()\n\n    @PublishedApi\n    internal val secondsComponent: Int\n        get() = if (isInfinite()) 0 else (inWholeSeconds % 60).toInt()\n\n    @PublishedApi\n    internal val nanosecondsComponent: Int\n        get() = when {\n            isInfinite() -> 0\n            isInMillis() -> millisToNanos(value % 1_000).toInt()\n            else -> (value % 1_000_000_000).toInt()\n        }\n\n\n    // conversion to units\n\n    /**\n     * Returns the value of this duration expressed as a [Double] number of the specified [unit].\n     *\n     * An infinite duration value is converted either to [Double.POSITIVE_INFINITY] or [Double.NEGATIVE_INFINITY] depending on its sign.\n     */\n    public fun toDouble(unit: DurationUnit): Double {\n        return when (rawValue) {\n            INFINITE.rawValue -> Double.POSITIVE_INFINITY\n            NEG_INFINITE.rawValue -> Double.NEGATIVE_INFINITY\n            else -> {\n                // TODO: whether it's ok to convert to Double before scaling\n                convertDurationUnit(value.toDouble(), storageUnit, unit)\n            }\n        }\n    }\n\n    /**\n     * Returns the value of this duration expressed as a [Long] number of the specified [unit].\n     *\n     * If the result doesn't fit in the range of [Long] type, it is coerced into that range:\n     * - [Long.MIN_VALUE] is returned if it's less than `Long.MIN_VALUE`,\n     * - [Long.MAX_VALUE] is returned if it's greater than `Long.MAX_VALUE`.\n     *\n     * An infinite duration value is converted either to [Long.MAX_VALUE] or [Long.MIN_VALUE] depending on its sign.\n     */\n    public fun toLong(unit: DurationUnit): Long {\n        return when (rawValue) {\n            INFINITE.rawValue -> Long.MAX_VALUE\n            NEG_INFINITE.rawValue -> Long.MIN_VALUE\n            else -> convertDurationUnit(value, storageUnit, unit)\n        }\n    }\n\n    /**\n     * Returns the value of this duration expressed as an [Int] number of the specified [unit].\n     *\n     * If the result doesn't fit in the range of [Int] type, it is coerced into that range:\n     * - [Int.MIN_VALUE] is returned if it's less than `Int.MIN_VALUE`,\n     * - [Int.MAX_VALUE] is returned if it's greater than `Int.MAX_VALUE`.\n     *\n     * An infinite duration value is converted either to [Int.MAX_VALUE] or [Int.MIN_VALUE] depending on its sign.\n     */\n    public fun toInt(unit: DurationUnit): Int =\n        toLong(unit).coerceIn(Int.MIN_VALUE.toLong(), Int.MAX_VALUE.toLong()).toInt()\n\n    /** The value of this duration expressed as a [Double] number of days. */\n    @Deprecated(\"Use inWholeDays property instead or convert toDouble(DAYS) if a double value is required.\", ReplaceWith(\"toDouble(DurationUnit.DAYS)\"))\n    public val inDays: Double get() = toDouble(DurationUnit.DAYS)\n\n    /** The value of this duration expressed as a [Double] number of hours. */\n    @Deprecated(\"Use inWholeHours property instead or convert toDouble(HOURS) if a double value is required.\", ReplaceWith(\"toDouble(DurationUnit.HOURS)\"))\n    public val inHours: Double get() = toDouble(DurationUnit.HOURS)\n\n    /** The value of this duration expressed as a [Double] number of minutes. */\n    @Deprecated(\"Use inWholeMinutes property instead or convert toDouble(MINUTES) if a double value is required.\", ReplaceWith(\"toDouble(DurationUnit.MINUTES)\"))\n    public val inMinutes: Double get() = toDouble(DurationUnit.MINUTES)\n\n    /** The value of this duration expressed as a [Double] number of seconds. */\n    @Deprecated(\"Use inWholeSeconds property instead or convert toDouble(SECONDS) if a double value is required.\", ReplaceWith(\"toDouble(DurationUnit.SECONDS)\"))\n    public val inSeconds: Double get() = toDouble(DurationUnit.SECONDS)\n\n    /** The value of this duration expressed as a [Double] number of milliseconds. */\n    @Deprecated(\"Use inWholeMilliseconds property instead or convert toDouble(MILLISECONDS) if a double value is required.\", ReplaceWith(\"toDouble(DurationUnit.MILLISECONDS)\"))\n    public val inMilliseconds: Double get() = toDouble(DurationUnit.MILLISECONDS)\n\n    /** The value of this duration expressed as a [Double] number of microseconds. */\n    @Deprecated(\"Use inWholeMicroseconds property instead or convert toDouble(MICROSECONDS) if a double value is required.\", ReplaceWith(\"toDouble(DurationUnit.MICROSECONDS)\"))\n    public val inMicroseconds: Double get() = toDouble(DurationUnit.MICROSECONDS)\n\n    /** The value of this duration expressed as a [Double] number of nanoseconds. */\n    @Deprecated(\"Use inWholeNanoseconds property instead or convert toDouble(NANOSECONDS) if a double value is required.\", ReplaceWith(\"toDouble(DurationUnit.NANOSECONDS)\"))\n    public val inNanoseconds: Double get() = toDouble(DurationUnit.NANOSECONDS)\n\n\n    /**\n     * The value of this duration expressed as a [Long] number of days.\n     *\n     * An infinite duration value is converted either to [Long.MAX_VALUE] or [Long.MIN_VALUE] depending on its sign.\n     */\n    @SinceKotlin(\"1.5\")\n    public val inWholeDays: Long\n        get() = toLong(DurationUnit.DAYS)\n\n    /**\n     * The value of this duration expressed as a [Long] number of hours.\n     *\n     * An infinite duration value is converted either to [Long.MAX_VALUE] or [Long.MIN_VALUE] depending on its sign.\n     */\n    @SinceKotlin(\"1.5\")\n    public val inWholeHours: Long\n        get() = toLong(DurationUnit.HOURS)\n\n    /**\n     * The value of this duration expressed as a [Long] number of minutes.\n     *\n     * An infinite duration value is converted either to [Long.MAX_VALUE] or [Long.MIN_VALUE] depending on its sign.\n     */\n    @SinceKotlin(\"1.5\")\n    public val inWholeMinutes: Long\n        get() = toLong(DurationUnit.MINUTES)\n\n    /**\n     * The value of this duration expressed as a [Long] number of seconds.\n     *\n     * An infinite duration value is converted either to [Long.MAX_VALUE] or [Long.MIN_VALUE] depending on its sign.\n     */\n    @SinceKotlin(\"1.5\")\n    public val inWholeSeconds: Long\n        get() = toLong(DurationUnit.SECONDS)\n\n    /**\n     * The value of this duration expressed as a [Long] number of milliseconds.\n     *\n     * An infinite duration value is converted either to [Long.MAX_VALUE] or [Long.MIN_VALUE] depending on its sign.\n     */\n    @SinceKotlin(\"1.5\")\n    public val inWholeMilliseconds: Long\n        get() {\n            return if (isInMillis() && isFinite()) value else toLong(DurationUnit.MILLISECONDS)\n        }\n\n    /**\n     * The value of this duration expressed as a [Long] number of microseconds.\n     *\n     * If the result doesn't fit in the range of [Long] type, it is coerced into that range:\n     * - [Long.MIN_VALUE] is returned if it's less than `Long.MIN_VALUE`,\n     * - [Long.MAX_VALUE] is returned if it's greater than `Long.MAX_VALUE`.\n     *\n     * An infinite duration value is converted either to [Long.MAX_VALUE] or [Long.MIN_VALUE] depending on its sign.\n     */\n    @SinceKotlin(\"1.5\")\n    public val inWholeMicroseconds: Long\n        get() = toLong(DurationUnit.MICROSECONDS)\n\n    /**\n     * The value of this duration expressed as a [Long] number of nanoseconds.\n     *\n     * If the result doesn't fit in the range of [Long] type, it is coerced into that range:\n     * - [Long.MIN_VALUE] is returned if it's less than `Long.MIN_VALUE`,\n     * - [Long.MAX_VALUE] is returned if it's greater than `Long.MAX_VALUE`.\n     *\n     * An infinite duration value is converted either to [Long.MAX_VALUE] or [Long.MIN_VALUE] depending on its sign.\n     */\n    @SinceKotlin(\"1.5\")\n    public val inWholeNanoseconds: Long\n        get() {\n            val value = value\n            return when {\n                isInNanos() -> value\n                value > Long.MAX_VALUE / NANOS_IN_MILLIS -> Long.MAX_VALUE\n                value < Long.MIN_VALUE / NANOS_IN_MILLIS -> Long.MIN_VALUE\n                else -> millisToNanos(value)\n            }\n        }\n\n    // shortcuts\n\n    /**\n     * Returns the value of this duration expressed as a [Long] number of nanoseconds.\n     *\n     * If the value doesn't fit in the range of [Long] type, it is coerced into that range, see the conversion [Double.toLong] for details.\n     *\n     * The range of durations that can be expressed as a `Long` number of nanoseconds is approximately ±292 years.\n     */\n    @Deprecated(\"Use inWholeNanoseconds property instead.\", ReplaceWith(\"this.inWholeNanoseconds\"))\n    public fun toLongNanoseconds(): Long = inWholeNanoseconds\n\n    /**\n     * Returns the value of this duration expressed as a [Long] number of milliseconds.\n     *\n     * The value is coerced to the range of [Long] type, if it doesn't fit in that range, see the conversion [Double.toLong] for details.\n     *\n     * The range of durations that can be expressed as a `Long` number of milliseconds is approximately ±292 million years.\n     */\n    @Deprecated(\"Use inWholeMilliseconds property instead.\", ReplaceWith(\"this.inWholeMilliseconds\"))\n    public fun toLongMilliseconds(): Long = inWholeMilliseconds\n\n    /**\n     * Returns a string representation of this duration value expressed in the unit which yields the most compact and readable number value.\n     *\n     * Special cases:\n     *  - zero duration is formatted as `\"0s\"`\n     *  - the infinite duration is formatted as `\"Infinity\"` without unit\n     *  - very small durations (less than 1e-15 s) are expressed in seconds and formatted in scientific notation\n     *  - very big durations (more than 1e+7 days) are expressed in days and formatted in scientific notation\n     *\n     * @return the value of duration in the automatically determined unit followed by that unit abbreviated name: `d`, `h`, `m`, `s`, `ms`, `us`, or `ns`.\n     *\n     * @sample samples.time.Durations.toStringDefault\n     */\n    override fun toString(): String = when (rawValue) {\n        0L -> \"0s\"\n        INFINITE.rawValue -> \"Infinity\"\n        NEG_INFINITE.rawValue -> \"-Infinity\"\n        else -> {\n            val absNs = absoluteValue.toDouble(DurationUnit.NANOSECONDS)\n            var scientific = false\n            var maxDecimals = 0\n            val unit = when {\n                absNs < 1e-6 -> DurationUnit.SECONDS.also { scientific = true }\n                absNs < 1 -> DurationUnit.NANOSECONDS.also { maxDecimals = 7 }\n                absNs < 1e3 -> DurationUnit.NANOSECONDS\n                absNs < 1e6 -> DurationUnit.MICROSECONDS\n                absNs < 1e9 -> DurationUnit.MILLISECONDS\n                absNs < 1000e9 -> DurationUnit.SECONDS\n                absNs < 60_000e9 -> DurationUnit.MINUTES\n                absNs < 3600_000e9 -> DurationUnit.HOURS\n                absNs < 86400e9 * 1e7 -> DurationUnit.DAYS\n                else -> DurationUnit.DAYS.also { scientific = true }\n            }\n            val value = toDouble(unit)\n            when {\n                scientific -> formatScientific(value)\n                maxDecimals > 0 -> formatUpToDecimals(value, maxDecimals)\n                else -> formatToExactDecimals(value, precision(abs(value)))\n            } + unit.shortName()\n        }\n    }\n\n    private fun precision(value: Double): Int = when {\n        value < 1 -> 3\n        value < 10 -> 2\n        value < 100 -> 1\n        else -> 0\n    }\n\n    /**\n     * Returns a string representation of this duration value expressed in the given [unit]\n     * and formatted with the specified [decimals] number of digits after decimal point.\n     *\n     * Special cases:\n     *  - the infinite duration is formatted as `\"Infinity\"` without unit\n     *\n     * @return the value of duration in the specified [unit] followed by that unit abbreviated name: `d`, `h`, `m`, `s`, `ms`, `us`, or `ns`.\n     *\n     * @throws IllegalArgumentException if [decimals] is less than zero.\n     *\n     * @sample samples.time.Durations.toStringDecimals\n     */\n    public fun toString(unit: DurationUnit, decimals: Int = 0): String {\n        require(decimals >= 0) { \"decimals must be not negative, but was $decimals\" }\n        val number = toDouble(unit)\n        if (number.isInfinite()) return number.toString()\n        return when {\n            abs(number) < 1e14 -> formatToExactDecimals(number, decimals.coerceAtMost(12))\n            else -> formatScientific(number)\n        } + unit.shortName()\n    }\n\n\n    /**\n     * Returns an ISO-8601 based string representation of this duration.\n     *\n     * The returned value is presented in the format `PThHmMs.fS`, where `h`, `m`, `s` are the integer components of this duration (see [toComponents])\n     * and `f` is a fractional part of second. Depending on the roundness of the value the fractional part can be formatted with either\n     * 0, 3, 6, or 9 decimal digits.\n     *\n     * If the hours component absolute value of this duration is greater than [Int.MAX_VALUE], it is replaced with [Int.MAX_VALUE],\n     * so the infinite duration is formatted as `\"PT2147483647H\".\n     *\n     * Negative durations are indicated with the sign `-` in the beginning of the returned string, for example, `\"-PT5M30S\"`.\n     *\n     * @sample samples.time.Durations.toIsoString\n     */\n    @OptIn(ExperimentalStdlibApi::class)\n    public fun toIsoString(): String = buildString {\n        if (isNegative()) append('-')\n        append(\"PT\")\n        absoluteValue.toComponents { hours, minutes, seconds, nanoseconds ->\n            val hasHours = hours != 0\n            val hasSeconds = seconds != 0 || nanoseconds != 0\n            val hasMinutes = minutes != 0 || (hasSeconds && hasHours)\n            if (hasHours) {\n                append(hours).append('H')\n            }\n            if (hasMinutes) {\n                append(minutes).append('M')\n            }\n            if (hasSeconds || (!hasHours && !hasMinutes)) {\n                append(seconds)\n                if (nanoseconds != 0) {\n                    append('.')\n                    val nss = nanoseconds.toString().padStart(9, '0')\n                    when {\n                        nanoseconds % 1_000_000 == 0 -> appendRange(nss, 0, 3)\n                        nanoseconds % 1_000 == 0 -> appendRange(nss, 0, 6)\n                        else -> append(nss)\n                    }\n                }\n                append('S')\n            }\n        }\n    }\n\n}\n\n// constructing from number of units\n// extension functions\n\n/** Returns a [Duration] equal to this [Int] number of the specified [unit]. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic fun Int.toDuration(unit: DurationUnit): Duration {\n    return if (unit <= DurationUnit.SECONDS) {\n        durationOfNanos(convertDurationUnitOverflow(this.toLong(), unit, DurationUnit.NANOSECONDS))\n    } else\n        toLong().toDuration(unit)\n}\n\n/** Returns a [Duration] equal to this [Long] number of the specified [unit]. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic fun Long.toDuration(unit: DurationUnit): Duration {\n    val maxNsInUnit = convertDurationUnitOverflow(MAX_NANOS, DurationUnit.NANOSECONDS, unit)\n    if (this in -maxNsInUnit..maxNsInUnit) {\n        return durationOfNanos(convertDurationUnitOverflow(this, unit, DurationUnit.NANOSECONDS))\n    } else {\n        val millis = convertDurationUnit(this, unit, DurationUnit.MILLISECONDS)\n        return durationOfMillis(millis.coerceIn(-MAX_MILLIS, MAX_MILLIS))\n    }\n}\n\n/**\n * Returns a [Duration] equal to this [Double] number of the specified [unit].\n *\n * @throws IllegalArgumentException if this `Double` value is `NaN`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic fun Double.toDuration(unit: DurationUnit): Duration {\n    val valueInNs = convertDurationUnit(this, unit, DurationUnit.NANOSECONDS)\n    require(!valueInNs.isNaN()) { \"Duration value cannot be NaN.\" }\n    val nanos = valueInNs.toLong()\n    return if (nanos in -MAX_NANOS..MAX_NANOS) {\n        durationOfNanos(nanos)\n    } else {\n        val millis = convertDurationUnit(this, unit, DurationUnit.MILLISECONDS).toLong()\n        durationOfMillisNormalized(millis)\n    }\n}\n\n// constructing from number of units\n// extension properties\n\n/** Returns a [Duration] equal to this [Int] number of nanoseconds. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use Duration.nanoseconds() function instead.\", ReplaceWith(\"Duration.nanoseconds(this)\", \"kotlin.time.Duration\"))\npublic val Int.nanoseconds get() = toDuration(DurationUnit.NANOSECONDS)\n\n/** Returns a [Duration] equal to this [Long] number of nanoseconds. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use Duration.nanoseconds() function instead.\", ReplaceWith(\"Duration.nanoseconds(this)\", \"kotlin.time.Duration\"))\npublic val Long.nanoseconds get() = toDuration(DurationUnit.NANOSECONDS)\n\n/**\n * Returns a [Duration] equal to this [Double] number of nanoseconds.\n *\n * @throws IllegalArgumentException if this `Double` value is `NaN`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use Duration.nanoseconds() function instead.\", ReplaceWith(\"Duration.nanoseconds(this)\", \"kotlin.time.Duration\"))\npublic val Double.nanoseconds get() = toDuration(DurationUnit.NANOSECONDS)\n\n/** Returns a [Duration] equal to this [Int] number of microseconds. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use Duration.microseconds() function instead.\", ReplaceWith(\"Duration.microseconds(this)\", \"kotlin.time.Duration\"))\npublic val Int.microseconds get() = toDuration(DurationUnit.MICROSECONDS)\n\n/** Returns a [Duration] equal to this [Long] number of microseconds. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use Duration.microseconds() function instead.\", ReplaceWith(\"Duration.microseconds(this)\", \"kotlin.time.Duration\"))\npublic val Long.microseconds get() = toDuration(DurationUnit.MICROSECONDS)\n\n/**\n * Returns a [Duration] equal to this [Double] number of microseconds.\n *\n * @throws IllegalArgumentException if this `Double` value is `NaN`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use Duration.microseconds() function instead.\", ReplaceWith(\"Duration.microseconds(this)\", \"kotlin.time.Duration\"))\npublic val Double.microseconds get() = toDuration(DurationUnit.MICROSECONDS)\n\n/** Returns a [Duration] equal to this [Int] number of milliseconds. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use Duration.milliseconds() function instead.\", ReplaceWith(\"Duration.milliseconds(this)\", \"kotlin.time.Duration\"))\npublic val Int.milliseconds get() = toDuration(DurationUnit.MILLISECONDS)\n\n/** Returns a [Duration] equal to this [Long] number of milliseconds. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use Duration.milliseconds() function instead.\", ReplaceWith(\"Duration.milliseconds(this)\", \"kotlin.time.Duration\"))\npublic val Long.milliseconds get() = toDuration(DurationUnit.MILLISECONDS)\n\n/**\n * Returns a [Duration] equal to this [Double] number of milliseconds.\n *\n * @throws IllegalArgumentException if this `Double` value is `NaN`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use Duration.milliseconds() function instead.\", ReplaceWith(\"Duration.milliseconds(this)\", \"kotlin.time.Duration\"))\npublic val Double.milliseconds get() = toDuration(DurationUnit.MILLISECONDS)\n\n/** Returns a [Duration] equal to this [Int] number of seconds. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use Duration.seconds() function instead.\", ReplaceWith(\"Duration.seconds(this)\", \"kotlin.time.Duration\"))\npublic val Int.seconds get() = toDuration(DurationUnit.SECONDS)\n\n/** Returns a [Duration] equal to this [Long] number of seconds. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use Duration.seconds() function instead.\", ReplaceWith(\"Duration.seconds(this)\", \"kotlin.time.Duration\"))\npublic val Long.seconds get() = toDuration(DurationUnit.SECONDS)\n\n/**\n * Returns a [Duration] equal to this [Double] number of seconds.\n *\n * @throws IllegalArgumentException if this `Double` value is `NaN`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use Duration.seconds() function instead.\", ReplaceWith(\"Duration.seconds(this)\", \"kotlin.time.Duration\"))\npublic val Double.seconds get() = toDuration(DurationUnit.SECONDS)\n\n/** Returns a [Duration] equal to this [Int] number of minutes. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use Duration.minutes() function instead.\", ReplaceWith(\"Duration.minutes(this)\", \"kotlin.time.Duration\"))\npublic val Int.minutes get() = toDuration(DurationUnit.MINUTES)\n\n/** Returns a [Duration] equal to this [Long] number of minutes. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use Duration.minutes() function instead.\", ReplaceWith(\"Duration.minutes(this)\", \"kotlin.time.Duration\"))\npublic val Long.minutes get() = toDuration(DurationUnit.MINUTES)\n\n/**\n * Returns a [Duration] equal to this [Double] number of minutes.\n *\n * @throws IllegalArgumentException if this `Double` value is `NaN`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use Duration.minutes() function instead.\", ReplaceWith(\"Duration.minutes(this)\", \"kotlin.time.Duration\"))\npublic val Double.minutes get() = toDuration(DurationUnit.MINUTES)\n\n/** Returns a [Duration] equal to this [Int] number of hours. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use Duration.hours() function instead.\", ReplaceWith(\"Duration.hours(this)\", \"kotlin.time.Duration\"))\npublic val Int.hours get() = toDuration(DurationUnit.HOURS)\n\n/** Returns a [Duration] equal to this [Long] number of hours. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use Duration.hours() function instead.\", ReplaceWith(\"Duration.hours(this)\", \"kotlin.time.Duration\"))\npublic val Long.hours get() = toDuration(DurationUnit.HOURS)\n\n/**\n * Returns a [Duration] equal to this [Double] number of hours.\n *\n * @throws IllegalArgumentException if this `Double` value is `NaN`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use Duration.hours() function instead.\", ReplaceWith(\"Duration.hours(this)\", \"kotlin.time.Duration\"))\npublic val Double.hours get() = toDuration(DurationUnit.HOURS)\n\n/** Returns a [Duration] equal to this [Int] number of days. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use Duration.days() function instead.\", ReplaceWith(\"Duration.days(this)\", \"kotlin.time.Duration\"))\npublic val Int.days get() = toDuration(DurationUnit.DAYS)\n\n/** Returns a [Duration] equal to this [Long] number of days. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use Duration.days() function instead.\", ReplaceWith(\"Duration.days(this)\", \"kotlin.time.Duration\"))\npublic val Long.days get() = toDuration(DurationUnit.DAYS)\n\n/**\n * Returns a [Duration] equal to this [Double] number of days.\n *\n * @throws IllegalArgumentException if this `Double` value is `NaN`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use Duration.days() function instead.\", ReplaceWith(\"Duration.days(this)\", \"kotlin.time.Duration\"))\npublic val Double.days get() = toDuration(DurationUnit.DAYS)\n\n\n/** Returns a duration whose value is the specified [duration] value multiplied by this number. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@kotlin.internal.InlineOnly\npublic inline operator fun Int.times(duration: Duration): Duration = duration * this\n\n/**\n * Returns a duration whose value is the specified [duration] value multiplied by this number.\n *\n * @throws IllegalArgumentException if the operation results in a `NaN` value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@kotlin.internal.InlineOnly\npublic inline operator fun Double.times(duration: Duration): Duration = duration * this\n\n\n// The ranges are chosen so that they are:\n// - symmetric relative to zero: this greatly simplifies operations with sign, e.g. unaryMinus and minus.\n// - non-overlapping, but adjacent: the first value that doesn't fit in nanos range, can be exactly represented in millis.\n\ninternal const val NANOS_IN_MILLIS = 1_000_000\n// maximum number duration can store in nanosecond range\ninternal const val MAX_NANOS = Long.MAX_VALUE / 2 / NANOS_IN_MILLIS * NANOS_IN_MILLIS - 1 // ends in ..._999_999\n// maximum number duration can store in millisecond range, also encodes an infinite value\ninternal const val MAX_MILLIS = Long.MAX_VALUE / 2\n// MAX_NANOS expressed in milliseconds\nprivate const val MAX_NANOS_IN_MILLIS = MAX_NANOS / NANOS_IN_MILLIS\n\nprivate fun nanosToMillis(nanos: Long): Long = nanos / NANOS_IN_MILLIS\nprivate fun millisToNanos(millis: Long): Long = millis * NANOS_IN_MILLIS\n\n@ExperimentalTime private fun durationOfNanos(normalNanos: Long) = Duration(normalNanos shl 1)\n@ExperimentalTime private fun durationOfMillis(normalMillis: Long) = Duration((normalMillis shl 1) + 1)\n@ExperimentalTime private fun durationOf(normalValue: Long, unitDiscriminator: Int) = Duration((normalValue shl 1) + unitDiscriminator)\n@ExperimentalTime private fun durationOfNanosNormalized(nanos: Long) =\n    if (nanos in -MAX_NANOS..MAX_NANOS) {\n        durationOfNanos(nanos)\n    } else {\n        durationOfMillis(nanosToMillis(nanos))\n    }\n\n@ExperimentalTime private fun durationOfMillisNormalized(millis: Long) =\n    if (millis in -MAX_NANOS_IN_MILLIS..MAX_NANOS_IN_MILLIS) {\n        durationOfNanos(millisToNanos(millis))\n    } else {\n        durationOfMillis(millis.coerceIn(-MAX_MILLIS, MAX_MILLIS))\n    }\n\n\ninternal expect fun formatToExactDecimals(value: Double, decimals: Int): String\ninternal expect fun formatUpToDecimals(value: Double, decimals: Int): String\ninternal expect fun formatScientific(value: Double): String","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n@file:kotlin.jvm.JvmName(\"UnsignedKt\")\npackage kotlin\n\n@PublishedApi\ninternal fun uintCompare(v1: Int, v2: Int): Int = (v1 xor Int.MIN_VALUE).compareTo(v2 xor Int.MIN_VALUE)\n@PublishedApi\ninternal fun ulongCompare(v1: Long, v2: Long): Int = (v1 xor Long.MIN_VALUE).compareTo(v2 xor Long.MIN_VALUE)\n\n@PublishedApi\ninternal fun uintDivide(v1: UInt, v2: UInt): UInt = (v1.toLong() / v2.toLong()).toUInt()\n@PublishedApi\ninternal fun uintRemainder(v1: UInt, v2: UInt): UInt = (v1.toLong() % v2.toLong()).toUInt()\n\n// Division and remainder are based on Guava's UnsignedLongs implementation\n// Copyright 2011 The Guava Authors\n\n@PublishedApi\ninternal fun ulongDivide(v1: ULong, v2: ULong): ULong {\n    val dividend = v1.toLong()\n    val divisor = v2.toLong()\n    if (divisor < 0) { // i.e., divisor >= 2^63:\n        return if (v1 < v2) ULong(0) else ULong(1)\n    }\n\n    // Optimization - use signed division if both dividend and divisor < 2^63\n    if (dividend >= 0) {\n        return ULong(dividend / divisor)\n    }\n\n    // Otherwise, approximate the quotient, check, and correct if necessary.\n    val quotient = ((dividend ushr 1) / divisor) shl 1\n    val rem = dividend - quotient * divisor\n    return ULong(quotient + if (ULong(rem) >= ULong(divisor)) 1 else 0)\n\n}\n\n@PublishedApi\ninternal fun ulongRemainder(v1: ULong, v2: ULong): ULong {\n    val dividend = v1.toLong()\n    val divisor = v2.toLong()\n    if (divisor < 0) { // i.e., divisor >= 2^63:\n        return if (v1 < v2) {\n            v1 // dividend < divisor\n        } else {\n            v1 - v2 // dividend >= divisor\n        }\n    }\n\n    // Optimization - use signed modulus if both dividend and divisor < 2^63\n    if (dividend >= 0) {\n        return ULong(dividend % divisor)\n    }\n\n    // Otherwise, approximate the quotient, check, and correct if necessary.\n    val quotient = ((dividend ushr 1) / divisor) shl 1\n    val rem = dividend - quotient * divisor\n    return ULong(rem - if (ULong(rem) >= ULong(divisor)) divisor else 0)\n}\n\n@PublishedApi\ninternal fun doubleToUInt(v: Double): UInt = when {\n    v.isNaN() -> 0u\n    v <= UInt.MIN_VALUE.toDouble() -> UInt.MIN_VALUE\n    v >= UInt.MAX_VALUE.toDouble() -> UInt.MAX_VALUE\n    v <= Int.MAX_VALUE -> v.toInt().toUInt()\n    else -> (v - Int.MAX_VALUE).toInt().toUInt() + Int.MAX_VALUE.toUInt()      // Int.MAX_VALUE < v < UInt.MAX_VALUE\n}\n\n@PublishedApi\ninternal fun doubleToULong(v: Double): ULong = when {\n    v.isNaN() -> 0u\n    v <= ULong.MIN_VALUE.toDouble() -> ULong.MIN_VALUE\n    v >= ULong.MAX_VALUE.toDouble() -> ULong.MAX_VALUE\n    v < Long.MAX_VALUE -> v.toLong().toULong()\n\n    // Real values from Long.MAX_VALUE to (Long.MAX_VALUE + 1) are not representable in Double, so don't handle them.\n    else -> (v - 9223372036854775808.0).toLong().toULong() + 9223372036854775808uL      // Long.MAX_VALUE + 1 < v < ULong.MAX_VALUE\n}\n\n\n@PublishedApi\ninternal fun uintToDouble(v: Int): Double = (v and Int.MAX_VALUE).toDouble() + (v ushr 31 shl 30).toDouble() * 2\n\n@PublishedApi\ninternal fun ulongToDouble(v: Long): Double = (v ushr 11).toDouble() * 2048 + (v and 2047)\n\n\ninternal fun ulongToString(v: Long): String = ulongToString(v, 10)\n\ninternal fun ulongToString(v: Long, base: Int): String {\n    if (v >= 0) return v.toString(base)\n\n    var quotient = ((v ushr 1) / base) shl 1\n    var rem = v - quotient * base\n    if (rem >= base) {\n        rem -= base\n        quotient += 1\n    }\n    return quotient.toString(base) + rem.toString(base)\n}\n\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"SequencesKt\")\n\npackage kotlin.sequences\n\nimport kotlin.random.Random\n\n/**\n * Given an [iterator] function constructs a [Sequence] that returns values through the [Iterator]\n * provided by that function.\n * The values are evaluated lazily, and the sequence is potentially infinite.\n *\n * @sample samples.collections.Sequences.Building.sequenceFromIterator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence(crossinline iterator: () -> Iterator<T>): Sequence<T> = object : Sequence<T> {\n    override fun iterator(): Iterator<T> = iterator()\n}\n\n/**\n * Creates a sequence that returns all elements from this iterator. The sequence is constrained to be iterated only once.\n *\n * @sample samples.collections.Sequences.Building.sequenceFromIterator\n */\npublic fun <T> Iterator<T>.asSequence(): Sequence<T> = Sequence { this }.constrainOnce()\n\n/**\n * Creates a sequence that returns the specified values.\n *\n * @sample samples.collections.Sequences.Building.sequenceOfValues\n */\npublic fun <T> sequenceOf(vararg elements: T): Sequence<T> = if (elements.isEmpty()) emptySequence() else elements.asSequence()\n\n/**\n * Returns an empty sequence.\n */\npublic fun <T> emptySequence(): Sequence<T> = EmptySequence\n\nprivate object EmptySequence : Sequence<Nothing>, DropTakeSequence<Nothing> {\n    override fun iterator(): Iterator<Nothing> = EmptyIterator\n    override fun drop(n: Int) = EmptySequence\n    override fun take(n: Int) = EmptySequence\n}\n\n/**\n * Returns this sequence if it's not `null` and the empty sequence otherwise.\n * @sample samples.collections.Sequences.Usage.sequenceOrEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>?.orEmpty(): Sequence<T> = this ?: emptySequence()\n\n\n/**\n * Returns a sequence that iterates through the elements either of this sequence\n * or, if this sequence turns out to be empty, of the sequence returned by [defaultValue] function.\n *\n * @sample samples.collections.Sequences.Usage.sequenceIfEmpty\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> Sequence<T>.ifEmpty(defaultValue: () -> Sequence<T>): Sequence<T> = sequence {\n    val iterator = this@ifEmpty.iterator()\n    if (iterator.hasNext()) {\n        yieldAll(iterator)\n    } else {\n        yieldAll(defaultValue())\n    }\n}\n\n/**\n * Returns a sequence of all elements from all sequences in this sequence.\n *\n * The operation is _intermediate_ and _stateless_.\n *\n * @sample samples.collections.Sequences.Transformations.flattenSequenceOfSequences\n */\npublic fun <T> Sequence<Sequence<T>>.flatten(): Sequence<T> = flatten { it.iterator() }\n\n/**\n * Returns a sequence of all elements from all iterables in this sequence.\n *\n * The operation is _intermediate_ and _stateless_.\n *\n * @sample samples.collections.Sequences.Transformations.flattenSequenceOfLists\n */\n@kotlin.jvm.JvmName(\"flattenSequenceOfIterable\")\npublic fun <T> Sequence<Iterable<T>>.flatten(): Sequence<T> = flatten { it.iterator() }\n\nprivate fun <T, R> Sequence<T>.flatten(iterator: (T) -> Iterator<R>): Sequence<R> {\n    if (this is TransformingSequence<*, *>) {\n        return (this as TransformingSequence<*, T>).flatten(iterator)\n    }\n    return FlatteningSequence(this, { it }, iterator)\n}\n\n/**\n * Returns a pair of lists, where\n * *first* list is built from the first values of each pair from this sequence,\n * *second* list is built from the second values of each pair from this sequence.\n *\n * The operation is _terminal_.\n *\n * @sample samples.collections.Sequences.Transformations.unzip\n */\npublic fun <T, R> Sequence<Pair<T, R>>.unzip(): Pair<List<T>, List<R>> {\n    val listT = ArrayList<T>()\n    val listR = ArrayList<R>()\n    for (pair in this) {\n        listT.add(pair.first)\n        listR.add(pair.second)\n    }\n    return listT to listR\n}\n\n/**\n * Returns a sequence that yields elements of this sequence randomly shuffled.\n *\n * Note that every iteration of the sequence returns elements in a different order.\n *\n * The operation is _intermediate_ and _stateful_.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Sequence<T>.shuffled(): Sequence<T> = shuffled(Random)\n\n/**\n * Returns a sequence that yields elements of this sequence randomly shuffled\n * using the specified [random] instance as the source of randomness.\n *\n * Note that every iteration of the sequence returns elements in a different order.\n *\n * The operation is _intermediate_ and _stateful_.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Sequence<T>.shuffled(random: Random): Sequence<T> = sequence<T> {\n    val buffer = toMutableList()\n    while (buffer.isNotEmpty()) {\n        val j = random.nextInt(buffer.size)\n        val last = @OptIn(ExperimentalStdlibApi::class) buffer.removeLast()\n        val value = if (j < buffer.size) buffer.set(j, last) else last\n        yield(value)\n    }\n}\n\n\n/**\n * A sequence that returns the values from the underlying [sequence] that either match or do not match\n * the specified [predicate].\n *\n * @param sendWhen If `true`, values for which the predicate returns `true` are returned. Otherwise,\n * values for which the predicate returns `false` are returned\n */\ninternal class FilteringSequence<T>(\n    private val sequence: Sequence<T>,\n    private val sendWhen: Boolean = true,\n    private val predicate: (T) -> Boolean\n) : Sequence<T> {\n\n    override fun iterator(): Iterator<T> = object : Iterator<T> {\n        val iterator = sequence.iterator()\n        var nextState: Int = -1 // -1 for unknown, 0 for done, 1 for continue\n        var nextItem: T? = null\n\n        private fun calcNext() {\n            while (iterator.hasNext()) {\n                val item = iterator.next()\n                if (predicate(item) == sendWhen) {\n                    nextItem = item\n                    nextState = 1\n                    return\n                }\n            }\n            nextState = 0\n        }\n\n        override fun next(): T {\n            if (nextState == -1)\n                calcNext()\n            if (nextState == 0)\n                throw NoSuchElementException()\n            val result = nextItem\n            nextItem = null\n            nextState = -1\n            @Suppress(\"UNCHECKED_CAST\")\n            return result as T\n        }\n\n        override fun hasNext(): Boolean {\n            if (nextState == -1)\n                calcNext()\n            return nextState == 1\n        }\n    }\n}\n\n/**\n * A sequence which returns the results of applying the given [transformer] function to the values\n * in the underlying [sequence].\n */\n\ninternal class TransformingSequence<T, R>\nconstructor(private val sequence: Sequence<T>, private val transformer: (T) -> R) : Sequence<R> {\n    override fun iterator(): Iterator<R> = object : Iterator<R> {\n        val iterator = sequence.iterator()\n        override fun next(): R {\n            return transformer(iterator.next())\n        }\n\n        override fun hasNext(): Boolean {\n            return iterator.hasNext()\n        }\n    }\n\n    internal fun <E> flatten(iterator: (R) -> Iterator<E>): Sequence<E> {\n        return FlatteningSequence<T, R, E>(sequence, transformer, iterator)\n    }\n}\n\n/**\n * A sequence which returns the results of applying the given [transformer] function to the values\n * in the underlying [sequence], where the transformer function takes the index of the value in the underlying\n * sequence along with the value itself.\n */\ninternal class TransformingIndexedSequence<T, R>\nconstructor(private val sequence: Sequence<T>, private val transformer: (Int, T) -> R) : Sequence<R> {\n    override fun iterator(): Iterator<R> = object : Iterator<R> {\n        val iterator = sequence.iterator()\n        var index = 0\n        override fun next(): R {\n            return transformer(checkIndexOverflow(index++), iterator.next())\n        }\n\n        override fun hasNext(): Boolean {\n            return iterator.hasNext()\n        }\n    }\n}\n\n/**\n * A sequence which combines values from the underlying [sequence] with their indices and returns them as\n * [IndexedValue] objects.\n */\ninternal class IndexingSequence<T>\nconstructor(private val sequence: Sequence<T>) : Sequence<IndexedValue<T>> {\n    override fun iterator(): Iterator<IndexedValue<T>> = object : Iterator<IndexedValue<T>> {\n        val iterator = sequence.iterator()\n        var index = 0\n        override fun next(): IndexedValue<T> {\n            return IndexedValue(checkIndexOverflow(index++), iterator.next())\n        }\n\n        override fun hasNext(): Boolean {\n            return iterator.hasNext()\n        }\n    }\n}\n\n/**\n * A sequence which takes the values from two parallel underlying sequences, passes them to the given\n * [transform] function and returns the values returned by that function. The sequence stops returning\n * values as soon as one of the underlying sequences stops returning values.\n */\ninternal class MergingSequence<T1, T2, V>\nconstructor(\n    private val sequence1: Sequence<T1>,\n    private val sequence2: Sequence<T2>,\n    private val transform: (T1, T2) -> V\n) : Sequence<V> {\n    override fun iterator(): Iterator<V> = object : Iterator<V> {\n        val iterator1 = sequence1.iterator()\n        val iterator2 = sequence2.iterator()\n        override fun next(): V {\n            return transform(iterator1.next(), iterator2.next())\n        }\n\n        override fun hasNext(): Boolean {\n            return iterator1.hasNext() && iterator2.hasNext()\n        }\n    }\n}\n\ninternal class FlatteningSequence<T, R, E>\nconstructor(\n    private val sequence: Sequence<T>,\n    private val transformer: (T) -> R,\n    private val iterator: (R) -> Iterator<E>\n) : Sequence<E> {\n    override fun iterator(): Iterator<E> = object : Iterator<E> {\n        val iterator = sequence.iterator()\n        var itemIterator: Iterator<E>? = null\n\n        override fun next(): E {\n            if (!ensureItemIterator())\n                throw NoSuchElementException()\n            return itemIterator!!.next()\n        }\n\n        override fun hasNext(): Boolean {\n            return ensureItemIterator()\n        }\n\n        private fun ensureItemIterator(): Boolean {\n            if (itemIterator?.hasNext() == false)\n                itemIterator = null\n\n            while (itemIterator == null) {\n                if (!iterator.hasNext()) {\n                    return false\n                } else {\n                    val element = iterator.next()\n                    val nextItemIterator = iterator(transformer(element))\n                    if (nextItemIterator.hasNext()) {\n                        itemIterator = nextItemIterator\n                        return true\n                    }\n                }\n            }\n            return true\n        }\n    }\n}\n\ninternal fun <T, C, R> flatMapIndexed(source: Sequence<T>, transform: (Int, T) -> C, iterator: (C) -> Iterator<R>): Sequence<R> =\n    sequence {\n        var index = 0\n        for (element in source) {\n            val result = transform(checkIndexOverflow(index++), element)\n            yieldAll(iterator(result))\n        }\n    }\n\n/**\n * A sequence that supports drop(n) and take(n) operations\n */\ninternal interface DropTakeSequence<T> : Sequence<T> {\n    fun drop(n: Int): Sequence<T>\n    fun take(n: Int): Sequence<T>\n}\n\n/**\n * A sequence that skips [startIndex] values from the underlying [sequence]\n * and stops returning values right before [endIndex], i.e. stops at `endIndex - 1`\n */\ninternal class SubSequence<T>(\n    private val sequence: Sequence<T>,\n    private val startIndex: Int,\n    private val endIndex: Int\n) : Sequence<T>, DropTakeSequence<T> {\n\n    init {\n        require(startIndex >= 0) { \"startIndex should be non-negative, but is $startIndex\" }\n        require(endIndex >= 0) { \"endIndex should be non-negative, but is $endIndex\" }\n        require(endIndex >= startIndex) { \"endIndex should be not less than startIndex, but was $endIndex < $startIndex\" }\n    }\n\n    private val count: Int get() = endIndex - startIndex\n\n    override fun drop(n: Int): Sequence<T> = if (n >= count) emptySequence() else SubSequence(sequence, startIndex + n, endIndex)\n    override fun take(n: Int): Sequence<T> = if (n >= count) this else SubSequence(sequence, startIndex, startIndex + n)\n\n    override fun iterator() = object : Iterator<T> {\n\n        val iterator = sequence.iterator()\n        var position = 0\n\n        // Shouldn't be called from constructor to avoid premature iteration\n        private fun drop() {\n            while (position < startIndex && iterator.hasNext()) {\n                iterator.next()\n                position++\n            }\n        }\n\n        override fun hasNext(): Boolean {\n            drop()\n            return (position < endIndex) && iterator.hasNext()\n        }\n\n        override fun next(): T {\n            drop()\n            if (position >= endIndex)\n                throw NoSuchElementException()\n            position++\n            return iterator.next()\n        }\n    }\n}\n\n/**\n * A sequence that returns at most [count] values from the underlying [sequence], and stops returning values\n * as soon as that count is reached.\n */\ninternal class TakeSequence<T>(\n    private val sequence: Sequence<T>,\n    private val count: Int\n) : Sequence<T>, DropTakeSequence<T> {\n\n    init {\n        require(count >= 0) { \"count must be non-negative, but was $count.\" }\n    }\n\n    override fun drop(n: Int): Sequence<T> = if (n >= count) emptySequence() else SubSequence(sequence, n, count)\n    override fun take(n: Int): Sequence<T> = if (n >= count) this else TakeSequence(sequence, n)\n\n    override fun iterator(): Iterator<T> = object : Iterator<T> {\n        var left = count\n        val iterator = sequence.iterator()\n\n        override fun next(): T {\n            if (left == 0)\n                throw NoSuchElementException()\n            left--\n            return iterator.next()\n        }\n\n        override fun hasNext(): Boolean {\n            return left > 0 && iterator.hasNext()\n        }\n    }\n}\n\n/**\n * A sequence that returns values from the underlying [sequence] while the [predicate] function returns\n * `true`, and stops returning values once the function returns `false` for the next element.\n */\ninternal class TakeWhileSequence<T>\nconstructor(\n    private val sequence: Sequence<T>,\n    private val predicate: (T) -> Boolean\n) : Sequence<T> {\n    override fun iterator(): Iterator<T> = object : Iterator<T> {\n        val iterator = sequence.iterator()\n        var nextState: Int = -1 // -1 for unknown, 0 for done, 1 for continue\n        var nextItem: T? = null\n\n        private fun calcNext() {\n            if (iterator.hasNext()) {\n                val item = iterator.next()\n                if (predicate(item)) {\n                    nextState = 1\n                    nextItem = item\n                    return\n                }\n            }\n            nextState = 0\n        }\n\n        override fun next(): T {\n            if (nextState == -1)\n                calcNext() // will change nextState\n            if (nextState == 0)\n                throw NoSuchElementException()\n            @Suppress(\"UNCHECKED_CAST\")\n            val result = nextItem as T\n\n            // Clean next to avoid keeping reference on yielded instance\n            nextItem = null\n            nextState = -1\n            return result\n        }\n\n        override fun hasNext(): Boolean {\n            if (nextState == -1)\n                calcNext() // will change nextState\n            return nextState == 1\n        }\n    }\n}\n\n/**\n * A sequence that skips the specified number of values from the underlying [sequence] and returns\n * all values after that.\n */\ninternal class DropSequence<T>(\n    private val sequence: Sequence<T>,\n    private val count: Int\n) : Sequence<T>, DropTakeSequence<T> {\n    init {\n        require(count >= 0) { \"count must be non-negative, but was $count.\" }\n    }\n\n    override fun drop(n: Int): Sequence<T> = (count + n).let { n1 -> if (n1 < 0) DropSequence(this, n) else DropSequence(sequence, n1) }\n    override fun take(n: Int): Sequence<T> = (count + n).let { n1 -> if (n1 < 0) TakeSequence(this, n) else SubSequence(sequence, count, n1) }\n\n    override fun iterator(): Iterator<T> = object : Iterator<T> {\n        val iterator = sequence.iterator()\n        var left = count\n\n        // Shouldn't be called from constructor to avoid premature iteration\n        private fun drop() {\n            while (left > 0 && iterator.hasNext()) {\n                iterator.next()\n                left--\n            }\n        }\n\n        override fun next(): T {\n            drop()\n            return iterator.next()\n        }\n\n        override fun hasNext(): Boolean {\n            drop()\n            return iterator.hasNext()\n        }\n    }\n}\n\n/**\n * A sequence that skips the values from the underlying [sequence] while the given [predicate] returns `true` and returns\n * all values after that.\n */\ninternal class DropWhileSequence<T>\nconstructor(\n    private val sequence: Sequence<T>,\n    private val predicate: (T) -> Boolean\n) : Sequence<T> {\n\n    override fun iterator(): Iterator<T> = object : Iterator<T> {\n        val iterator = sequence.iterator()\n        var dropState: Int = -1 // -1 for not dropping, 1 for nextItem, 0 for normal iteration\n        var nextItem: T? = null\n\n        private fun drop() {\n            while (iterator.hasNext()) {\n                val item = iterator.next()\n                if (!predicate(item)) {\n                    nextItem = item\n                    dropState = 1\n                    return\n                }\n            }\n            dropState = 0\n        }\n\n        override fun next(): T {\n            if (dropState == -1)\n                drop()\n\n            if (dropState == 1) {\n                @Suppress(\"UNCHECKED_CAST\")\n                val result = nextItem as T\n                nextItem = null\n                dropState = 0\n                return result\n            }\n            return iterator.next()\n        }\n\n        override fun hasNext(): Boolean {\n            if (dropState == -1)\n                drop()\n            return dropState == 1 || iterator.hasNext()\n        }\n    }\n}\n\ninternal class DistinctSequence<T, K>(private val source: Sequence<T>, private val keySelector: (T) -> K) : Sequence<T> {\n    override fun iterator(): Iterator<T> = DistinctIterator(source.iterator(), keySelector)\n}\n\nprivate class DistinctIterator<T, K>(private val source: Iterator<T>, private val keySelector: (T) -> K) : AbstractIterator<T>() {\n    private val observed = HashSet<K>()\n\n    override fun computeNext() {\n        while (source.hasNext()) {\n            val next = source.next()\n            val key = keySelector(next)\n\n            if (observed.add(key)) {\n                setNext(next)\n                return\n            }\n        }\n\n        done()\n    }\n}\n\n\nprivate class GeneratorSequence<T : Any>(private val getInitialValue: () -> T?, private val getNextValue: (T) -> T?) : Sequence<T> {\n    override fun iterator(): Iterator<T> = object : Iterator<T> {\n        var nextItem: T? = null\n        var nextState: Int = -2 // -2 for initial unknown, -1 for next unknown, 0 for done, 1 for continue\n\n        private fun calcNext() {\n            nextItem = if (nextState == -2) getInitialValue() else getNextValue(nextItem!!)\n            nextState = if (nextItem == null) 0 else 1\n        }\n\n        override fun next(): T {\n            if (nextState < 0)\n                calcNext()\n\n            if (nextState == 0)\n                throw NoSuchElementException()\n            val result = nextItem as T\n            // Do not clean nextItem (to avoid keeping reference on yielded instance) -- need to keep state for getNextValue\n            nextState = -1\n            return result\n        }\n\n        override fun hasNext(): Boolean {\n            if (nextState < 0)\n                calcNext()\n            return nextState == 1\n        }\n    }\n}\n\n/**\n * Returns a wrapper sequence that provides values of this sequence, but ensures it can be iterated only one time.\n *\n * The operation is _intermediate_ and _stateless_.\n *\n * [IllegalStateException] is thrown on iterating the returned sequence from the second time.\n *\n */\npublic fun <T> Sequence<T>.constrainOnce(): Sequence<T> {\n    // as? does not work in js\n    //return this as? ConstrainedOnceSequence<T> ?: ConstrainedOnceSequence(this)\n    return if (this is ConstrainedOnceSequence<T>) this else ConstrainedOnceSequence(this)\n}\n\n\n/**\n * Returns a sequence which invokes the function to calculate the next value on each iteration until the function returns `null`.\n *\n * The returned sequence is constrained to be iterated only once.\n *\n * @see constrainOnce\n * @see kotlin.sequences.sequence\n *\n * @sample samples.collections.Sequences.Building.generateSequence\n */\npublic fun <T : Any> generateSequence(nextFunction: () -> T?): Sequence<T> {\n    return GeneratorSequence(nextFunction, { nextFunction() }).constrainOnce()\n}\n\n/**\n * Returns a sequence defined by the starting value [seed] and the function [nextFunction],\n * which is invoked to calculate the next value based on the previous one on each iteration.\n *\n * The sequence produces values until it encounters first `null` value.\n * If [seed] is `null`, an empty sequence is produced.\n *\n * The sequence can be iterated multiple times, each time starting with [seed].\n *\n * @see kotlin.sequences.sequence\n *\n * @sample samples.collections.Sequences.Building.generateSequenceWithSeed\n */\n@kotlin.internal.LowPriorityInOverloadResolution\npublic fun <T : Any> generateSequence(seed: T?, nextFunction: (T) -> T?): Sequence<T> =\n    if (seed == null)\n        EmptySequence\n    else\n        GeneratorSequence({ seed }, nextFunction)\n\n/**\n * Returns a sequence defined by the function [seedFunction], which is invoked to produce the starting value,\n * and the [nextFunction], which is invoked to calculate the next value based on the previous one on each iteration.\n *\n * The sequence produces values until it encounters first `null` value.\n * If [seedFunction] returns `null`, an empty sequence is produced.\n *\n * The sequence can be iterated multiple times.\n *\n * @see kotlin.sequences.sequence\n *\n * @sample samples.collections.Sequences.Building.generateSequenceWithLazySeed\n */\npublic fun <T : Any> generateSequence(seedFunction: () -> T?, nextFunction: (T) -> T?): Sequence<T> =\n    GeneratorSequence(seedFunction, nextFunction)\n\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n\npackage kotlin.collections\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.random.*\nimport kotlin.ranges.contains\nimport kotlin.ranges.reversed\n\n/**\n * Returns 1st *element* from the list.\n * \n * Throws an [IndexOutOfBoundsException] if the size of this list is less than 1.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component1(): T {\n    return get(0)\n}\n\n/**\n * Returns 2nd *element* from the list.\n * \n * Throws an [IndexOutOfBoundsException] if the size of this list is less than 2.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component2(): T {\n    return get(1)\n}\n\n/**\n * Returns 3rd *element* from the list.\n * \n * Throws an [IndexOutOfBoundsException] if the size of this list is less than 3.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component3(): T {\n    return get(2)\n}\n\n/**\n * Returns 4th *element* from the list.\n * \n * Throws an [IndexOutOfBoundsException] if the size of this list is less than 4.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component4(): T {\n    return get(3)\n}\n\n/**\n * Returns 5th *element* from the list.\n * \n * Throws an [IndexOutOfBoundsException] if the size of this list is less than 5.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component5(): T {\n    return get(4)\n}\n\n/**\n * Returns `true` if [element] is found in the collection.\n */\npublic operator fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.contains(element: T): Boolean {\n    if (this is Collection)\n        return contains(element)\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this collection.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic fun <T> Iterable<T>.elementAt(index: Int): T {\n    if (this is List)\n        return get(index)\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"Collection doesn't contain element at index $index.\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAt(index: Int): T {\n    return get(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this collection.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\npublic fun <T> Iterable<T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    if (this is List)\n        return this.getOrElse(index, defaultValue)\n    if (index < 0)\n        return defaultValue(index)\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this collection.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\npublic fun <T> Iterable<T>.elementAtOrNull(index: Int): T? {\n    if (this is List)\n        return this.getOrNull(index)\n    if (index < 0)\n        return null\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAtOrNull(index: Int): T? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.find(predicate: (T) -> Boolean): T? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the collection is empty.\n */\npublic fun <T> Iterable<T>.first(): T {\n    when (this) {\n        is List -> return this.first()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            return iterator.next()\n        }\n    }\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the list is empty.\n */\npublic fun <T> List<T>.first(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"List is empty.\")\n    return this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun <T> Iterable<T>.first(predicate: (T) -> Boolean): T {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first non-null value produced by [transform] function being applied to elements of this collection in iteration order,\n * or throws [NoSuchElementException] if no non-null value was produced.\n * \n * @sample samples.collections.Collections.Transformations.firstNotNullOf\n */\n@SinceKotlin(\"1.5\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Any> Iterable<T>.firstNotNullOf(transform: (T) -> R?): R {\n    return firstNotNullOfOrNull(transform) ?: throw NoSuchElementException(\"No element of the collection was transformed to a non-null value.\")\n}\n\n/**\n * Returns the first non-null value produced by [transform] function being applied to elements of this collection in iteration order,\n * or `null` if no non-null value was produced.\n * \n * @sample samples.collections.Collections.Transformations.firstNotNullOf\n */\n@SinceKotlin(\"1.5\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Any> Iterable<T>.firstNotNullOfOrNull(transform: (T) -> R?): R? {\n    for (element in this) {\n        val result = transform(element)\n        if (result != null) {\n            return result\n        }\n    }\n    return null\n}\n\n/**\n * Returns the first element, or `null` if the collection is empty.\n */\npublic fun <T> Iterable<T>.firstOrNull(): T? {\n    when (this) {\n        is List -> {\n            if (isEmpty())\n                return null\n            else\n                return this[0]\n        }\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            return iterator.next()\n        }\n    }\n}\n\n/**\n * Returns the first element, or `null` if the list is empty.\n */\npublic fun <T> List<T>.firstOrNull(): T? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun <T> Iterable<T>.firstOrNull(predicate: (T) -> Boolean): T? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this list.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.getOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun <T> List<T>.getOrNull(index: Int): T? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns first index of [element], or -1 if the collection does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.indexOf(element: T): Int {\n    if (this is List) return this.indexOf(element)\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (element == item)\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the list does not contain element.\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\npublic fun <@kotlin.internal.OnlyInputTypes T> List<T>.indexOf(element: T): Int {\n    return indexOf(element)\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the collection does not contain such element.\n */\npublic inline fun <T> Iterable<T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (predicate(item))\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the list does not contain such element.\n */\npublic inline fun <T> List<T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    var index = 0\n    for (item in this) {\n        if (predicate(item))\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the collection does not contain such element.\n */\npublic inline fun <T> Iterable<T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (predicate(item))\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the list does not contain such element.\n */\npublic inline fun <T> List<T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        if (predicate(iterator.previous())) {\n            return iterator.nextIndex()\n        }\n    }\n    return -1\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the collection is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> Iterable<T>.last(): T {\n    when (this) {\n        is List -> return this.last()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            var last = iterator.next()\n            while (iterator.hasNext())\n                last = iterator.next()\n            return last\n        }\n    }\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the list is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> List<T>.last(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"List is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> Iterable<T>.last(predicate: (T) -> Boolean): T {\n    var last: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return last as T\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> List<T>.last(predicate: (T) -> Boolean): T {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        val element = iterator.previous()\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"List contains no element matching the predicate.\")\n}\n\n/**\n * Returns last index of [element], or -1 if the collection does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.lastIndexOf(element: T): Int {\n    if (this is List) return this.lastIndexOf(element)\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (element == item)\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns last index of [element], or -1 if the list does not contain element.\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\npublic fun <@kotlin.internal.OnlyInputTypes T> List<T>.lastIndexOf(element: T): Int {\n    return lastIndexOf(element)\n}\n\n/**\n * Returns the last element, or `null` if the collection is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> Iterable<T>.lastOrNull(): T? {\n    when (this) {\n        is List -> return if (isEmpty()) null else this[size - 1]\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            var last = iterator.next()\n            while (iterator.hasNext())\n                last = iterator.next()\n            return last\n        }\n    }\n}\n\n/**\n * Returns the last element, or `null` if the list is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> List<T>.lastOrNull(): T? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> Iterable<T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    var last: T? = null\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n        }\n    }\n    return last\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> List<T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        val element = iterator.previous()\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns a random element from this collection.\n * \n * @throws NoSuchElementException if this collection is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.random(): T {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this collection using the specified source of randomness.\n * \n * @throws NoSuchElementException if this collection is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> Collection<T>.random(random: Random): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"Collection is empty.\")\n    return elementAt(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this collection, or `null` if this collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.randomOrNull(): T? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this collection using the specified source of randomness, or `null` if this collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <T> Collection<T>.randomOrNull(random: Random): T? {\n    if (isEmpty())\n        return null\n    return elementAt(random.nextInt(size))\n}\n\n/**\n * Returns the single element, or throws an exception if the collection is empty or has more than one element.\n */\npublic fun <T> Iterable<T>.single(): T {\n    when (this) {\n        is List -> return this.single()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            val single = iterator.next()\n            if (iterator.hasNext())\n                throw IllegalArgumentException(\"Collection has more than one element.\")\n            return single\n        }\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the list is empty or has more than one element.\n */\npublic fun <T> List<T>.single(): T {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"List is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"List has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun <T> Iterable<T>.single(predicate: (T) -> Boolean): T {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Collection contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as T\n}\n\n/**\n * Returns single element, or `null` if the collection is empty or has more than one element.\n */\npublic fun <T> Iterable<T>.singleOrNull(): T? {\n    when (this) {\n        is List -> return if (size == 1) this[0] else null\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            val single = iterator.next()\n            if (iterator.hasNext())\n                return null\n            return single\n        }\n    }\n}\n\n/**\n * Returns single element, or `null` if the list is empty or has more than one element.\n */\npublic fun <T> List<T>.singleOrNull(): T? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun <T> Iterable<T>.singleOrNull(predicate: (T) -> Boolean): T? {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> Iterable<T>.drop(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return toList()\n    val list: ArrayList<T>\n    if (this is Collection<*>) {\n        val resultSize = size - n\n        if (resultSize <= 0)\n            return emptyList()\n        if (resultSize == 1)\n            return listOf(last())\n        list = ArrayList<T>(resultSize)\n        if (this is List<T>) {\n            if (this is RandomAccess) {\n                for (index in n until size)\n                    list.add(this[index])\n            } else {\n                for (item in listIterator(n))\n                    list.add(item)\n            }\n            return list\n        }\n    }\n    else {\n        list = ArrayList<T>()\n    }\n    var count = 0\n    for (item in this) {\n        if (count >= n) list.add(item) else ++count\n    }\n    return list.optimizeReadOnlyList()\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> List<T>.dropLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> List<T>.dropLastWhile(predicate: (T) -> Boolean): List<T> {\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            if (!predicate(iterator.previous())) {\n                return take(iterator.nextIndex() + 1)\n            }\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> Iterable<T>.dropWhile(predicate: (T) -> Boolean): List<T> {\n    var yielding = false\n    val list = ArrayList<T>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun <T> Iterable<T>.filter(predicate: (T) -> Boolean): List<T> {\n    return filterTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun <T> Iterable<T>.filterIndexed(predicate: (index: Int, T) -> Boolean): List<T> {\n    return filterIndexedTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterIndexedTo(destination: C, predicate: (index: Int, T) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Returns a list containing all elements that are instances of specified type parameter R.\n * \n * @sample samples.collections.Collections.Filtering.filterIsInstance\n */\npublic inline fun <reified R> Iterable<*>.filterIsInstance(): List<@kotlin.internal.NoInfer R> {\n    return filterIsInstanceTo(ArrayList<R>())\n}\n\n/**\n * Appends all elements that are instances of specified type parameter R to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterIsInstanceTo\n */\npublic inline fun <reified R, C : MutableCollection<in R>> Iterable<*>.filterIsInstanceTo(destination: C): C {\n    for (element in this) if (element is R) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun <T> Iterable<T>.filterNot(predicate: (T) -> Boolean): List<T> {\n    return filterNotTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing all elements that are not `null`.\n * \n * @sample samples.collections.Collections.Filtering.filterNotNull\n */\npublic fun <T : Any> Iterable<T?>.filterNotNull(): List<T> {\n    return filterNotNullTo(ArrayList<T>())\n}\n\n/**\n * Appends all elements that are not `null` to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterNotNullTo\n */\npublic fun <C : MutableCollection<in T>, T : Any> Iterable<T?>.filterNotNullTo(destination: C): C {\n    for (element in this) if (element != null) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterNotTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun <T> List<T>.slice(indices: IntRange): List<T> {\n    if (indices.isEmpty()) return listOf()\n    return this.subList(indices.start, indices.endInclusive + 1).toList()\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun <T> List<T>.slice(indices: Iterable<Int>): List<T> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<T>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> Iterable<T>.take(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (this is Collection<T>) {\n        if (n >= size) return toList()\n        if (n == 1) return listOf(first())\n    }\n    var count = 0\n    val list = ArrayList<T>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list.optimizeReadOnlyList()\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> List<T>.takeLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(last())\n    val list = ArrayList<T>(n)\n    if (this is RandomAccess) {\n        for (index in size - n until size)\n            list.add(this[index])\n    } else {\n        for (item in listIterator(size - n))\n            list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> List<T>.takeLastWhile(predicate: (T) -> Boolean): List<T> {\n    if (isEmpty())\n        return emptyList()\n    val iterator = listIterator(size)\n    while (iterator.hasPrevious()) {\n        if (!predicate(iterator.previous())) {\n            iterator.next()\n            val expectedSize = size - iterator.nextIndex()\n            if (expectedSize == 0) return emptyList()\n            return ArrayList<T>(expectedSize).apply {\n                while (iterator.hasNext())\n                    add(iterator.next())\n            }\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> Iterable<T>.takeWhile(predicate: (T) -> Boolean): List<T> {\n    val list = ArrayList<T>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Reverses elements in the list in-place.\n */\npublic expect fun <T> MutableList<T>.reverse(): Unit\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun <T> Iterable<T>.reversed(): List<T> {\n    if (this is Collection && size <= 1) return toList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Randomly shuffles elements in this list in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> MutableList<T>.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        this[j] = this.set(i, this[j])\n    }\n}\n\n/**\n * Sorts elements in the list in-place according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> MutableList<T>.sortBy(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareBy(selector))\n}\n\n/**\n * Sorts elements in the list in-place descending according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> MutableList<T>.sortByDescending(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareByDescending(selector))\n}\n\n/**\n * Sorts elements in the list in-place descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> MutableList<T>.sortDescending(): Unit {\n    sortWith(reverseOrder())\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Iterable<T>.sorted(): List<T> {\n    if (this is Collection) {\n        if (size <= 1) return this.toList()\n        @Suppress(\"UNCHECKED_CAST\")\n        return (toTypedArray<Comparable<T>>() as Array<T>).apply { sort() }.asList()\n    }\n    return toMutableList().apply { sort() }\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.sortedBy(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.sortedByDescending(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Iterable<T>.sortedDescending(): List<T> {\n    return sortedWith(reverseOrder())\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T> Iterable<T>.sortedWith(comparator: Comparator<in T>): List<T> {\n    if (this is Collection) {\n       if (size <= 1) return this.toList()\n       @Suppress(\"UNCHECKED_CAST\")\n       return (toTypedArray<Any?>() as Array<T>).apply { sortWith(comparator) }.asList()\n    }\n    return toMutableList().apply { sortWith(comparator) }\n}\n\n/**\n * Returns an array of Boolean containing all of the elements of this collection.\n */\npublic fun Collection<Boolean>.toBooleanArray(): BooleanArray {\n    val result = BooleanArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Byte containing all of the elements of this collection.\n */\npublic fun Collection<Byte>.toByteArray(): ByteArray {\n    val result = ByteArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Char containing all of the elements of this collection.\n */\npublic fun Collection<Char>.toCharArray(): CharArray {\n    val result = CharArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Double containing all of the elements of this collection.\n */\npublic fun Collection<Double>.toDoubleArray(): DoubleArray {\n    val result = DoubleArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Float containing all of the elements of this collection.\n */\npublic fun Collection<Float>.toFloatArray(): FloatArray {\n    val result = FloatArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Int containing all of the elements of this collection.\n */\npublic fun Collection<Int>.toIntArray(): IntArray {\n    val result = IntArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Long containing all of the elements of this collection.\n */\npublic fun Collection<Long>.toLongArray(): LongArray {\n    val result = LongArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Short containing all of the elements of this collection.\n */\npublic fun Collection<Short>.toShortArray(): ShortArray {\n    val result = ShortArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given collection.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n * \n * @sample samples.collections.Collections.Transformations.associate\n */\npublic inline fun <T, K, V> Iterable<T>.associate(transform: (T) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing the elements from the given collection indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n * \n * @sample samples.collections.Collections.Transformations.associateBy\n */\npublic inline fun <T, K> Iterable<T>.associateBy(keySelector: (T) -> K): Map<K, T> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, T>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given collection.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n * \n * @sample samples.collections.Collections.Transformations.associateByWithValueTransform\n */\npublic inline fun <T, K, V> Iterable<T>.associateBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, V> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given collection\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Collections.Transformations.associateByTo\n */\npublic inline fun <T, K, M : MutableMap<in K, in T>> Iterable<T>.associateByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given collection.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Collections.Transformations.associateByToWithValueTransform\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Iterable<T>.associateByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given collection.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Collections.Transformations.associateTo\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Iterable<T>.associateTo(destination: M, transform: (T) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Returns a [Map] where keys are elements from the given collection and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <K, V> Iterable<K>.associateWith(valueSelector: (K) -> V): Map<K, V> {\n    val result = LinkedHashMap<K, V>(mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given collection,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <K, V, M : MutableMap<in K, in V>> Iterable<K>.associateWithTo(destination: M, valueSelector: (K) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <T, C : MutableCollection<in T>> Iterable<T>.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun <T> Iterable<T>.toHashSet(): HashSet<T> {\n    return toCollection(HashSet<T>(mapCapacity(collectionSizeOrDefault(12))))\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun <T> Iterable<T>.toList(): List<T> {\n    if (this is Collection) {\n        return when (size) {\n            0 -> emptyList()\n            1 -> listOf(if (this is List) get(0) else iterator().next())\n            else -> this.toMutableList()\n        }\n    }\n    return this.toMutableList().optimizeReadOnlyList()\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this collection.\n */\npublic fun <T> Iterable<T>.toMutableList(): MutableList<T> {\n    if (this is Collection<T>)\n        return this.toMutableList()\n    return toCollection(ArrayList<T>())\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this collection.\n */\npublic fun <T> Collection<T>.toMutableList(): MutableList<T> {\n    return ArrayList(this)\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic fun <T> Iterable<T>.toSet(): Set<T> {\n    if (this is Collection) {\n        return when (size) {\n            0 -> emptySet()\n            1 -> setOf(if (this is List) this[0] else iterator().next())\n            else -> toCollection(LinkedHashSet<T>(mapCapacity(size)))\n        }\n    }\n    return toCollection(LinkedHashSet<T>()).optimizeReadOnlySet()\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original collection.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <T, R> Iterable<T>.flatMap(transform: (T) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original collection.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapSequence\")\npublic inline fun <T, R> Iterable<T>.flatMap(transform: (T) -> Sequence<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original collection.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Iterable<T>.flatMapIndexed(transform: (index: Int, T) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original collection.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedSequence\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Iterable<T>.flatMapIndexed(transform: (index: Int, T) -> Sequence<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original collection, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.flatMapIndexedTo(destination: C, transform: (index: Int, T) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(checkIndexOverflow(index++), element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original collection, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedSequenceTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.flatMapIndexedTo(destination: C, transform: (index: Int, T) -> Sequence<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(checkIndexOverflow(index++), element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original collection, to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.flatMapTo(destination: C, transform: (T) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original collection, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapSequenceTo\")\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.flatMapTo(destination: C, transform: (T) -> Sequence<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original collection by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original collection.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K> Iterable<T>.groupBy(keySelector: (T) -> K): Map<K, List<T>> {\n    return groupByTo(LinkedHashMap<K, MutableList<T>>(), keySelector)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original collection\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original collection.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V> Iterable<T>.groupBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups elements of the original collection by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K, M : MutableMap<in K, MutableList<T>>> Iterable<T>.groupByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<T>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original collection\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V, M : MutableMap<in K, MutableList<V>>> Iterable<T>.groupByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Creates a [Grouping] source from a collection to be used later with one of group-and-fold operations\n * using the specified [keySelector] function to extract a key from each element.\n * \n * @sample samples.collections.Grouping.groupingByEachCount\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, K> Iterable<T>.groupingBy(crossinline keySelector: (T) -> K): Grouping<T, K> {\n    return object : Grouping<T, K> {\n        override fun sourceIterator(): Iterator<T> = this@groupingBy.iterator()\n        override fun keyOf(element: T): K = keySelector(element)\n    }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original collection.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <T, R> Iterable<T>.map(transform: (T) -> R): List<R> {\n    return mapTo(ArrayList<R>(collectionSizeOrDefault(10)), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original collection.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R> Iterable<T>.mapIndexed(transform: (index: Int, T) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(collectionSizeOrDefault(10)), transform)\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element and its index in the original collection.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any> Iterable<T>.mapIndexedNotNull(transform: (index: Int, T) -> R?): List<R> {\n    return mapIndexedNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original collection\n * and appends only the non-null results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Iterable<T>.mapIndexedNotNullTo(destination: C, transform: (index: Int, T) -> R?): C {\n    forEachIndexed { index, element -> transform(index, element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original collection\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.mapIndexedTo(destination: C, transform: (index: Int, T) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(checkIndexOverflow(index++), item))\n    return destination\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element in the original collection.\n * \n * @sample samples.collections.Collections.Transformations.mapNotNull\n */\npublic inline fun <T, R : Any> Iterable<T>.mapNotNull(transform: (T) -> R?): List<R> {\n    return mapNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element in the original collection\n * and appends only the non-null results to the given [destination].\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Iterable<T>.mapNotNullTo(destination: C, transform: (T) -> R?): C {\n    forEach { element -> transform(element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original collection\n * and appends the results to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.mapTo(destination: C, transform: (T) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original collection\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun <T> Iterable<T>.withIndex(): Iterable<IndexedValue<T>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a list containing only distinct elements from the given collection.\n * \n * Among equal elements of the given collection, only the first one will be present in the resulting list.\n * The elements in the resulting list are in the same order as they were in the source collection.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun <T> Iterable<T>.distinct(): List<T> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only elements from the given collection\n * having distinct keys returned by the given [selector] function.\n * \n * Among elements of the given collection with equal keys, only the first one will be present in the resulting list.\n * The elements in the resulting list are in the same order as they were in the source collection.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <T, K> Iterable<T>.distinctBy(selector: (T) -> K): List<T> {\n    val set = HashSet<K>()\n    val list = ArrayList<T>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a set containing all elements that are contained by both this collection and the specified collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun <T> Iterable<T>.intersect(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this collection and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic infix fun <T> Iterable<T>.subtract(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic fun <T> Iterable<T>.toMutableSet(): MutableSet<T> {\n    return when (this) {\n        is Collection<T> -> LinkedHashSet(this)\n        else -> toCollection(LinkedHashSet<T>())\n    }\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original collection.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun <T> Iterable<T>.union(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun <T> Iterable<T>.all(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return true\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if collection has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun <T> Iterable<T>.any(): Boolean {\n    if (this is Collection) return !isEmpty()\n    return iterator().hasNext()\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun <T> Iterable<T>.any(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return false\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns the number of elements in this collection.\n */\npublic fun <T> Iterable<T>.count(): Int {\n    if (this is Collection) return size\n    var count = 0\n    for (element in this) checkCountOverflow(++count)\n    return count\n}\n\n/**\n * Returns the number of elements in this collection.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun <T> Iterable<T>.count(predicate: (T) -> Boolean): Int {\n    if (this is Collection && isEmpty()) return 0\n    var count = 0\n    for (element in this) if (predicate(element)) checkCountOverflow(++count)\n    return count\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the collection is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Iterable<T>.fold(initial: R, operation: (acc: R, T) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original collection.\n * \n * Returns the specified [initial] value if the collection is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Iterable<T>.foldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(checkIndexOverflow(index++), accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the list is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <T, R> List<T>.foldRight(initial: R, operation: (T, acc: R) -> R): R {\n    var accumulator = initial\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            accumulator = operation(iterator.previous(), accumulator)\n        }\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original list and current accumulator value.\n * \n * Returns the specified [initial] value if the list is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <T, R> List<T>.foldRightIndexed(initial: R, operation: (index: Int, T, acc: R) -> R): R {\n    var accumulator = initial\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            val index = iterator.previousIndex()\n            accumulator = operation(index, iterator.previous(), accumulator)\n        }\n    }\n    return accumulator\n}\n\n/**\n * Performs the given [action] on each element.\n */\n@kotlin.internal.HidesMembers\npublic inline fun <T> Iterable<T>.forEach(action: (T) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun <T> Iterable<T>.forEachIndexed(action: (index: Int, T) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(checkIndexOverflow(index++), item)\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Double>.max(): Double? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Float>.max(): Float? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun <T : Comparable<T>> Iterable<T>.max(): T? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <T, R : Comparable<R>> Iterable<T>.maxBy(selector: (T) -> R): T? {\n    return maxByOrNull(selector)\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R : Comparable<R>> Iterable<T>.maxByOrNull(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxElem = iterator.next()\n    if (!iterator.hasNext()) return maxElem\n    var maxValue = selector(maxElem)\n    do {\n        val e = iterator.next()\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    } while (iterator.hasNext())\n    return maxElem\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the collection.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.maxOf(selector: (T) -> Double): Double {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the collection.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.maxOf(selector: (T) -> Float): Float {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the collection.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Iterable<T>.maxOf(selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the collection or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.maxOfOrNull(selector: (T) -> Double): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the collection or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.maxOfOrNull(selector: (T) -> Float): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the collection or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Iterable<T>.maxOfOrNull(selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the collection.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Iterable<T>.maxOfWith(comparator: Comparator<in R>, selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the collection or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Iterable<T>.maxOfWithOrNull(comparator: Comparator<in R>, selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Iterable<Double>.maxOrNull(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Iterable<Float>.maxOrNull(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Comparable<T>> Iterable<T>.maxOrNull(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (max < e) max = e\n    }\n    return max\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun <T> Iterable<T>.maxWith(comparator: Comparator<in T>): T? {\n    return maxWithOrNull(comparator)\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Iterable<T>.maxWithOrNull(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Double>.min(): Double? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Float>.min(): Float? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun <T : Comparable<T>> Iterable<T>.min(): T? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <T, R : Comparable<R>> Iterable<T>.minBy(selector: (T) -> R): T? {\n    return minByOrNull(selector)\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R : Comparable<R>> Iterable<T>.minByOrNull(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minElem = iterator.next()\n    if (!iterator.hasNext()) return minElem\n    var minValue = selector(minElem)\n    do {\n        val e = iterator.next()\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    } while (iterator.hasNext())\n    return minElem\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the collection.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.minOf(selector: (T) -> Double): Double {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the collection.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.minOf(selector: (T) -> Float): Float {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the collection.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Iterable<T>.minOf(selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the collection or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.minOfOrNull(selector: (T) -> Double): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the collection or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.minOfOrNull(selector: (T) -> Float): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the collection or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Iterable<T>.minOfOrNull(selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the collection.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Iterable<T>.minOfWith(comparator: Comparator<in R>, selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the collection or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Iterable<T>.minOfWithOrNull(comparator: Comparator<in R>, selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Iterable<Double>.minOrNull(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Iterable<Float>.minOrNull(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Comparable<T>> Iterable<T>.minOrNull(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (min > e) min = e\n    }\n    return min\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun <T> Iterable<T>.minWith(comparator: Comparator<in T>): T? {\n    return minWithOrNull(comparator)\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Iterable<T>.minWithOrNull(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns `true` if the collection has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun <T> Iterable<T>.none(): Boolean {\n    if (this is Collection) return isEmpty()\n    return !iterator().hasNext()\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun <T> Iterable<T>.none(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return true\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Performs the given [action] on each element and returns the collection itself afterwards.\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, C : Iterable<T>> C.onEach(action: (T) -> Unit): C {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the collection itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, C : Iterable<T>> C.onEachIndexed(action: (index: Int, T) -> Unit): C {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this collection is empty. If the collection can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun <S, T : S> Iterable<T>.reduce(operation: (acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty collection can't be reduced.\")\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original collection.\n * \n * Throws an exception if this collection is empty. If the collection can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun <S, T : S> Iterable<T>.reduceIndexed(operation: (index: Int, acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty collection can't be reduced.\")\n    var index = 1\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(checkIndexOverflow(index++), accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original collection.\n * \n * Returns `null` if the collection is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <S, T : S> Iterable<T>.reduceIndexedOrNull(operation: (index: Int, acc: S, T) -> S): S? {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) return null\n    var index = 1\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(checkIndexOverflow(index++), accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the collection is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <S, T : S> Iterable<T>.reduceOrNull(operation: (acc: S, T) -> S): S? {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) return null\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this list is empty. If the list can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun <S, T : S> List<T>.reduceRight(operation: (T, acc: S) -> S): S {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        throw UnsupportedOperationException(\"Empty list can't be reduced.\")\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        accumulator = operation(iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original list and current accumulator value.\n * \n * Throws an exception if this list is empty. If the list can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun <S, T : S> List<T>.reduceRightIndexed(operation: (index: Int, T, acc: S) -> S): S {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        throw UnsupportedOperationException(\"Empty list can't be reduced.\")\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        val index = iterator.previousIndex()\n        accumulator = operation(index, iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original list and current accumulator value.\n * \n * Returns `null` if the list is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <S, T : S> List<T>.reduceRightIndexedOrNull(operation: (index: Int, T, acc: S) -> S): S? {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        return null\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        val index = iterator.previousIndex()\n        accumulator = operation(index, iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the list is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <S, T : S> List<T>.reduceRightOrNull(operation: (T, acc: S) -> S): S? {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        return null\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        accumulator = operation(iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R> Iterable<T>.runningFold(initial: R, operation: (acc: R, T) -> R): List<R> {\n    val estimatedSize = collectionSizeOrDefault(9)\n    if (estimatedSize == 0) return listOf(initial)\n    val result = ArrayList<R>(estimatedSize + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original collection and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R> Iterable<T>.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): List<R> {\n    val estimatedSize = collectionSizeOrDefault(9)\n    if (estimatedSize == 0) return listOf(initial)\n    val result = ArrayList<R>(estimatedSize + 1).apply { add(initial) }\n    var index = 0\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(index++, accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this collection.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and the element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <S, T : S> Iterable<T>.runningReduce(operation: (acc: S, T) -> S): List<S> {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) return emptyList()\n    var accumulator: S = iterator.next()\n    val result = ArrayList<S>(collectionSizeOrDefault(10)).apply { add(accumulator) }\n    while (iterator.hasNext()) {\n        accumulator = operation(accumulator, iterator.next())\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original collection and current accumulator value that starts with the first element of this collection.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <S, T : S> Iterable<T>.runningReduceIndexed(operation: (index: Int, acc: S, T) -> S): List<S> {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) return emptyList()\n    var accumulator: S = iterator.next()\n    val result = ArrayList<S>(collectionSizeOrDefault(10)).apply { add(accumulator) }\n    var index = 1\n    while (iterator.hasNext()) {\n        accumulator = operation(index++, accumulator, iterator.next())\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <T, R> Iterable<T>.scan(initial: R, operation: (acc: R, T) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original collection and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <T, R> Iterable<T>.scanIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun <T> Iterable<T>.sumBy(selector: (T) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun <T> Iterable<T>.sumByDouble(selector: (T) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.sumOf(selector: (T) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.sumOf(selector: (T) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.sumOf(selector: (T) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.sumOf(selector: (T) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.sumOf(selector: (T) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n */\npublic fun <T : Any> Iterable<T?>.requireNoNulls(): Iterable<T> {\n    for (element in this) {\n        if (element == null) {\n            throw IllegalArgumentException(\"null element found in $this.\")\n        }\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return this as Iterable<T>\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n */\npublic fun <T : Any> List<T?>.requireNoNulls(): List<T> {\n    for (element in this) {\n        if (element == null) {\n            throw IllegalArgumentException(\"null element found in $this.\")\n        }\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return this as List<T>\n}\n\n/**\n * Splits this collection into a list of lists each not exceeding the given [size].\n * \n * The last list in the resulting list may have fewer elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this collection.\n * \n * @sample samples.collections.Collections.Transformations.chunked\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.chunked(size: Int): List<List<T>> {\n    return windowed(size, size, partialWindows = true)\n}\n\n/**\n * Splits this collection into several lists each not exceeding the given [size]\n * and applies the given [transform] function to an each.\n * \n * @return list of results of the [transform] applied to an each list.\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * The last list may have fewer elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this collection.\n * \n * @sample samples.text.Strings.chunkedTransform\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Iterable<T>.chunked(size: Int, transform: (List<T>) -> R): List<R> {\n    return windowed(size, size, partialWindows = true, transform = transform)\n}\n\n/**\n * Returns a list containing all elements of the original collection without the first occurrence of the given [element].\n */\npublic operator fun <T> Iterable<T>.minus(element: T): List<T> {\n    val result = ArrayList<T>(collectionSizeOrDefault(10))\n    var removed = false\n    return this.filterTo(result) { if (!removed && it == element) { removed = true; false } else true }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] array.\n * \n * The [elements] array may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Array<out T>): List<T> {\n    if (elements.isEmpty()) return this.toList()\n    val other = elements.toHashSet()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] collection.\n * \n * The [elements] collection may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Iterable<T>): List<T> {\n    val other = elements.convertToSetForSetOperationWith(this)\n    if (other.isEmpty())\n        return this.toList()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] sequence.\n * \n * The [elements] sequence may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Sequence<T>): List<T> {\n    val other = elements.toHashSet()\n    if (other.isEmpty())\n        return this.toList()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection without the first occurrence of the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.minusElement(element: T): List<T> {\n    return minus(element)\n}\n\n/**\n * Splits the original collection into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Iterables.Operations.partition\n */\npublic inline fun <T> Iterable<T>.partition(predicate: (T) -> Boolean): Pair<List<T>, List<T>> {\n    val first = ArrayList<T>()\n    val second = ArrayList<T>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\npublic operator fun <T> Iterable<T>.plus(element: T): List<T> {\n    if (this is Collection) return this.plus(element)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.add(element)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\npublic operator fun <T> Collection<T>.plus(element: T): List<T> {\n    val result = ArrayList<T>(size + 1)\n    result.addAll(this)\n    result.add(element)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] array.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Array<out T>): List<T> {\n    if (this is Collection) return this.plus(elements)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] array.\n */\npublic operator fun <T> Collection<T>.plus(elements: Array<out T>): List<T> {\n    val result = ArrayList<T>(this.size + elements.size)\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] collection.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Iterable<T>): List<T> {\n    if (this is Collection) return this.plus(elements)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] collection.\n */\npublic operator fun <T> Collection<T>.plus(elements: Iterable<T>): List<T> {\n    if (elements is Collection) {\n        val result = ArrayList<T>(this.size + elements.size)\n        result.addAll(this)\n        result.addAll(elements)\n        return result\n    } else {\n        val result = ArrayList<T>(this)\n        result.addAll(elements)\n        return result\n    }\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] sequence.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Sequence<T>): List<T> {\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] sequence.\n */\npublic operator fun <T> Collection<T>.plus(elements: Sequence<T>): List<T> {\n    val result = ArrayList<T>(this.size + 10)\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.plusElement(element: T): List<T> {\n    return plus(element)\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.plusElement(element: T): List<T> {\n    return plus(element)\n}\n\n/**\n * Returns a list of snapshots of the window of the given [size]\n * sliding along this collection with the given [step], where each\n * snapshot is a list.\n * \n * Several last lists may have fewer elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this collection.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.takeWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false): List<List<T>> {\n    checkWindowSizeStep(size, step)\n    if (this is RandomAccess && this is List) {\n        val thisSize = this.size\n        val resultCapacity = thisSize / step + if (thisSize % step == 0) 0 else 1\n        val result = ArrayList<List<T>>(resultCapacity)\n        var index = 0\n        while (index in 0 until thisSize) {\n            val windowSize = size.coerceAtMost(thisSize - index)\n            if (windowSize < size && !partialWindows) break\n            result.add(List(windowSize) { this[it + index] })\n            index += step\n        }\n        return result\n    }\n    val result = ArrayList<List<T>>()\n    windowedIterator(iterator(), size, step, partialWindows, reuseBuffer = false).forEach {\n        result.add(it)\n    }\n    return result\n}\n\n/**\n * Returns a list of results of applying the given [transform] function to\n * an each list representing a view over the window of the given [size]\n * sliding along this collection with the given [step].\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * Several last lists may have fewer elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this collection.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.averageWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Iterable<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false, transform: (List<T>) -> R): List<R> {\n    checkWindowSizeStep(size, step)\n    if (this is RandomAccess && this is List) {\n        val thisSize = this.size\n        val resultCapacity = thisSize / step + if (thisSize % step == 0) 0 else 1\n        val result = ArrayList<R>(resultCapacity)\n        val window = MovingSubList(this)\n        var index = 0\n        while (index in 0 until thisSize) {\n            val windowSize = size.coerceAtMost(thisSize - index)\n            if (!partialWindows && windowSize < size) break\n            window.move(index, index + windowSize)\n            result.add(transform(window))\n            index += step\n        }\n        return result\n    }\n    val result = ArrayList<R>()\n    windowedIterator(iterator(), size, step, partialWindows, reuseBuffer = true).forEach {\n        result.add(transform(it))\n    }\n    return result\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Iterable<T>.zip(other: Array<out R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` collection and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Iterable<T>.zip(other: Array<out R>, transform: (a: T, b: R) -> V): List<V> {\n    val arraySize = other.size\n    val list = ArrayList<V>(minOf(collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in this) {\n        if (i >= arraySize) break\n        list.add(transform(element, other[i++]))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] collection with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Iterable<T>.zip(other: Iterable<R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` collection and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Iterable<T>.zip(other: Iterable<R>, transform: (a: T, b: R) -> V): List<V> {\n    val first = iterator()\n    val second = other.iterator()\n    val list = ArrayList<V>(minOf(collectionSizeOrDefault(10), other.collectionSizeOrDefault(10)))\n    while (first.hasNext() && second.hasNext()) {\n        list.add(transform(first.next(), second.next()))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs of each two adjacent elements in this collection.\n * \n * The returned list is empty if this collection contains less than two elements.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNext\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.zipWithNext(): List<Pair<T, T>> {\n    return zipWithNext { a, b -> a to b }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to an each pair of two adjacent elements in this collection.\n * \n * The returned list is empty if this collection contains less than two elements.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNextToFindDeltas\n */\n@SinceKotlin(\"1.2\")\npublic inline fun <T, R> Iterable<T>.zipWithNext(transform: (a: T, b: T) -> R): List<R> {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return emptyList()\n    val result = mutableListOf<R>()\n    var current = iterator.next()\n    while (iterator.hasNext()) {\n        val next = iterator.next()\n        result.add(transform(current, next))\n        current = next\n    }\n    return result\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <T, A : Appendable> Iterable<T>.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            buffer.appendElement(element, transform)\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun <T> Iterable<T>.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Returns this collection as an [Iterable].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.asIterable(): Iterable<T> {\n    return this\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original collection returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromCollection\n */\npublic fun <T> Iterable<T>.asSequence(): Sequence<T> {\n    return Sequence { this.iterator() }\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfByte\")\npublic fun Iterable<Byte>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfShort\")\npublic fun Iterable<Short>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfInt\")\npublic fun Iterable<Int>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfLong\")\npublic fun Iterable<Long>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfFloat\")\npublic fun Iterable<Float>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfDouble\")\npublic fun Iterable<Double>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfByte\")\npublic fun Iterable<Byte>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfShort\")\npublic fun Iterable<Short>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfInt\")\npublic fun Iterable<Int>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfLong\")\npublic fun Iterable<Long>.sum(): Long {\n    var sum: Long = 0L\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfFloat\")\npublic fun Iterable<Float>.sum(): Float {\n    var sum: Float = 0.0f\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfDouble\")\npublic fun Iterable<Double>.sum(): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"SequencesKt\")\n\npackage kotlin.sequences\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.random.*\n\n/**\n * Returns `true` if [element] is found in the sequence.\n *\n * The operation is _terminal_.\n */\npublic operator fun <@kotlin.internal.OnlyInputTypes T> Sequence<T>.contains(element: T): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic fun <T> Sequence<T>.elementAt(index: Int): T {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"Sequence doesn't contain element at index $index.\") }\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\npublic fun <T> Sequence<T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    if (index < 0)\n        return defaultValue(index)\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\npublic fun <T> Sequence<T>.elementAtOrNull(index: Int): T? {\n    if (index < 0)\n        return null\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.find(predicate: (T) -> Boolean): T? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the sequence is empty.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.first(): T {\n    val iterator = iterator()\n    if (!iterator.hasNext())\n        throw NoSuchElementException(\"Sequence is empty.\")\n    return iterator.next()\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.first(predicate: (T) -> Boolean): T {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Sequence contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first non-null value produced by [transform] function being applied to elements of this sequence in iteration order,\n * or throws [NoSuchElementException] if no non-null value was produced.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.firstNotNullOf\n */\n@SinceKotlin(\"1.5\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Any> Sequence<T>.firstNotNullOf(transform: (T) -> R?): R {\n    return firstNotNullOfOrNull(transform) ?: throw NoSuchElementException(\"No element of the sequence was transformed to a non-null value.\")\n}\n\n/**\n * Returns the first non-null value produced by [transform] function being applied to elements of this sequence in iteration order,\n * or `null` if no non-null value was produced.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.firstNotNullOf\n */\n@SinceKotlin(\"1.5\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Any> Sequence<T>.firstNotNullOfOrNull(transform: (T) -> R?): R? {\n    for (element in this) {\n        val result = transform(element)\n        if (result != null) {\n            return result\n        }\n    }\n    return null\n}\n\n/**\n * Returns the first element, or `null` if the sequence is empty.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.firstOrNull(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext())\n        return null\n    return iterator.next()\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.firstOrNull(predicate: (T) -> Boolean): T? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns first index of [element], or -1 if the sequence does not contain element.\n *\n * The operation is _terminal_.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Sequence<T>.indexOf(element: T): Int {\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (element == item)\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the sequence does not contain such element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (predicate(item))\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the sequence does not contain such element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (predicate(item))\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns the last element.\n *\n * The operation is _terminal_.\n * \n * @throws NoSuchElementException if the sequence is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> Sequence<T>.last(): T {\n    val iterator = iterator()\n    if (!iterator.hasNext())\n        throw NoSuchElementException(\"Sequence is empty.\")\n    var last = iterator.next()\n    while (iterator.hasNext())\n        last = iterator.next()\n    return last\n}\n\n/**\n * Returns the last element matching the given [predicate].\n *\n * The operation is _terminal_.\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> Sequence<T>.last(predicate: (T) -> Boolean): T {\n    var last: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Sequence contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return last as T\n}\n\n/**\n * Returns last index of [element], or -1 if the sequence does not contain element.\n *\n * The operation is _terminal_.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Sequence<T>.lastIndexOf(element: T): Int {\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (element == item)\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns the last element, or `null` if the sequence is empty.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> Sequence<T>.lastOrNull(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext())\n        return null\n    var last = iterator.next()\n    while (iterator.hasNext())\n        last = iterator.next()\n    return last\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> Sequence<T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    var last: T? = null\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n        }\n    }\n    return last\n}\n\n/**\n * Returns the single element, or throws an exception if the sequence is empty or has more than one element.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.single(): T {\n    val iterator = iterator()\n    if (!iterator.hasNext())\n        throw NoSuchElementException(\"Sequence is empty.\")\n    val single = iterator.next()\n    if (iterator.hasNext())\n        throw IllegalArgumentException(\"Sequence has more than one element.\")\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.single(predicate: (T) -> Boolean): T {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Sequence contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Sequence contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as T\n}\n\n/**\n * Returns single element, or `null` if the sequence is empty or has more than one element.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.singleOrNull(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext())\n        return null\n    val single = iterator.next()\n    if (iterator.hasNext())\n        return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.singleOrNull(predicate: (T) -> Boolean): T? {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns a sequence containing all elements except first [n] elements.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> Sequence<T>.drop(n: Int): Sequence<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return when {\n        n == 0 -> this\n        this is DropTakeSequence -> this.drop(n)\n        else -> DropSequence(this, n)\n    }\n}\n\n/**\n * Returns a sequence containing all elements except first elements that satisfy the given [predicate].\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> Sequence<T>.dropWhile(predicate: (T) -> Boolean): Sequence<T> {\n    return DropWhileSequence(this, predicate)\n}\n\n/**\n * Returns a sequence containing only elements matching the given [predicate].\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic fun <T> Sequence<T>.filter(predicate: (T) -> Boolean): Sequence<T> {\n    return FilteringSequence(this, true, predicate)\n}\n\n/**\n * Returns a sequence containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic fun <T> Sequence<T>.filterIndexed(predicate: (index: Int, T) -> Boolean): Sequence<T> {\n    // TODO: Rewrite with generalized MapFilterIndexingSequence\n    return TransformingSequence(FilteringSequence(IndexingSequence(this), true, { predicate(it.index, it.value) }), { it.value })\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Sequence<T>.filterIndexedTo(destination: C, predicate: (index: Int, T) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Returns a sequence containing all elements that are instances of specified type parameter R.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Filtering.filterIsInstance\n */\npublic inline fun <reified R> Sequence<*>.filterIsInstance(): Sequence<@kotlin.internal.NoInfer R> {\n    @Suppress(\"UNCHECKED_CAST\")\n    return filter { it is R } as Sequence<R>\n}\n\n/**\n * Appends all elements that are instances of specified type parameter R to the given [destination].\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Filtering.filterIsInstanceTo\n */\npublic inline fun <reified R, C : MutableCollection<in R>> Sequence<*>.filterIsInstanceTo(destination: C): C {\n    for (element in this) if (element is R) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a sequence containing all elements not matching the given [predicate].\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic fun <T> Sequence<T>.filterNot(predicate: (T) -> Boolean): Sequence<T> {\n    return FilteringSequence(this, false, predicate)\n}\n\n/**\n * Returns a sequence containing all elements that are not `null`.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Filtering.filterNotNull\n */\npublic fun <T : Any> Sequence<T?>.filterNotNull(): Sequence<T> {\n    @Suppress(\"UNCHECKED_CAST\")\n    return filterNot { it == null } as Sequence<T>\n}\n\n/**\n * Appends all elements that are not `null` to the given [destination].\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Filtering.filterNotNullTo\n */\npublic fun <C : MutableCollection<in T>, T : Any> Sequence<T?>.filterNotNullTo(destination: C): C {\n    for (element in this) if (element != null) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Sequence<T>.filterNotTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Sequence<T>.filterTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a sequence containing first [n] elements.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> Sequence<T>.take(n: Int): Sequence<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return when {\n        n == 0 -> emptySequence()\n        this is DropTakeSequence -> this.take(n)\n        else -> TakeSequence(this, n)\n    }\n}\n\n/**\n * Returns a sequence containing first elements satisfying the given [predicate].\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> Sequence<T>.takeWhile(predicate: (T) -> Boolean): Sequence<T> {\n    return TakeWhileSequence(this, predicate)\n}\n\n/**\n * Returns a sequence that yields elements of this sequence sorted according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n *\n * The operation is _intermediate_ and _stateful_.\n */\npublic fun <T : Comparable<T>> Sequence<T>.sorted(): Sequence<T> {\n    return object : Sequence<T> {\n        override fun iterator(): Iterator<T> {\n            val sortedList = this@sorted.toMutableList()\n            sortedList.sort()\n            return sortedList.iterator()\n        }\n    }\n}\n\n/**\n * Returns a sequence that yields elements of this sequence sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n *\n * The operation is _intermediate_ and _stateful_.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <T, R : Comparable<R>> Sequence<T>.sortedBy(crossinline selector: (T) -> R?): Sequence<T> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a sequence that yields elements of this sequence sorted descending according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n *\n * The operation is _intermediate_ and _stateful_.\n */\npublic inline fun <T, R : Comparable<R>> Sequence<T>.sortedByDescending(crossinline selector: (T) -> R?): Sequence<T> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a sequence that yields elements of this sequence sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n *\n * The operation is _intermediate_ and _stateful_.\n */\npublic fun <T : Comparable<T>> Sequence<T>.sortedDescending(): Sequence<T> {\n    return sortedWith(reverseOrder())\n}\n\n/**\n * Returns a sequence that yields elements of this sequence sorted according to the specified [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n *\n * The operation is _intermediate_ and _stateful_.\n */\npublic fun <T> Sequence<T>.sortedWith(comparator: Comparator<in T>): Sequence<T> {\n    return object : Sequence<T> {\n        override fun iterator(): Iterator<T> {\n            val sortedList = this@sortedWith.toMutableList()\n            sortedList.sortWith(comparator)\n            return sortedList.iterator()\n        }\n    }\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given sequence.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associate\n */\npublic inline fun <T, K, V> Sequence<T>.associate(transform: (T) -> Pair<K, V>): Map<K, V> {\n    return associateTo(LinkedHashMap<K, V>(), transform)\n}\n\n/**\n * Returns a [Map] containing the elements from the given sequence indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associateBy\n */\npublic inline fun <T, K> Sequence<T>.associateBy(keySelector: (T) -> K): Map<K, T> {\n    return associateByTo(LinkedHashMap<K, T>(), keySelector)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given sequence.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associateByWithValueTransform\n */\npublic inline fun <T, K, V> Sequence<T>.associateBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, V> {\n    return associateByTo(LinkedHashMap<K, V>(), keySelector, valueTransform)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given sequence\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associateByTo\n */\npublic inline fun <T, K, M : MutableMap<in K, in T>> Sequence<T>.associateByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given sequence.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associateByToWithValueTransform\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Sequence<T>.associateByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given sequence.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associateTo\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Sequence<T>.associateTo(destination: M, transform: (T) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Returns a [Map] where keys are elements from the given sequence and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <K, V> Sequence<K>.associateWith(valueSelector: (K) -> V): Map<K, V> {\n    val result = LinkedHashMap<K, V>()\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given sequence,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <K, V, M : MutableMap<in K, in V>> Sequence<K>.associateWithTo(destination: M, valueSelector: (K) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n *\n * The operation is _terminal_.\n */\npublic fun <T, C : MutableCollection<in T>> Sequence<T>.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.toHashSet(): HashSet<T> {\n    return toCollection(HashSet<T>())\n}\n\n/**\n * Returns a [List] containing all elements.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.toList(): List<T> {\n    return this.toMutableList().optimizeReadOnlyList()\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this sequence.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.toMutableList(): MutableList<T> {\n    return toCollection(ArrayList<T>())\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original sequence.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.toSet(): Set<T> {\n    return toCollection(LinkedHashSet<T>()).optimizeReadOnlySet()\n}\n\n/**\n * Returns a single sequence of all elements from results of [transform] function being invoked on each element of original sequence.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIterable\")\npublic fun <T, R> Sequence<T>.flatMap(transform: (T) -> Iterable<R>): Sequence<R> {\n    return FlatteningSequence(this, transform, Iterable<R>::iterator)\n}\n\n/**\n * Returns a single sequence of all elements from results of [transform] function being invoked on each element of original sequence.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic fun <T, R> Sequence<T>.flatMap(transform: (T) -> Sequence<R>): Sequence<R> {\n    return FlatteningSequence(this, transform, Sequence<R>::iterator)\n}\n\n/**\n * Returns a single sequence of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original sequence.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\npublic fun <T, R> Sequence<T>.flatMapIndexed(transform: (index: Int, T) -> Iterable<R>): Sequence<R> {\n    return flatMapIndexed(this, transform, Iterable<R>::iterator)\n}\n\n/**\n * Returns a single sequence of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original sequence.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedSequence\")\npublic fun <T, R> Sequence<T>.flatMapIndexed(transform: (index: Int, T) -> Sequence<R>): Sequence<R> {\n    return flatMapIndexed(this, transform, Sequence<R>::iterator)\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original sequence, to the given [destination].\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R, C : MutableCollection<in R>> Sequence<T>.flatMapIndexedTo(destination: C, transform: (index: Int, T) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(checkIndexOverflow(index++), element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original sequence, to the given [destination].\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedSequenceTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R, C : MutableCollection<in R>> Sequence<T>.flatMapIndexedTo(destination: C, transform: (index: Int, T) -> Sequence<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(checkIndexOverflow(index++), element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original sequence, to the given [destination].\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIterableTo\")\npublic inline fun <T, R, C : MutableCollection<in R>> Sequence<T>.flatMapTo(destination: C, transform: (T) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original sequence, to the given [destination].\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Sequence<T>.flatMapTo(destination: C, transform: (T) -> Sequence<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original sequence by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K> Sequence<T>.groupBy(keySelector: (T) -> K): Map<K, List<T>> {\n    return groupByTo(LinkedHashMap<K, MutableList<T>>(), keySelector)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original sequence\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V> Sequence<T>.groupBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups elements of the original sequence by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K, M : MutableMap<in K, MutableList<T>>> Sequence<T>.groupByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<T>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original sequence\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V, M : MutableMap<in K, MutableList<V>>> Sequence<T>.groupByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Creates a [Grouping] source from a sequence to be used later with one of group-and-fold operations\n * using the specified [keySelector] function to extract a key from each element.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Grouping.groupingByEachCount\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, K> Sequence<T>.groupingBy(crossinline keySelector: (T) -> K): Grouping<T, K> {\n    return object : Grouping<T, K> {\n        override fun sourceIterator(): Iterator<T> = this@groupingBy.iterator()\n        override fun keyOf(element: T): K = keySelector(element)\n    }\n}\n\n/**\n * Returns a sequence containing the results of applying the given [transform] function\n * to each element in the original sequence.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic fun <T, R> Sequence<T>.map(transform: (T) -> R): Sequence<R> {\n    return TransformingSequence(this, transform)\n}\n\n/**\n * Returns a sequence containing the results of applying the given [transform] function\n * to each element and its index in the original sequence.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic fun <T, R> Sequence<T>.mapIndexed(transform: (index: Int, T) -> R): Sequence<R> {\n    return TransformingIndexedSequence(this, transform)\n}\n\n/**\n * Returns a sequence containing only the non-null results of applying the given [transform] function\n * to each element and its index in the original sequence.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic fun <T, R : Any> Sequence<T>.mapIndexedNotNull(transform: (index: Int, T) -> R?): Sequence<R> {\n    return TransformingIndexedSequence(this, transform).filterNotNull()\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original sequence\n * and appends only the non-null results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Sequence<T>.mapIndexedNotNullTo(destination: C, transform: (index: Int, T) -> R?): C {\n    forEachIndexed { index, element -> transform(index, element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original sequence\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Sequence<T>.mapIndexedTo(destination: C, transform: (index: Int, T) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(checkIndexOverflow(index++), item))\n    return destination\n}\n\n/**\n * Returns a sequence containing only the non-null results of applying the given [transform] function\n * to each element in the original sequence.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.mapNotNull\n */\npublic fun <T, R : Any> Sequence<T>.mapNotNull(transform: (T) -> R?): Sequence<R> {\n    return TransformingSequence(this, transform).filterNotNull()\n}\n\n/**\n * Applies the given [transform] function to each element in the original sequence\n * and appends only the non-null results to the given [destination].\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Sequence<T>.mapNotNullTo(destination: C, transform: (T) -> R?): C {\n    forEach { element -> transform(element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original sequence\n * and appends the results to the given [destination].\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Sequence<T>.mapTo(destination: C, transform: (T) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Returns a sequence that wraps each element of the original sequence\n * into an [IndexedValue] containing the index of that element and the element itself.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic fun <T> Sequence<T>.withIndex(): Sequence<IndexedValue<T>> {\n    return IndexingSequence(this)\n}\n\n/**\n * Returns a sequence containing only distinct elements from the given sequence.\n * \n * Among equal elements of the given sequence, only the first one will be present in the resulting sequence.\n * The elements in the resulting sequence are in the same order as they were in the source sequence.\n *\n * The operation is _intermediate_ and _stateful_.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun <T> Sequence<T>.distinct(): Sequence<T> {\n    return this.distinctBy { it }\n}\n\n/**\n * Returns a sequence containing only elements from the given sequence\n * having distinct keys returned by the given [selector] function.\n * \n * Among elements of the given sequence with equal keys, only the first one will be present in the resulting sequence.\n * The elements in the resulting sequence are in the same order as they were in the source sequence.\n *\n * The operation is _intermediate_ and _stateful_.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun <T, K> Sequence<T>.distinctBy(selector: (T) -> K): Sequence<T> {\n    return DistinctSequence(this, selector)\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given sequence.\n * \n * The returned set preserves the element iteration order of the original sequence.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.toMutableSet(): MutableSet<T> {\n    val set = LinkedHashSet<T>()\n    for (item in this) set.add(item)\n    return set\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun <T> Sequence<T>.all(predicate: (T) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if sequence has at least one element.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun <T> Sequence<T>.any(): Boolean {\n    return iterator().hasNext()\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun <T> Sequence<T>.any(predicate: (T) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns the number of elements in this sequence.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.count(): Int {\n    var count = 0\n    for (element in this) checkCountOverflow(++count)\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.count(predicate: (T) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) checkCountOverflow(++count)\n    return count\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the sequence is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R> Sequence<T>.fold(initial: R, operation: (acc: R, T) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original sequence.\n * \n * Returns the specified [initial] value if the sequence is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R> Sequence<T>.foldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(checkIndexOverflow(index++), accumulator, element)\n    return accumulator\n}\n\n/**\n * Performs the given [action] on each element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.forEach(action: (T) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.forEachIndexed(action: (index: Int, T) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(checkIndexOverflow(index++), item)\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\n@SinceKotlin(\"1.1\")\npublic fun Sequence<Double>.max(): Double? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\n@SinceKotlin(\"1.1\")\npublic fun Sequence<Float>.max(): Float? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun <T : Comparable<T>> Sequence<T>.max(): T? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <T, R : Comparable<R>> Sequence<T>.maxBy(selector: (T) -> R): T? {\n    return maxByOrNull(selector)\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R : Comparable<R>> Sequence<T>.maxByOrNull(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxElem = iterator.next()\n    if (!iterator.hasNext()) return maxElem\n    var maxValue = selector(maxElem)\n    do {\n        val e = iterator.next()\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    } while (iterator.hasNext())\n    return maxElem\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the sequence.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the sequence is empty.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.maxOf(selector: (T) -> Double): Double {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the sequence.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the sequence is empty.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.maxOf(selector: (T) -> Float): Float {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the sequence.\n * \n * @throws NoSuchElementException if the sequence is empty.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Sequence<T>.maxOf(selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the sequence or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.maxOfOrNull(selector: (T) -> Double): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the sequence or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.maxOfOrNull(selector: (T) -> Float): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the sequence or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Sequence<T>.maxOfOrNull(selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the sequence.\n * \n * @throws NoSuchElementException if the sequence is empty.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Sequence<T>.maxOfWith(comparator: Comparator<in R>, selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the sequence or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Sequence<T>.maxOfWithOrNull(comparator: Comparator<in R>, selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\npublic fun Sequence<Double>.maxOrNull(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\npublic fun Sequence<Float>.maxOrNull(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Comparable<T>> Sequence<T>.maxOrNull(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (max < e) max = e\n    }\n    return max\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun <T> Sequence<T>.maxWith(comparator: Comparator<in T>): T? {\n    return maxWithOrNull(comparator)\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Sequence<T>.maxWithOrNull(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\n@SinceKotlin(\"1.1\")\npublic fun Sequence<Double>.min(): Double? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\n@SinceKotlin(\"1.1\")\npublic fun Sequence<Float>.min(): Float? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun <T : Comparable<T>> Sequence<T>.min(): T? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <T, R : Comparable<R>> Sequence<T>.minBy(selector: (T) -> R): T? {\n    return minByOrNull(selector)\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R : Comparable<R>> Sequence<T>.minByOrNull(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minElem = iterator.next()\n    if (!iterator.hasNext()) return minElem\n    var minValue = selector(minElem)\n    do {\n        val e = iterator.next()\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    } while (iterator.hasNext())\n    return minElem\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the sequence.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the sequence is empty.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.minOf(selector: (T) -> Double): Double {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the sequence.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the sequence is empty.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.minOf(selector: (T) -> Float): Float {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the sequence.\n * \n * @throws NoSuchElementException if the sequence is empty.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Sequence<T>.minOf(selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the sequence or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.minOfOrNull(selector: (T) -> Double): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the sequence or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.minOfOrNull(selector: (T) -> Float): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the sequence or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Sequence<T>.minOfOrNull(selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the sequence.\n * \n * @throws NoSuchElementException if the sequence is empty.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Sequence<T>.minOfWith(comparator: Comparator<in R>, selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the sequence or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Sequence<T>.minOfWithOrNull(comparator: Comparator<in R>, selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\npublic fun Sequence<Double>.minOrNull(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\npublic fun Sequence<Float>.minOrNull(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Comparable<T>> Sequence<T>.minOrNull(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (min > e) min = e\n    }\n    return min\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun <T> Sequence<T>.minWith(comparator: Comparator<in T>): T? {\n    return minWithOrNull(comparator)\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Sequence<T>.minWithOrNull(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns `true` if the sequence has no elements.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun <T> Sequence<T>.none(): Boolean {\n    return !iterator().hasNext()\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun <T> Sequence<T>.none(predicate: (T) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns a sequence which performs the given [action] on each element of the original sequence as they pass through it.\n *\n * The operation is _intermediate_ and _stateless_.\n */\n@SinceKotlin(\"1.1\")\npublic fun <T> Sequence<T>.onEach(action: (T) -> Unit): Sequence<T> {\n    return map {\n        action(it)\n        it\n    }\n}\n\n/**\n * Returns a sequence which performs the given [action] on each element of the original sequence as they pass through it.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n *\n * The operation is _intermediate_ and _stateless_.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Sequence<T>.onEachIndexed(action: (index: Int, T) -> Unit): Sequence<T> {\n    return mapIndexed { index, element ->\n        action(index, element)\n        element\n    }\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this sequence is empty. If the sequence can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun <S, T : S> Sequence<T>.reduce(operation: (acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty sequence can't be reduced.\")\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original sequence.\n * \n * Throws an exception if this sequence is empty. If the sequence can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun <S, T : S> Sequence<T>.reduceIndexed(operation: (index: Int, acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty sequence can't be reduced.\")\n    var index = 1\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(checkIndexOverflow(index++), accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original sequence.\n * \n * Returns `null` if the sequence is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <S, T : S> Sequence<T>.reduceIndexedOrNull(operation: (index: Int, acc: S, T) -> S): S? {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) return null\n    var index = 1\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(checkIndexOverflow(index++), accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the sequence is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <S, T : S> Sequence<T>.reduceOrNull(operation: (acc: S, T) -> S): S? {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) return null\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Returns a sequence containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting sequence.\n * The [initial] value should also be immutable (or should not be mutated)\n * as it may be passed to [operation] function later because of sequence's lazy nature.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\npublic fun <T, R> Sequence<T>.runningFold(initial: R, operation: (acc: R, T) -> R): Sequence<R> {\n    return sequence {\n        yield(initial)\n        var accumulator = initial\n        for (element in this@runningFold) {\n            accumulator = operation(accumulator, element)\n            yield(accumulator)\n        }\n    }\n}\n\n/**\n * Returns a sequence containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original sequence and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting sequence.\n * The [initial] value should also be immutable (or should not be mutated)\n * as it may be passed to [operation] function later because of sequence's lazy nature.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\npublic fun <T, R> Sequence<T>.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): Sequence<R> {\n    return sequence {\n        yield(initial)\n        var index = 0\n        var accumulator = initial\n        for (element in this@runningFoldIndexed) {\n            accumulator = operation(checkIndexOverflow(index++), accumulator, element)\n            yield(accumulator)\n        }\n    }\n}\n\n/**\n * Returns a sequence containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this sequence.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting sequence.\n * \n * @param [operation] function that takes current accumulator value and the element, and calculates the next accumulator value.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <S, T : S> Sequence<T>.runningReduce(operation: (acc: S, T) -> S): Sequence<S> {\n    return sequence {\n        val iterator = iterator()\n        if (iterator.hasNext()) {\n            var accumulator: S = iterator.next()\n            yield(accumulator)\n            while (iterator.hasNext()) {\n                accumulator = operation(accumulator, iterator.next())\n                yield(accumulator)\n            }\n        }\n    }\n}\n\n/**\n * Returns a sequence containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original sequence and current accumulator value that starts with the first element of this sequence.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting sequence.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\npublic fun <S, T : S> Sequence<T>.runningReduceIndexed(operation: (index: Int, acc: S, T) -> S): Sequence<S> {\n    return sequence {\n        val iterator = iterator()\n        if (iterator.hasNext()) {\n            var accumulator: S = iterator.next()\n            yield(accumulator)\n            var index = 1\n            while (iterator.hasNext()) {\n                accumulator = operation(checkIndexOverflow(index++), accumulator, iterator.next())\n                yield(accumulator)\n            }\n        }\n    }\n}\n\n/**\n * Returns a sequence containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting sequence.\n * The [initial] value should also be immutable (or should not be mutated)\n * as it may be passed to [operation] function later because of sequence's lazy nature.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <T, R> Sequence<T>.scan(initial: R, operation: (acc: R, T) -> R): Sequence<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a sequence containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original sequence and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting sequence.\n * The [initial] value should also be immutable (or should not be mutated)\n * as it may be passed to [operation] function later because of sequence's lazy nature.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <T, R> Sequence<T>.scanIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): Sequence<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the sequence.\n *\n * The operation is _terminal_.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun <T> Sequence<T>.sumBy(selector: (T) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the sequence.\n *\n * The operation is _terminal_.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun <T> Sequence<T>.sumByDouble(selector: (T) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the sequence.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.sumOf(selector: (T) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the sequence.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.sumOf(selector: (T) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the sequence.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.sumOf(selector: (T) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the sequence.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.sumOf(selector: (T) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the sequence.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.sumOf(selector: (T) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic fun <T : Any> Sequence<T?>.requireNoNulls(): Sequence<T> {\n    return map { it ?: throw IllegalArgumentException(\"null element found in $this.\") }\n}\n\n/**\n * Splits this sequence into a sequence of lists each not exceeding the given [size].\n * \n * The last list in the resulting sequence may have fewer elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this sequence.\n *\n * The operation is _intermediate_ and _stateful_.\n * \n * @sample samples.collections.Collections.Transformations.chunked\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Sequence<T>.chunked(size: Int): Sequence<List<T>> {\n    return windowed(size, size, partialWindows = true)\n}\n\n/**\n * Splits this sequence into several lists each not exceeding the given [size]\n * and applies the given [transform] function to an each.\n * \n * @return sequence of results of the [transform] applied to an each list.\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * The last list may have fewer elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this sequence.\n *\n * The operation is _intermediate_ and _stateful_.\n * \n * @sample samples.text.Strings.chunkedTransform\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Sequence<T>.chunked(size: Int, transform: (List<T>) -> R): Sequence<R> {\n    return windowed(size, size, partialWindows = true, transform = transform)\n}\n\n/**\n * Returns a sequence containing all elements of the original sequence without the first occurrence of the given [element].\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic operator fun <T> Sequence<T>.minus(element: T): Sequence<T> {\n    return object: Sequence<T> {\n        override fun iterator(): Iterator<T> {\n            var removed = false\n            return this@minus.filter { if (!removed && it == element) { removed = true; false } else true }.iterator()\n        }\n    }\n}\n\n/**\n * Returns a sequence containing all elements of original sequence except the elements contained in the given [elements] array.\n * \n * Note that the source sequence and the array being subtracted are iterated only when an `iterator` is requested from\n * the resulting sequence. Changing any of them between successive calls to `iterator` may affect the result.\n * \n * The [elements] array may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n *\n * The operation is _intermediate_ and _stateful_.\n */\npublic operator fun <T> Sequence<T>.minus(elements: Array<out T>): Sequence<T> {\n    if (elements.isEmpty()) return this\n    return object: Sequence<T> {\n        override fun iterator(): Iterator<T> {\n            val other = elements.toHashSet()\n            return this@minus.filterNot { it in other }.iterator()\n        }\n    }\n}\n\n/**\n * Returns a sequence containing all elements of original sequence except the elements contained in the given [elements] collection.\n * \n * Note that the source sequence and the collection being subtracted are iterated only when an `iterator` is requested from\n * the resulting sequence. Changing any of them between successive calls to `iterator` may affect the result.\n * \n * The [elements] collection may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n *\n * The operation is _intermediate_ and _stateful_.\n */\npublic operator fun <T> Sequence<T>.minus(elements: Iterable<T>): Sequence<T> {\n    return object: Sequence<T> {\n        override fun iterator(): Iterator<T> {\n            val other = elements.convertToSetForSetOperation()\n            if (other.isEmpty())\n                return this@minus.iterator()\n            else\n                return this@minus.filterNot { it in other }.iterator()\n        }\n    }\n}\n\n/**\n * Returns a sequence containing all elements of original sequence except the elements contained in the given [elements] sequence.\n * \n * Note that the source sequence and the sequence being subtracted are iterated only when an `iterator` is requested from\n * the resulting sequence. Changing any of them between successive calls to `iterator` may affect the result.\n * \n * The operation is _intermediate_ for this sequence and _terminal_ and _stateful_ for the [elements] sequence.\n * \n * The [elements] sequence may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Sequence<T>.minus(elements: Sequence<T>): Sequence<T> {\n    return object: Sequence<T> {\n        override fun iterator(): Iterator<T> {\n            val other = elements.toHashSet()\n            if (other.isEmpty())\n                return this@minus.iterator()\n            else\n                return this@minus.filterNot { it in other }.iterator()\n        }\n    }\n}\n\n/**\n * Returns a sequence containing all elements of the original sequence without the first occurrence of the given [element].\n *\n * The operation is _intermediate_ and _stateless_.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.minusElement(element: T): Sequence<T> {\n    return minus(element)\n}\n\n/**\n * Splits the original sequence into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Sequences.Transformations.partition\n */\npublic inline fun <T> Sequence<T>.partition(predicate: (T) -> Boolean): Pair<List<T>, List<T>> {\n    val first = ArrayList<T>()\n    val second = ArrayList<T>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Returns a sequence containing all elements of the original sequence and then the given [element].\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic operator fun <T> Sequence<T>.plus(element: T): Sequence<T> {\n    return sequenceOf(this, sequenceOf(element)).flatten()\n}\n\n/**\n * Returns a sequence containing all elements of original sequence and then all elements of the given [elements] array.\n * \n * Note that the source sequence and the array being added are iterated only when an `iterator` is requested from\n * the resulting sequence. Changing any of them between successive calls to `iterator` may affect the result.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic operator fun <T> Sequence<T>.plus(elements: Array<out T>): Sequence<T> {\n    return this.plus(elements.asList())\n}\n\n/**\n * Returns a sequence containing all elements of original sequence and then all elements of the given [elements] collection.\n * \n * Note that the source sequence and the collection being added are iterated only when an `iterator` is requested from\n * the resulting sequence. Changing any of them between successive calls to `iterator` may affect the result.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic operator fun <T> Sequence<T>.plus(elements: Iterable<T>): Sequence<T> {\n    return sequenceOf(this, elements.asSequence()).flatten()\n}\n\n/**\n * Returns a sequence containing all elements of original sequence and then all elements of the given [elements] sequence.\n * \n * Note that the source sequence and the sequence being added are iterated only when an `iterator` is requested from\n * the resulting sequence. Changing any of them between successive calls to `iterator` may affect the result.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic operator fun <T> Sequence<T>.plus(elements: Sequence<T>): Sequence<T> {\n    return sequenceOf(this, elements).flatten()\n}\n\n/**\n * Returns a sequence containing all elements of the original sequence and then the given [element].\n *\n * The operation is _intermediate_ and _stateless_.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.plusElement(element: T): Sequence<T> {\n    return plus(element)\n}\n\n/**\n * Returns a sequence of snapshots of the window of the given [size]\n * sliding along this sequence with the given [step], where each\n * snapshot is a list.\n * \n * Several last lists may have fewer elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this sequence.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.takeWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Sequence<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false): Sequence<List<T>> {\n    return windowedSequence(size, step, partialWindows, reuseBuffer = false)\n}\n\n/**\n * Returns a sequence of results of applying the given [transform] function to\n * an each list representing a view over the window of the given [size]\n * sliding along this sequence with the given [step].\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * Several last lists may have fewer elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this sequence.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.averageWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Sequence<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false, transform: (List<T>) -> R): Sequence<R> {\n    return windowedSequence(size, step, partialWindows, reuseBuffer = true).map(transform)\n}\n\n/**\n * Returns a sequence of values built from the elements of `this` sequence and the [other] sequence with the same index.\n * The resulting sequence ends as soon as the shortest input sequence ends.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Sequences.Transformations.zip\n */\npublic infix fun <T, R> Sequence<T>.zip(other: Sequence<R>): Sequence<Pair<T, R>> {\n    return MergingSequence(this, other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a sequence of values built from the elements of `this` sequence and the [other] sequence with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The resulting sequence ends as soon as the shortest input sequence ends.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Sequences.Transformations.zipWithTransform\n */\npublic fun <T, R, V> Sequence<T>.zip(other: Sequence<R>, transform: (a: T, b: R) -> V): Sequence<V> {\n    return MergingSequence(this, other, transform)\n}\n\n/**\n * Returns a sequence of pairs of each two adjacent elements in this sequence.\n * \n * The returned sequence is empty if this sequence contains less than two elements.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNext\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Sequence<T>.zipWithNext(): Sequence<Pair<T, T>> {\n    return zipWithNext { a, b -> a to b }\n}\n\n/**\n * Returns a sequence containing the results of applying the given [transform] function\n * to an each pair of two adjacent elements in this sequence.\n * \n * The returned sequence is empty if this sequence contains less than two elements.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNextToFindDeltas\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Sequence<T>.zipWithNext(transform: (a: T, b: T) -> R): Sequence<R> {\n    return sequence result@ {\n        val iterator = iterator()\n        if (!iterator.hasNext()) return@result\n        var current = iterator.next()\n        while (iterator.hasNext()) {\n            val next = iterator.next()\n            yield(transform(current, next))\n            current = next\n        }\n    }\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <T, A : Appendable> Sequence<T>.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            buffer.appendElement(element, transform)\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun <T> Sequence<T>.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original sequence returning its elements when being iterated.\n */\npublic fun <T> Sequence<T>.asIterable(): Iterable<T> {\n    return Iterable { this.iterator() }\n}\n\n/**\n * Returns this sequence as a [Sequence].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.asSequence(): Sequence<T> {\n    return this\n}\n\n/**\n * Returns an average value of elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"averageOfByte\")\npublic fun Sequence<Byte>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"averageOfShort\")\npublic fun Sequence<Short>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"averageOfInt\")\npublic fun Sequence<Int>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"averageOfLong\")\npublic fun Sequence<Long>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"averageOfFloat\")\npublic fun Sequence<Float>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"averageOfDouble\")\npublic fun Sequence<Double>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns the sum of all elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"sumOfByte\")\npublic fun Sequence<Byte>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"sumOfShort\")\npublic fun Sequence<Short>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"sumOfInt\")\npublic fun Sequence<Int>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"sumOfLong\")\npublic fun Sequence<Long>.sum(): Long {\n    var sum: Long = 0L\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"sumOfFloat\")\npublic fun Sequence<Float>.sum(): Float {\n    var sum: Float = 0.0f\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"sumOfDouble\")\npublic fun Sequence<Double>.sum(): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"PreconditionsKt\")\n\npackage kotlin\n\nimport kotlin.contracts.contract\n\n/**\n * Throws an [IllegalArgumentException] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failRequireWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun require(value: Boolean): Unit {\n    contract {\n        returns() implies value\n    }\n    require(value) { \"Failed requirement.\" }\n}\n\n/**\n * Throws an [IllegalArgumentException] with the result of calling [lazyMessage] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failRequireWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun require(value: Boolean, lazyMessage: () -> Any): Unit {\n    contract {\n        returns() implies value\n    }\n    if (!value) {\n        val message = lazyMessage()\n        throw IllegalArgumentException(message.toString())\n    }\n}\n\n/**\n * Throws an [IllegalArgumentException] if the [value] is null. Otherwise returns the not null value.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> requireNotNull(value: T?): T {\n    contract {\n        returns() implies (value != null)\n    }\n    return requireNotNull(value) { \"Required value was null.\" }\n}\n\n/**\n * Throws an [IllegalArgumentException] with the result of calling [lazyMessage] if the [value] is null. Otherwise\n * returns the not null value.\n *\n * @sample samples.misc.Preconditions.failRequireNotNullWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> requireNotNull(value: T?, lazyMessage: () -> Any): T {\n    contract {\n        returns() implies (value != null)\n    }\n\n    if (value == null) {\n        val message = lazyMessage()\n        throw IllegalArgumentException(message.toString())\n    } else {\n        return value\n    }\n}\n\n/**\n * Throws an [IllegalStateException] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun check(value: Boolean): Unit {\n    contract {\n        returns() implies value\n    }\n    check(value) { \"Check failed.\" }\n}\n\n/**\n * Throws an [IllegalStateException] with the result of calling [lazyMessage] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun check(value: Boolean, lazyMessage: () -> Any): Unit {\n    contract {\n        returns() implies value\n    }\n    if (!value) {\n        val message = lazyMessage()\n        throw IllegalStateException(message.toString())\n    }\n}\n\n/**\n * Throws an [IllegalStateException] if the [value] is null. Otherwise\n * returns the not null value.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> checkNotNull(value: T?): T {\n    contract {\n        returns() implies (value != null)\n    }\n    return checkNotNull(value) { \"Required value was null.\" }\n}\n\n/**\n * Throws an [IllegalStateException] with the result of calling [lazyMessage]  if the [value] is null. Otherwise\n * returns the not null value.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> checkNotNull(value: T?, lazyMessage: () -> Any): T {\n    contract {\n        returns() implies (value != null)\n    }\n\n    if (value == null) {\n        val message = lazyMessage()\n        throw IllegalStateException(message.toString())\n    } else {\n        return value\n    }\n}\n\n\n/**\n * Throws an [IllegalStateException] with the given [message].\n *\n * @sample samples.misc.Preconditions.failWithError\n */\n@kotlin.internal.InlineOnly\npublic inline fun error(message: Any): Nothing = throw IllegalStateException(message.toString())\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\nimport kotlin.js.RegExp\n\n/**\n * Converts the characters in the specified array to a string.\n */\n@SinceKotlin(\"1.2\")\n@Deprecated(\"Use CharArray.concatToString() instead\", ReplaceWith(\"chars.concatToString()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic actual fun String(chars: CharArray): String {\n    var result = \"\"\n    for (char in chars) {\n        result += char\n    }\n    return result\n}\n\n/**\n * Converts the characters from a portion of the specified array to a string.\n *\n * @throws IndexOutOfBoundsException if either [offset] or [length] are less than zero\n * or `offset + length` is out of [chars] array bounds.\n */\n@SinceKotlin(\"1.2\")\n@Deprecated(\"Use CharArray.concatToString(startIndex, endIndex) instead\", ReplaceWith(\"chars.concatToString(offset, offset + length)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic actual fun String(chars: CharArray, offset: Int, length: Int): String {\n    if (offset < 0 || length < 0 || chars.size - offset < length)\n        throw IndexOutOfBoundsException(\"size: ${chars.size}; offset: $offset; length: $length\")\n    var result = \"\"\n    for (index in offset until offset + length) {\n        result += chars[index]\n    }\n    return result\n}\n\n/**\n * Concatenates characters in this [CharArray] into a String.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun CharArray.concatToString(): String {\n    var result = \"\"\n    for (char in this) {\n        result += char\n    }\n    return result\n}\n\n/**\n * Concatenates characters in this [CharArray] or its subrange into a String.\n *\n * @param startIndex the beginning (inclusive) of the subrange of characters, 0 by default.\n * @param endIndex the end (exclusive) of the subrange of characters, size of this array by default.\n *\n * @throws IndexOutOfBoundsException if [startIndex] is less than zero or [endIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [startIndex] is greater than [endIndex].\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun CharArray.concatToString(startIndex: Int = 0, endIndex: Int = this.size): String {\n    AbstractList.checkBoundsIndexes(startIndex, endIndex, this.size)\n    var result = \"\"\n    for (index in startIndex until endIndex) {\n        result += this[index]\n    }\n    return result\n}\n\n/**\n * Returns a [CharArray] containing characters of this string.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun String.toCharArray(): CharArray {\n    return CharArray(length) { get(it) }\n}\n\n/**\n * Returns a [CharArray] containing characters of this string or its substring.\n *\n * @param startIndex the beginning (inclusive) of the substring, 0 by default.\n * @param endIndex the end (exclusive) of the substring, length of this string by default.\n *\n * @throws IndexOutOfBoundsException if [startIndex] is less than zero or [endIndex] is greater than the length of this string.\n * @throws IllegalArgumentException if [startIndex] is greater than [endIndex].\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.toCharArray(startIndex: Int = 0, endIndex: Int = this.length): CharArray {\n    AbstractList.checkBoundsIndexes(startIndex, endIndex, length)\n    return CharArray(endIndex - startIndex) { get(startIndex + it) }\n}\n\n/**\n * Decodes a string from the bytes in UTF-8 encoding in this array.\n *\n * Malformed byte sequences are replaced by the replacement char `\\uFFFD`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun ByteArray.decodeToString(): String {\n    return decodeUtf8(this, 0, size, false)\n}\n\n/**\n * Decodes a string from the bytes in UTF-8 encoding in this array or its subrange.\n *\n * @param startIndex the beginning (inclusive) of the subrange to decode, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to decode, size of this array by default.\n * @param throwOnInvalidSequence specifies whether to throw an exception on malformed byte sequence or replace it by the replacement char `\\uFFFD`.\n *\n * @throws IndexOutOfBoundsException if [startIndex] is less than zero or [endIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [startIndex] is greater than [endIndex].\n * @throws CharacterCodingException if the byte array contains malformed UTF-8 byte sequence and [throwOnInvalidSequence] is true.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun ByteArray.decodeToString(\n    startIndex: Int = 0,\n    endIndex: Int = this.size,\n    throwOnInvalidSequence: Boolean = false\n): String {\n    AbstractList.checkBoundsIndexes(startIndex, endIndex, this.size)\n    return decodeUtf8(this, startIndex, endIndex, throwOnInvalidSequence)\n}\n\n/**\n * Encodes this string to an array of bytes in UTF-8 encoding.\n *\n * Any malformed char sequence is replaced by the replacement byte sequence.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun String.encodeToByteArray(): ByteArray {\n    return encodeUtf8(this, 0, length, false)\n}\n\n/**\n * Encodes this string or its substring to an array of bytes in UTF-8 encoding.\n *\n * @param startIndex the beginning (inclusive) of the substring to encode, 0 by default.\n * @param endIndex the end (exclusive) of the substring to encode, length of this string by default.\n * @param throwOnInvalidSequence specifies whether to throw an exception on malformed char sequence or replace.\n *\n * @throws IndexOutOfBoundsException if [startIndex] is less than zero or [endIndex] is greater than the length of this string.\n * @throws IllegalArgumentException if [startIndex] is greater than [endIndex].\n * @throws CharacterCodingException if this string contains malformed char sequence and [throwOnInvalidSequence] is true.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.encodeToByteArray(\n    startIndex: Int = 0,\n    endIndex: Int = this.length,\n    throwOnInvalidSequence: Boolean = false\n): ByteArray {\n    AbstractList.checkBoundsIndexes(startIndex, endIndex, length)\n    return encodeUtf8(this, startIndex, endIndex, throwOnInvalidSequence)\n}\n\n/**\n * Returns a copy of this string converted to upper case using the rules of the default locale.\n */\n@Deprecated(\"Use uppercase() instead.\", ReplaceWith(\"uppercase()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\n@kotlin.internal.InlineOnly\npublic actual inline fun String.toUpperCase(): String = asDynamic().toUpperCase()\n\n/**\n * Returns a copy of this string converted to upper case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many and many-to-one character mapping,\n * thus the length of the returned string can be different from the length of the original string.\n *\n * @sample samples.text.Strings.uppercase\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic actual inline fun String.uppercase(): String = asDynamic().toUpperCase()\n\n/**\n * Returns a copy of this string converted to lower case using the rules of the default locale.\n */\n@Deprecated(\"Use lowercase() instead.\", ReplaceWith(\"lowercase()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\n@kotlin.internal.InlineOnly\npublic actual inline fun String.toLowerCase(): String = asDynamic().toLowerCase()\n\n/**\n * Returns a copy of this string converted to lower case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many and many-to-one character mapping,\n * thus the length of the returned string can be different from the length of the original string.\n *\n * @sample samples.text.Strings.lowercase\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic actual inline fun String.lowercase(): String = asDynamic().toLowerCase()\n\n@kotlin.internal.InlineOnly\ninternal actual inline fun String.nativeIndexOf(str: String, fromIndex: Int): Int = asDynamic().indexOf(str, fromIndex)\n\n@kotlin.internal.InlineOnly\ninternal actual inline fun String.nativeLastIndexOf(str: String, fromIndex: Int): Int = asDynamic().lastIndexOf(str, fromIndex)\n\n@kotlin.internal.InlineOnly\ninternal inline fun String.nativeStartsWith(s: String, position: Int): Boolean = asDynamic().startsWith(s, position)\n\n@kotlin.internal.InlineOnly\ninternal inline fun String.nativeEndsWith(s: String): Boolean = asDynamic().endsWith(s)\n\n@kotlin.internal.InlineOnly\npublic actual inline fun String.substring(startIndex: Int): String = asDynamic().substring(startIndex)\n\n@kotlin.internal.InlineOnly\npublic actual inline fun String.substring(startIndex: Int, endIndex: Int): String = asDynamic().substring(startIndex, endIndex)\n\n@kotlin.internal.InlineOnly\npublic inline fun String.concat(str: String): String = asDynamic().concat(str)\n\n@kotlin.internal.InlineOnly\npublic inline fun String.match(regex: String): Array<String>? = asDynamic().match(regex)\n\n//native public fun String.trim(): String\n//TODO: String.replace to implement effective trimLeading and trimTrailing\n\n@kotlin.internal.InlineOnly\ninternal inline fun String.nativeReplace(pattern: RegExp, replacement: String): String = asDynamic().replace(pattern, replacement)\n\n@OptIn(ExperimentalStdlibApi::class)\n@SinceKotlin(\"1.2\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.compareTo(other: String, ignoreCase: Boolean = false): Int {\n    if (ignoreCase) {\n        val n1 = this.length\n        val n2 = other.length\n        val min = minOf(n1, n2)\n        if (min == 0) return n1 - n2\n        var start = 0\n        while (true) {\n            val end = minOf(start + 16, min)\n            var s1 = this.substring(start, end)\n            var s2 = other.substring(start, end)\n            if (s1 != s2) {\n                s1 = s1.uppercase()\n                s2 = s2.uppercase()\n                if (s1 != s2) {\n                    s1 = s1.lowercase()\n                    s2 = s2.lowercase()\n                    if (s1 != s2) {\n                        return s1.compareTo(s2)\n                    }\n                }\n            }\n            if (end == min) break\n            start = end\n        }\n        return n1 - n2\n    } else {\n        return compareTo(other)\n    }\n}\n\n/**\n * Returns `true` if the contents of this char sequence are equal to the contents of the specified [other],\n * i.e. both char sequences contain the same number of the same characters in the same order.\n *\n * @sample samples.text.Strings.contentEquals\n */\n@SinceKotlin(\"1.5\")\npublic actual infix fun CharSequence?.contentEquals(other: CharSequence?): Boolean = contentEqualsImpl(other)\n\n/**\n * Returns `true` if the contents of this char sequence are equal to the contents of the specified [other], optionally ignoring case difference.\n *\n * @param ignoreCase `true` to ignore character case when comparing contents.\n *\n * @sample samples.text.Strings.contentEquals\n */\n@SinceKotlin(\"1.5\")\npublic actual fun CharSequence?.contentEquals(other: CharSequence?, ignoreCase: Boolean): Boolean {\n    return if (ignoreCase)\n        this.contentEqualsIgnoreCaseImpl(other)\n    else\n        this.contentEqualsImpl(other)\n}\n\n\nprivate val STRING_CASE_INSENSITIVE_ORDER = Comparator<String> { a, b -> a.compareTo(b, ignoreCase = true) }\n\n@SinceKotlin(\"1.2\")\npublic actual val String.Companion.CASE_INSENSITIVE_ORDER: Comparator<String>\n    get() = STRING_CASE_INSENSITIVE_ORDER\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin.collections\n\n/** An iterator over a sequence of values of type `Byte`. */\npublic abstract class ByteIterator : Iterator<Byte> {\n    override final fun next() = nextByte()\n\n    /** Returns the next value in the sequence without boxing. */\n    public abstract fun nextByte(): Byte\n}\n\n/** An iterator over a sequence of values of type `Char`. */\npublic abstract class CharIterator : Iterator<Char> {\n    override final fun next() = nextChar()\n\n    /** Returns the next value in the sequence without boxing. */\n    public abstract fun nextChar(): Char\n}\n\n/** An iterator over a sequence of values of type `Short`. */\npublic abstract class ShortIterator : Iterator<Short> {\n    override final fun next() = nextShort()\n\n    /** Returns the next value in the sequence without boxing. */\n    public abstract fun nextShort(): Short\n}\n\n/** An iterator over a sequence of values of type `Int`. */\npublic abstract class IntIterator : Iterator<Int> {\n    override final fun next() = nextInt()\n\n    /** Returns the next value in the sequence without boxing. */\n    public abstract fun nextInt(): Int\n}\n\n/** An iterator over a sequence of values of type `Long`. */\npublic abstract class LongIterator : Iterator<Long> {\n    override final fun next() = nextLong()\n\n    /** Returns the next value in the sequence without boxing. */\n    public abstract fun nextLong(): Long\n}\n\n/** An iterator over a sequence of values of type `Float`. */\npublic abstract class FloatIterator : Iterator<Float> {\n    override final fun next() = nextFloat()\n\n    /** Returns the next value in the sequence without boxing. */\n    public abstract fun nextFloat(): Float\n}\n\n/** An iterator over a sequence of values of type `Double`. */\npublic abstract class DoubleIterator : Iterator<Double> {\n    override final fun next() = nextDouble()\n\n    /** Returns the next value in the sequence without boxing. */\n    public abstract fun nextDouble(): Double\n}\n\n/** An iterator over a sequence of values of type `Boolean`. */\npublic abstract class BooleanIterator : Iterator<Boolean> {\n    override final fun next() = nextBoolean()\n\n    /** Returns the next value in the sequence without boxing. */\n    public abstract fun nextBoolean(): Boolean\n}\n\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin.ranges\n\n/**\n * An iterator over a progression of values of type `Char`.\n * @property step the number by which the value is incremented on each step.\n */\ninternal class CharProgressionIterator(first: Char, last: Char, val step: Int) : CharIterator() {\n    private val finalElement: Int = last.code\n    private var hasNext: Boolean = if (step > 0) first <= last else first >= last\n    private var next: Int = if (hasNext) first.code else finalElement\n\n    override fun hasNext(): Boolean = hasNext\n\n    override fun nextChar(): Char {\n        val value = next\n        if (value == finalElement) {\n            if (!hasNext) throw kotlin.NoSuchElementException()\n            hasNext = false\n        }\n        else {\n            next += step\n        }\n        return value.toChar()\n    }\n}\n\n/**\n * An iterator over a progression of values of type `Int`.\n * @property step the number by which the value is incremented on each step.\n */\ninternal class IntProgressionIterator(first: Int, last: Int, val step: Int) : IntIterator() {\n    private val finalElement: Int = last\n    private var hasNext: Boolean = if (step > 0) first <= last else first >= last\n    private var next: Int = if (hasNext) first else finalElement\n\n    override fun hasNext(): Boolean = hasNext\n\n    override fun nextInt(): Int {\n        val value = next\n        if (value == finalElement) {\n            if (!hasNext) throw kotlin.NoSuchElementException()\n            hasNext = false\n        }\n        else {\n            next += step\n        }\n        return value\n    }\n}\n\n/**\n * An iterator over a progression of values of type `Long`.\n * @property step the number by which the value is incremented on each step.\n */\ninternal class LongProgressionIterator(first: Long, last: Long, val step: Long) : LongIterator() {\n    private val finalElement: Long = last\n    private var hasNext: Boolean = if (step > 0) first <= last else first >= last\n    private var next: Long = if (hasNext) first else finalElement\n\n    override fun hasNext(): Boolean = hasNext\n\n    override fun nextLong(): Long {\n        val value = next\n        if (value == finalElement) {\n            if (!hasNext) throw kotlin.NoSuchElementException()\n            hasNext = false\n        }\n        else {\n            next += step\n        }\n        return value\n    }\n}\n\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin\n\n\n/**\n * Creates a Char with the specified [code], or throws an exception if the [code] is out of `Char.MIN_VALUE.code..Char.MAX_VALUE.code`.\n *\n * If the program that calls this function is written in a way that only valid [code] is passed as the argument,\n * using the overload that takes a [UShort] argument is preferable (`Char(intValue.toUShort())`).\n * That overload doesn't check validity of the argument, and may improve program performance when the function is called routinely inside a loop.\n *\n * @sample samples.text.Chars.charFromCode\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun Char(code: Int): Char {\n    if (code < Char.MIN_VALUE.code || code > Char.MAX_VALUE.code) {\n        throw IllegalArgumentException(\"Invalid Char code: $code\")\n    }\n    return Char(code.toUShort())\n}\n\n/**\n * Creates a Char with the specified [code].\n *\n * @sample samples.text.Chars.charFromCode\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect fun Char(code: UShort): Char\n\n/**\n * Returns the code of this Char.\n *\n * Code of a Char is the value it was constructed with, and the UTF-16 code unit corresponding to this Char.\n *\n * @sample samples.text.Chars.code\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION\")\npublic inline val Char.code: Int get() = this.toInt()\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin.ranges\n\nimport kotlin.internal.getProgressionLastElement\n\n/**\n * A progression of values of type `Char`.\n */\npublic open class CharProgression\n    internal constructor\n    (\n            start: Char,\n            endInclusive: Char,\n            step: Int\n    ) : Iterable<Char> {\n    init {\n        if (step == 0) throw kotlin.IllegalArgumentException(\"Step must be non-zero.\")\n        if (step == Int.MIN_VALUE) throw kotlin.IllegalArgumentException(\"Step must be greater than Int.MIN_VALUE to avoid overflow on negation.\")\n    }\n\n    /**\n     * The first element in the progression.\n     */\n    public val first: Char = start\n\n    /**\n     * The last element in the progression.\n     */\n    public val last: Char = getProgressionLastElement(start.code, endInclusive.code, step).toChar()\n\n    /**\n     * The step of the progression.\n     */\n    public val step: Int = step\n\n    override fun iterator(): CharIterator = CharProgressionIterator(first, last, step)\n\n    /**\n     * Checks if the progression is empty.\n     *\n     * Progression with a positive step is empty if its first element is greater than the last element.\n     * Progression with a negative step is empty if its first element is less than the last element.\n     */\n    public open fun isEmpty(): Boolean = if (step > 0) first > last else first < last\n\n    override fun equals(other: Any?): Boolean =\n        other is CharProgression && (isEmpty() && other.isEmpty() ||\n        first == other.first && last == other.last && step == other.step)\n\n    override fun hashCode(): Int =\n        if (isEmpty()) -1 else (31 * (31 * first.code + last.code) + step)\n\n    override fun toString(): String = if (step > 0) \"$first..$last step $step\" else \"$first downTo $last step ${-step}\"\n\n    companion object {\n        /**\n         * Creates CharProgression within the specified bounds of a closed range.\n         *\n         * The progression starts with the [rangeStart] value and goes toward the [rangeEnd] value not excluding it, with the specified [step].\n         * In order to go backwards the [step] must be negative.\n         *\n         * [step] must be greater than `Int.MIN_VALUE` and not equal to zero.\n         */\n        public fun fromClosedRange(rangeStart: Char, rangeEnd: Char, step: Int): CharProgression = CharProgression(rangeStart, rangeEnd, step)\n    }\n}\n\n/**\n * A progression of values of type `Int`.\n */\npublic open class IntProgression\n    internal constructor\n    (\n            start: Int,\n            endInclusive: Int,\n            step: Int\n    ) : Iterable<Int> {\n    init {\n        if (step == 0) throw kotlin.IllegalArgumentException(\"Step must be non-zero.\")\n        if (step == Int.MIN_VALUE) throw kotlin.IllegalArgumentException(\"Step must be greater than Int.MIN_VALUE to avoid overflow on negation.\")\n    }\n\n    /**\n     * The first element in the progression.\n     */\n    public val first: Int = start\n\n    /**\n     * The last element in the progression.\n     */\n    public val last: Int = getProgressionLastElement(start, endInclusive, step)\n\n    /**\n     * The step of the progression.\n     */\n    public val step: Int = step\n\n    override fun iterator(): IntIterator = IntProgressionIterator(first, last, step)\n\n    /**\n     * Checks if the progression is empty.\n     *\n     * Progression with a positive step is empty if its first element is greater than the last element.\n     * Progression with a negative step is empty if its first element is less than the last element.\n     */\n    public open fun isEmpty(): Boolean = if (step > 0) first > last else first < last\n\n    override fun equals(other: Any?): Boolean =\n        other is IntProgression && (isEmpty() && other.isEmpty() ||\n        first == other.first && last == other.last && step == other.step)\n\n    override fun hashCode(): Int =\n        if (isEmpty()) -1 else (31 * (31 * first + last) + step)\n\n    override fun toString(): String = if (step > 0) \"$first..$last step $step\" else \"$first downTo $last step ${-step}\"\n\n    companion object {\n        /**\n         * Creates IntProgression within the specified bounds of a closed range.\n         *\n         * The progression starts with the [rangeStart] value and goes toward the [rangeEnd] value not excluding it, with the specified [step].\n         * In order to go backwards the [step] must be negative.\n         *\n         * [step] must be greater than `Int.MIN_VALUE` and not equal to zero.\n         */\n        public fun fromClosedRange(rangeStart: Int, rangeEnd: Int, step: Int): IntProgression = IntProgression(rangeStart, rangeEnd, step)\n    }\n}\n\n/**\n * A progression of values of type `Long`.\n */\npublic open class LongProgression\n    internal constructor\n    (\n            start: Long,\n            endInclusive: Long,\n            step: Long\n    ) : Iterable<Long> {\n    init {\n        if (step == 0L) throw kotlin.IllegalArgumentException(\"Step must be non-zero.\")\n        if (step == Long.MIN_VALUE) throw kotlin.IllegalArgumentException(\"Step must be greater than Long.MIN_VALUE to avoid overflow on negation.\")\n    }\n\n    /**\n     * The first element in the progression.\n     */\n    public val first: Long = start\n\n    /**\n     * The last element in the progression.\n     */\n    public val last: Long = getProgressionLastElement(start, endInclusive, step)\n\n    /**\n     * The step of the progression.\n     */\n    public val step: Long = step\n\n    override fun iterator(): LongIterator = LongProgressionIterator(first, last, step)\n\n    /**\n     * Checks if the progression is empty.\n     *\n     * Progression with a positive step is empty if its first element is greater than the last element.\n     * Progression with a negative step is empty if its first element is less than the last element.\n     */\n    public open fun isEmpty(): Boolean = if (step > 0) first > last else first < last\n\n    override fun equals(other: Any?): Boolean =\n        other is LongProgression && (isEmpty() && other.isEmpty() ||\n        first == other.first && last == other.last && step == other.step)\n\n    override fun hashCode(): Int =\n        if (isEmpty()) -1 else (31 * (31 * (first xor (first ushr 32)) + (last xor (last ushr 32))) + (step xor (step ushr 32))).toInt()\n\n    override fun toString(): String = if (step > 0) \"$first..$last step $step\" else \"$first downTo $last step ${-step}\"\n\n    companion object {\n        /**\n         * Creates LongProgression within the specified bounds of a closed range.\n         *\n         * The progression starts with the [rangeStart] value and goes toward the [rangeEnd] value not excluding it, with the specified [step].\n         * In order to go backwards the [step] must be negative.\n         *\n         * [step] must be greater than `Long.MIN_VALUE` and not equal to zero.\n         */\n        public fun fromClosedRange(rangeStart: Long, rangeEnd: Long, step: Long): LongProgression = LongProgression(rangeStart, rangeEnd, step)\n    }\n}\n\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.collections\n\nimport kotlin.internal.PlatformDependent\n\n/**\n * Classes that inherit from this interface can be represented as a sequence of elements that can\n * be iterated over.\n * @param T the type of element being iterated over. The iterator is covariant in its element type.\n */\npublic interface Iterable<out T> {\n    /**\n     * Returns an iterator over the elements of this object.\n     */\n    public operator fun iterator(): Iterator<T>\n}\n\n/**\n * Classes that inherit from this interface can be represented as a sequence of elements that can\n * be iterated over and that supports removing elements during iteration.\n * @param T the type of element being iterated over. The mutable iterator is invariant in its element type.\n */\npublic interface MutableIterable<out T> : Iterable<T> {\n    /**\n     * Returns an iterator over the elements of this sequence that supports removing elements during iteration.\n     */\n    override fun iterator(): MutableIterator<T>\n}\n\n/**\n * A generic collection of elements. Methods in this interface support only read-only access to the collection;\n * read/write access is supported through the [MutableCollection] interface.\n * @param E the type of elements contained in the collection. The collection is covariant in its element type.\n */\npublic interface Collection<out E> : Iterable<E> {\n    // Query Operations\n    /**\n     * Returns the size of the collection.\n     */\n    public val size: Int\n\n    /**\n     * Returns `true` if the collection is empty (contains no elements), `false` otherwise.\n     */\n    public fun isEmpty(): Boolean\n\n    /**\n     * Checks if the specified element is contained in this collection.\n     */\n    public operator fun contains(element: @UnsafeVariance E): Boolean\n\n    override fun iterator(): Iterator<E>\n\n    // Bulk Operations\n    /**\n     * Checks if all elements in the specified collection are contained in this collection.\n     */\n    public fun containsAll(elements: Collection<@UnsafeVariance E>): Boolean\n}\n\n/**\n * A generic collection of elements that supports adding and removing elements.\n *\n * @param E the type of elements contained in the collection. The mutable collection is invariant in its element type.\n */\npublic interface MutableCollection<E> : Collection<E>, MutableIterable<E> {\n    // Query Operations\n    override fun iterator(): MutableIterator<E>\n\n    // Modification Operations\n    /**\n     * Adds the specified element to the collection.\n     *\n     * @return `true` if the element has been added, `false` if the collection does not support duplicates\n     * and the element is already contained in the collection.\n     */\n    public fun add(element: E): Boolean\n\n    /**\n     * Removes a single instance of the specified element from this\n     * collection, if it is present.\n     *\n     * @return `true` if the element has been successfully removed; `false` if it was not present in the collection.\n     */\n    public fun remove(element: E): Boolean\n\n    // Bulk Modification Operations\n    /**\n     * Adds all of the elements of the specified collection to this collection.\n     *\n     * @return `true` if any of the specified elements was added to the collection, `false` if the collection was not modified.\n     */\n    public fun addAll(elements: Collection<E>): Boolean\n\n    /**\n     * Removes all of this collection's elements that are also contained in the specified collection.\n     *\n     * @return `true` if any of the specified elements was removed from the collection, `false` if the collection was not modified.\n     */\n    public fun removeAll(elements: Collection<E>): Boolean\n\n    /**\n     * Retains only the elements in this collection that are contained in the specified collection.\n     *\n     * @return `true` if any element was removed from the collection, `false` if the collection was not modified.\n     */\n    public fun retainAll(elements: Collection<E>): Boolean\n\n    /**\n     * Removes all elements from this collection.\n     */\n    public fun clear(): Unit\n}\n\n/**\n * A generic ordered collection of elements. Methods in this interface support only read-only access to the list;\n * read/write access is supported through the [MutableList] interface.\n * @param E the type of elements contained in the list. The list is covariant in its element type.\n */\npublic interface List<out E> : Collection<E> {\n    // Query Operations\n\n    override val size: Int\n    override fun isEmpty(): Boolean\n    override fun contains(element: @UnsafeVariance E): Boolean\n    override fun iterator(): Iterator<E>\n\n    // Bulk Operations\n    override fun containsAll(elements: Collection<@UnsafeVariance E>): Boolean\n\n    // Positional Access Operations\n    /**\n     * Returns the element at the specified index in the list.\n     */\n    public operator fun get(index: Int): E\n\n    // Search Operations\n    /**\n     * Returns the index of the first occurrence of the specified element in the list, or -1 if the specified\n     * element is not contained in the list.\n     */\n    public fun indexOf(element: @UnsafeVariance E): Int\n\n    /**\n     * Returns the index of the last occurrence of the specified element in the list, or -1 if the specified\n     * element is not contained in the list.\n     */\n    public fun lastIndexOf(element: @UnsafeVariance E): Int\n\n    // List Iterators\n    /**\n     * Returns a list iterator over the elements in this list (in proper sequence).\n     */\n    public fun listIterator(): ListIterator<E>\n\n    /**\n     * Returns a list iterator over the elements in this list (in proper sequence), starting at the specified [index].\n     */\n    public fun listIterator(index: Int): ListIterator<E>\n\n    // View\n    /**\n     * Returns a view of the portion of this list between the specified [fromIndex] (inclusive) and [toIndex] (exclusive).\n     * The returned list is backed by this list, so non-structural changes in the returned list are reflected in this list, and vice-versa.\n     *\n     * Structural changes in the base list make the behavior of the view undefined.\n     */\n    public fun subList(fromIndex: Int, toIndex: Int): List<E>\n}\n\n/**\n * A generic ordered collection of elements that supports adding and removing elements.\n * @param E the type of elements contained in the list. The mutable list is invariant in its element type.\n */\npublic interface MutableList<E> : List<E>, MutableCollection<E> {\n    // Modification Operations\n    /**\n     * Adds the specified element to the end of this list.\n     *\n     * @return `true` because the list is always modified as the result of this operation.\n     */\n    override fun add(element: E): Boolean\n\n    override fun remove(element: E): Boolean\n\n    // Bulk Modification Operations\n    /**\n     * Adds all of the elements of the specified collection to the end of this list.\n     *\n     * The elements are appended in the order they appear in the [elements] collection.\n     *\n     * @return `true` if the list was changed as the result of the operation.\n     */\n    override fun addAll(elements: Collection<E>): Boolean\n\n    /**\n     * Inserts all of the elements of the specified collection [elements] into this list at the specified [index].\n     *\n     * @return `true` if the list was changed as the result of the operation.\n     */\n    public fun addAll(index: Int, elements: Collection<E>): Boolean\n\n    override fun removeAll(elements: Collection<E>): Boolean\n    override fun retainAll(elements: Collection<E>): Boolean\n    override fun clear(): Unit\n\n    // Positional Access Operations\n    /**\n     * Replaces the element at the specified position in this list with the specified element.\n     *\n     * @return the element previously at the specified position.\n     */\n    public operator fun set(index: Int, element: E): E\n\n    /**\n     * Inserts an element into the list at the specified [index].\n     */\n    public fun add(index: Int, element: E): Unit\n\n    /**\n     * Removes an element at the specified [index] from the list.\n     *\n     * @return the element that has been removed.\n     */\n    public fun removeAt(index: Int): E\n\n    // List Iterators\n    override fun listIterator(): MutableListIterator<E>\n\n    override fun listIterator(index: Int): MutableListIterator<E>\n\n    // View\n    override fun subList(fromIndex: Int, toIndex: Int): MutableList<E>\n}\n\n/**\n * A generic unordered collection of elements that does not support duplicate elements.\n * Methods in this interface support only read-only access to the set;\n * read/write access is supported through the [MutableSet] interface.\n * @param E the type of elements contained in the set. The set is covariant in its element type.\n */\npublic interface Set<out E> : Collection<E> {\n    // Query Operations\n\n    override val size: Int\n    override fun isEmpty(): Boolean\n    override fun contains(element: @UnsafeVariance E): Boolean\n    override fun iterator(): Iterator<E>\n\n    // Bulk Operations\n    override fun containsAll(elements: Collection<@UnsafeVariance E>): Boolean\n}\n\n/**\n * A generic unordered collection of elements that does not support duplicate elements, and supports\n * adding and removing elements.\n * @param E the type of elements contained in the set. The mutable set is invariant in its element type.\n */\npublic interface MutableSet<E> : Set<E>, MutableCollection<E> {\n    // Query Operations\n    override fun iterator(): MutableIterator<E>\n\n    // Modification Operations\n\n    /**\n     * Adds the specified element to the set.\n     *\n     * @return `true` if the element has been added, `false` if the element is already contained in the set.\n     */\n    override fun add(element: E): Boolean\n\n    override fun remove(element: E): Boolean\n\n    // Bulk Modification Operations\n\n    override fun addAll(elements: Collection<E>): Boolean\n    override fun removeAll(elements: Collection<E>): Boolean\n    override fun retainAll(elements: Collection<E>): Boolean\n    override fun clear(): Unit\n}\n\n/**\n * A collection that holds pairs of objects (keys and values) and supports efficiently retrieving\n * the value corresponding to each key. Map keys are unique; the map holds only one value for each key.\n * Methods in this interface support only read-only access to the map; read-write access is supported through\n * the [MutableMap] interface.\n * @param K the type of map keys. The map is invariant in its key type, as it\n *          can accept key as a parameter (of [containsKey] for example) and return it in [keys] set.\n * @param V the type of map values. The map is covariant in its value type.\n */\npublic interface Map<K, out V> {\n    // Query Operations\n    /**\n     * Returns the number of key/value pairs in the map.\n     */\n    public val size: Int\n\n    /**\n     * Returns `true` if the map is empty (contains no elements), `false` otherwise.\n     */\n    public fun isEmpty(): Boolean\n\n    /**\n     * Returns `true` if the map contains the specified [key].\n     */\n    public fun containsKey(key: K): Boolean\n\n    /**\n     * Returns `true` if the map maps one or more keys to the specified [value].\n     */\n    public fun containsValue(value: @UnsafeVariance V): Boolean\n\n    /**\n     * Returns the value corresponding to the given [key], or `null` if such a key is not present in the map.\n     */\n    public operator fun get(key: K): V?\n\n    /**\n     * Returns the value corresponding to the given [key], or [defaultValue] if such a key is not present in the map.\n     *\n     * @since JDK 1.8\n     */\n    @SinceKotlin(\"1.1\")\n    @PlatformDependent\n    public fun getOrDefault(key: K, defaultValue: @UnsafeVariance V): V {\n        // See default implementation in JDK sources\n        throw NotImplementedError()\n    }\n\n    // Views\n    /**\n     * Returns a read-only [Set] of all keys in this map.\n     */\n    public val keys: Set<K>\n\n    /**\n     * Returns a read-only [Collection] of all values in this map. Note that this collection may contain duplicate values.\n     */\n    public val values: Collection<V>\n\n    /**\n     * Returns a read-only [Set] of all key/value pairs in this map.\n     */\n    public val entries: Set<Map.Entry<K, V>>\n\n    /**\n     * Represents a key/value pair held by a [Map].\n     */\n    public interface Entry<out K, out V> {\n        /**\n         * Returns the key of this key/value pair.\n         */\n        public val key: K\n\n        /**\n         * Returns the value of this key/value pair.\n         */\n        public val value: V\n    }\n}\n\n/**\n * A modifiable collection that holds pairs of objects (keys and values) and supports efficiently retrieving\n * the value corresponding to each key. Map keys are unique; the map holds only one value for each key.\n * @param K the type of map keys. The map is invariant in its key type.\n * @param V the type of map values. The mutable map is invariant in its value type.\n */\npublic interface MutableMap<K, V> : Map<K, V> {\n    // Modification Operations\n    /**\n     * Associates the specified [value] with the specified [key] in the map.\n     *\n     * @return the previous value associated with the key, or `null` if the key was not present in the map.\n     */\n    public fun put(key: K, value: V): V?\n\n    /**\n     * Removes the specified key and its corresponding value from this map.\n     *\n     * @return the previous value associated with the key, or `null` if the key was not present in the map.\n     */\n    public fun remove(key: K): V?\n\n    /**\n     * Removes the entry for the specified key only if it is mapped to the specified value.\n     *\n     * @return true if entry was removed\n     */\n    @SinceKotlin(\"1.1\")\n    @PlatformDependent\n    public fun remove(key: K, value: V): Boolean {\n        // See default implementation in JDK sources\n        return true\n    }\n\n    // Bulk Modification Operations\n    /**\n     * Updates this map with key/value pairs from the specified map [from].\n     */\n    public fun putAll(from: Map<out K, V>): Unit\n\n    /**\n     * Removes all elements from this map.\n     */\n    public fun clear(): Unit\n\n    // Views\n    /**\n     * Returns a [MutableSet] of all keys in this map.\n     */\n    override val keys: MutableSet<K>\n\n    /**\n     * Returns a [MutableCollection] of all values in this map. Note that this collection may contain duplicate values.\n     */\n    override val values: MutableCollection<V>\n\n    /**\n     * Returns a [MutableSet] of all key/value pairs in this map.\n     */\n    override val entries: MutableSet<MutableMap.MutableEntry<K, V>>\n\n    /**\n     * Represents a key/value pair held by a [MutableMap].\n     */\n    public interface MutableEntry<K, V> : Map.Entry<K, V> {\n        /**\n         * Changes the value associated with the key of this entry.\n         *\n         * @return the previous value corresponding to the key.\n         */\n        public fun setValue(newValue: V): V\n    }\n}\n","/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.ranges\n\n/**\n * Represents a range of values (for example, numbers or characters).\n * See the [Kotlin language documentation](https://kotlinlang.org/docs/reference/ranges.html) for more information.\n */\npublic interface ClosedRange<T: Comparable<T>> {\n    /**\n     * The minimum value in the range.\n     */\n    public val start: T\n\n    /**\n     * The maximum value in the range (inclusive).\n     */\n    public val endInclusive: T\n\n    /**\n     * Checks whether the specified [value] belongs to the range.\n     */\n    public operator fun contains(value: T): Boolean = value >= start && value <= endInclusive\n\n    /**\n     * Checks whether the range is empty.\n     *\n     * The range is empty if its start value is greater than the end value.\n     */\n    public fun isEmpty(): Boolean = start > endInclusive\n}\n","/*\n * Copyright 2010-2015 JetBrains s.r.o.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage kotlin\n\n/**\n * The type with only one value: the `Unit` object. This type corresponds to the `void` type in Java.\n */\npublic object Unit {\n    override fun toString() = \"kotlin.Unit\"\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.internal\n\n// a mod b (in arithmetical sense)\nprivate fun mod(a: Int, b: Int): Int {\n    val mod = a % b\n    return if (mod >= 0) mod else mod + b\n}\n\nprivate fun mod(a: Long, b: Long): Long {\n    val mod = a % b\n    return if (mod >= 0) mod else mod + b\n}\n\n// (a - b) mod c\nprivate fun differenceModulo(a: Int, b: Int, c: Int): Int {\n    return mod(mod(a, c) - mod(b, c), c)\n}\n\nprivate fun differenceModulo(a: Long, b: Long, c: Long): Long {\n    return mod(mod(a, c) - mod(b, c), c)\n}\n\n/**\n * Calculates the final element of a bounded arithmetic progression, i.e. the last element of the progression which is in the range\n * from [start] to [end] in case of a positive [step], or from [end] to [start] in case of a negative\n * [step].\n *\n * No validation on passed parameters is performed. The given parameters should satisfy the condition:\n *\n * - either `step > 0` and `start <= end`,\n * - or `step < 0` and `start >= end`.\n *\n * @param start first element of the progression\n * @param end ending bound for the progression\n * @param step increment, or difference of successive elements in the progression\n * @return the final element of the progression\n * @suppress\n */\n@PublishedApi\ninternal fun getProgressionLastElement(start: Int, end: Int, step: Int): Int = when {\n    step > 0 -> if (start >= end) end else end - differenceModulo(end, start, step)\n    step < 0 -> if (start <= end) end else end + differenceModulo(start, end, -step)\n    else -> throw kotlin.IllegalArgumentException(\"Step is zero.\")\n}\n\n/**\n * Calculates the final element of a bounded arithmetic progression, i.e. the last element of the progression which is in the range\n * from [start] to [end] in case of a positive [step], or from [end] to [start] in case of a negative\n * [step].\n *\n * No validation on passed parameters is performed. The given parameters should satisfy the condition:\n *\n * - either `step > 0` and `start <= end`,\n * - or `step < 0` and `start >= end`.\n *\n * @param start first element of the progression\n * @param end ending bound for the progression\n * @param step increment, or difference of successive elements in the progression\n * @return the final element of the progression\n * @suppress\n */\n@PublishedApi\ninternal fun getProgressionLastElement(start: Long, end: Long, step: Long): Long = when {\n    step > 0 -> if (start >= end) end else end - differenceModulo(end, start, step)\n    step < 0 -> if (start <= end) end else end + differenceModulo(start, end, -step)\n    else -> throw kotlin.IllegalArgumentException(\"Step is zero.\")\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@JsName(\"arrayIterator\")\ninternal fun arrayIterator(array: dynamic, type: String?) = when (type) {\n    null -> {\n        val arr: Array<dynamic> = array\n        object : Iterator<dynamic> {\n            var index = 0\n            override fun hasNext() = index < arr.size\n            override fun next() = if (index < arr.size) arr[index++] else throw NoSuchElementException(\"$index\")\n        }\n    }\n    \"BooleanArray\" -> booleanArrayIterator(array)\n    \"ByteArray\" -> byteArrayIterator(array)\n    \"ShortArray\" -> shortArrayIterator(array)\n    \"CharArray\" -> charArrayIterator(array)\n    \"IntArray\" -> intArrayIterator(array)\n    \"LongArray\" -> longArrayIterator(array)\n    \"FloatArray\" -> floatArrayIterator(array)\n    \"DoubleArray\" -> doubleArrayIterator(array)\n    else -> throw IllegalStateException(\"Unsupported type argument for arrayIterator: $type\")\n}\n\n@JsName(\"booleanArrayIterator\")\ninternal fun booleanArrayIterator(array: BooleanArray) = object : BooleanIterator() {\n    var index = 0\n    override fun hasNext() = index < array.size\n    override fun nextBoolean() = if (index < array.size) array[index++] else throw NoSuchElementException(\"$index\")\n}\n\n@JsName(\"byteArrayIterator\")\ninternal fun byteArrayIterator(array: ByteArray) = object : ByteIterator() {\n    var index = 0\n    override fun hasNext() = index < array.size\n    override fun nextByte() = if (index < array.size) array[index++] else throw NoSuchElementException(\"$index\")\n}\n\n@JsName(\"shortArrayIterator\")\ninternal fun shortArrayIterator(array: ShortArray) = object : ShortIterator() {\n    var index = 0\n    override fun hasNext() = index < array.size\n    override fun nextShort() = if (index < array.size) array[index++] else throw NoSuchElementException(\"$index\")\n}\n\n@JsName(\"charArrayIterator\")\ninternal fun charArrayIterator(array: CharArray) = object : CharIterator() {\n    var index = 0\n    override fun hasNext() = index < array.size\n    override fun nextChar() = if (index < array.size) array[index++] else throw NoSuchElementException(\"$index\")\n}\n\n@JsName(\"intArrayIterator\")\ninternal fun intArrayIterator(array: IntArray) = object : IntIterator() {\n    var index = 0\n    override fun hasNext() = index < array.size\n    override fun nextInt() = if (index < array.size) array[index++] else throw NoSuchElementException(\"$index\")\n}\n\n@JsName(\"floatArrayIterator\")\ninternal fun floatArrayIterator(array: FloatArray) = object : FloatIterator() {\n    var index = 0\n    override fun hasNext() = index < array.size\n    override fun nextFloat() = if (index < array.size) array[index++] else throw NoSuchElementException(\"$index\")\n}\n\n@JsName(\"doubleArrayIterator\")\ninternal fun doubleArrayIterator(array: DoubleArray) = object : DoubleIterator() {\n    var index = 0\n    override fun hasNext() = index < array.size\n    override fun nextDouble() = if (index < array.size) array[index++] else throw NoSuchElementException(\"$index\")\n}\n\n@JsName(\"longArrayIterator\")\ninternal fun longArrayIterator(array: LongArray) = object : LongIterator() {\n    var index = 0\n    override fun hasNext() = index < array.size\n    override fun nextLong() = if (index < array.size) array[index++] else throw NoSuchElementException(\"$index\")\n}\n\n@JsName(\"PropertyMetadata\")\ninternal class PropertyMetadata(@JsName(\"callableName\") val name: String)\n\n@JsName(\"noWhenBranchMatched\")\ninternal fun noWhenBranchMatched(): Nothing = throw NoWhenBranchMatchedException()\n\n@JsName(\"subSequence\")\ninternal fun subSequence(c: CharSequence, startIndex: Int, endIndex: Int): CharSequence {\n    if (c is String) {\n        return c.substring(startIndex, endIndex)\n    } else {\n        return c.asDynamic().`subSequence_vux9f0$`(startIndex, endIndex)\n    }\n}\n\n@JsName(\"captureStack\")\ninternal fun captureStack(@Suppress(\"UNUSED_PARAMETER\") baseClass: JsClass<in Throwable>, instance: Throwable) {\n    if (js(\"Error\").captureStackTrace) {\n        // Using uncropped stack traces due to KT-37563.\n        // Precise stack traces are implemented in JS IR compiler and stdlib\n        js(\"Error\").captureStackTrace(instance);\n    } else {\n        instance.asDynamic().stack = js(\"new Error()\").stack;\n    }\n}\n\n@JsName(\"newThrowable\")\ninternal fun newThrowable(message: String?, cause: Throwable?): Throwable {\n    val throwable = js(\"new Error()\")\n    throwable.message = if (jsTypeOf(message) == \"undefined\") {\n        if (cause != null) cause.toString() else null\n    } else {\n        message\n    }\n    throwable.cause = cause\n    throwable.name = \"Throwable\"\n    return throwable\n}\n\n@JsName(\"BoxedChar\")\ninternal class BoxedChar(val c: Int) : Comparable<Int> {\n    override fun equals(other: Any?): Boolean {\n        return other is BoxedChar && c == other.c\n    }\n\n    override fun hashCode(): Int {\n        return c\n    }\n\n    override fun toString(): String {\n        return js(\"this.c\").unsafeCast<Char>().toString()\n    }\n\n    override fun compareTo(other: Int): Int {\n        return js(\"this.c - other\").unsafeCast<Int>()\n    }\n\n    @JsName(\"valueOf\")\n    public fun valueOf(): Int {\n        return c\n    }\n}\n\n@kotlin.internal.InlineOnly\ninternal inline fun <T> concat(args: Array<T>): T {\n    val typed = js(\"Array\")(args.size)\n    for (i in args.indices) {\n        val arr = args[i]\n        if (arr !is Array<*>) {\n            typed[i] = js(\"[]\").slice.call(arr)\n        } else {\n            typed[i] = arr\n        }\n    }\n    return js(\"[]\").concat.apply(js(\"[]\"), typed);\n}\n\n/** Concat regular Array's and TypedArray's into an Array.\n */\n@PublishedApi\n@JsName(\"arrayConcat\")\n@Suppress(\"UNUSED_PARAMETER\")\ninternal fun <T> arrayConcat(a: T, b: T): T {\n    return concat(js(\"arguments\"))\n}\n\n/** Concat primitive arrays. Main use: prepare vararg arguments.\n *  For compatibility with 1.1.0 the arguments may be a mixture of Array's and TypedArray's.\n *\n *  If the first argument is TypedArray (Byte-, Short-, Char-, Int-, Float-, and DoubleArray) returns a TypedArray, otherwise an Array.\n *  If the first argument has the $type$ property (Boolean-, Char-, and LongArray) copy its value to result.$type$.\n *  If the first argument is a regular Array without the $type$ property default to arrayConcat.\n */\n@PublishedApi\n@JsName(\"primitiveArrayConcat\")\n@Suppress(\"UNUSED_PARAMETER\")\ninternal fun <T> primitiveArrayConcat(a: T, b: T): T {\n    val args: Array<T> = js(\"arguments\")\n    if (a is Array<*> && a.asDynamic().`$type$` === undefined) {\n        return concat(args)\n    } else {\n        var size = 0\n        for (i in args.indices) {\n            size += args[i].asDynamic().length as Int\n        }\n        val result = js(\"new a.constructor(size)\")\n        kotlin.copyArrayType(a, result)\n        size = 0\n        for (i in args.indices) {\n            val arr = args[i].asDynamic()\n            for (j in 0 until arr.length) {\n                result[size++] = arr[j]\n            }\n        }\n        return result\n    }\n}\n\n@JsName(\"booleanArrayOf\")\ninternal fun booleanArrayOf() = withType(\"BooleanArray\", js(\"[].slice.call(arguments)\"))\n\n@JsName(\"charArrayOf\") // The arguments have to be slice'd here because of Rhino (see KT-16974)\ninternal fun charArrayOf() = withType(\"CharArray\", js(\"new Uint16Array([].slice.call(arguments))\"))\n\n@JsName(\"longArrayOf\")\ninternal fun longArrayOf() = withType(\"LongArray\", js(\"[].slice.call(arguments)\"))\n\n@JsName(\"withType\")\n@kotlin.internal.InlineOnly\ninternal inline fun withType(type: String, array: dynamic): dynamic {\n    array.`$type$` = type\n    return array\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.coroutines\n\nimport kotlin.coroutines.intrinsics.COROUTINE_SUSPENDED\n\n@SinceKotlin(\"1.3\")\n@JsName(\"CoroutineImpl\")\ninternal abstract class CoroutineImpl(private val resultContinuation: Continuation<Any?>) : Continuation<Any?> {\n    protected var state = 0\n    protected var exceptionState = 0\n    protected var result: Any? = null\n    protected var exception: Throwable? = null\n    protected var finallyPath: Array<Int>? = null\n\n    public override val context: CoroutineContext = resultContinuation.context\n\n    private var intercepted_: Continuation<Any?>? = null\n\n    public fun intercepted(): Continuation<Any?> =\n        intercepted_\n            ?: (context[ContinuationInterceptor]?.interceptContinuation(this) ?: this)\n                .also { intercepted_ = it }\n\n    override fun resumeWith(result: Result<Any?>) {\n        var current = this\n        var currentResult: Any? = result.getOrNull()\n        var currentException: Throwable? = result.exceptionOrNull()\n\n        // This loop unrolls recursion in current.resumeWith(param) to make saner and shorter stack traces on resume\n        while (true) {\n            with(current) {\n                val completion = resultContinuation\n\n                // Set result and exception fields in the current continuation\n                if (currentException == null) {\n                    this.result = currentResult\n                } else {\n                    state = exceptionState\n                    exception = currentException\n                }\n\n                try {\n                    val outcome = doResume()\n                    if (outcome === COROUTINE_SUSPENDED) return\n                    currentResult = outcome\n                    currentException = null\n                } catch (exception: dynamic) { // Catch all exceptions\n                    currentResult = null\n                    currentException = exception.unsafeCast<Throwable>()\n                }\n\n                releaseIntercepted() // this state machine instance is terminating\n\n                if (completion is CoroutineImpl) {\n                    // unrolling recursion via loop\n                    current = completion\n                } else {\n                    // top-level completion reached -- invoke and return\n                    currentException?.let {\n                        completion.resumeWithException(it)\n                    } ?: completion.resume(currentResult)\n                    return\n                }\n            }\n        }\n    }\n\n    private fun releaseIntercepted() {\n        val intercepted = intercepted_\n        if (intercepted != null && intercepted !== this) {\n            context[ContinuationInterceptor]!!.releaseInterceptedContinuation(intercepted)\n        }\n        this.intercepted_ = CompletedContinuation // just in case\n    }\n\n    protected abstract fun doResume(): Any?\n}\n\ninternal object CompletedContinuation : Continuation<Any?> {\n    override val context: CoroutineContext\n        get() = error(\"This continuation is already complete\")\n\n    override fun resumeWith(result: Result<Any?>) {\n        error(\"This continuation is already complete\")\n    }\n\n    override fun toString(): String = \"This continuation is already complete\"\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StandardKt\")\npackage kotlin\n\nimport kotlin.contracts.*\n\n/**\n * An exception is thrown to indicate that a method body remains to be implemented.\n */\npublic class NotImplementedError(message: String = \"An operation is not implemented.\") : Error(message)\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n */\n\n@kotlin.internal.InlineOnly\npublic inline fun TODO(): Nothing = throw NotImplementedError()\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n *\n * @param reason a string explaining why the implementation is missing.\n */\n@kotlin.internal.InlineOnly\npublic inline fun TODO(reason: String): Nothing = throw NotImplementedError(\"An operation is not implemented: $reason\")\n\n\n\n/**\n * Calls the specified function [block] and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#run).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <R> run(block: () -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#run).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.run(block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with the given [receiver] as its receiver and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#with).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> with(receiver: T, block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return receiver.block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns `this` value.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#apply).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> T.apply(block: T.() -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block()\n    return this\n}\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns `this` value.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#also).\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.also(block: (T) -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block(this)\n    return this\n}\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#let).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.let(block: (T) -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block(this)\n}\n\n/**\n * Returns `this` value if it satisfies the given [predicate] or `null`, if it doesn't.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#takeif-and-takeunless).\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeIf(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (predicate(this)) this else null\n}\n\n/**\n * Returns `this` value if it _does not_ satisfy the given [predicate] or `null`, if it does.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#takeif-and-takeunless).\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeUnless(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (!predicate(this)) this else null\n}\n\n/**\n * Executes the given function [action] specified number of [times].\n *\n * A zero-based index of current iteration is passed as a parameter to [action].\n *\n * @sample samples.misc.ControlFlow.repeat\n */\n@kotlin.internal.InlineOnly\npublic inline fun repeat(times: Int, action: (Int) -> Unit) {\n    contract { callsInPlace(action) }\n\n    for (index in 0 until times) {\n        action(index)\n    }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:Suppress(\"UNCHECKED_CAST\", \"RedundantVisibilityModifier\")\n\npackage kotlin\n\nimport kotlin.contracts.*\nimport kotlin.internal.InlineOnly\nimport kotlin.jvm.JvmField\nimport kotlin.jvm.JvmInline\nimport kotlin.jvm.JvmName\n\n/**\n * A discriminated union that encapsulates a successful outcome with a value of type [T]\n * or a failure with an arbitrary [Throwable] exception.\n */\n@SinceKotlin(\"1.3\")\n@JvmInline\npublic value class Result<out T> @PublishedApi internal constructor(\n    @PublishedApi\n    internal val value: Any?\n) : Serializable {\n    // discovery\n\n    /**\n     * Returns `true` if this instance represents a successful outcome.\n     * In this case [isFailure] returns `false`.\n     */\n    public val isSuccess: Boolean get() = value !is Failure\n\n    /**\n     * Returns `true` if this instance represents a failed outcome.\n     * In this case [isSuccess] returns `false`.\n     */\n    public val isFailure: Boolean get() = value is Failure\n\n    // value & exception retrieval\n\n    /**\n     * Returns the encapsulated value if this instance represents [success][Result.isSuccess] or `null`\n     * if it is [failure][Result.isFailure].\n     *\n     * This function is a shorthand for `getOrElse { null }` (see [getOrElse]) or\n     * `fold(onSuccess = { it }, onFailure = { null })` (see [fold]).\n     */\n    @InlineOnly\n    public inline fun getOrNull(): T? =\n        when {\n            isFailure -> null\n            else -> value as T\n        }\n\n    /**\n     * Returns the encapsulated [Throwable] exception if this instance represents [failure][isFailure] or `null`\n     * if it is [success][isSuccess].\n     *\n     * This function is a shorthand for `fold(onSuccess = { null }, onFailure = { it })` (see [fold]).\n     */\n    public fun exceptionOrNull(): Throwable? =\n        when (value) {\n            is Failure -> value.exception\n            else -> null\n        }\n\n    /**\n     * Returns a string `Success(v)` if this instance represents [success][Result.isSuccess]\n     * where `v` is a string representation of the value or a string `Failure(x)` if\n     * it is [failure][isFailure] where `x` is a string representation of the exception.\n     */\n    public override fun toString(): String =\n        when (value) {\n            is Failure -> value.toString() // \"Failure($exception)\"\n            else -> \"Success($value)\"\n        }\n\n    // companion with constructors\n\n    /**\n     * Companion object for [Result] class that contains its constructor functions\n     * [success] and [failure].\n     */\n    public companion object {\n        /**\n         * Returns an instance that encapsulates the given [value] as successful value.\n         */\n        @Suppress(\"INAPPLICABLE_JVM_NAME\")\n        @InlineOnly\n        @JvmName(\"success\")\n        public inline fun <T> success(value: T): Result<T> =\n            Result(value)\n\n        /**\n         * Returns an instance that encapsulates the given [Throwable] [exception] as failure.\n         */\n        @Suppress(\"INAPPLICABLE_JVM_NAME\")\n        @InlineOnly\n        @JvmName(\"failure\")\n        public inline fun <T> failure(exception: Throwable): Result<T> =\n            Result(createFailure(exception))\n    }\n\n    internal class Failure(\n        @JvmField\n        val exception: Throwable\n    ) : Serializable {\n        override fun equals(other: Any?): Boolean = other is Failure && exception == other.exception\n        override fun hashCode(): Int = exception.hashCode()\n        override fun toString(): String = \"Failure($exception)\"\n    }\n}\n\n/**\n * Creates an instance of internal marker [Result.Failure] class to\n * make sure that this class is not exposed in ABI.\n */\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun createFailure(exception: Throwable): Any =\n    Result.Failure(exception)\n\n/**\n * Throws exception if the result is failure. This internal function minimizes\n * inlined bytecode for [getOrThrow] and makes sure that in the future we can\n * add some exception-augmenting logic here (if needed).\n */\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun Result<*>.throwOnFailure() {\n    if (value is Result.Failure) throw value.exception\n}\n\n/**\n * Calls the specified function [block] and returns its encapsulated result if invocation was successful,\n * catching any [Throwable] exception that was thrown from the [block] function execution and encapsulating it as a failure.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R> runCatching(block: () -> R): Result<R> {\n    return try {\n        Result.success(block())\n    } catch (e: Throwable) {\n        Result.failure(e)\n    }\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns its encapsulated result if invocation was successful,\n * catching any [Throwable] exception that was thrown from the [block] function execution and encapsulating it as a failure.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <T, R> T.runCatching(block: T.() -> R): Result<R> {\n    return try {\n        Result.success(block())\n    } catch (e: Throwable) {\n        Result.failure(e)\n    }\n}\n\n// -- extensions ---\n\n/**\n * Returns the encapsulated value if this instance represents [success][Result.isSuccess] or throws the encapsulated [Throwable] exception\n * if it is [failure][Result.isFailure].\n *\n * This function is a shorthand for `getOrElse { throw it }` (see [getOrElse]).\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <T> Result<T>.getOrThrow(): T {\n    throwOnFailure()\n    return value as T\n}\n\n/**\n * Returns the encapsulated value if this instance represents [success][Result.isSuccess] or the\n * result of [onFailure] function for the encapsulated [Throwable] exception if it is [failure][Result.isFailure].\n *\n * Note, that this function rethrows any [Throwable] exception thrown by [onFailure] function.\n *\n * This function is a shorthand for `fold(onSuccess = { it }, onFailure = onFailure)` (see [fold]).\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R, T : R> Result<T>.getOrElse(onFailure: (exception: Throwable) -> R): R {\n    contract {\n        callsInPlace(onFailure, InvocationKind.AT_MOST_ONCE)\n    }\n    return when (val exception = exceptionOrNull()) {\n        null -> value as T\n        else -> onFailure(exception)\n    }\n}\n\n/**\n * Returns the encapsulated value if this instance represents [success][Result.isSuccess] or the\n * [defaultValue] if it is [failure][Result.isFailure].\n *\n * This function is a shorthand for `getOrElse { defaultValue }` (see [getOrElse]).\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R, T : R> Result<T>.getOrDefault(defaultValue: R): R {\n    if (isFailure) return defaultValue\n    return value as T\n}\n\n/**\n * Returns the result of [onSuccess] for the encapsulated value if this instance represents [success][Result.isSuccess]\n * or the result of [onFailure] function for the encapsulated [Throwable] exception if it is [failure][Result.isFailure].\n *\n * Note, that this function rethrows any [Throwable] exception thrown by [onSuccess] or by [onFailure] function.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R, T> Result<T>.fold(\n    onSuccess: (value: T) -> R,\n    onFailure: (exception: Throwable) -> R\n): R {\n    contract {\n        callsInPlace(onSuccess, InvocationKind.AT_MOST_ONCE)\n        callsInPlace(onFailure, InvocationKind.AT_MOST_ONCE)\n    }\n    return when (val exception = exceptionOrNull()) {\n        null -> onSuccess(value as T)\n        else -> onFailure(exception)\n    }\n}\n\n// transformation\n\n/**\n * Returns the encapsulated result of the given [transform] function applied to the encapsulated value\n * if this instance represents [success][Result.isSuccess] or the\n * original encapsulated [Throwable] exception if it is [failure][Result.isFailure].\n *\n * Note, that this function rethrows any [Throwable] exception thrown by [transform] function.\n * See [mapCatching] for an alternative that encapsulates exceptions.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R, T> Result<T>.map(transform: (value: T) -> R): Result<R> {\n    contract {\n        callsInPlace(transform, InvocationKind.AT_MOST_ONCE)\n    }\n    return when {\n        isSuccess -> Result.success(transform(value as T))\n        else -> Result(value)\n    }\n}\n\n/**\n * Returns the encapsulated result of the given [transform] function applied to the encapsulated value\n * if this instance represents [success][Result.isSuccess] or the\n * original encapsulated [Throwable] exception if it is [failure][Result.isFailure].\n *\n * This function catches any [Throwable] exception thrown by [transform] function and encapsulates it as a failure.\n * See [map] for an alternative that rethrows exceptions from `transform` function.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R, T> Result<T>.mapCatching(transform: (value: T) -> R): Result<R> {\n    return when {\n        isSuccess -> runCatching { transform(value as T) }\n        else -> Result(value)\n    }\n}\n\n/**\n * Returns the encapsulated result of the given [transform] function applied to the encapsulated [Throwable] exception\n * if this instance represents [failure][Result.isFailure] or the\n * original encapsulated value if it is [success][Result.isSuccess].\n *\n * Note, that this function rethrows any [Throwable] exception thrown by [transform] function.\n * See [recoverCatching] for an alternative that encapsulates exceptions.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R, T : R> Result<T>.recover(transform: (exception: Throwable) -> R): Result<R> {\n    contract {\n        callsInPlace(transform, InvocationKind.AT_MOST_ONCE)\n    }\n    return when (val exception = exceptionOrNull()) {\n        null -> this\n        else -> Result.success(transform(exception))\n    }\n}\n\n/**\n * Returns the encapsulated result of the given [transform] function applied to the encapsulated [Throwable] exception\n * if this instance represents [failure][Result.isFailure] or the\n * original encapsulated value if it is [success][Result.isSuccess].\n *\n * This function catches any [Throwable] exception thrown by [transform] function and encapsulates it as a failure.\n * See [recover] for an alternative that rethrows exceptions.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R, T : R> Result<T>.recoverCatching(transform: (exception: Throwable) -> R): Result<R> {\n    return when (val exception = exceptionOrNull()) {\n        null -> this\n        else -> runCatching { transform(exception) }\n    }\n}\n\n// \"peek\" onto value/exception and pipe\n\n/**\n * Performs the given [action] on the encapsulated [Throwable] exception if this instance represents [failure][Result.isFailure].\n * Returns the original `Result` unchanged.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <T> Result<T>.onFailure(action: (exception: Throwable) -> Unit): Result<T> {\n    contract {\n        callsInPlace(action, InvocationKind.AT_MOST_ONCE)\n    }\n    exceptionOrNull()?.let { action(it) }\n    return this\n}\n\n/**\n * Performs the given [action] on the encapsulated value if this instance represents [success][Result.isSuccess].\n * Returns the original `Result` unchanged.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <T> Result<T>.onSuccess(action: (value: T) -> Unit): Result<T> {\n    contract {\n        callsInPlace(action, InvocationKind.AT_MOST_ONCE)\n    }\n    if (isSuccess) action(value as T)\n    return this\n}\n\n// -------------------\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.coroutines\n\nimport kotlin.contracts.*\nimport kotlin.coroutines.intrinsics.*\nimport kotlin.internal.InlineOnly\n\n/**\n * Interface representing a continuation after a suspension point that returns a value of type `T`.\n */\n@SinceKotlin(\"1.3\")\npublic interface Continuation<in T> {\n    /**\n     * The context of the coroutine that corresponds to this continuation.\n     */\n    public val context: CoroutineContext\n\n    /**\n     * Resumes the execution of the corresponding coroutine passing a successful or failed [result] as the\n     * return value of the last suspension point.\n     */\n    public fun resumeWith(result: Result<T>)\n}\n\n/**\n * Classes and interfaces marked with this annotation are restricted when used as receivers for extension\n * `suspend` functions. These `suspend` extensions can only invoke other member or extension `suspend` functions on this particular\n * receiver and are restricted from calling arbitrary suspension functions.\n */\n@SinceKotlin(\"1.3\")\n@Target(AnnotationTarget.CLASS)\n@Retention(AnnotationRetention.BINARY)\npublic annotation class RestrictsSuspension\n\n/**\n * Resumes the execution of the corresponding coroutine passing [value] as the return value of the last suspension point.\n */\n@SinceKotlin(\"1.3\")\n@InlineOnly\npublic inline fun <T> Continuation<T>.resume(value: T): Unit =\n    resumeWith(Result.success(value))\n\n/**\n * Resumes the execution of the corresponding coroutine so that the [exception] is re-thrown right after the\n * last suspension point.\n */\n@SinceKotlin(\"1.3\")\n@InlineOnly\npublic inline fun <T> Continuation<T>.resumeWithException(exception: Throwable): Unit =\n    resumeWith(Result.failure(exception))\n\n\n/**\n * Creates a [Continuation] instance with the given [context] and implementation of [resumeWith] method.\n */\n@SinceKotlin(\"1.3\")\n@InlineOnly\npublic inline fun <T> Continuation(\n    context: CoroutineContext,\n    crossinline resumeWith: (Result<T>) -> Unit\n): Continuation<T> =\n    object : Continuation<T> {\n        override val context: CoroutineContext\n            get() = context\n\n        override fun resumeWith(result: Result<T>) =\n            resumeWith(result)\n    }\n\n/**\n * Creates a coroutine without a receiver and with result type [T].\n * This function creates a new, fresh instance of suspendable computation every time it is invoked.\n *\n * To start executing the created coroutine, invoke `resume(Unit)` on the returned [Continuation] instance.\n * The [completion] continuation is invoked when the coroutine completes with a result or an exception.\n * Subsequent invocation of any resume function on the resulting continuation will produce an [IllegalStateException].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"UNCHECKED_CAST\")\npublic fun <T> (suspend () -> T).createCoroutine(\n    completion: Continuation<T>\n): Continuation<Unit> =\n    SafeContinuation(createCoroutineUnintercepted(completion).intercepted(), COROUTINE_SUSPENDED)\n\n/**\n * Creates a coroutine with receiver type [R] and result type [T].\n * This function creates a new, fresh instance of suspendable computation every time it is invoked.\n *\n * To start executing the created coroutine, invoke `resume(Unit)` on the returned [Continuation] instance.\n * The [completion] continuation is invoked when the coroutine completes with a result or an exception.\n * Subsequent invocation of any resume function on the resulting continuation will produce an [IllegalStateException].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"UNCHECKED_CAST\")\npublic fun <R, T> (suspend R.() -> T).createCoroutine(\n    receiver: R,\n    completion: Continuation<T>\n): Continuation<Unit> =\n    SafeContinuation(createCoroutineUnintercepted(receiver, completion).intercepted(), COROUTINE_SUSPENDED)\n\n/**\n * Starts a coroutine without a receiver and with result type [T].\n * This function creates and starts a new, fresh instance of suspendable computation every time it is invoked.\n * The [completion] continuation is invoked when the coroutine completes with a result or an exception.\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"UNCHECKED_CAST\")\npublic fun <T> (suspend () -> T).startCoroutine(\n    completion: Continuation<T>\n) {\n    createCoroutineUnintercepted(completion).intercepted().resume(Unit)\n}\n\n/**\n * Starts a coroutine with receiver type [R] and result type [T].\n * This function creates and starts a new, fresh instance of suspendable computation every time it is invoked.\n * The [completion] continuation is invoked when the coroutine completes with a result or an exception.\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"UNCHECKED_CAST\")\npublic fun <R, T> (suspend R.() -> T).startCoroutine(\n    receiver: R,\n    completion: Continuation<T>\n) {\n    createCoroutineUnintercepted(receiver, completion).intercepted().resume(Unit)\n}\n\n/**\n * Obtains the current continuation instance inside suspend functions and suspends\n * the currently running coroutine.\n *\n * In this function both [Continuation.resume] and [Continuation.resumeWithException] can be used either synchronously in\n * the same stack-frame where the suspension function is run or asynchronously later in the same thread or\n * from a different thread of execution. Subsequent invocation of any resume function will produce an [IllegalStateException].\n */\n@SinceKotlin(\"1.3\")\n@InlineOnly\npublic suspend inline fun <T> suspendCoroutine(crossinline block: (Continuation<T>) -> Unit): T {\n    contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }\n    return suspendCoroutineUninterceptedOrReturn { c: Continuation<T> ->\n        val safe = SafeContinuation(c.intercepted())\n        block(safe)\n        safe.getOrThrow()\n    }\n}\n\n/**\n * Returns the context of the current coroutine.\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"WRONG_MODIFIER_TARGET\")\n@InlineOnly\npublic suspend inline val coroutineContext: CoroutineContext\n    get() {\n        throw NotImplementedError(\"Implemented as intrinsic\")\n    }\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin\n\n// NOTE: Do not author your exceptions as they are written in this file, instead use this template:\n/*\npublic open class MyException : Exception {\n    constructor() : super()\n    constructor(message: String?) : super(message)\n    constructor(message: String?, cause: Throwable?) : super(message, cause)\n    constructor(cause: Throwable?) : super(cause)\n}\n*/\n\n\n// TODO: remove primary constructors, make all secondary KT-22055\n\n@Suppress(\"USELESS_ELVIS_RIGHT_IS_NULL\")\npublic actual open class Error actual constructor(message: String?, cause: Throwable?) : Throwable(message, cause ?: null) {\n    actual constructor() : this(null, null)\n    actual constructor(message: String?) : this(message, null)\n    actual constructor(cause: Throwable?) : this(undefined, cause)\n}\n\n@Suppress(\"USELESS_ELVIS_RIGHT_IS_NULL\")\npublic actual open class Exception actual constructor(message: String?, cause: Throwable?) : Throwable(message, cause ?: null) {\n    actual constructor() : this(null, null)\n    actual constructor(message: String?) : this(message, null)\n    actual constructor(cause: Throwable?) : this(undefined, cause)\n}\n\npublic actual open class RuntimeException actual constructor(message: String?, cause: Throwable?) : Exception(message, cause) {\n    actual constructor() : this(null, null)\n    actual constructor(message: String?) : this(message, null)\n    actual constructor(cause: Throwable?) : this(undefined, cause)\n}\n\npublic actual open class IllegalArgumentException actual constructor(message: String?, cause: Throwable?) : RuntimeException(message, cause) {\n    actual constructor() : this(null, null)\n    actual constructor(message: String?) : this(message, null)\n    actual constructor(cause: Throwable?) : this(undefined, cause)\n}\n\npublic actual open class IllegalStateException actual constructor(message: String?, cause: Throwable?) : RuntimeException(message, cause) {\n    actual constructor() : this(null, null)\n    actual constructor(message: String?) : this(message, null)\n    actual constructor(cause: Throwable?) : this(undefined, cause)\n}\n\npublic actual open class IndexOutOfBoundsException actual constructor(message: String?) : RuntimeException(message) {\n    actual constructor() : this(null)\n}\n\npublic actual open class ConcurrentModificationException actual constructor(message: String?, cause: Throwable?) : RuntimeException(message, cause) {\n    actual constructor() : this(null, null)\n    actual constructor(message: String?) : this(message, null)\n    actual constructor(cause: Throwable?) : this(undefined, cause)\n}\n\npublic actual open class UnsupportedOperationException actual constructor(message: String?, cause: Throwable?) : RuntimeException(message, cause) {\n    actual constructor() : this(null, null)\n    actual constructor(message: String?) : this(message, null)\n    actual constructor(cause: Throwable?) : this(undefined, cause)\n}\n\n\npublic actual open class NumberFormatException actual constructor(message: String?) : IllegalArgumentException(message) {\n    actual constructor() : this(null)\n}\n\n\npublic actual open class NullPointerException actual constructor(message: String?) : RuntimeException(message) {\n    actual constructor() : this(null)\n}\n\npublic actual open class ClassCastException actual constructor(message: String?) : RuntimeException(message) {\n    actual constructor() : this(null)\n}\n\npublic actual open class AssertionError\n@SinceKotlin(\"1.4\")\nconstructor(message: String?, cause: Throwable?) : Error(message, cause) {\n    actual constructor() : this(null)\n    constructor(message: String?) : this(message, null)\n    actual constructor(message: Any?) : this(message.toString(), message as? Throwable)\n}\n\npublic actual open class NoSuchElementException actual constructor(message: String?) : RuntimeException(message) {\n    actual constructor() : this(null)\n}\n\n@SinceKotlin(\"1.3\")\npublic actual open class ArithmeticException actual constructor(message: String?) : RuntimeException(message) {\n    actual constructor() : this(null)\n}\n\npublic actual open class NoWhenBranchMatchedException actual constructor(message: String?, cause: Throwable?) : RuntimeException(message, cause) {\n    actual constructor() : this(null, null)\n    actual constructor(message: String?) : this(message, null)\n    actual constructor(cause: Throwable?) : this(undefined, cause)\n}\n\npublic actual open class UninitializedPropertyAccessException actual constructor(message: String?, cause: Throwable?) : RuntimeException(message, cause) {\n    actual constructor() : this(null, null)\n    actual constructor(message: String?) : this(message, null)\n    actual constructor(cause: Throwable?) : this(undefined, cause)\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:Suppress(\"UNUSED_PARAMETER\", \"NOTHING_TO_INLINE\")\n\npackage kotlin\n\n/**\n * Returns an empty array of the specified type [T].\n */\npublic inline fun <T> emptyArray(): Array<T> = js(\"[]\")\n\n@library\npublic fun <T> arrayOf(vararg elements: T): Array<T> = definedExternally\n\n@library\npublic fun doubleArrayOf(vararg elements: Double): DoubleArray = definedExternally\n\n@library\npublic fun floatArrayOf(vararg elements: Float): FloatArray = definedExternally\n\n@library\npublic fun longArrayOf(vararg elements: Long): LongArray = definedExternally\n\n@library\npublic fun intArrayOf(vararg elements: Int): IntArray = definedExternally\n\n@library\npublic fun charArrayOf(vararg elements: Char): CharArray = definedExternally\n\n@library\npublic fun shortArrayOf(vararg elements: Short): ShortArray = definedExternally\n\n@library\npublic fun byteArrayOf(vararg elements: Byte): ByteArray = definedExternally\n\n@library\npublic fun booleanArrayOf(vararg elements: Boolean): BooleanArray = definedExternally\n\n/**\n * Creates a new instance of the [Lazy] that uses the specified initialization function [initializer].\n */\npublic actual fun <T> lazy(initializer: () -> T): Lazy<T> = UnsafeLazyImpl(initializer)\n\n/**\n * Creates a new instance of the [Lazy] that uses the specified initialization function [initializer].\n *\n * The [mode] parameter is ignored. */\npublic actual fun <T> lazy(mode: LazyThreadSafetyMode, initializer: () -> T): Lazy<T> = UnsafeLazyImpl(initializer)\n\n/**\n * Creates a new instance of the [Lazy] that uses the specified initialization function [initializer].\n *\n * The [lock] parameter is ignored.\n */\npublic actual fun <T> lazy(lock: Any?, initializer: () -> T): Lazy<T> = UnsafeLazyImpl(initializer)\n\n\ninternal fun fillFrom(src: dynamic, dst: dynamic): dynamic {\n    val srcLen: Int = src.length\n    val dstLen: Int = dst.length\n    var index: Int = 0\n    while (index < srcLen && index < dstLen) dst[index] = src[index++]\n    return dst\n}\n\n\ninternal fun arrayCopyResize(source: dynamic, newSize: Int, defaultValue: Any?): dynamic {\n    val result = source.slice(0, newSize)\n    copyArrayType(source, result)\n    var index: Int = source.length\n    if (newSize > index) {\n        result.length = newSize\n        while (index < newSize) result[index++] = defaultValue\n    }\n    return result\n}\n\ninternal fun <T> arrayPlusCollection(array: dynamic, collection: Collection<T>): dynamic {\n    val result = array.slice()\n    result.length += collection.size\n    copyArrayType(array, result)\n    var index: Int = array.length\n    for (element in collection) result[index++] = element\n    return result\n}\n\ninternal fun <T> fillFromCollection(dst: dynamic, startIndex: Int, collection: Collection<T>): dynamic {\n    var index = startIndex\n    for (element in collection) dst[index++] = element\n    return dst\n}\n\ninternal inline fun copyArrayType(from: dynamic, to: dynamic) {\n    if (from.`$type$` !== undefined) {\n        to.`$type$` = from.`$type$`\n    }\n}\n\ninternal inline fun jsIsType(obj: dynamic, jsClass: dynamic) = js(\"Kotlin\").isType(obj, jsClass)","/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\n/**\n * Returns a string representation of this [Long] value in the specified [radix].\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for number to string conversion.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Long.toString(radix: Int): String = asDynamic().toString(checkRadix(radix))","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.collections\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.js.*\nimport primitiveArrayConcat\nimport withType\nimport kotlin.ranges.contains\nimport kotlin.ranges.reversed\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun <T> Array<out T>.elementAt(index: Int): T {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun ByteArray.elementAt(index: Int): Byte {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun ShortArray.elementAt(index: Int): Short {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun IntArray.elementAt(index: Int): Int {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun LongArray.elementAt(index: Int): Long {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun FloatArray.elementAt(index: Int): Float {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun DoubleArray.elementAt(index: Int): Double {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun BooleanArray.elementAt(index: Int): Boolean {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun CharArray.elementAt(index: Int): Char {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic actual fun <T> Array<out T>.asList(): List<T> {\n    return ArrayList<T>(this.unsafeCast<Array<Any?>>())\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun ByteArray.asList(): List<Byte> {\n    return this.unsafeCast<Array<Byte>>().asList()\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun ShortArray.asList(): List<Short> {\n    return this.unsafeCast<Array<Short>>().asList()\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun IntArray.asList(): List<Int> {\n    return this.unsafeCast<Array<Int>>().asList()\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun LongArray.asList(): List<Long> {\n    return this.unsafeCast<Array<Long>>().asList()\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun FloatArray.asList(): List<Float> {\n    return this.unsafeCast<Array<Float>>().asList()\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun DoubleArray.asList(): List<Double> {\n    return this.unsafeCast<Array<Double>>().asList()\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun BooleanArray.asList(): List<Boolean> {\n    return this.unsafeCast<Array<Boolean>>().asList()\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic actual fun CharArray.asList(): List<Char> {\n    return object : AbstractList<Char>(), RandomAccess {\n        override val size: Int get() = this@asList.size\n        override fun isEmpty(): Boolean = this@asList.isEmpty()\n        override fun contains(element: Char): Boolean = this@asList.contains(element)\n        override fun get(index: Int): Char {\n            AbstractList.checkElementIndex(index, size)\n            return this@asList[index]\n        }\n        override fun indexOf(element: Char): Int {\n            @Suppress(\"USELESS_CAST\")\n            if ((element as Any?) !is Char) return -1\n            return this@asList.indexOf(element)\n        }\n        override fun lastIndexOf(element: Char): Int {\n            @Suppress(\"USELESS_CAST\")\n            if ((element as Any?) !is Char) return -1\n            return this@asList.lastIndexOf(element)\n        }\n    }\n}\n\n/**\n * Returns `true` if the two specified arrays are *deeply* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * If two corresponding elements are nested arrays, they are also compared deeply.\n * If any of arrays contains itself on any nesting level the behavior is undefined.\n * \n * The elements of other types are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.LowPriorityInOverloadResolution\npublic actual infix fun <T> Array<out T>.contentDeepEquals(other: Array<out T>): Boolean {\n    return this.contentDeepEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *deeply* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The specified arrays are also considered deeply equal if both are `null`.\n * \n * If two corresponding elements are nested arrays, they are also compared deeply.\n * If any of arrays contains itself on any nesting level the behavior is undefined.\n * \n * The elements of other types are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayDeepEquals\")\npublic actual infix fun <T> Array<out T>?.contentDeepEquals(other: Array<out T>?): Boolean {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n * Nested arrays are treated as lists too.\n * \n * If any of arrays contains itself on any nesting level the behavior is undefined.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.LowPriorityInOverloadResolution\npublic actual fun <T> Array<out T>.contentDeepHashCode(): Int {\n    return this.contentDeepHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n * Nested arrays are treated as lists too.\n * \n * If any of arrays contains itself on any nesting level the behavior is undefined.\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayDeepHashCode\")\npublic actual fun <T> Array<out T>?.contentDeepHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of this array as if it is a [List].\n * Nested arrays are treated as lists too.\n * \n * If any of arrays contains itself on any nesting level that reference\n * is rendered as `\"[...]\"` to prevent recursion.\n * \n * @sample samples.collections.Arrays.ContentOperations.contentDeepToString\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.LowPriorityInOverloadResolution\npublic actual fun <T> Array<out T>.contentDeepToString(): String {\n    return this.contentDeepToString()\n}\n\n/**\n * Returns a string representation of the contents of this array as if it is a [List].\n * Nested arrays are treated as lists too.\n * \n * If any of arrays contains itself on any nesting level that reference\n * is rendered as `\"[...]\"` to prevent recursion.\n * \n * @sample samples.collections.Arrays.ContentOperations.contentDeepToString\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayDeepToString\")\npublic actual fun <T> Array<out T>?.contentDeepToString(): String {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual infix fun <T> Array<out T>.contentEquals(other: Array<out T>): Boolean {\n    return this.contentEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual infix fun ByteArray.contentEquals(other: ByteArray): Boolean {\n    return this.contentEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual infix fun ShortArray.contentEquals(other: ShortArray): Boolean {\n    return this.contentEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual infix fun IntArray.contentEquals(other: IntArray): Boolean {\n    return this.contentEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual infix fun LongArray.contentEquals(other: LongArray): Boolean {\n    return this.contentEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual infix fun FloatArray.contentEquals(other: FloatArray): Boolean {\n    return this.contentEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual infix fun DoubleArray.contentEquals(other: DoubleArray): Boolean {\n    return this.contentEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual infix fun BooleanArray.contentEquals(other: BooleanArray): Boolean {\n    return this.contentEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual infix fun CharArray.contentEquals(other: CharArray): Boolean {\n    return this.contentEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayEquals\")\npublic actual infix fun <T> Array<out T>?.contentEquals(other: Array<out T>?): Boolean {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayEquals\")\npublic actual infix fun ByteArray?.contentEquals(other: ByteArray?): Boolean {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayEquals\")\npublic actual infix fun ShortArray?.contentEquals(other: ShortArray?): Boolean {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayEquals\")\npublic actual infix fun IntArray?.contentEquals(other: IntArray?): Boolean {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayEquals\")\npublic actual infix fun LongArray?.contentEquals(other: LongArray?): Boolean {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayEquals\")\npublic actual infix fun FloatArray?.contentEquals(other: FloatArray?): Boolean {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayEquals\")\npublic actual infix fun DoubleArray?.contentEquals(other: DoubleArray?): Boolean {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayEquals\")\npublic actual infix fun BooleanArray?.contentEquals(other: BooleanArray?): Boolean {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayEquals\")\npublic actual infix fun CharArray?.contentEquals(other: CharArray?): Boolean {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun <T> Array<out T>.contentHashCode(): Int {\n    return this.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun ByteArray.contentHashCode(): Int {\n    return this.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun ShortArray.contentHashCode(): Int {\n    return this.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun IntArray.contentHashCode(): Int {\n    return this.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun LongArray.contentHashCode(): Int {\n    return this.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun FloatArray.contentHashCode(): Int {\n    return this.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun DoubleArray.contentHashCode(): Int {\n    return this.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun BooleanArray.contentHashCode(): Int {\n    return this.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun CharArray.contentHashCode(): Int {\n    return this.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayHashCode\")\npublic actual fun <T> Array<out T>?.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayHashCode\")\npublic actual fun ByteArray?.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayHashCode\")\npublic actual fun ShortArray?.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayHashCode\")\npublic actual fun IntArray?.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayHashCode\")\npublic actual fun LongArray?.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayHashCode\")\npublic actual fun FloatArray?.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayHashCode\")\npublic actual fun DoubleArray?.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayHashCode\")\npublic actual fun BooleanArray?.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayHashCode\")\npublic actual fun CharArray?.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun <T> Array<out T>.contentToString(): String {\n    return this.contentToString()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun ByteArray.contentToString(): String {\n    return this.contentToString()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun ShortArray.contentToString(): String {\n    return this.contentToString()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun IntArray.contentToString(): String {\n    return this.contentToString()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun LongArray.contentToString(): String {\n    return this.contentToString()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun FloatArray.contentToString(): String {\n    return this.contentToString()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun DoubleArray.contentToString(): String {\n    return this.contentToString()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun BooleanArray.contentToString(): String {\n    return this.contentToString()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun CharArray.contentToString(): String {\n    return this.contentToString()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayToString\")\npublic actual fun <T> Array<out T>?.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayToString\")\npublic actual fun ByteArray?.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayToString\")\npublic actual fun ShortArray?.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayToString\")\npublic actual fun IntArray?.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayToString\")\npublic actual fun LongArray?.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayToString\")\npublic actual fun FloatArray?.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayToString\")\npublic actual fun DoubleArray?.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayToString\")\npublic actual fun BooleanArray?.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayToString\")\npublic actual fun CharArray?.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun <T> Array<out T>.copyInto(destination: Array<T>, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): Array<T> {\n    arrayCopy(this, destination, destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun ByteArray.copyInto(destination: ByteArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): ByteArray {\n    arrayCopy(this.unsafeCast<Array<Byte>>(), destination.unsafeCast<Array<Byte>>(), destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun ShortArray.copyInto(destination: ShortArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): ShortArray {\n    arrayCopy(this.unsafeCast<Array<Short>>(), destination.unsafeCast<Array<Short>>(), destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun IntArray.copyInto(destination: IntArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): IntArray {\n    arrayCopy(this.unsafeCast<Array<Int>>(), destination.unsafeCast<Array<Int>>(), destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun LongArray.copyInto(destination: LongArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): LongArray {\n    arrayCopy(this.unsafeCast<Array<Long>>(), destination.unsafeCast<Array<Long>>(), destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun FloatArray.copyInto(destination: FloatArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): FloatArray {\n    arrayCopy(this.unsafeCast<Array<Float>>(), destination.unsafeCast<Array<Float>>(), destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun DoubleArray.copyInto(destination: DoubleArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): DoubleArray {\n    arrayCopy(this.unsafeCast<Array<Double>>(), destination.unsafeCast<Array<Double>>(), destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun BooleanArray.copyInto(destination: BooleanArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): BooleanArray {\n    arrayCopy(this.unsafeCast<Array<Boolean>>(), destination.unsafeCast<Array<Boolean>>(), destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun CharArray.copyInto(destination: CharArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): CharArray {\n    arrayCopy(this.unsafeCast<Array<Char>>(), destination.unsafeCast<Array<Char>>(), destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\", \"NOTHING_TO_INLINE\")\npublic actual inline fun <T> Array<out T>.copyOf(): Array<T> {\n    return this.asDynamic().slice()\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun ByteArray.copyOf(): ByteArray {\n    return this.asDynamic().slice()\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun ShortArray.copyOf(): ShortArray {\n    return this.asDynamic().slice()\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun IntArray.copyOf(): IntArray {\n    return this.asDynamic().slice()\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic actual fun LongArray.copyOf(): LongArray {\n    return withType(\"LongArray\", this.asDynamic().slice())\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun FloatArray.copyOf(): FloatArray {\n    return this.asDynamic().slice()\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun DoubleArray.copyOf(): DoubleArray {\n    return this.asDynamic().slice()\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic actual fun BooleanArray.copyOf(): BooleanArray {\n    return withType(\"BooleanArray\", this.asDynamic().slice())\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic actual fun CharArray.copyOf(): CharArray {\n    return withType(\"CharArray\", this.asDynamic().slice())\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic actual fun ByteArray.copyOf(newSize: Int): ByteArray {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return fillFrom(this, ByteArray(newSize))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic actual fun ShortArray.copyOf(newSize: Int): ShortArray {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return fillFrom(this, ShortArray(newSize))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic actual fun IntArray.copyOf(newSize: Int): IntArray {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return fillFrom(this, IntArray(newSize))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic actual fun LongArray.copyOf(newSize: Int): LongArray {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return withType(\"LongArray\", arrayCopyResize(this, newSize, 0L))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic actual fun FloatArray.copyOf(newSize: Int): FloatArray {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return fillFrom(this, FloatArray(newSize))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic actual fun DoubleArray.copyOf(newSize: Int): DoubleArray {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return fillFrom(this, DoubleArray(newSize))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with `false` values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with `false` values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic actual fun BooleanArray.copyOf(newSize: Int): BooleanArray {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return withType(\"BooleanArray\", arrayCopyResize(this, newSize, false))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with null char (`\\u0000`) values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with null char (`\\u0000`) values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic actual fun CharArray.copyOf(newSize: Int): CharArray {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return withType(\"CharArray\", fillFrom(this, CharArray(newSize)))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with `null` values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with `null` values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizingCopyOf\n */\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\")\npublic actual fun <T> Array<out T>.copyOf(newSize: Int): Array<T?> {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return arrayCopyResize(this, newSize, null)\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\")\npublic actual fun <T> Array<out T>.copyOfRange(fromIndex: Int, toIndex: Int): Array<T> {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return this.asDynamic().slice(fromIndex, toIndex)\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic actual fun ByteArray.copyOfRange(fromIndex: Int, toIndex: Int): ByteArray {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return this.asDynamic().slice(fromIndex, toIndex)\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic actual fun ShortArray.copyOfRange(fromIndex: Int, toIndex: Int): ShortArray {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return this.asDynamic().slice(fromIndex, toIndex)\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic actual fun IntArray.copyOfRange(fromIndex: Int, toIndex: Int): IntArray {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return this.asDynamic().slice(fromIndex, toIndex)\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic actual fun LongArray.copyOfRange(fromIndex: Int, toIndex: Int): LongArray {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return withType(\"LongArray\", this.asDynamic().slice(fromIndex, toIndex))\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic actual fun FloatArray.copyOfRange(fromIndex: Int, toIndex: Int): FloatArray {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return this.asDynamic().slice(fromIndex, toIndex)\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic actual fun DoubleArray.copyOfRange(fromIndex: Int, toIndex: Int): DoubleArray {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return this.asDynamic().slice(fromIndex, toIndex)\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic actual fun BooleanArray.copyOfRange(fromIndex: Int, toIndex: Int): BooleanArray {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return withType(\"BooleanArray\", this.asDynamic().slice(fromIndex, toIndex))\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic actual fun CharArray.copyOfRange(fromIndex: Int, toIndex: Int): CharArray {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return withType(\"CharArray\", this.asDynamic().slice(fromIndex, toIndex))\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun <T> Array<T>.fill(element: T, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    this.asDynamic().fill(element, fromIndex, toIndex);\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun ByteArray.fill(element: Byte, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    this.asDynamic().fill(element, fromIndex, toIndex);\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun ShortArray.fill(element: Short, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    this.asDynamic().fill(element, fromIndex, toIndex);\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun IntArray.fill(element: Int, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    this.asDynamic().fill(element, fromIndex, toIndex);\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun LongArray.fill(element: Long, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    this.asDynamic().fill(element, fromIndex, toIndex);\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun FloatArray.fill(element: Float, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    this.asDynamic().fill(element, fromIndex, toIndex);\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun DoubleArray.fill(element: Double, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    this.asDynamic().fill(element, fromIndex, toIndex);\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun BooleanArray.fill(element: Boolean, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    this.asDynamic().fill(element, fromIndex, toIndex);\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun CharArray.fill(element: Char, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    this.asDynamic().fill(element, fromIndex, toIndex);\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\", \"NOTHING_TO_INLINE\")\npublic actual inline operator fun <T> Array<out T>.plus(element: T): Array<T> {\n    return this.asDynamic().concat(arrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun ByteArray.plus(element: Byte): ByteArray {\n    return plus(byteArrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun ShortArray.plus(element: Short): ShortArray {\n    return plus(shortArrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun IntArray.plus(element: Int): IntArray {\n    return plus(intArrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun LongArray.plus(element: Long): LongArray {\n    return plus(longArrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun FloatArray.plus(element: Float): FloatArray {\n    return plus(floatArrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun DoubleArray.plus(element: Double): DoubleArray {\n    return plus(doubleArrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun BooleanArray.plus(element: Boolean): BooleanArray {\n    return plus(booleanArrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun CharArray.plus(element: Char): CharArray {\n    return plus(charArrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\")\npublic actual operator fun <T> Array<out T>.plus(elements: Collection<T>): Array<T> {\n    return arrayPlusCollection(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic actual operator fun ByteArray.plus(elements: Collection<Byte>): ByteArray {\n    return fillFromCollection(this.copyOf(size + elements.size), this.size, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic actual operator fun ShortArray.plus(elements: Collection<Short>): ShortArray {\n    return fillFromCollection(this.copyOf(size + elements.size), this.size, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic actual operator fun IntArray.plus(elements: Collection<Int>): IntArray {\n    return fillFromCollection(this.copyOf(size + elements.size), this.size, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic actual operator fun LongArray.plus(elements: Collection<Long>): LongArray {\n    return arrayPlusCollection(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic actual operator fun FloatArray.plus(elements: Collection<Float>): FloatArray {\n    return fillFromCollection(this.copyOf(size + elements.size), this.size, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic actual operator fun DoubleArray.plus(elements: Collection<Double>): DoubleArray {\n    return fillFromCollection(this.copyOf(size + elements.size), this.size, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic actual operator fun BooleanArray.plus(elements: Collection<Boolean>): BooleanArray {\n    return arrayPlusCollection(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic actual operator fun CharArray.plus(elements: Collection<Char>): CharArray {\n    return fillFromCollection(this.copyOf(size + elements.size), this.size, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\", \"NOTHING_TO_INLINE\")\npublic actual inline operator fun <T> Array<out T>.plus(elements: Array<out T>): Array<T> {\n    return this.asDynamic().concat(elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun ByteArray.plus(elements: ByteArray): ByteArray {\n    return primitiveArrayConcat(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun ShortArray.plus(elements: ShortArray): ShortArray {\n    return primitiveArrayConcat(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun IntArray.plus(elements: IntArray): IntArray {\n    return primitiveArrayConcat(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun LongArray.plus(elements: LongArray): LongArray {\n    return primitiveArrayConcat(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun FloatArray.plus(elements: FloatArray): FloatArray {\n    return primitiveArrayConcat(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun DoubleArray.plus(elements: DoubleArray): DoubleArray {\n    return primitiveArrayConcat(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun BooleanArray.plus(elements: BooleanArray): BooleanArray {\n    return primitiveArrayConcat(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun CharArray.plus(elements: CharArray): CharArray {\n    return primitiveArrayConcat(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\", \"NOTHING_TO_INLINE\")\npublic actual inline fun <T> Array<out T>.plusElement(element: T): Array<T> {\n    return this.asDynamic().concat(arrayOf(element))\n}\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\n@library(\"primitiveArraySort\")\npublic actual fun IntArray.sort(): Unit {\n    definedExternally\n}\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\npublic actual fun LongArray.sort(): Unit {\n    if (size > 1) sort { a: Long, b: Long -> a.compareTo(b) }\n}\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\n@library(\"primitiveArraySort\")\npublic actual fun ByteArray.sort(): Unit {\n    definedExternally\n}\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\n@library(\"primitiveArraySort\")\npublic actual fun ShortArray.sort(): Unit {\n    definedExternally\n}\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\n@library(\"primitiveArraySort\")\npublic actual fun DoubleArray.sort(): Unit {\n    definedExternally\n}\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\n@library(\"primitiveArraySort\")\npublic actual fun FloatArray.sort(): Unit {\n    definedExternally\n}\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\n@library(\"primitiveArraySort\")\npublic actual fun CharArray.sort(): Unit {\n    definedExternally\n}\n\n/**\n * Sorts the array in-place according to the natural order of its elements.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n * \n * @sample samples.collections.Arrays.Sorting.sortArrayOfComparable\n */\npublic actual fun <T : Comparable<T>> Array<out T>.sort(): Unit {\n    if (size > 1) sortArray(this)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparison] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T> Array<out T>.sort(comparison: (a: T, b: T) -> Int): Unit {\n    if (size > 1) sortArrayWith(this, comparison)\n}\n\n/**\n * Sorts a range in the array in-place.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArrayOfComparable\n */\n@SinceKotlin(\"1.4\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun <T : Comparable<T>> Array<out T>.sort(fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    sortArrayWith(this, fromIndex, toIndex, naturalOrder())\n}\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun ByteArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val subarray = this.asDynamic().subarray(fromIndex, toIndex).unsafeCast<ByteArray>()\n    subarray.sort()\n}\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun ShortArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val subarray = this.asDynamic().subarray(fromIndex, toIndex).unsafeCast<ShortArray>()\n    subarray.sort()\n}\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun IntArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val subarray = this.asDynamic().subarray(fromIndex, toIndex).unsafeCast<IntArray>()\n    subarray.sort()\n}\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun LongArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    sortArrayWith(this.unsafeCast<Array<Long>>(), fromIndex, toIndex, naturalOrder())\n}\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun FloatArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val subarray = this.asDynamic().subarray(fromIndex, toIndex).unsafeCast<FloatArray>()\n    subarray.sort()\n}\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun DoubleArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val subarray = this.asDynamic().subarray(fromIndex, toIndex).unsafeCast<DoubleArray>()\n    subarray.sort()\n}\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun CharArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val subarray = this.asDynamic().subarray(fromIndex, toIndex).unsafeCast<CharArray>()\n    subarray.sort()\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparison] function.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.sort(noinline comparison: (a: Byte, b: Byte) -> Int): Unit {\n    asDynamic().sort(comparison)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparison] function.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.sort(noinline comparison: (a: Short, b: Short) -> Int): Unit {\n    asDynamic().sort(comparison)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparison] function.\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.sort(noinline comparison: (a: Int, b: Int) -> Int): Unit {\n    asDynamic().sort(comparison)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparison] function.\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.sort(noinline comparison: (a: Long, b: Long) -> Int): Unit {\n    asDynamic().sort(comparison)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparison] function.\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.sort(noinline comparison: (a: Float, b: Float) -> Int): Unit {\n    asDynamic().sort(comparison)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparison] function.\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.sort(noinline comparison: (a: Double, b: Double) -> Int): Unit {\n    asDynamic().sort(comparison)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparison] function.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.sort(noinline comparison: (a: Char, b: Char) -> Int): Unit {\n    asDynamic().sort(comparison)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic actual fun <T> Array<out T>.sortWith(comparator: Comparator<in T>): Unit {\n    if (size > 1) sortArrayWith(this, comparator)\n}\n\n/**\n * Sorts a range in the array in-place with the given [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun <T> Array<out T>.sortWith(comparator: Comparator<in T>, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    sortArrayWith(this, fromIndex, toIndex, comparator)\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic actual fun ByteArray.toTypedArray(): Array<Byte> {\n    return js(\"[]\").slice.call(this)\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic actual fun ShortArray.toTypedArray(): Array<Short> {\n    return js(\"[]\").slice.call(this)\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic actual fun IntArray.toTypedArray(): Array<Int> {\n    return js(\"[]\").slice.call(this)\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic actual fun LongArray.toTypedArray(): Array<Long> {\n    return js(\"[]\").slice.call(this)\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic actual fun FloatArray.toTypedArray(): Array<Float> {\n    return js(\"[]\").slice.call(this)\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic actual fun DoubleArray.toTypedArray(): Array<Double> {\n    return js(\"[]\").slice.call(this)\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic actual fun BooleanArray.toTypedArray(): Array<Boolean> {\n    return js(\"[]\").slice.call(this)\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic actual fun CharArray.toTypedArray(): Array<Char> {\n    return Array(size) { index -> this[index] }\n}\n\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateUnicodeData.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\n// 9 ranges totally\n/**\n * Returns `true` if this character is a whitespace.\n */\ninternal fun Char.isWhitespaceImpl(): Boolean {\n    val ch = this.code\n    return ch in 0x0009..0x000d\n            || ch in 0x001c..0x0020\n            || ch == 0x00a0\n            || ch > 0x1000 && (\n                ch == 0x1680\n                || ch in 0x2000..0x200a\n                || ch == 0x2028\n                || ch == 0x2029\n                || ch == 0x202f\n                || ch == 0x205f\n                || ch == 0x3000\n            )\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.collections\n\nimport kotlin.comparisons.naturalOrder\nimport kotlin.random.Random\n\n/** Returns the array if it's not `null`, or an empty array otherwise. */\n@kotlin.internal.InlineOnly\npublic actual inline fun <T> Array<out T>?.orEmpty(): Array<out T> = this ?: emptyArray<T>()\n\n@kotlin.internal.InlineOnly\npublic actual inline fun <T> Collection<T>.toTypedArray(): Array<T> = copyToArray(this)\n\n@JsName(\"copyToArray\")\n@PublishedApi\ninternal fun <T> copyToArray(collection: Collection<T>): Array<T> {\n    return if (collection.asDynamic().toArray !== undefined)\n        collection.asDynamic().toArray().unsafeCast<Array<T>>()\n    else\n        copyToArrayImpl(collection).unsafeCast<Array<T>>()\n}\n\n@JsName(\"copyToArrayImpl\")\ninternal actual fun copyToArrayImpl(collection: Collection<*>): Array<Any?> {\n    val array = emptyArray<Any?>()\n    val iterator = collection.iterator()\n    while (iterator.hasNext())\n        array.asDynamic().push(iterator.next())\n    return array\n}\n\n@JsName(\"copyToExistingArrayImpl\")\ninternal actual fun <T> copyToArrayImpl(collection: Collection<*>, array: Array<T>): Array<T> {\n    if (array.size < collection.size)\n        return copyToArrayImpl(collection).unsafeCast<Array<T>>()\n\n    val iterator = collection.iterator()\n    var index = 0\n    while (iterator.hasNext()) {\n        array[index++] = iterator.next().unsafeCast<T>()\n    }\n    if (index < array.size) {\n        array[index] = null.unsafeCast<T>()\n    }\n    return array\n}\n\n\n/**\n * Returns an immutable list containing only the specified object [element].\n */\npublic fun <T> listOf(element: T): List<T> = arrayListOf(element)\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal actual inline fun <E> buildListInternal(builderAction: MutableList<E>.() -> Unit): List<E> {\n    return ArrayList<E>().apply(builderAction).build()\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal actual inline fun <E> buildListInternal(capacity: Int, builderAction: MutableList<E>.() -> Unit): List<E> {\n    checkBuilderCapacity(capacity)\n    return ArrayList<E>(capacity).apply(builderAction).build()\n}\n\n\n/**\n * Returns an immutable set containing only the specified object [element].\n */\npublic fun <T> setOf(element: T): Set<T> = hashSetOf(element)\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal actual inline fun <E> buildSetInternal(builderAction: MutableSet<E>.() -> Unit): Set<E> {\n    return LinkedHashSet<E>().apply(builderAction).build()\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal actual inline fun <E> buildSetInternal(capacity: Int, builderAction: MutableSet<E>.() -> Unit): Set<E> {\n    return LinkedHashSet<E>(capacity).apply(builderAction).build()\n}\n\n\n/**\n * Returns an immutable map, mapping only the specified key to the\n * specified value.\n */\npublic fun <K, V> mapOf(pair: Pair<K, V>): Map<K, V> = hashMapOf(pair)\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal actual inline fun <K, V> buildMapInternal(builderAction: MutableMap<K, V>.() -> Unit): Map<K, V> {\n    return LinkedHashMap<K, V>().apply(builderAction).build()\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\ninternal actual inline fun <K, V> buildMapInternal(capacity: Int, builderAction: MutableMap<K, V>.() -> Unit): Map<K, V> {\n    return LinkedHashMap<K, V>(capacity).apply(builderAction).build()\n}\n\n\n/**\n * Fills the list with the provided [value].\n *\n * Each element in the list gets replaced with the [value].\n */\n@SinceKotlin(\"1.2\")\npublic actual fun <T> MutableList<T>.fill(value: T): Unit {\n    for (index in 0..lastIndex) {\n        this[index] = value\n    }\n}\n\n/**\n * Randomly shuffles elements in this list.\n *\n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.2\")\npublic actual fun <T> MutableList<T>.shuffle(): Unit = shuffle(Random)\n\n/**\n * Returns a new list with the elements of this list randomly shuffled.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun <T> Iterable<T>.shuffled(): List<T> = toMutableList().apply { shuffle() }\n\n/**\n * Sorts elements in the list in-place according to their natural sort order.\n *\n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic actual fun <T : Comparable<T>> MutableList<T>.sort(): Unit {\n    collectionsSort(this, naturalOrder())\n}\n\n/**\n * Sorts elements in the list in-place according to the order specified with [comparator].\n *\n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic actual fun <T> MutableList<T>.sortWith(comparator: Comparator<in T>): Unit {\n    collectionsSort(this, comparator)\n}\n\nprivate fun <T> collectionsSort(list: MutableList<T>, comparator: Comparator<in T>) {\n    if (list.size <= 1) return\n\n    val array = copyToArray(list)\n    sortArrayWith(array, comparator)\n\n    for (i in 0 until array.size) {\n        list[i] = array[i]\n    }\n}\n\ninternal actual fun <T> arrayOfNulls(reference: Array<T>, size: Int): Array<T> {\n    return arrayOfNulls<Any>(size).unsafeCast<Array<T>>()\n}\n\n@SinceKotlin(\"1.3\")\n@PublishedApi\n@JsName(\"arrayCopy\")\ninternal fun <T> arrayCopy(source: Array<out T>, destination: Array<in T>, destinationOffset: Int, startIndex: Int, endIndex: Int) {\n    AbstractList.checkRangeIndexes(startIndex, endIndex, source.size)\n    val rangeSize = endIndex - startIndex\n    AbstractList.checkRangeIndexes(destinationOffset, destinationOffset + rangeSize, destination.size)\n\n    if (js(\"ArrayBuffer\").isView(destination) && js(\"ArrayBuffer\").isView(source)) {\n        val subrange = source.asDynamic().subarray(startIndex, endIndex)\n        destination.asDynamic().set(subrange, destinationOffset)\n    } else {\n        if (source !== destination || destinationOffset <= startIndex) {\n            for (index in 0 until rangeSize) {\n                destination[destinationOffset + index] = source[startIndex + index]\n            }\n        } else {\n            for (index in rangeSize - 1 downTo 0) {\n                destination[destinationOffset + index] = source[startIndex + index]\n            }\n        }\n    }\n}\n\n// no singleton map implementation in js, return map as is\n@Suppress(\"NOTHING_TO_INLINE\")\ninternal actual inline fun <K, V> Map<K, V>.toSingletonMapOrSelf(): Map<K, V> = this\n\n@Suppress(\"NOTHING_TO_INLINE\")\ninternal actual inline fun <K, V> Map<out K, V>.toSingletonMap(): Map<K, V> = this.toMutableMap()\n\n\n@Suppress(\"NOTHING_TO_INLINE\")\ninternal actual inline fun <T> Array<out T>.copyToArrayOfAny(isVarargs: Boolean): Array<out Any?> =\n    if (isVarargs)\n    // no need to copy vararg array in JS\n        this\n    else\n        this.copyOf()\n\n\n\n@PublishedApi\ninternal actual fun checkIndexOverflow(index: Int): Int {\n    if (index < 0) {\n        throwIndexOverflow()\n    }\n    return index\n}\n\n@PublishedApi\ninternal actual fun checkCountOverflow(count: Int): Int {\n    if (count < 0) {\n        throwCountOverflow()\n    }\n    return count\n}\n\n\n/**\n * JS map and set implementations do not make use of capacities or load factors.\n */\n@PublishedApi\ninternal actual fun mapCapacity(expectedSize: Int) = expectedSize\n\n/**\n * Checks a collection builder function capacity argument.\n * In JS no validation is made in Map/Set constructor yet.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@PublishedApi\ninternal fun checkBuilderCapacity(capacity: Int) {\n    require(capacity >= 0) { \"capacity must be non-negative.\" }\n}","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.collections\n\n/**\n * Provides a skeletal implementation of the [MutableCollection] interface.\n *\n * @param E the type of elements contained in the collection. The collection is invariant in its element type.\n */\npublic actual abstract class AbstractMutableCollection<E> protected actual constructor() : AbstractCollection<E>(), MutableCollection<E> {\n\n    actual abstract override fun add(element: E): Boolean\n\n    actual override fun remove(element: E): Boolean {\n        checkIsMutable()\n        val iterator = iterator()\n        while (iterator.hasNext()) {\n            if (iterator.next() == element) {\n                iterator.remove()\n                return true\n            }\n        }\n        return false\n    }\n\n    actual override fun addAll(elements: Collection<E>): Boolean {\n        checkIsMutable()\n        var modified = false\n        for (element in elements) {\n            if (add(element)) modified = true\n        }\n        return modified\n    }\n\n    actual override fun removeAll(elements: Collection<E>): Boolean {\n        checkIsMutable()\n        return (this as MutableIterable<E>).removeAll { it in elements }\n    }\n\n    actual override fun retainAll(elements: Collection<E>): Boolean {\n        checkIsMutable()\n        return (this as MutableIterable<E>).removeAll { it !in elements }\n    }\n\n    actual override fun clear(): Unit {\n        checkIsMutable()\n        val iterator = this.iterator()\n        while (iterator.hasNext()) {\n            iterator.next()\n            iterator.remove()\n        }\n    }\n\n    @JsName(\"toJSON\")\n    open fun toJSON(): Any = this.toArray()\n\n\n    /**\n     * This method is called every time when a mutating method is called on this mutable collection.\n     * Mutable collections that are built (frozen) must throw `UnsupportedOperationException`.\n     */\n    internal open fun checkIsMutable(): Unit { }\n}\n\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n/*\n * Based on GWT AbstractList\n * Copyright 2007 Google Inc.\n*/\n\n\npackage kotlin.collections\n\n/**\n * Provides a skeletal implementation of the [MutableList] interface.\n *\n * @param E the type of elements contained in the list. The list is invariant in its element type.\n */\npublic actual abstract class AbstractMutableList<E> protected actual constructor() : AbstractMutableCollection<E>(), MutableList<E> {\n    protected var modCount: Int = 0\n\n    abstract override fun add(index: Int, element: E): Unit\n    abstract override fun removeAt(index: Int): E\n    abstract override fun set(index: Int, element: E): E\n\n    /**\n     * Adds the specified element to the end of this list.\n     *\n     * @return `true` because the list is always modified as the result of this operation.\n     */\n    actual override fun add(element: E): Boolean {\n        checkIsMutable()\n        add(size, element)\n        return true\n    }\n\n    actual override fun addAll(index: Int, elements: Collection<E>): Boolean {\n        checkIsMutable()\n        var _index = index\n        var changed = false\n        for (e in elements) {\n            add(_index++, e)\n            changed = true\n        }\n        return changed\n    }\n\n    actual override fun clear() {\n        checkIsMutable()\n        removeRange(0, size)\n    }\n\n    actual override fun removeAll(elements: Collection<E>): Boolean {\n        checkIsMutable()\n        return removeAll { it in elements }\n    }\n\n    actual override fun retainAll(elements: Collection<E>): Boolean {\n        checkIsMutable()\n        return removeAll { it !in elements }\n    }\n\n\n    actual override fun iterator(): MutableIterator<E> = IteratorImpl()\n\n    actual override fun contains(element: E): Boolean = indexOf(element) >= 0\n\n    actual override fun indexOf(element: E): Int {\n        for (index in 0..lastIndex) {\n            if (get(index) == element) {\n                return index\n            }\n        }\n        return -1\n    }\n\n    actual override fun lastIndexOf(element: E): Int {\n        for (index in lastIndex downTo 0) {\n            if (get(index) == element) {\n                return index\n            }\n        }\n        return -1\n    }\n\n    actual override fun listIterator(): MutableListIterator<E> = listIterator(0)\n    actual override fun listIterator(index: Int): MutableListIterator<E> = ListIteratorImpl(index)\n\n\n    actual override fun subList(fromIndex: Int, toIndex: Int): MutableList<E> = SubList(this, fromIndex, toIndex)\n\n    /**\n     * Removes the range of elements from this list starting from [fromIndex] and ending with but not including [toIndex].\n     */\n    protected open fun removeRange(fromIndex: Int, toIndex: Int) {\n        val iterator = listIterator(fromIndex)\n        repeat(toIndex - fromIndex) {\n            iterator.next()\n            iterator.remove()\n        }\n    }\n\n    /**\n     * Compares this list with another list instance with the ordered structural equality.\n     *\n     * @return true, if [other] instance is a [List] of the same size, which contains the same elements in the same order.\n     */\n    override fun equals(other: Any?): Boolean {\n        if (other === this) return true\n        if (other !is List<*>) return false\n\n        return AbstractList.orderedEquals(this, other)\n    }\n\n    /**\n     * Returns the hash code value for this list.\n     */\n    override fun hashCode(): Int = AbstractList.orderedHashCode(this)\n\n\n    private open inner class IteratorImpl : MutableIterator<E> {\n        /** the index of the item that will be returned on the next call to [next]`()` */\n        protected var index = 0\n        /** the index of the item that was returned on the previous call to [next]`()`\n         * or [ListIterator.previous]`()` (for `ListIterator`),\n         * -1 if no such item exists\n         */\n        protected var last = -1\n\n        override fun hasNext(): Boolean = index < size\n\n        override fun next(): E {\n            if (!hasNext()) throw NoSuchElementException()\n            last = index++\n            return get(last)\n        }\n\n        override fun remove() {\n            check(last != -1) { \"Call next() or previous() before removing element from the iterator.\" }\n\n            removeAt(last)\n            index = last\n            last = -1\n        }\n    }\n\n    /**\n     * Implementation of `MutableListIterator` for abstract lists.\n     */\n    private inner class ListIteratorImpl(index: Int) : IteratorImpl(), MutableListIterator<E> {\n\n        init {\n            AbstractList.checkPositionIndex(index, this@AbstractMutableList.size)\n            this.index = index\n        }\n\n        override fun hasPrevious(): Boolean = index > 0\n\n        override fun nextIndex(): Int = index\n\n        override fun previous(): E {\n            if (!hasPrevious()) throw NoSuchElementException()\n\n            last = --index\n            return get(last)\n        }\n\n        override fun previousIndex(): Int = index - 1\n\n        override fun add(element: E) {\n            add(index, element)\n            index++\n            last = -1\n        }\n\n        override fun set(element: E) {\n            check(last != -1) { \"Call next() or previous() before updating element value with the iterator.\" }\n            set(last, element)\n        }\n    }\n\n    private class SubList<E>(private val list: AbstractMutableList<E>, private val fromIndex: Int, toIndex: Int) : AbstractMutableList<E>(), RandomAccess {\n        private var _size: Int = 0\n\n        init {\n            AbstractList.checkRangeIndexes(fromIndex, toIndex, list.size)\n            this._size = toIndex - fromIndex\n        }\n\n        override fun add(index: Int, element: E) {\n            AbstractList.checkPositionIndex(index, _size)\n\n            list.add(fromIndex + index, element)\n            _size++\n        }\n\n        override fun get(index: Int): E {\n            AbstractList.checkElementIndex(index, _size)\n\n            return list[fromIndex + index]\n        }\n\n        override fun removeAt(index: Int): E {\n            AbstractList.checkElementIndex(index, _size)\n\n            val result = list.removeAt(fromIndex + index)\n            _size--\n            return result\n        }\n\n        override fun set(index: Int, element: E): E {\n            AbstractList.checkElementIndex(index, _size)\n\n            return list.set(fromIndex + index, element)\n        }\n\n        override val size: Int get() = _size\n\n        internal override fun checkIsMutable(): Unit = list.checkIsMutable()\n    }\n\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n/*\n * Based on GWT AbstractMap\n * Copyright 2007 Google Inc.\n */\n\npackage kotlin.collections\n\n/**\n * Provides a skeletal implementation of the [MutableMap] interface.\n *\n * The implementor is required to implement [entries] property, which should return mutable set of map entries, and [put] function.\n *\n * @param K the type of map keys. The map is invariant in its key type.\n * @param V the type of map values. The map is invariant in its value type.\n */\npublic actual abstract class AbstractMutableMap<K, V> protected actual constructor() : AbstractMap<K, V>(), MutableMap<K, V> {\n\n    /**\n     * A mutable [Map.Entry] shared by several [Map] implementations.\n     */\n    internal open class SimpleEntry<K, V>(override val key: K, value: V) : MutableMap.MutableEntry<K, V> {\n        constructor(entry: Map.Entry<K, V>) : this(entry.key, entry.value)\n\n        private var _value = value\n\n        override val value: V get() = _value\n\n        override fun setValue(newValue: V): V {\n            // Should check if the map containing this entry is mutable.\n            // However, to not increase entry memory footprint it might be worthwhile not to check it here and\n            // force subclasses that implement `build()` (freezing) operation to implement their own `MutableEntry`.\n//            this@AbstractMutableMap.checkIsMutable()\n            val oldValue = this._value\n            this._value = newValue\n            return oldValue\n        }\n\n        override fun hashCode(): Int = entryHashCode(this)\n        override fun toString(): String = entryToString(this)\n        override fun equals(other: Any?): Boolean = entryEquals(this, other)\n\n    }\n\n    // intermediate abstract class to workaround KT-43321\n    internal abstract class AbstractEntrySet<E : Map.Entry<K, V>, K, V> : AbstractMutableSet<E>() {\n        final override fun contains(element: E): Boolean = containsEntry(element)\n        abstract fun containsEntry(element: Map.Entry<K, V>): Boolean\n    }\n\n    actual override fun clear() {\n        entries.clear()\n    }\n\n    private var _keys: MutableSet<K>? = null\n    actual override val keys: MutableSet<K>\n        get() {\n            if (_keys == null) {\n                _keys = object : AbstractMutableSet<K>() {\n                    override fun add(element: K): Boolean = throw UnsupportedOperationException(\"Add is not supported on keys\")\n                    override fun clear() {\n                        this@AbstractMutableMap.clear()\n                    }\n\n                    override operator fun contains(element: K): Boolean = containsKey(element)\n\n                    override operator fun iterator(): MutableIterator<K> {\n                        val entryIterator = entries.iterator()\n                        return object : MutableIterator<K> {\n                            override fun hasNext(): Boolean = entryIterator.hasNext()\n                            override fun next(): K = entryIterator.next().key\n                            override fun remove() = entryIterator.remove()\n                        }\n                    }\n\n                    override fun remove(element: K): Boolean {\n                        checkIsMutable()\n                        if (containsKey(element)) {\n                            this@AbstractMutableMap.remove(element)\n                            return true\n                        }\n                        return false\n                    }\n\n                    override val size: Int get() = this@AbstractMutableMap.size\n\n                    override fun checkIsMutable(): Unit = this@AbstractMutableMap.checkIsMutable()\n                }\n            }\n            return _keys!!\n        }\n\n    actual abstract override fun put(key: K, value: V): V?\n\n    actual override fun putAll(from: Map<out K, V>) {\n        checkIsMutable()\n        for ((key, value) in from) {\n            put(key, value)\n        }\n    }\n\n    private var _values: MutableCollection<V>? = null\n    actual override val values: MutableCollection<V>\n        get() {\n            if (_values == null) {\n                _values = object : AbstractMutableCollection<V>() {\n                    override fun add(element: V): Boolean = throw UnsupportedOperationException(\"Add is not supported on values\")\n                    override fun clear() = this@AbstractMutableMap.clear()\n\n                    override operator fun contains(element: V): Boolean = containsValue(element)\n\n                    override operator fun iterator(): MutableIterator<V> {\n                        val entryIterator = entries.iterator()\n                        return object : MutableIterator<V> {\n                            override fun hasNext(): Boolean = entryIterator.hasNext()\n                            override fun next(): V = entryIterator.next().value\n                            override fun remove() = entryIterator.remove()\n                        }\n                    }\n\n                    override val size: Int get() = this@AbstractMutableMap.size\n\n                    // TODO: should we implement them this way? Currently it's unspecified in JVM\n                    override fun equals(other: Any?): Boolean {\n                        if (this === other) return true\n                        if (other !is Collection<*>) return false\n                        return AbstractList.orderedEquals(this, other)\n                    }\n\n                    override fun hashCode(): Int = AbstractList.orderedHashCode(this)\n\n                    override fun checkIsMutable(): Unit = this@AbstractMutableMap.checkIsMutable()\n                }\n            }\n            return _values!!\n        }\n\n    actual override fun remove(key: K): V? {\n        checkIsMutable()\n        val iter = entries.iterator()\n        while (iter.hasNext()) {\n            val entry = iter.next()\n            val k = entry.key\n            if (key == k) {\n                val value = entry.value\n                iter.remove()\n                return value\n            }\n        }\n        return null\n    }\n\n\n    /**\n     * This method is called every time when a mutating method is called on this mutable map.\n     * Mutable maps that are built (frozen) must throw `UnsupportedOperationException`.\n     */\n    internal open fun checkIsMutable(): Unit {}\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\npackage kotlin.collections\n\n/**\n * Provides a skeletal implementation of the [MutableSet] interface.\n *\n * @param E the type of elements contained in the set. The set is invariant in its element type.\n */\npublic actual abstract class AbstractMutableSet<E> protected actual constructor() : AbstractMutableCollection<E>(), MutableSet<E> {\n\n    /**\n     * Compares this set with another set instance with the unordered structural equality.\n     *\n     * @return `true`, if [other] instance is a [Set] of the same size, all elements of which are contained in this set.\n     */\n    override fun equals(other: Any?): Boolean {\n        if (other === this) return true\n        if (other !is Set<*>) return false\n        return AbstractSet.setEquals(this, other)\n    }\n\n    /**\n     * Returns the hash code value for this set.\n     */\n    override fun hashCode(): Int = AbstractSet.unorderedHashCode(this)\n\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.collections\n\n/**\n * Provides a [MutableList] implementation, which uses a resizable array as its backing storage.\n *\n * This implementation doesn't provide a way to manage capacity, as backing JS array is resizeable itself.\n * There is no speed advantage to pre-allocating array sizes in JavaScript, so this implementation does not include any of the\n * capacity and \"growth increment\" concepts.\n */\npublic actual open class ArrayList<E> internal constructor(private var array: Array<Any?>) : AbstractMutableList<E>(), MutableList<E>, RandomAccess {\n    private var isReadOnly: Boolean = false\n\n    /**\n     * Creates an empty [ArrayList].\n     */\n    public actual constructor() : this(emptyArray()) {}\n\n    /**\n     * Creates an empty [ArrayList].\n     * @param initialCapacity initial capacity (ignored)\n     */\n    @Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\n    public actual constructor(initialCapacity: Int = 0) : this(emptyArray()) {}\n\n    /**\n     * Creates an [ArrayList] filled from the [elements] collection.\n     */\n    public actual constructor(elements: Collection<E>) : this(elements.toTypedArray<Any?>()) {}\n\n    @PublishedApi\n    internal fun build(): List<E> {\n        checkIsMutable()\n        isReadOnly = true\n        return this\n    }\n\n    /** Does nothing in this ArrayList implementation. */\n    public actual fun trimToSize() {}\n\n    /** Does nothing in this ArrayList implementation. */\n    public actual fun ensureCapacity(minCapacity: Int) {}\n\n    actual override val size: Int get() = array.size\n    @Suppress(\"UNCHECKED_CAST\")\n    actual override fun get(index: Int): E = array[rangeCheck(index)] as E\n    actual override fun set(index: Int, element: E): E {\n        checkIsMutable()\n        rangeCheck(index)\n        @Suppress(\"UNCHECKED_CAST\")\n        return array[index].apply { array[index] = element } as E\n    }\n\n    actual override fun add(element: E): Boolean {\n        checkIsMutable()\n        array.asDynamic().push(element)\n        modCount++\n        return true\n    }\n\n    actual override fun add(index: Int, element: E): Unit {\n        checkIsMutable()\n        array.asDynamic().splice(insertionRangeCheck(index), 0, element)\n        modCount++\n    }\n\n    actual override fun addAll(elements: Collection<E>): Boolean {\n        checkIsMutable()\n        if (elements.isEmpty()) return false\n\n        array += elements.toTypedArray<Any?>()\n        modCount++\n        return true\n    }\n\n    actual override fun addAll(index: Int, elements: Collection<E>): Boolean {\n        checkIsMutable()\n        insertionRangeCheck(index)\n\n        if (index == size) return addAll(elements)\n        if (elements.isEmpty()) return false\n        when (index) {\n            size -> return addAll(elements)\n            0 -> array = elements.toTypedArray<Any?>() + array\n            else -> array = array.copyOfRange(0, index).asDynamic().concat(elements.toTypedArray<Any?>(), array.copyOfRange(index, size))\n        }\n\n        modCount++\n        return true\n    }\n\n    actual override fun removeAt(index: Int): E {\n        checkIsMutable()\n        rangeCheck(index)\n        modCount++\n        return if (index == lastIndex)\n            array.asDynamic().pop()\n        else\n            array.asDynamic().splice(index, 1)[0]\n    }\n\n    actual override fun remove(element: E): Boolean {\n        checkIsMutable()\n        for (index in array.indices) {\n            if (array[index] == element) {\n                array.asDynamic().splice(index, 1)\n                modCount++\n                return true\n            }\n        }\n        return false\n    }\n\n    override fun removeRange(fromIndex: Int, toIndex: Int) {\n        checkIsMutable()\n        modCount++\n        array.asDynamic().splice(fromIndex, toIndex - fromIndex)\n    }\n\n    actual override fun clear() {\n        checkIsMutable()\n        array = emptyArray()\n        modCount++\n    }\n\n\n    actual override fun indexOf(element: E): Int = array.indexOf(element)\n\n    actual override fun lastIndexOf(element: E): Int = array.lastIndexOf(element)\n\n    override fun toString() = arrayToString(array)\n\n    @Suppress(\"UNCHECKED_CAST\")\n    override fun <T> toArray(array: Array<T>): Array<T> {\n        if (array.size < size) {\n            return toArray() as Array<T>\n        }\n\n        (this.array as Array<T>).copyInto(array)\n\n        if (array.size > size) {\n            array[size] = null as T // null-terminate\n        }\n\n        return array\n    }\n\n    override fun toArray(): Array<Any?> {\n        return js(\"[]\").slice.call(array)\n    }\n\n\n    internal override fun checkIsMutable() {\n        if (isReadOnly) throw UnsupportedOperationException()\n    }\n\n    private fun rangeCheck(index: Int) = index.apply {\n        AbstractList.checkElementIndex(index, size)\n    }\n\n    private fun insertionRangeCheck(index: Int) = index.apply {\n        AbstractList.checkPositionIndex(index, size)\n    }\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.collections\n\ninternal interface EqualityComparator {\n    /**\n     * Subclasses must override to return a value indicating\n     * whether or not two keys or values are equal.\n     */\n    abstract fun equals(value1: Any?, value2: Any?): Boolean\n\n    /**\n     * Subclasses must override to return the hash code of a given key.\n     */\n    abstract fun getHashCode(value: Any?): Int\n\n\n    object HashCode : EqualityComparator {\n        override fun equals(value1: Any?, value2: Any?): Boolean = value1 == value2\n\n        override fun getHashCode(value: Any?): Int = value?.hashCode() ?: 0\n    }\n}","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin\n\n\npublic actual fun interface Comparator<T> {\n    @JsName(\"compare\")\n    public actual fun compare(a: T, b: T): Int\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n/*\n * Based on GWT AbstractHashMap\n * Copyright 2008 Google Inc.\n */\n\npackage kotlin.collections\n\nimport kotlin.collections.MutableMap.MutableEntry\n\n/**\n * Hash table based implementation of the [MutableMap] interface.\n *\n * This implementation makes no guarantees regarding the order of enumeration of [keys], [values] and [entries] collections.\n */\n// Classes that extend HashMap and implement `build()` (freezing) operation\n// have to make sure mutating methods check `checkIsMutable`.\npublic actual open class HashMap<K, V> : AbstractMutableMap<K, V>, MutableMap<K, V> {\n\n    private inner class EntrySet : AbstractEntrySet<MutableEntry<K, V>, K, V>() {\n\n        override fun add(element: MutableEntry<K, V>): Boolean = throw UnsupportedOperationException(\"Add is not supported on entries\")\n        override fun clear() {\n            this@HashMap.clear()\n        }\n\n        override fun containsEntry(element: Map.Entry<K, V>): Boolean = this@HashMap.containsEntry(element)\n\n        override operator fun iterator(): MutableIterator<MutableEntry<K, V>> = internalMap.iterator()\n\n        override fun remove(element: MutableEntry<K, V>): Boolean {\n            if (contains(element)) {\n                this@HashMap.remove(element.key)\n                return true\n            }\n            return false\n        }\n\n        override val size: Int get() = this@HashMap.size\n    }\n\n\n    /**\n     * Internal implementation of the map: either string-based or hashcode-based.\n     */\n    private val internalMap: InternalMap<K, V>\n\n    private val equality: EqualityComparator\n\n    internal constructor(internalMap: InternalMap<K, V>) : super() {\n        this.internalMap = internalMap\n        this.equality = internalMap.equality\n    }\n\n    /**\n     * Constructs an empty [HashMap] instance.\n     */\n    actual constructor() : this(InternalHashCodeMap(EqualityComparator.HashCode))\n\n    /**\n     * Constructs an empty [HashMap] instance.\n     *\n     * @param  initialCapacity the initial capacity (ignored)\n     * @param  loadFactor      the load factor (ignored)\n     *\n     * @throws IllegalArgumentException if the initial capacity or load factor are negative\n     */\n    @Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\n    actual constructor(initialCapacity: Int, loadFactor: Float = 0.0f) : this() {\n        // This implementation of HashMap has no need of load factors or capacities.\n        require(initialCapacity >= 0) { \"Negative initial capacity: $initialCapacity\" }\n        require(loadFactor >= 0) { \"Non-positive load factor: $loadFactor\" }\n    }\n\n    actual constructor(initialCapacity: Int) : this(initialCapacity, 0.0f)\n\n\n    /**\n     * Constructs an instance of [HashMap] filled with the contents of the specified [original] map.\n     */\n    actual constructor(original: Map<out K, V>) : this() {\n        this.putAll(original)\n    }\n\n    actual override fun clear() {\n        internalMap.clear()\n//        structureChanged(this)\n    }\n\n    actual override fun containsKey(key: K): Boolean = internalMap.contains(key)\n\n    actual override fun containsValue(value: V): Boolean = internalMap.any { equality.equals(it.value, value) }\n\n    private var _entries: MutableSet<MutableMap.MutableEntry<K, V>>? = null\n    actual override val entries: MutableSet<MutableMap.MutableEntry<K, V>>\n        get() {\n            if (_entries == null) {\n                _entries = createEntrySet()\n            }\n            return _entries!!\n        }\n\n    protected open fun createEntrySet(): MutableSet<MutableMap.MutableEntry<K, V>> = EntrySet()\n\n    actual override operator fun get(key: K): V? = internalMap.get(key)\n\n    actual override fun put(key: K, value: V): V? = internalMap.put(key, value)\n\n    actual override fun remove(key: K): V? = internalMap.remove(key)\n\n    actual override val size: Int get() = internalMap.size\n\n}\n\n/**\n * Constructs the specialized implementation of [HashMap] with [String] keys, which stores the keys as properties of\n * JS object without hashing them.\n */\npublic fun <V> stringMapOf(vararg pairs: Pair<String, V>): HashMap<String, V> {\n    return HashMap<String, V>(InternalStringMap(EqualityComparator.HashCode)).apply { putAll(pairs) }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n/*\n * Based on GWT HashSet\n * Copyright 2008 Google Inc.\n */\n\npackage kotlin.collections\n\n/**\n * The implementation of the [MutableSet] interface, backed by a [HashMap] instance.\n */\n// Classes that extend HashSet and implement `build()` (freezing) operation\n// have to make sure mutating methods check `checkIsMutable`.\npublic actual open class HashSet<E> : AbstractMutableSet<E>, MutableSet<E> {\n\n    internal val map: HashMap<E, Any>\n\n    /**\n     * Constructs a new empty [HashSet].\n     */\n    actual constructor() {\n        map = HashMap<E, Any>()\n    }\n\n    /**\n     * Constructs a new [HashSet] filled with the elements of the specified collection.\n     */\n    actual constructor(elements: Collection<E>) {\n        map = HashMap<E, Any>(elements.size)\n        addAll(elements)\n    }\n\n    /**\n     * Constructs a new empty [HashSet].\n     *\n     * @param  initialCapacity the initial capacity (ignored)\n     * @param  loadFactor      the load factor (ignored)\n     *\n     * @throws IllegalArgumentException if the initial capacity or load factor are negative\n     */\n    @Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\n    actual constructor(initialCapacity: Int, loadFactor: Float = 0.0f) {\n        map = HashMap<E, Any>(initialCapacity, loadFactor)\n    }\n\n    actual constructor(initialCapacity: Int) : this(initialCapacity, 0.0f)\n\n    /**\n     * Protected constructor to specify the underlying map. This is used by\n     * LinkedHashSet.\n\n     * @param map underlying map to use.\n     */\n    internal constructor(map: HashMap<E, Any>) {\n        this.map = map\n    }\n\n    actual override fun add(element: E): Boolean {\n        val old = map.put(element, this)\n        return old == null\n    }\n\n    actual override fun clear() {\n        map.clear()\n    }\n\n//    public override fun clone(): Any {\n//        return HashSet<E>(this)\n//    }\n\n    actual override operator fun contains(element: E): Boolean = map.containsKey(element)\n\n    actual override fun isEmpty(): Boolean = map.isEmpty()\n\n    actual override fun iterator(): MutableIterator<E> = map.keys.iterator()\n\n    actual override fun remove(element: E): Boolean = map.remove(element) != null\n\n    actual override val size: Int get() = map.size\n\n}\n\n/**\n * Creates a new instance of the specialized implementation of [HashSet] with the specified [String] elements,\n * which elements the keys as properties of JS object without hashing them.\n */\npublic fun stringSetOf(vararg elements: String): HashSet<String> {\n    return HashSet(stringMapOf<Any>()).apply { addAll(elements) }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n/*\n * Based on GWT InternalHashCodeMap\n * Copyright 2008 Google Inc.\n */\n\npackage kotlin.collections\n\nimport kotlin.collections.MutableMap.MutableEntry\nimport kotlin.collections.AbstractMutableMap.SimpleEntry\n\n/**\n * A simple wrapper around JavaScriptObject to provide [java.util.Map]-like semantics for any\n * key type.\n *\n *\n * Implementation notes:\n *\n *\n * A key's hashCode is the index in backingMap which should contain that key. Since several keys may\n * have the same hash, each value in hashCodeMap is actually an array containing all entries whose\n * keys share the same hash.\n */\ninternal class InternalHashCodeMap<K, V>(override val equality: EqualityComparator) : InternalMap<K, V> {\n\n    private var backingMap: dynamic = createJsMap()\n    override var size: Int = 0\n        private set\n\n    override fun put(key: K, value: V): V? {\n        val hashCode = equality.getHashCode(key)\n        val chainOrEntry = getChainOrEntryOrNull(hashCode)\n        if (chainOrEntry == null) {\n            // This is a new chain, put it to the map.\n            backingMap[hashCode] = SimpleEntry(key, value)\n        } else {\n            if (chainOrEntry !is Array<*>) {\n                // It is an entry\n                val entry: SimpleEntry<K, V> = chainOrEntry\n                if (equality.equals(entry.key, key)) {\n                    return entry.setValue(value)\n                } else {\n                    backingMap[hashCode] = arrayOf(entry, SimpleEntry(key, value))\n                    size++\n                    return null\n                }\n            } else {\n                // Chain already exists, perhaps key also exists.\n                val chain: Array<MutableEntry<K, V>> = chainOrEntry\n                val entry = chain.findEntryInChain(key)\n                if (entry != null) {\n                    return entry.setValue(value)\n                }\n                chain.asDynamic().push(SimpleEntry(key, value))\n            }\n        }\n        size++\n//        structureChanged(host)\n        return null\n    }\n\n    override fun remove(key: K): V? {\n        val hashCode = equality.getHashCode(key)\n        val chainOrEntry = getChainOrEntryOrNull(hashCode) ?: return null\n        if (chainOrEntry !is Array<*>) {\n            val entry: MutableEntry<K, V> = chainOrEntry\n            if (equality.equals(entry.key, key)) {\n                jsDeleteProperty(backingMap, hashCode)\n                size--\n                return entry.value\n            } else {\n                return null\n            }\n        } else {\n            val chain: Array<MutableEntry<K, V>> = chainOrEntry\n            for (index in chain.indices) {\n                val entry = chain[index]\n                if (equality.equals(key, entry.key)) {\n                    if (chain.size == 1) {\n                        chain.asDynamic().length = 0\n                        // remove the whole array\n                        jsDeleteProperty(backingMap, hashCode)\n                    } else {\n                        // splice out the entry we're removing\n                        chain.asDynamic().splice(index, 1)\n                    }\n                    size--\n//                structureChanged(host)\n                    return entry.value\n                }\n            }\n        }\n        return null\n    }\n\n    override fun clear() {\n        backingMap = createJsMap()\n        size = 0\n    }\n\n    override fun contains(key: K): Boolean = getEntry(key) != null\n\n    override fun get(key: K): V? = getEntry(key)?.value\n\n    private fun getEntry(key: K): MutableEntry<K, V>? {\n        val chainOrEntry = getChainOrEntryOrNull(equality.getHashCode(key)) ?: return null\n        if (chainOrEntry !is Array<*>) {\n            val entry: MutableEntry<K, V> = chainOrEntry\n            if (equality.equals(entry.key, key)) {\n                return entry\n            } else {\n                return null\n            }\n        } else {\n            val chain: Array<MutableEntry<K, V>> = chainOrEntry\n            return chain.findEntryInChain(key)\n        }\n    }\n\n    private fun Array<MutableEntry<K, V>>.findEntryInChain(key: K): MutableEntry<K, V>? =\n        firstOrNull { entry -> equality.equals(entry.key, key) }\n\n    override fun iterator(): MutableIterator<MutableEntry<K, V>> {\n\n        return object : MutableIterator<MutableEntry<K, V>> {\n            var state = -1 // -1 not ready, 0 - ready, 1 - done\n\n            val keys: Array<String> = js(\"Object\").keys(backingMap)\n            var keyIndex = -1\n\n            var chainOrEntry: dynamic = null\n            var isChain = false\n            var itemIndex = -1\n            var lastEntry: MutableEntry<K, V>? = null\n\n            private fun computeNext(): Int {\n                if (chainOrEntry != null && isChain) {\n                    val chainSize: Int = chainOrEntry.unsafeCast<Array<MutableEntry<K, V>>>().size\n                    if (++itemIndex < chainSize)\n                        return 0\n                }\n\n                if (++keyIndex < keys.size) {\n                    chainOrEntry = backingMap[keys[keyIndex]]\n                    isChain = chainOrEntry is Array<*>\n                    itemIndex = 0\n                    return 0\n                } else {\n                    chainOrEntry = null\n                    return 1\n                }\n            }\n\n            override fun hasNext(): Boolean {\n                if (state == -1)\n                    state = computeNext()\n                return state == 0\n            }\n\n            override fun next(): MutableEntry<K, V> {\n                if (!hasNext()) throw NoSuchElementException()\n                val lastEntry = if (isChain) {\n                    chainOrEntry.unsafeCast<Array<MutableEntry<K, V>>>()[itemIndex]\n                } else {\n                    chainOrEntry.unsafeCast<MutableEntry<K, V>>()\n                }\n                this.lastEntry = lastEntry\n                state = -1\n                return lastEntry\n            }\n\n            override fun remove() {\n                checkNotNull(lastEntry)\n                this@InternalHashCodeMap.remove(lastEntry!!.key)\n                lastEntry = null\n                // the chain being iterated just got modified by InternalHashCodeMap.remove\n                itemIndex--\n            }\n        }\n    }\n\n    private fun getChainOrEntryOrNull(hashCode: Int): dynamic {\n        val chainOrEntry = backingMap[hashCode]\n        return if (chainOrEntry === undefined) null else chainOrEntry\n    }\n\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n/*\n * Based on GWT InternalStringMap\n * Copyright 2008 Google Inc.\n */\npackage kotlin.collections\n\nimport kotlin.collections.MutableMap.MutableEntry\n\n/**\n * A simple wrapper around JavaScript Map for key type is string.\n *\n * Though this map is instantiated only with K=String, the K type is not fixed to String statically,\n * because we want to have it erased to Any? in order not to generate type-safe override bridges for\n * [get], [contains], [remove] etc, if they ever are generated.\n */\ninternal class InternalStringMap<K, V>(override val equality: EqualityComparator) : InternalMap<K, V> {\n\n    private var backingMap: dynamic = createJsMap()\n    override var size: Int = 0\n        private set\n\n//    /**\n//     * A mod count to track 'value' replacements in map to ensure that the 'value' that we have in the\n//     * iterator entry is guaranteed to be still correct.\n//     * This is to optimize for the common scenario where the values are not modified during\n//     * iterations where the entries are never stale.\n//     */\n//    private var valueMod: Int = 0\n\n    override operator fun contains(key: K): Boolean {\n        if (key !is String) return false\n        return backingMap[key] !== undefined\n    }\n\n    override operator fun get(key: K): V? {\n        if (key !is String) return null\n        val value = backingMap[key]\n        return if (value !== undefined) value.unsafeCast<V>() else null\n    }\n\n\n    override fun put(key: K, value: V): V? {\n        require(key is String)\n        val oldValue = backingMap[key]\n        backingMap[key] = value\n\n        if (oldValue === undefined) {\n            size++\n//            structureChanged(host)\n            return null\n        } else {\n//            valueMod++\n            return oldValue.unsafeCast<V>()\n        }\n    }\n\n    override fun remove(key: K): V? {\n        if (key !is String) return null\n        val value = backingMap[key]\n        if (value !== undefined) {\n            jsDeleteProperty(backingMap, key)\n            size--\n//            structureChanged(host)\n            return value.unsafeCast<V>()\n        } else {\n//            valueMod++\n            return null\n        }\n    }\n\n\n    override fun clear() {\n        backingMap = createJsMap()\n        size = 0\n    }\n\n\n    override fun iterator(): MutableIterator<MutableEntry<K, V>> {\n        return object : MutableIterator<MutableEntry<K, V>> {\n            private val keys: Array<String> = js(\"Object\").keys(backingMap)\n            private val iterator = keys.iterator()\n            private var lastKey: String? = null\n\n            override fun hasNext(): Boolean = iterator.hasNext()\n\n            override fun next(): MutableEntry<K, V> {\n                val key = iterator.next()\n                lastKey = key\n                @Suppress(\"UNCHECKED_CAST\")\n                return newMapEntry(key as K)\n            }\n\n            override fun remove() {\n                @Suppress(\"UNCHECKED_CAST\")\n                this@InternalStringMap.remove(checkNotNull(lastKey) as K)\n            }\n        }\n    }\n\n    private fun newMapEntry(key: K): MutableEntry<K, V> = object : MutableEntry<K, V> {\n        override val key: K get() = key\n        override val value: V get() = this@InternalStringMap[key].unsafeCast<V>()\n\n        override fun setValue(newValue: V): V = this@InternalStringMap.put(key, newValue).unsafeCast<V>()\n\n        override fun hashCode(): Int = AbstractMap.entryHashCode(this)\n        override fun toString(): String = AbstractMap.entryToString(this)\n        override fun equals(other: Any?): Boolean = AbstractMap.entryEquals(this, other)\n    }\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n/*\n * Based on GWT LinkedHashMap\n * Copyright 2008 Google Inc.\n */\npackage kotlin.collections\n\nimport kotlin.collections.MutableMap.MutableEntry\n\n/**\n * Hash table based implementation of the [MutableMap] interface, which additionally preserves the insertion order\n * of entries during the iteration.\n *\n * The insertion order is preserved by maintaining a doubly-linked list of all of its entries.\n */\npublic actual open class LinkedHashMap<K, V> : HashMap<K, V>, MutableMap<K, V> {\n\n    /**\n     * The entry we use includes next/prev pointers for a doubly-linked circular\n     * list with a head node. This reduces the special cases we have to deal with\n     * in the list operations.\n\n     * Note that we duplicate the key from the underlying hash map so we can find\n     * the eldest entry. The alternative would have been to modify HashMap so more\n     * of the code was directly usable here, but this would have added some\n     * overhead to HashMap, or to reimplement most of the HashMap code here with\n     * small modifications. Paying a small storage cost only if you use\n     * LinkedHashMap and minimizing code size seemed like a better tradeoff\n     */\n    private inner class ChainEntry<K, V>(key: K, value: V) : AbstractMutableMap.SimpleEntry<K, V>(key, value) {\n        internal var next: ChainEntry<K, V>? = null\n        internal var prev: ChainEntry<K, V>? = null\n\n        override fun setValue(newValue: V): V {\n            this@LinkedHashMap.checkIsMutable()\n            return super.setValue(newValue)\n        }\n    }\n\n    private inner class EntrySet : AbstractEntrySet<MutableEntry<K, V>, K, V>() {\n\n        private inner class EntryIterator : MutableIterator<MutableEntry<K, V>> {\n            // The last entry that was returned from this iterator.\n            private var last: ChainEntry<K, V>? = null\n\n            // The next entry to return from this iterator.\n            private var next: ChainEntry<K, V>? = null\n\n            init {\n                next = head\n//                recordLastKnownStructure(map, this)\n            }\n\n            override fun hasNext(): Boolean {\n                return next !== null\n            }\n\n            override fun next(): MutableEntry<K, V> {\n//                checkStructuralChange(map, this)\n                if (!hasNext()) throw NoSuchElementException()\n\n                val current = next!!\n                last = current\n                next = current.next.takeIf { it !== head }\n                return current\n            }\n\n            override fun remove() {\n                check(last != null)\n                this@EntrySet.checkIsMutable()\n//                checkStructuralChange(map, this)\n\n                last!!.remove()\n                map.remove(last!!.key)\n//                recordLastKnownStructure(map, this)\n                last = null\n            }\n        }\n\n        override fun add(element: MutableEntry<K, V>): Boolean = throw UnsupportedOperationException(\"Add is not supported on entries\")\n        override fun clear() {\n            this@LinkedHashMap.clear()\n        }\n\n        override fun containsEntry(element: Map.Entry<K, V>): Boolean = this@LinkedHashMap.containsEntry(element)\n\n        override operator fun iterator(): MutableIterator<MutableEntry<K, V>> = EntryIterator()\n\n        override fun remove(element: MutableEntry<K, V>): Boolean {\n            checkIsMutable()\n            if (contains(element)) {\n                this@LinkedHashMap.remove(element.key)\n                return true\n            }\n            return false\n        }\n\n        override val size: Int get() = this@LinkedHashMap.size\n\n        override fun checkIsMutable(): Unit = this@LinkedHashMap.checkIsMutable()\n    }\n\n\n    /*\n   * The head of the insert order chain, which is a doubly-linked circular\n   * list.\n   *\n   * The most recently inserted node is at the end of the chain, ie.\n   * chain.prev.\n   */\n    private var head: ChainEntry<K, V>? = null\n\n    /**\n     * Add this node to the end of the chain.\n     */\n    private fun ChainEntry<K, V>.addToEnd() {\n        // This entry is not in the list.\n        check(next == null && prev == null)\n\n        val _head = head\n        if (_head == null) {\n            head = this\n            next = this\n            prev = this\n        } else {\n            // Chain is valid.\n            val _tail = checkNotNull(_head.prev)\n            // Update me.\n            prev = _tail\n            next = _head\n            // Update my new siblings: current head and old tail\n            _head.prev = this\n            _tail.next = this\n        }\n    }\n\n    /**\n     * Remove this node from the chain it is a part of.\n     */\n    private fun ChainEntry<K, V>.remove() {\n        if (this.next === this) {\n            // if this is single element, remove head\n            head = null\n        } else {\n            if (head === this) {\n                // if this is first element, move head to next\n                head = next\n            }\n            next!!.prev = prev\n            prev!!.next = next\n        }\n        next = null\n        prev = null\n    }\n\n    /*\n   * The hashmap that keeps track of our entries and the chain. Note that we\n   * duplicate the key here to eliminate changes to HashMap and minimize the\n   * code here, at the expense of additional space.\n   */\n    private val map: HashMap<K, ChainEntry<K, V>>\n\n    private var isReadOnly: Boolean = false\n\n    /**\n     * Constructs an empty [LinkedHashMap] instance.\n     */\n    actual constructor() : super() {\n        map = HashMap<K, ChainEntry<K, V>>()\n    }\n\n    internal constructor(backingMap: HashMap<K, Any>) : super() {\n        @Suppress(\"UNCHECKED_CAST\") // expected to work due to erasure\n        map = backingMap as HashMap<K, ChainEntry<K, V>>\n    }\n\n    /**\n     * Constructs an empty [LinkedHashMap] instance.\n     *\n     * @param  initialCapacity the initial capacity (ignored)\n     * @param  loadFactor      the load factor (ignored)\n     *\n     * @throws IllegalArgumentException if the initial capacity or load factor are negative\n     */\n    @Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\n    actual constructor(initialCapacity: Int, loadFactor: Float = 0.0f) : super(initialCapacity, loadFactor) {\n        map = HashMap<K, ChainEntry<K, V>>()\n    }\n\n    actual constructor(initialCapacity: Int) : this(initialCapacity, 0.0f)\n\n    /**\n     * Constructs an instance of [LinkedHashMap] filled with the contents of the specified [original] map.\n     */\n    actual constructor(original: Map<out K, V>) {\n        map = HashMap<K, ChainEntry<K, V>>()\n        this.putAll(original)\n    }\n\n    @PublishedApi\n    internal fun build(): Map<K, V> {\n        checkIsMutable()\n        isReadOnly = true\n        return this\n    }\n\n    actual override fun clear() {\n        checkIsMutable()\n        map.clear()\n        head = null\n    }\n\n\n//    override fun clone(): Any {\n//        return LinkedHashMap(this)\n//    }\n\n\n    actual override fun containsKey(key: K): Boolean = map.containsKey(key)\n\n    actual override fun containsValue(value: V): Boolean {\n        var node: ChainEntry<K, V> = head ?: return false\n        do {\n            if (node.value == value) {\n                return true\n            }\n            node = node.next!!\n        } while (node !== head)\n        return false\n    }\n\n\n    override fun createEntrySet(): MutableSet<MutableMap.MutableEntry<K, V>> = EntrySet()\n\n    actual override operator fun get(key: K): V? = map.get(key)?.value\n\n    actual override fun put(key: K, value: V): V? {\n        checkIsMutable()\n\n        val old = map.get(key)\n        if (old == null) {\n            val newEntry = ChainEntry(key, value)\n            map.put(key, newEntry)\n            newEntry.addToEnd()\n            return null\n        } else {\n            return old.setValue(value)\n        }\n    }\n\n    actual override fun remove(key: K): V? {\n        checkIsMutable()\n\n        val entry = map.remove(key)\n        if (entry != null) {\n            entry.remove()\n            return entry.value\n        }\n        return null\n    }\n\n    actual override val size: Int get() = map.size\n\n    internal override fun checkIsMutable() {\n        if (isReadOnly) throw UnsupportedOperationException()\n    }\n}\n\n/**\n * Constructs the specialized implementation of [LinkedHashMap] with [String] keys, which stores the keys as properties of\n * JS object without hashing them.\n */\npublic fun <V> linkedStringMapOf(vararg pairs: Pair<String, V>): LinkedHashMap<String, V> {\n    return LinkedHashMap<String, V>(stringMapOf<Any>()).apply { putAll(pairs) }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n/*\n * Based on GWT LinkedHashSet\n * Copyright 2008 Google Inc.\n */\n\npackage kotlin.collections\n\n/**\n * The implementation of the [MutableSet] interface, backed by a [LinkedHashMap] instance.\n *\n * This implementation preserves the insertion order of elements during the iteration.\n */\npublic actual open class LinkedHashSet<E> : HashSet<E>, MutableSet<E> {\n\n    internal constructor(map: LinkedHashMap<E, Any>) : super(map)\n\n    /**\n     * Constructs a new empty [LinkedHashSet].\n     */\n    actual constructor() : super(LinkedHashMap<E, Any>())\n\n    /**\n     * Constructs a new [LinkedHashSet] filled with the elements of the specified collection.\n     */\n    actual constructor(elements: Collection<E>) : super(LinkedHashMap<E, Any>()) {\n        addAll(elements)\n    }\n\n    /**\n     * Constructs a new empty [LinkedHashSet].\n     *\n     * @param  initialCapacity the initial capacity (ignored)\n     * @param  loadFactor      the load factor (ignored)\n     *\n     * @throws IllegalArgumentException if the initial capacity or load factor are negative\n     */\n    @Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\n    actual constructor(initialCapacity: Int, loadFactor: Float = 0.0f) : super(LinkedHashMap<E, Any>(initialCapacity, loadFactor))\n\n    actual constructor(initialCapacity: Int) : this(initialCapacity, 0.0f)\n\n    @PublishedApi\n    internal fun build(): Set<E> {\n        (map as LinkedHashMap<E, Any>).build()\n        return this\n    }\n\n    internal override fun checkIsMutable(): Unit = map.checkIsMutable()\n\n//    public override fun clone(): Any {\n//        return LinkedHashSet(this)\n//    }\n\n}\n\n/**\n * Creates a new instance of the specialized implementation of [LinkedHashSet] with the specified [String] elements,\n * which elements the keys as properties of JS object without hashing them.\n */\npublic fun linkedStringSetOf(vararg elements: String): LinkedHashSet<String> {\n    return LinkedHashSet(linkedStringMapOf<Any>()).apply { addAll(elements) }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.io\n\ninternal abstract class BaseOutput {\n    open fun println() {\n        print(\"\\n\")\n    }\n\n    open fun println(message: Any?) {\n        print(message)\n        println()\n    }\n\n    abstract fun print(message: Any?)\n\n    open fun flush() {}\n}\n\n/** JsName used to make the declaration available outside of module to test it */\n@JsName(\"NodeJsOutput\")\ninternal class NodeJsOutput(val outputStream: dynamic) : BaseOutput() {\n    override fun print(message: Any?) {\n        // TODO: Using local variable because of bug in block decomposition lowering in IR backend\n        val messageString = String(message)\n        outputStream.write(messageString)\n    }\n}\n\n/** JsName used to make the declaration available outside of module to test it */\n@JsName(\"OutputToConsoleLog\")\ninternal class OutputToConsoleLog : BaseOutput() {\n    override fun print(message: Any?) {\n        console.log(message)\n    }\n\n    override fun println(message: Any?) {\n        console.log(message)\n    }\n\n    override fun println() {\n        console.log(\"\")\n    }\n}\n\n/** JsName used to make the declaration available outside of module to test it and use at try.kotl.in */\n@JsName(\"BufferedOutput\")\ninternal open class BufferedOutput : BaseOutput() {\n    var buffer = \"\"\n\n    override fun print(message: Any?) {\n        buffer += String(message)\n    }\n\n    override fun flush() {\n        buffer = \"\"\n    }\n}\n\n/** JsName used to make the declaration available outside of module to test it */\n@JsName(\"BufferedOutputToConsoleLog\")\ninternal class BufferedOutputToConsoleLog : BufferedOutput() {\n    override fun print(message: Any?) {\n        var s = String(message)\n        val i = s.nativeLastIndexOf(\"\\n\", 0)\n        if (i >= 0) {\n            buffer += s.substring(0, i)\n            flush()\n            s = s.substring(i + 1)\n        }\n        buffer += s\n    }\n\n    override fun flush() {\n        console.log(buffer)\n        buffer = \"\"\n    }\n}\n\n/** JsName used to make the declaration available outside of module to test it and use at try.kotl.in */\n@JsName(\"output\")\ninternal var output = run {\n    val isNode: Boolean = js(\"typeof process !== 'undefined' && process.versions && !!process.versions.node\")\n    if (isNode) NodeJsOutput(js(\"process.stdout\")) else BufferedOutputToConsoleLog()\n}\n\n@kotlin.internal.InlineOnly\nprivate inline fun String(value: Any?): String = js(\"String\")(value)\n\n/** Prints the line separator to the standard output stream. */\npublic actual fun println() {\n    output.println()\n}\n\n/** Prints the given [message] and the line separator to the standard output stream. */\npublic actual fun println(message: Any?) {\n    output.println(message)\n}\n\n/** Prints the given [message] to the standard output stream. */\npublic actual fun print(message: Any?) {\n    output.print(message)\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.coroutines\n\nimport kotlin.coroutines.intrinsics.CoroutineSingletons.*\nimport kotlin.coroutines.intrinsics.COROUTINE_SUSPENDED\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal actual class SafeContinuation<in T>\ninternal actual constructor(\n    private val delegate: Continuation<T>,\n    initialResult: Any?\n) : Continuation<T> {\n    @PublishedApi\n    internal actual constructor(delegate: Continuation<T>) : this(delegate, UNDECIDED)\n\n    public actual override val context: CoroutineContext\n        get() = delegate.context\n\n    private var result: Any? = initialResult\n\n    public actual override fun resumeWith(result: Result<T>) {\n        val cur = this.result\n        when {\n            cur === UNDECIDED -> {\n                this.result = result.value\n            }\n            cur === COROUTINE_SUSPENDED -> {\n                this.result = RESUMED\n                delegate.resumeWith(result)\n            }\n            else -> throw IllegalStateException(\"Already resumed\")\n        }\n    }\n\n    @PublishedApi\n    internal actual fun getOrThrow(): Any? {\n        if (result === UNDECIDED) {\n            result = COROUTINE_SUSPENDED\n            return COROUTINE_SUSPENDED\n        }\n        val result = this.result\n        return when {\n            result === RESUMED -> COROUTINE_SUSPENDED // already called continuation, indicate COROUTINE_SUSPENDED upstream\n            result is Result.Failure -> throw result.exception\n            else -> result // either COROUTINE_SUSPENDED or data\n        }\n    }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage org.w3c.dom\n\npublic external interface ItemArrayLike<out T> {\n    val length: Int\n    fun item(index: Int): T?\n}\n\n/**\n * Returns the view of this `ItemArrayLike<T>` collection as `List<T>`\n */\npublic fun <T> ItemArrayLike<T>.asList(): List<T> = object : AbstractList<T>() {\n    override val size: Int get() = this@asList.length\n\n    override fun get(index: Int): T = when (index) {\n        in 0..lastIndex -> this@asList.item(index).unsafeCast<T>()\n        else -> throw IndexOutOfBoundsException(\"index $index is not in range [0..$lastIndex]\")\n    }\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// a package is omitted to get declarations directly under the module\n\n@JsName(\"throwNPE\")\ninternal fun throwNPE(message: String) {\n    throw NullPointerException(message)\n}\n\n@JsName(\"throwCCE\")\ninternal fun throwCCE() {\n    throw ClassCastException(\"Illegal cast\")\n}\n\n@JsName(\"throwISE\")\ninternal fun throwISE(message: String) {\n    throw IllegalStateException(message)\n}\n\n@JsName(\"throwUPAE\")\ninternal fun throwUPAE(propertyName: String) {\n    throw UninitializedPropertyAccessException(\"lateinit property ${propertyName} has not been initialized\")\n}\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin\n\n/**\n * Returns `true` if the specified number is a\n * Not-a-Number (NaN) value, `false` otherwise.\n */\npublic actual fun Double.isNaN(): Boolean = this != this\n\n/**\n * Returns `true` if the specified number is a\n * Not-a-Number (NaN) value, `false` otherwise.\n */\npublic actual fun Float.isNaN(): Boolean = this != this\n\n/**\n * Returns `true` if this value is infinitely large in magnitude.\n */\npublic actual fun Double.isInfinite(): Boolean = this == Double.POSITIVE_INFINITY || this == Double.NEGATIVE_INFINITY\n\n/**\n * Returns `true` if this value is infinitely large in magnitude.\n */\npublic actual fun Float.isInfinite(): Boolean = this == Float.POSITIVE_INFINITY || this == Float.NEGATIVE_INFINITY\n\n/**\n * Returns `true` if the argument is a finite floating-point value; returns `false` otherwise (for `NaN` and infinity arguments).\n */\npublic actual fun Double.isFinite(): Boolean = !isInfinite() && !isNaN()\n\n/**\n * Returns `true` if the argument is a finite floating-point value; returns `false` otherwise (for `NaN` and infinity arguments).\n */\npublic actual fun Float.isFinite(): Boolean = !isInfinite() && !isNaN()\n\n\n/**\n * Counts the number of set bits in the binary representation of this [Int] number.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun Int.countOneBits(): Int {\n    // Hacker's Delight 5-1 algorithm\n    var v = this\n    v = (v and 0x55555555) + (v.ushr(1) and 0x55555555)\n    v = (v and 0x33333333) + (v.ushr(2) and 0x33333333)\n    v = (v and 0x0F0F0F0F) + (v.ushr(4) and 0x0F0F0F0F)\n    v = (v and 0x00FF00FF) + (v.ushr(8) and 0x00FF00FF)\n    v = (v and 0x0000FFFF) + (v.ushr(16))\n    return v\n}\n\n/**\n * Counts the number of consecutive most significant bits that are zero in the binary representation of this [Int] number.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic actual inline fun Int.countLeadingZeroBits(): Int = JsMath.clz32(this)\n\n/**\n * Counts the number of consecutive least significant bits that are zero in the binary representation of this [Int] number.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun Int.countTrailingZeroBits(): Int =\n    // Hacker's Delight 5-4 algorithm for expressing countTrailingZeroBits with countLeadingZeroBits\n    Int.SIZE_BITS - (this or -this).inv().countLeadingZeroBits()\n\n/**\n * Returns a number having a single bit set in the position of the most significant set bit of this [Int] number,\n * or zero, if this number is zero.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun Int.takeHighestOneBit(): Int =\n    if (this == 0) 0 else 1.shl(Int.SIZE_BITS - 1 - countLeadingZeroBits())\n\n/**\n * Returns a number having a single bit set in the position of the least significant set bit of this [Int] number,\n * or zero, if this number is zero.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun Int.takeLowestOneBit(): Int =\n    // Hacker's Delight 2-1 algorithm for isolating rightmost 1-bit\n    this and -this\n\n/**\n * Rotates the binary representation of this [Int] number left by the specified [bitCount] number of bits.\n * The most significant bits pushed out from the left side reenter the number as the least significant bits on the right side.\n *\n * Rotating the number left by a negative bit count is the same as rotating it right by the negated bit count:\n * `number.rotateLeft(-n) == number.rotateRight(n)`\n *\n * Rotating by a multiple of [Int.SIZE_BITS] (32) returns the same number, or more generally\n * `number.rotateLeft(n) == number.rotateLeft(n % 32)`\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic actual fun Int.rotateLeft(bitCount: Int): Int =\n    shl(bitCount) or ushr(Int.SIZE_BITS - bitCount)\n\n\n/**\n * Rotates the binary representation of this [Int] number right by the specified [bitCount] number of bits.\n * The least significant bits pushed out from the right side reenter the number as the most significant bits on the left side.\n *\n * Rotating the number right by a negative bit count is the same as rotating it left by the negated bit count:\n * `number.rotateRight(-n) == number.rotateLeft(n)`\n *\n * Rotating by a multiple of [Int.SIZE_BITS] (32) returns the same number, or more generally\n * `number.rotateRight(n) == number.rotateRight(n % 32)`\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic actual fun Int.rotateRight(bitCount: Int): Int =\n    shl(Int.SIZE_BITS - bitCount) or ushr(bitCount)\n\n\n/**\n * Counts the number of set bits in the binary representation of this [Long] number.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun Long.countOneBits(): Int =\n    high.countOneBits() + low.countOneBits()\n\n/**\n * Counts the number of consecutive most significant bits that are zero in the binary representation of this [Long] number.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun Long.countLeadingZeroBits(): Int =\n    when (val high = this.high) {\n        0 -> Int.SIZE_BITS + low.countLeadingZeroBits()\n        else -> high.countLeadingZeroBits()\n    }\n\n/**\n * Counts the number of consecutive least significant bits that are zero in the binary representation of this [Long] number.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun Long.countTrailingZeroBits(): Int =\n    when (val low = this.low) {\n        0 -> Int.SIZE_BITS + high.countTrailingZeroBits()\n        else -> low.countTrailingZeroBits()\n    }\n\n/**\n * Returns a number having a single bit set in the position of the most significant set bit of this [Long] number,\n * or zero, if this number is zero.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun Long.takeHighestOneBit(): Long =\n    when (val high = this.high) {\n        0 -> Long(low.takeHighestOneBit(), 0)\n        else -> Long(0, high.takeHighestOneBit())\n    }\n\n/**\n * Returns a number having a single bit set in the position of the least significant set bit of this [Long] number,\n * or zero, if this number is zero.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun Long.takeLowestOneBit(): Long =\n    when (val low = this.low) {\n        0 -> Long(0, high.takeLowestOneBit())\n        else -> Long(low.takeLowestOneBit(), 0)\n    }\n\n/**\n * Rotates the binary representation of this [Long] number left by the specified [bitCount] number of bits.\n * The most significant bits pushed out from the left side reenter the number as the least significant bits on the right side.\n *\n * Rotating the number left by a negative bit count is the same as rotating it right by the negated bit count:\n * `number.rotateLeft(-n) == number.rotateRight(n)`\n *\n * Rotating by a multiple of [Long.SIZE_BITS] (64) returns the same number, or more generally\n * `number.rotateLeft(n) == number.rotateLeft(n % 64)`\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic actual fun Long.rotateLeft(bitCount: Int): Long {\n    if ((bitCount and 31) != 0) {\n        val low = this.low\n        val high = this.high\n        val newLow = low.shl(bitCount) or high.ushr(-bitCount)\n        val newHigh = high.shl(bitCount) or low.ushr(-bitCount)\n        return if ((bitCount and 32) == 0) Long(newLow, newHigh) else Long(newHigh, newLow)\n    } else {\n        return if ((bitCount and 32) == 0) this else Long(high, low)\n    }\n}\n\n\n/**\n * Rotates the binary representation of this [Long] number right by the specified [bitCount] number of bits.\n * The least significant bits pushed out from the right side reenter the number as the most significant bits on the left side.\n *\n * Rotating the number right by a negative bit count is the same as rotating it left by the negated bit count:\n * `number.rotateRight(-n) == number.rotateLeft(n)`\n *\n * Rotating by a multiple of [Long.SIZE_BITS] (64) returns the same number, or more generally\n * `number.rotateRight(n) == number.rotateRight(n % 64)`\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic actual inline fun Long.rotateRight(bitCount: Int): Long = rotateLeft(-bitCount)\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.reflect.js.internal\n\nimport kotlin.reflect.*\n\ninternal abstract class KClassImpl<T : Any>(\n    internal open val jClass: JsClass<T>\n) : KClass<T> {\n\n    override val qualifiedName: String?\n        get() = TODO()\n\n    override fun equals(other: Any?): Boolean {\n        return other is KClassImpl<*> && jClass == other.jClass\n    }\n\n    // TODO: use FQN\n    override fun hashCode(): Int = simpleName?.hashCode() ?: 0\n\n    override fun toString(): String {\n        // TODO: use FQN\n        return \"class $simpleName\"\n    }\n}\n\ninternal class SimpleKClassImpl<T : Any>(jClass: JsClass<T>) : KClassImpl<T>(jClass) {\n    override val simpleName: String? = jClass.asDynamic().`$metadata$`?.simpleName.unsafeCast<String?>()\n\n    override fun isInstance(value: Any?): Boolean {\n        return jsIsType(value, jClass)\n    }\n}\n\ninternal class PrimitiveKClassImpl<T : Any>(\n    jClass: JsClass<T>,\n    private val givenSimpleName: String,\n    private val isInstanceFunction: (Any?) -> Boolean\n) : KClassImpl<T>(jClass) {\n    override fun equals(other: Any?): Boolean {\n        if (other !is PrimitiveKClassImpl<*>) return false\n        return super.equals(other) && givenSimpleName == other.givenSimpleName\n    }\n\n    override val simpleName: String? get() = givenSimpleName\n\n    override fun isInstance(value: Any?): Boolean {\n        return isInstanceFunction(value)\n    }\n}\n\ninternal object NothingKClassImpl : KClassImpl<Nothing>(js(\"Object\")) {\n    override val simpleName: String = \"Nothing\"\n\n    override fun isInstance(value: Any?): Boolean = false\n\n    override val jClass: JsClass<Nothing>\n        get() = throw UnsupportedOperationException(\"There's no native JS class for Nothing type\")\n\n    override fun equals(other: Any?): Boolean = other === this\n\n    override fun hashCode(): Int = 0\n}\n\ninternal class ErrorKClass : KClass<Nothing> {\n    override val simpleName: String? get() = error(\"Unknown simpleName for ErrorKClass\")\n    override val qualifiedName: String? get() = error(\"Unknown qualifiedName for ErrorKClass\")\n\n    override fun isInstance(value: Any?): Boolean = error(\"Can's check isInstance on ErrorKClass\")\n\n    override fun equals(other: Any?): Boolean = other === this\n\n    override fun hashCode(): Int = 0\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.collections\n\n/**\n * The common interface of [InternalStringMap] and [InternalHashCodeMap].\n */\ninternal interface InternalMap<K, V> : MutableIterable<MutableMap.MutableEntry<K, V>> {\n    val equality: EqualityComparator\n    val size: Int\n    operator fun contains(key: K): Boolean\n    operator fun get(key: K): V?\n\n    fun put(key: K, value: V): V?\n    fun remove(key: K): V?\n    fun clear(): Unit\n\n    fun createJsMap(): dynamic {\n        val result = js(\"Object.create(null)\")\n        // force to switch object representation to dictionary mode\n        result[\"foo\"] = 1\n        jsDeleteProperty(result, \"foo\")\n        return result\n    }\n}\n","/*\n * Copyright 2010-2019 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\n * that can be found in the license/LICENSE.txt file.\n */\n\n\n@file:Suppress(\"UNUSED_PARAMETER\")\n\npackage kotlin.js\n\n@kotlin.internal.InlineOnly\ninternal inline fun jsDeleteProperty(obj: Any, property: Any) {\n    js(\"delete obj[property]\")\n}\n\n@kotlin.internal.InlineOnly\ninternal inline fun jsBitwiseOr(lhs: Any?, rhs: Any?): Int =\n    js(\"lhs | rhs\").unsafeCast<Int>()","/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.reflect.js.internal\n\nimport kotlin.reflect.*\n\ninternal class KTypeImpl(\n    override val classifier: KClassifier,\n    override val arguments: List<KTypeProjection>,\n    override val isMarkedNullable: Boolean\n) : KType {\n    override fun equals(other: Any?): Boolean =\n        other is KTypeImpl &&\n                classifier == other.classifier && arguments == other.arguments && isMarkedNullable == other.isMarkedNullable\n\n    override fun hashCode(): Int =\n        (classifier.hashCode() * 31 + arguments.hashCode()) * 31 + isMarkedNullable.hashCode()\n\n    override fun toString(): String {\n        val kClass = (classifier as? KClass<*>)\n        val classifierName = when {\n            kClass == null -> classifier.toString()\n            kClass.simpleName != null -> kClass.simpleName\n            else -> \"(non-denotable type)\"\n        }\n\n        val args =\n            if (arguments.isEmpty()) \"\"\n            else arguments.joinToString(\", \", \"<\", \">\") { it.asString() }\n        val nullable = if (isMarkedNullable) \"?\" else \"\"\n\n        return classifierName + args + nullable\n    }\n\n    // TODO: this should be the implementation of KTypeProjection.toString, see KT-30071\n    private fun KTypeProjection.asString(): String {\n        if (variance == null) return \"*\"\n        return variance.prefixString() + type.toString()\n    }\n}\n\ninternal object DynamicKType : KType {\n    override val classifier: KClassifier? = null\n    override val arguments: List<KTypeProjection> = emptyList()\n    override val isMarkedNullable: Boolean = false\n    override fun toString(): String = \"dynamic\"\n}\n\ninternal fun KVariance.prefixString() =\n    when (this) {\n        KVariance.INVARIANT -> \"\"\n        KVariance.IN -> \"in \"\n        KVariance.OUT -> \"out \"\n    }\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.reflect.js.internal\n\nimport kotlin.js.JsClass\n\n@JsName(\"PrimitiveClasses\")\ninternal object PrimitiveClasses {\n    @JsName(\"anyClass\")\n    val anyClass = PrimitiveKClassImpl(js(\"Object\").unsafeCast<JsClass<Any>>(), \"Any\", { it is Any })\n\n    @JsName(\"numberClass\")\n    val numberClass = PrimitiveKClassImpl(js(\"Number\").unsafeCast<JsClass<Number>>(), \"Number\", { it is Number })\n\n    @JsName(\"nothingClass\")\n    val nothingClass = NothingKClassImpl\n\n    @JsName(\"booleanClass\")\n    val booleanClass = PrimitiveKClassImpl(js(\"Boolean\").unsafeCast<JsClass<Boolean>>(), \"Boolean\", { it is Boolean })\n\n    @JsName(\"byteClass\")\n    val byteClass = PrimitiveKClassImpl(js(\"Number\").unsafeCast<JsClass<Byte>>(), \"Byte\", { it is Byte })\n\n    @JsName(\"shortClass\")\n    val shortClass = PrimitiveKClassImpl(js(\"Number\").unsafeCast<JsClass<Short>>(), \"Short\", { it is Short })\n\n    @JsName(\"intClass\")\n    val intClass = PrimitiveKClassImpl(js(\"Number\").unsafeCast<JsClass<Int>>(), \"Int\", { it is Int })\n\n    @JsName(\"floatClass\")\n    val floatClass = PrimitiveKClassImpl(js(\"Number\").unsafeCast<JsClass<Float>>(), \"Float\", { it is Float })\n\n    @JsName(\"doubleClass\")\n    val doubleClass = PrimitiveKClassImpl(js(\"Number\").unsafeCast<JsClass<Double>>(), \"Double\", { it is Double })\n\n    @JsName(\"arrayClass\")\n    val arrayClass = PrimitiveKClassImpl(js(\"Array\").unsafeCast<JsClass<Array<*>>>(), \"Array\", { it is Array<*> })\n\n    @JsName(\"stringClass\")\n    val stringClass = PrimitiveKClassImpl(js(\"String\").unsafeCast<JsClass<String>>(), \"String\", { it is String })\n\n    @JsName(\"throwableClass\")\n    val throwableClass = PrimitiveKClassImpl(js(\"Error\").unsafeCast<JsClass<Throwable>>(), \"Throwable\", { it is Throwable })\n\n    @JsName(\"booleanArrayClass\")\n    val booleanArrayClass = PrimitiveKClassImpl(js(\"Array\").unsafeCast<JsClass<BooleanArray>>(), \"BooleanArray\", { it is BooleanArray })\n\n    @JsName(\"charArrayClass\")\n    val charArrayClass = PrimitiveKClassImpl(js(\"Uint16Array\").unsafeCast<JsClass<CharArray>>(), \"CharArray\", { it is CharArray })\n\n    @JsName(\"byteArrayClass\")\n    val byteArrayClass = PrimitiveKClassImpl(js(\"Int8Array\").unsafeCast<JsClass<ByteArray>>(), \"ByteArray\", { it is ByteArray })\n\n    @JsName(\"shortArrayClass\")\n    val shortArrayClass = PrimitiveKClassImpl(js(\"Int16Array\").unsafeCast<JsClass<ShortArray>>(), \"ShortArray\", { it is ShortArray })\n\n    @JsName(\"intArrayClass\")\n    val intArrayClass = PrimitiveKClassImpl(js(\"Int32Array\").unsafeCast<JsClass<IntArray>>(), \"IntArray\", { it is IntArray })\n\n    @JsName(\"longArrayClass\")\n    val longArrayClass = PrimitiveKClassImpl(js(\"Array\").unsafeCast<JsClass<LongArray>>(), \"LongArray\", { it is LongArray })\n\n    @JsName(\"floatArrayClass\")\n    val floatArrayClass = PrimitiveKClassImpl(js(\"Float32Array\").unsafeCast<JsClass<FloatArray>>(), \"FloatArray\", { it is FloatArray })\n\n    @JsName(\"doubleArrayClass\")\n    val doubleArrayClass = PrimitiveKClassImpl(js(\"Float64Array\").unsafeCast<JsClass<DoubleArray>>(), \"DoubleArray\", { it is DoubleArray })\n\n    @JsName(\"functionClass\")\n    fun functionClass(arity: Int): KClassImpl<Any> {\n        return functionClasses.get(arity) ?: run {\n            val result = PrimitiveKClassImpl(js(\"Function\").unsafeCast<JsClass<Any>>(), \"Function$arity\",\n                                             { jsTypeOf(it) === \"function\" && it.asDynamic().length === arity })\n            functionClasses.asDynamic()[arity] = result\n            result\n        }\n    }\n}\n\nprivate val functionClasses = arrayOfNulls<KClassImpl<Any>>(0)","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// a package is omitted to get declarations directly under the module\n\nimport kotlin.reflect.*\nimport kotlin.reflect.js.internal.*\n\n@JsName(\"getKClass\")\ninternal fun <T : Any> getKClass(jClass: Any /* JsClass<T> | Array<JsClass<T>> */): KClass<T> {\n    return if (js(\"Array\").isArray(jClass)) {\n        getKClassM(jClass.unsafeCast<Array<JsClass<T>>>())\n    } else {\n        getKClass1(jClass.unsafeCast<JsClass<T>>())\n    }\n}\n\n@JsName(\"getKClassM\")\ninternal fun <T : Any> getKClassM(jClasses: Array<JsClass<T>>): KClass<T> = when (jClasses.size) {\n    1 -> getKClass1(jClasses[0])\n    0 -> NothingKClassImpl.unsafeCast<KClass<T>>()\n    else -> ErrorKClass().unsafeCast<KClass<T>>()\n}\n\n@JsName(\"getKClassFromExpression\")\ninternal fun <T : Any> getKClassFromExpression(e: T): KClass<T> =\n    when (jsTypeOf(e)) {\n        \"string\" -> PrimitiveClasses.stringClass\n        \"number\" -> if (jsBitwiseOr(e, 0).asDynamic() === e) PrimitiveClasses.intClass else PrimitiveClasses.doubleClass\n        \"boolean\" -> PrimitiveClasses.booleanClass\n        \"function\" -> PrimitiveClasses.functionClass(e.asDynamic().length)\n        else -> {\n            when {\n                e is BooleanArray -> PrimitiveClasses.booleanArrayClass\n                e is CharArray -> PrimitiveClasses.charArrayClass\n                e is ByteArray -> PrimitiveClasses.byteArrayClass\n                e is ShortArray -> PrimitiveClasses.shortArrayClass\n                e is IntArray -> PrimitiveClasses.intArrayClass\n                e is LongArray -> PrimitiveClasses.longArrayClass\n                e is FloatArray -> PrimitiveClasses.floatArrayClass\n                e is DoubleArray -> PrimitiveClasses.doubleArrayClass\n                e is KClass<*> -> KClass::class\n                e is Array<*> -> PrimitiveClasses.arrayClass\n                else -> {\n                    val constructor = js(\"Object\").getPrototypeOf(e).constructor\n                    when {\n                        constructor === js(\"Object\") -> PrimitiveClasses.anyClass\n                        constructor === js(\"Error\") -> PrimitiveClasses.throwableClass\n                        else -> {\n                            val jsClass: JsClass<T> = constructor\n                            getKClass1(jsClass)\n                        }\n                    }\n                }\n            }\n        }\n    }.unsafeCast<KClass<T>>()\n\n@JsName(\"getKClass1\")\ninternal fun <T : Any> getKClass1(jClass: JsClass<T>): KClass<T> {\n    if (jClass === js(\"String\")) return PrimitiveClasses.stringClass.unsafeCast<KClass<T>>()\n\n    val metadata = jClass.asDynamic().`$metadata$`\n\n    return if (metadata != null) {\n        if (metadata.`$kClass$` == null) {\n            val kClass = SimpleKClassImpl(jClass)\n            metadata.`$kClass$` = kClass\n            kClass\n        } else {\n            metadata.`$kClass$`\n        }\n    } else {\n        SimpleKClassImpl(jClass)\n    }\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.js\n\n/**\n * Exposes the JavaScript [RegExp object](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/RegExp) to Kotlin.\n */\n@Suppress(\"NOT_DOCUMENTED\")\npublic external class RegExp(pattern: String, flags: String? = definedExternally) {\n\n    public fun test(str: String): Boolean\n\n    public fun exec(str: String): RegExpMatch?\n\n    public override fun toString(): String\n\n    /**\n     * The lastIndex is a read/write integer property of regular expressions that specifies the index at which to start the next match.\n     */\n    public var lastIndex: Int\n\n    public val global: Boolean\n    public val ignoreCase: Boolean\n    public val multiline: Boolean\n}\n\n/**\n * Resets the regular expression so that subsequent [RegExp.test] and [RegExp.exec] calls will match starting with the beginning of the input string.\n */\npublic fun RegExp.reset() {\n    lastIndex = 0\n}\n\n// TODO: Inherit from array or introduce asArray() extension\n/**\n * Represents the return value of [RegExp.exec].\n */\n@Suppress(\"NOT_DOCUMENTED\")\npublic external interface RegExpMatch {\n    public val index: Int\n    public val input: String\n    public val length: Int\n}\n\n/**\n * Returns the entire text matched by [RegExp.exec] if the [index] parameter is 0, or the text matched by the capturing parenthesis\n * at the given index.\n */\npublic inline operator fun RegExpMatch.get(index: Int): String? = asDynamic()[index]\n\n/**\n * Converts the result of [RegExp.exec] to an array where the first element contains the entire matched text and each subsequent\n * element is the text matched by each capturing parenthesis.\n */\npublic inline fun RegExpMatch.asArray(): Array<out String?> = unsafeCast<Array<out String?>>()\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\n/**\n * A mutable sequence of characters.\n *\n * String builder can be used to efficiently perform multiple string manipulation operations.\n */\npublic actual class StringBuilder actual constructor(content: String) : Appendable, CharSequence {\n    /**\n     * Constructs an empty string builder with the specified initial [capacity].\n     *\n     * In Kotlin/JS implementation of StringBuilder the initial capacity has no effect on the further performance of operations.\n     */\n    actual constructor(capacity: Int) : this() {\n    }\n\n    /** Constructs a string builder that contains the same characters as the specified [content] char sequence. */\n    actual constructor(content: CharSequence) : this(content.toString()) {}\n\n    /** Constructs an empty string builder. */\n    actual constructor() : this(\"\")\n\n    private var string: String = if (content !== undefined) content else \"\"\n\n    actual override val length: Int\n        get() = string.asDynamic().length\n\n    actual override fun get(index: Int): Char =\n        string.getOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, length: $length}\") }\n\n    actual override fun subSequence(startIndex: Int, endIndex: Int): CharSequence = string.substring(startIndex, endIndex)\n\n    actual override fun append(value: Char): StringBuilder {\n        string += value\n        return this\n    }\n\n    actual override fun append(value: CharSequence?): StringBuilder {\n        string += value.toString()\n        return this\n    }\n\n    actual override fun append(value: CharSequence?, startIndex: Int, endIndex: Int): StringBuilder =\n        this.appendRange(value ?: \"null\", startIndex, endIndex)\n\n    /**\n     * Reverses the contents of this string builder and returns this instance.\n     *\n     * Surrogate pairs included in this string builder are treated as single characters.\n     * Therefore, the order of the high-low surrogates is never reversed.\n     *\n     * Note that the reverse operation may produce new surrogate pairs that were unpaired low-surrogates and high-surrogates before the operation.\n     * For example, reversing `\"\\uDC00\\uD800\"` produces `\"\\uD800\\uDC00\"` which is a valid surrogate pair.\n     */\n    actual fun reverse(): StringBuilder {\n        var reversed = \"\"\n        var index = string.length - 1\n        while (index >= 0) {\n            val low = string[index--]\n            if (low.isLowSurrogate() && index >= 0) {\n                val high = string[index--]\n                if (high.isHighSurrogate()) {\n                    reversed = reversed + high + low\n                } else {\n                    reversed = reversed + low + high\n                }\n            } else {\n                reversed += low\n            }\n        }\n        string = reversed\n        return this\n    }\n\n    /**\n     * Appends the string representation of the specified object [value] to this string builder and returns this instance.\n     *\n     * The overall effect is exactly as if the [value] were converted to a string by the `value.toString()` method,\n     * and then that string was appended to this string builder.\n     */\n    actual fun append(value: Any?): StringBuilder {\n        string += value.toString()\n        return this\n    }\n\n    /**\n     * Appends the string representation of the specified boolean [value] to this string builder and returns this instance.\n     *\n     * The overall effect is exactly as if the [value] were converted to a string by the `value.toString()` method,\n     * and then that string was appended to this string builder.\n     */\n    @SinceKotlin(\"1.3\")\n    actual fun append(value: Boolean): StringBuilder {\n        string += value\n        return this\n    }\n\n    /**\n     * Appends characters in the specified character array [value] to this string builder and returns this instance.\n     *\n     * Characters are appended in order, starting at the index 0.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun append(value: CharArray): StringBuilder {\n        @OptIn(ExperimentalStdlibApi::class)\n        string += value.concatToString()\n        return this\n    }\n\n    @Deprecated(\"Provided for binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    fun append(value: String): StringBuilder = append(value)\n\n    /**\n     * Appends the specified string [value] to this string builder and returns this instance.\n     *\n     * If [value] is `null`, then the four characters `\"null\"` are appended.\n     */\n    @SinceKotlin(\"1.3\")\n    actual fun append(value: String?): StringBuilder {\n        this.string += value ?: \"null\"\n        return this\n    }\n\n    /**\n     * Returns the current capacity of this string builder.\n     *\n     * The capacity is the maximum length this string builder can have before an allocation occurs.\n     *\n     * In Kotlin/JS implementation of StringBuilder the value returned from this method may not indicate the actual size of the backing storage.\n     */\n    @SinceKotlin(\"1.3\")\n//    @ExperimentalStdlibApi\n    @Deprecated(\"Obtaining StringBuilder capacity is not supported in JS and common code.\", level = DeprecationLevel.ERROR)\n    actual fun capacity(): Int = length\n\n    /**\n     * Ensures that the capacity of this string builder is at least equal to the specified [minimumCapacity].\n     *\n     * If the current capacity is less than the [minimumCapacity], a new backing storage is allocated with greater capacity.\n     * Otherwise, this method takes no action and simply returns.\n     *\n     * In Kotlin/JS implementation of StringBuilder the size of the backing storage is not extended to comply the given [minimumCapacity],\n     * thus calling this method has no effect on the further performance of operations.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun ensureCapacity(minimumCapacity: Int) {\n    }\n\n    /**\n     * Returns the index within this string builder of the first occurrence of the specified [string].\n     *\n     * Returns `-1` if the specified [string] does not occur in this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun indexOf(string: String): Int = this.string.asDynamic().indexOf(string)\n\n    /**\n     * Returns the index within this string builder of the first occurrence of the specified [string],\n     * starting at the specified [startIndex].\n     *\n     * Returns `-1` if the specified [string] does not occur in this string builder starting at the specified [startIndex].\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun indexOf(string: String, startIndex: Int): Int = this.string.asDynamic().indexOf(string, startIndex)\n\n    /**\n     * Returns the index within this string builder of the last occurrence of the specified [string].\n     * The last occurrence of empty string `\"\"` is considered to be at the index equal to `this.length`.\n     *\n     * Returns `-1` if the specified [string] does not occur in this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun lastIndexOf(string: String): Int = this.string.asDynamic().lastIndexOf(string)\n\n    /**\n     * Returns the index within this string builder of the last occurrence of the specified [string],\n     * starting from the specified [startIndex] toward the beginning.\n     *\n     * Returns `-1` if the specified [string] does not occur in this string builder starting at the specified [startIndex].\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun lastIndexOf(string: String, startIndex: Int): Int {\n        if (string.isEmpty() && startIndex < 0) return -1\n        return this.string.asDynamic().lastIndexOf(string, startIndex)\n    }\n\n    /**\n     * Inserts the string representation of the specified boolean [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The overall effect is exactly as if the [value] were converted to a string by the `value.toString()` method,\n     * and then that string was inserted into this string builder at the specified [index].\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun insert(index: Int, value: Boolean): StringBuilder {\n        AbstractList.checkPositionIndex(index, length)\n\n        string = string.substring(0, index) + value + string.substring(index)\n        return this\n    }\n\n    /**\n     * Inserts the specified character [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun insert(index: Int, value: Char): StringBuilder {\n        AbstractList.checkPositionIndex(index, length)\n\n        string = string.substring(0, index) + value + string.substring(index)\n        return this\n    }\n\n    /**\n     * Inserts characters in the specified character array [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The inserted characters go in same order as in the [value] character array, starting at [index].\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun insert(index: Int, value: CharArray): StringBuilder {\n        AbstractList.checkPositionIndex(index, length)\n\n        @OptIn(ExperimentalStdlibApi::class)\n        string = string.substring(0, index) + value.concatToString() + string.substring(index)\n        return this\n    }\n\n    /**\n     * Inserts characters in the specified character sequence [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The inserted characters go in the same order as in the [value] character sequence, starting at [index].\n     *\n     * @param index the position in this string builder to insert at.\n     * @param value the character sequence from which characters are inserted. If [value] is `null`, then the four characters `\"null\"` are inserted.\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun insert(index: Int, value: CharSequence?): StringBuilder {\n        AbstractList.checkPositionIndex(index, length)\n\n        string = string.substring(0, index) + value.toString() + string.substring(index)\n        return this\n    }\n\n    /**\n     * Inserts the string representation of the specified object [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The overall effect is exactly as if the [value] were converted to a string by the `value.toString()` method,\n     * and then that string was inserted into this string builder at the specified [index].\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun insert(index: Int, value: Any?): StringBuilder {\n        AbstractList.checkPositionIndex(index, length)\n\n        string = string.substring(0, index) + value.toString() + string.substring(index)\n        return this\n    }\n\n    @Deprecated(\"Provided for binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    fun insert(index: Int, value: String): StringBuilder = insert(index, value)\n\n    /**\n     * Inserts the string [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * If [value] is `null`, then the four characters `\"null\"` are inserted.\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun insert(index: Int, value: String?): StringBuilder {\n        AbstractList.checkPositionIndex(index, length)\n\n        val toInsert = value ?: \"null\"\n        this.string = this.string.substring(0, index) + toInsert + this.string.substring(index)\n        return this\n    }\n\n    /**\n     *  Sets the length of this string builder to the specified [newLength].\n     *\n     *  If the [newLength] is less than the current length, it is changed to the specified [newLength].\n     *  Otherwise, null characters '\\u0000' are appended to this string builder until its length is less than the [newLength].\n     *\n     *  Note that in Kotlin/JS [set] operator function has non-constant execution time complexity.\n     *  Therefore, increasing length of this string builder and then updating each character by index may slow down your program.\n     *\n     *  @throws IndexOutOfBoundsException or [IllegalArgumentException] if [newLength] is less than zero.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun setLength(newLength: Int) {\n        if (newLength < 0) {\n            throw IllegalArgumentException(\"Negative new length: $newLength.\")\n        }\n\n        if (newLength <= length) {\n            string = string.substring(0, newLength)\n        } else {\n            for (i in length until newLength) {\n                string += '\\u0000'\n            }\n        }\n    }\n\n    /**\n     * Returns a new [String] that contains characters in this string builder at [startIndex] (inclusive) and up to the [length] (exclusive).\n     *\n     * @throws IndexOutOfBoundsException if [startIndex] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun substring(startIndex: Int): String {\n        AbstractList.checkPositionIndex(startIndex, length)\n\n        return string.substring(startIndex)\n    }\n\n    /**\n     * Returns a new [String] that contains characters in this string builder at [startIndex] (inclusive) and up to the [endIndex] (exclusive).\n     *\n     * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this string builder indices or when `startIndex > endIndex`.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun substring(startIndex: Int, endIndex: Int): String {\n        AbstractList.checkBoundsIndexes(startIndex, endIndex, length)\n\n        return string.substring(startIndex, endIndex)\n    }\n\n    /**\n     * Attempts to reduce storage used for this string builder.\n     *\n     * If the backing storage of this string builder is larger than necessary to hold its current contents,\n     * then it may be resized to become more space efficient.\n     * Calling this method may, but is not required to, affect the value of the [capacity] property.\n     *\n     * In Kotlin/JS implementation of StringBuilder the size of the backing storage is always equal to the length of the string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun trimToSize() {\n    }\n\n    override fun toString(): String = string\n\n    /**\n     * Clears the content of this string builder making it empty and returns this instance.\n     *\n     * @sample samples.text.Strings.clearStringBuilder\n     */\n    @SinceKotlin(\"1.3\")\n    public fun clear(): StringBuilder {\n        string = \"\"\n        return this\n    }\n\n    /**\n     * Sets the character at the specified [index] to the specified [value].\n     *\n     * @throws IndexOutOfBoundsException if [index] is out of bounds of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    public operator fun set(index: Int, value: Char) {\n        AbstractList.checkElementIndex(index, length)\n\n        string = string.substring(0, index) + value + string.substring(index + 1)\n    }\n\n    /**\n     * Replaces characters in the specified range of this string builder with characters in the specified string [value] and returns this instance.\n     *\n     * @param startIndex the beginning (inclusive) of the range to replace.\n     * @param endIndex the end (exclusive) of the range to replace.\n     * @param value the string to replace with.\n     *\n     * @throws IndexOutOfBoundsException or [IllegalArgumentException] if [startIndex] is less than zero, greater than the length of this string builder, or `startIndex > endIndex`.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    public fun setRange(startIndex: Int, endIndex: Int, value: String): StringBuilder {\n        checkReplaceRange(startIndex, endIndex, length)\n\n        this.string = this.string.substring(0, startIndex) + value + this.string.substring(endIndex)\n        return this\n    }\n\n    private fun checkReplaceRange(startIndex: Int, endIndex: Int, length: Int) {\n        if (startIndex < 0 || startIndex > length) {\n            throw IndexOutOfBoundsException(\"startIndex: $startIndex, length: $length\")\n        }\n        if (startIndex > endIndex) {\n            throw IllegalArgumentException(\"startIndex($startIndex) > endIndex($endIndex)\")\n        }\n    }\n\n    /**\n     * Removes the character at the specified [index] from this string builder and returns this instance.\n     *\n     * If the `Char` at the specified [index] is part of a supplementary code point, this method does not remove the entire supplementary character.\n     *\n     * @param index the index of `Char` to remove.\n     *\n     * @throws IndexOutOfBoundsException if [index] is out of bounds of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    public fun deleteAt(index: Int): StringBuilder {\n        AbstractList.checkElementIndex(index, length)\n\n        string = string.substring(0, index) + string.substring(index + 1)\n        return this\n    }\n\n    /**\n     * Removes characters in the specified range from this string builder and returns this instance.\n     *\n     * @param startIndex the beginning (inclusive) of the range to remove.\n     * @param endIndex the end (exclusive) of the range to remove.\n     *\n     * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] is out of range of this string builder indices or when `startIndex > endIndex`.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    public fun deleteRange(startIndex: Int, endIndex: Int): StringBuilder {\n        checkReplaceRange(startIndex, endIndex, length)\n\n        string = string.substring(0, startIndex) + string.substring(endIndex)\n        return this\n    }\n\n    /**\n     * Copies characters from this string builder into the [destination] character array.\n     *\n     * @param destination the array to copy to.\n     * @param destinationOffset the position in the array to copy to, 0 by default.\n     * @param startIndex the beginning (inclusive) of the range to copy, 0 by default.\n     * @param endIndex the end (exclusive) of the range to copy, length of this string builder by default.\n     *\n     * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this string builder indices or when `startIndex > endIndex`.\n     * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n     *  or when that index is out of the [destination] array indices range.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    public fun toCharArray(destination: CharArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = this.length) {\n        AbstractList.checkBoundsIndexes(startIndex, endIndex, length)\n        AbstractList.checkBoundsIndexes(destinationOffset, destinationOffset + endIndex - startIndex, destination.size)\n\n        var dstIndex = destinationOffset\n        for (index in startIndex until endIndex) {\n            destination[dstIndex++] = string[index]\n        }\n    }\n\n    /**\n     * Appends characters in a subarray of the specified character array [value] to this string builder and returns this instance.\n     *\n     * Characters are appended in order, starting at specified [startIndex].\n     *\n     * @param value the array from which characters are appended.\n     * @param startIndex the beginning (inclusive) of the subarray to append.\n     * @param endIndex the end (exclusive) of the subarray to append.\n     *\n     * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] array indices or when `startIndex > endIndex`.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    public fun appendRange(value: CharArray, startIndex: Int, endIndex: Int): StringBuilder {\n        @OptIn(ExperimentalStdlibApi::class)\n        string += value.concatToString(startIndex, endIndex)\n        return this\n    }\n\n    /**\n     * Appends a subsequence of the specified character sequence [value] to this string builder and returns this instance.\n     *\n     * @param value the character sequence from which a subsequence is appended.\n     * @param startIndex the beginning (inclusive) of the subsequence to append.\n     * @param endIndex the end (exclusive) of the subsequence to append.\n     *\n     * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] character sequence indices or when `startIndex > endIndex`.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    public fun appendRange(value: CharSequence, startIndex: Int, endIndex: Int): StringBuilder {\n        val stringCsq = value.toString()\n        AbstractList.checkBoundsIndexes(startIndex, endIndex, stringCsq.length)\n\n        string += stringCsq.substring(startIndex, endIndex)\n        return this\n    }\n\n    /**\n     * Inserts characters in a subarray of the specified character array [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The inserted characters go in same order as in the [value] array, starting at [index].\n     *\n     * @param index the position in this string builder to insert at.\n     * @param value the array from which characters are inserted.\n     * @param startIndex the beginning (inclusive) of the subarray to insert.\n     * @param endIndex the end (exclusive) of the subarray to insert.\n     *\n     * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] array indices or when `startIndex > endIndex`.\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    public fun insertRange(index: Int, value: CharArray, startIndex: Int, endIndex: Int): StringBuilder {\n        AbstractList.checkPositionIndex(index, this.length)\n\n        @OptIn(ExperimentalStdlibApi::class)\n        string = string.substring(0, index) + value.concatToString(startIndex, endIndex) + string.substring(index)\n        return this\n    }\n\n    /**\n     * Inserts characters in a subsequence of the specified character sequence [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The inserted characters go in the same order as in the [value] character sequence, starting at [index].\n     *\n     * @param index the position in this string builder to insert at.\n     * @param value the character sequence from which a subsequence is inserted.\n     * @param startIndex the beginning (inclusive) of the subsequence to insert.\n     * @param endIndex the end (exclusive) of the subsequence to insert.\n     *\n     * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] character sequence indices or when `startIndex > endIndex`.\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    public fun insertRange(index: Int, value: CharSequence, startIndex: Int, endIndex: Int): StringBuilder {\n        AbstractList.checkPositionIndex(index, length)\n\n        val stringCsq = value.toString()\n        AbstractList.checkBoundsIndexes(startIndex, endIndex, stringCsq.length)\n\n        string = string.substring(0, index) + stringCsq.substring(startIndex, endIndex) + string.substring(index)\n        return this\n    }\n}\n\n\n/**\n * Clears the content of this string builder making it empty and returns this instance.\n *\n * @sample samples.text.Strings.clearStringBuilder\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"NOTHING_TO_INLINE\")\npublic actual inline fun StringBuilder.clear(): StringBuilder = this.clear()\n\n/**\n * Sets the character at the specified [index] to the specified [value].\n *\n * @throws IndexOutOfBoundsException if [index] is out of bounds of this string builder.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"NOTHING_TO_INLINE\")\npublic actual inline operator fun StringBuilder.set(index: Int, value: Char) = this.set(index, value)\n\n/**\n * Replaces characters in the specified range of this string builder with characters in the specified string [value] and returns this instance.\n *\n * @param startIndex the beginning (inclusive) of the range to replace.\n * @param endIndex the end (exclusive) of the range to replace.\n * @param value the string to replace with.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] if [startIndex] is less than zero, greater than the length of this string builder, or `startIndex > endIndex`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"NOTHING_TO_INLINE\")\npublic actual inline fun StringBuilder.setRange(startIndex: Int, endIndex: Int, value: String): StringBuilder =\n    this.setRange(startIndex, endIndex, value)\n\n/**\n * Removes the character at the specified [index] from this string builder and returns this instance.\n *\n * If the `Char` at the specified [index] is part of a supplementary code point, this method does not remove the entire supplementary character.\n *\n * @param index the index of `Char` to remove.\n *\n * @throws IndexOutOfBoundsException if [index] is out of bounds of this string builder.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"NOTHING_TO_INLINE\")\npublic actual inline fun StringBuilder.deleteAt(index: Int): StringBuilder = this.deleteAt(index)\n\n/**\n * Removes characters in the specified range from this string builder and returns this instance.\n *\n * @param startIndex the beginning (inclusive) of the range to remove.\n * @param endIndex the end (exclusive) of the range to remove.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] is out of range of this string builder indices or when `startIndex > endIndex`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"NOTHING_TO_INLINE\")\npublic actual inline fun StringBuilder.deleteRange(startIndex: Int, endIndex: Int): StringBuilder = this.deleteRange(startIndex, endIndex)\n\n/**\n * Copies characters from this string builder into the [destination] character array.\n *\n * @param destination the array to copy to.\n * @param destinationOffset the position in the array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the range to copy, 0 by default.\n * @param endIndex the end (exclusive) of the range to copy, length of this string builder by default.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this string builder indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n *  or when that index is out of the [destination] array indices range.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"NOTHING_TO_INLINE\", \"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun StringBuilder.toCharArray(destination: CharArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = this.length) =\n    this.toCharArray(destination, destinationOffset, startIndex, endIndex)\n\n/**\n * Appends characters in a subarray of the specified character array [value] to this string builder and returns this instance.\n *\n * Characters are appended in order, starting at specified [startIndex].\n *\n * @param value the array from which characters are appended.\n * @param startIndex the beginning (inclusive) of the subarray to append.\n * @param endIndex the end (exclusive) of the subarray to append.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] array indices or when `startIndex > endIndex`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"NOTHING_TO_INLINE\")\npublic actual inline fun StringBuilder.appendRange(value: CharArray, startIndex: Int, endIndex: Int): StringBuilder =\n    this.appendRange(value, startIndex, endIndex)\n\n/**\n * Appends a subsequence of the specified character sequence [value] to this string builder and returns this instance.\n *\n * @param value the character sequence from which a subsequence is appended.\n * @param startIndex the beginning (inclusive) of the subsequence to append.\n * @param endIndex the end (exclusive) of the subsequence to append.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] character sequence indices or when `startIndex > endIndex`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"NOTHING_TO_INLINE\")\npublic actual inline fun StringBuilder.appendRange(value: CharSequence, startIndex: Int, endIndex: Int): StringBuilder =\n    this.appendRange(value, startIndex, endIndex)\n\n/**\n * Inserts characters in a subarray of the specified character array [value] into this string builder at the specified [index] and returns this instance.\n *\n * The inserted characters go in same order as in the [value] array, starting at [index].\n *\n * @param index the position in this string builder to insert at.\n * @param value the array from which characters are inserted.\n * @param startIndex the beginning (inclusive) of the subarray to insert.\n * @param endIndex the end (exclusive) of the subarray to insert.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"NOTHING_TO_INLINE\")\npublic actual inline fun StringBuilder.insertRange(index: Int, value: CharArray, startIndex: Int, endIndex: Int): StringBuilder =\n    this.insertRange(index, value, startIndex, endIndex)\n\n/**\n * Inserts characters in a subsequence of the specified character sequence [value] into this string builder at the specified [index] and returns this instance.\n *\n * The inserted characters go in the same order as in the [value] character sequence, starting at [index].\n *\n * @param index the position in this string builder to insert at.\n * @param value the character sequence from which a subsequence is inserted.\n * @param startIndex the beginning (inclusive) of the subsequence to insert.\n * @param endIndex the end (exclusive) of the subsequence to insert.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] character sequence indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"NOTHING_TO_INLINE\")\npublic actual inline fun StringBuilder.insertRange(index: Int, value: CharSequence, startIndex: Int, endIndex: Int): StringBuilder =\n    this.insertRange(index, value, startIndex, endIndex)\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\n\n/**\n * Returns `true` if the content of this string is equal to the word \"true\", ignoring case, and `false` otherwise.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\n@kotlin.internal.InlineOnly\npublic actual inline fun String.toBoolean(): Boolean = this.toBoolean()\n\n/**\n * Returns `true` if this string is not `null` and its content is equal to the word \"true\", ignoring case, and `false` otherwise.\n *\n * There are also strict versions of the function available on non-nullable String, [toBooleanStrict] and [toBooleanStrictOrNull].\n */\n@OptIn(ExperimentalStdlibApi::class)\n@SinceKotlin(\"1.4\")\npublic actual fun String?.toBoolean(): Boolean = this != null && this.lowercase() == \"true\"\n\n/**\n * Parses the string as a signed [Byte] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n */\npublic actual fun String.toByte(): Byte = toByteOrNull() ?: numberFormatError(this)\n\n/**\n * Parses the string as a signed [Byte] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\npublic actual fun String.toByte(radix: Int): Byte = toByteOrNull(radix) ?: numberFormatError(this)\n\n\n/**\n * Parses the string as a [Short] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n */\npublic actual fun String.toShort(): Short = toShortOrNull() ?: numberFormatError(this)\n\n/**\n * Parses the string as a [Short] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\npublic actual fun String.toShort(radix: Int): Short = toShortOrNull(radix) ?: numberFormatError(this)\n\n/**\n * Parses the string as an [Int] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n */\npublic actual fun String.toInt(): Int = toIntOrNull() ?: numberFormatError(this)\n\n/**\n * Parses the string as an [Int] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\npublic actual fun String.toInt(radix: Int): Int = toIntOrNull(radix) ?: numberFormatError(this)\n\n/**\n * Parses the string as a [Long] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n */\npublic actual fun String.toLong(): Long = toLongOrNull() ?: numberFormatError(this)\n\n/**\n * Parses the string as a [Long] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\npublic actual fun String.toLong(radix: Int): Long = toLongOrNull(radix) ?: numberFormatError(this)\n\n/**\n * Parses the string as a [Double] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n */\npublic actual fun String.toDouble(): Double = (+(this.asDynamic())).unsafeCast<Double>().also {\n    if (it.isNaN() && !this.isNaN() || it == 0.0 && this.isBlank())\n        numberFormatError(this)\n}\n\n/**\n * Parses the string as a [Float] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun String.toFloat(): Float = toDouble().unsafeCast<Float>()\n\n/**\n * Parses the string as a [Double] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n */\npublic actual fun String.toDoubleOrNull(): Double? = (+(this.asDynamic())).unsafeCast<Double>().takeIf {\n    !(it.isNaN() && !this.isNaN() || it == 0.0 && this.isBlank())\n}\n\n/**\n * Parses the string as a [Float] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun String.toFloatOrNull(): Float? = toDoubleOrNull().unsafeCast<Float?>()\n\n/**\n * Returns a string representation of this [Byte] value in the specified [radix].\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for number to string conversion.\n */\n@SinceKotlin(\"1.2\")\n@kotlin.internal.InlineOnly\npublic actual inline fun Byte.toString(radix: Int): String = this.toInt().toString(radix)\n\n/**\n * Returns a string representation of this [Short] value in the specified [radix].\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for number to string conversion.\n */\n@SinceKotlin(\"1.2\")\n@kotlin.internal.InlineOnly\npublic actual inline fun Short.toString(radix: Int): String = this.toInt().toString(radix)\n\n/**\n * Returns a string representation of this [Int] value in the specified [radix].\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for number to string conversion.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Int.toString(radix: Int): String = asDynamic().toString(checkRadix(radix))\n\n@OptIn(ExperimentalStdlibApi::class)\nprivate fun String.isNaN(): Boolean = when (this.lowercase()) {\n    \"nan\", \"+nan\", \"-nan\" -> true\n    else -> false\n}\n\n/**\n * Checks whether the given [radix] is valid radix for string to number and number to string conversion.\n */\n@PublishedApi\ninternal actual fun checkRadix(radix: Int): Int {\n    if (radix !in 2..36) {\n        throw IllegalArgumentException(\"radix $radix was not in valid range 2..36\")\n    }\n    return radix\n}\n\ninternal actual fun digitOf(char: Char, radix: Int): Int = when {\n    char >= '0' && char <= '9' -> char - '0'\n    char >= 'A' && char <= 'Z' -> char - 'A' + 10\n    char >= 'a' && char <= 'z' -> char - 'a' + 10\n    else -> -1\n}.let { if (it >= radix) -1 else it }\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\nimport kotlin.js.RegExp\n\n/**\n * Provides enumeration values to use to set regular expression options.\n */\npublic actual enum class RegexOption(val value: String) {\n    /** Enables case-insensitive matching. */\n    IGNORE_CASE(\"i\"),\n    /** Enables multiline mode.\n     *\n     * In multiline mode the expressions `^` and `$` match just after or just before,\n     * respectively, a line terminator or the end of the input sequence. */\n    MULTILINE(\"m\")\n}\n\n\n/**\n * Represents the results from a single capturing group within a [MatchResult] of [Regex].\n *\n * @param value The value of captured group.\n */\npublic actual data class MatchGroup(actual val value: String)\n\n\n/**\n * Represents a compiled regular expression.\n * Provides functions to match strings in text with a pattern, replace the found occurrences and split text around matches.\n *\n * For pattern syntax reference see [MDN RegExp](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp#Special_characters_meaning_in_regular_expressions)\n * and [http://www.w3schools.com/jsref/jsref_obj_regexp.asp](https://www.w3schools.com/jsref/jsref_obj_regexp.asp).\n *\n * @constructor Creates a regular expression from the specified [pattern] string and the specified set of [options].\n */\npublic actual class Regex actual constructor(pattern: String, options: Set<RegexOption>) {\n\n    /** Creates a regular expression from the specified [pattern] string and the specified single [option].  */\n    public actual constructor(pattern: String, option: RegexOption) : this(pattern, setOf(option))\n\n    /** Creates a regular expression from the specified [pattern] string and the default options.  */\n    public actual constructor(pattern: String) : this(pattern, emptySet())\n\n\n    /** The pattern string of this regular expression. */\n    public actual val pattern: String = pattern\n    /** The set of options that were used to create this regular expression. */\n    public actual val options: Set<RegexOption> = options.toSet()\n    private val nativePattern: RegExp = RegExp(pattern, options.joinToString(separator = \"\", prefix = \"gu\") { it.value })\n\n    /** Indicates whether the regular expression matches the entire [input]. */\n    public actual infix fun matches(input: CharSequence): Boolean {\n        nativePattern.reset()\n        val match = nativePattern.exec(input.toString())\n        return match != null && match.index == 0 && nativePattern.lastIndex == input.length\n    }\n\n    /** Indicates whether the regular expression can find at least one match in the specified [input]. */\n    public actual fun containsMatchIn(input: CharSequence): Boolean {\n        nativePattern.reset()\n        return nativePattern.test(input.toString())\n    }\n\n    /** Returns the first match of a regular expression in the [input], beginning at the specified [startIndex].\n     *\n     * @param startIndex An index to start search with, by default 0. Must be not less than zero and not greater than `input.length()`\n     * @return An instance of [MatchResult] if match was found or `null` otherwise.\n     * @throws IndexOutOfBoundsException if [startIndex] is less than zero or greater than the length of the [input] char sequence.\n     */\n    @Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\n    public actual fun find(input: CharSequence, startIndex: Int = 0): MatchResult? {\n        if (startIndex < 0 || startIndex > input.length) {\n            throw IndexOutOfBoundsException(\"Start index out of bounds: $startIndex, input length: ${input.length}\")\n        }\n        return nativePattern.findNext(input.toString(), startIndex)\n    }\n\n    /**\n     * Returns a sequence of all occurrences of a regular expression within the [input] string, beginning at the specified [startIndex].\n     *\n     * @throws IndexOutOfBoundsException if [startIndex] is less than zero or greater than the length of the [input] char sequence.\n     *\n     * @sample samples.text.Regexps.findAll\n     */\n    @Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\n    public actual fun findAll(input: CharSequence, startIndex: Int = 0): Sequence<MatchResult> {\n        if (startIndex < 0 || startIndex > input.length) {\n            throw IndexOutOfBoundsException(\"Start index out of bounds: $startIndex, input length: ${input.length}\")\n        }\n        return generateSequence({ find(input, startIndex) }, { match -> match.next() })\n    }\n\n    /**\n     * Attempts to match the entire [input] CharSequence against the pattern.\n     *\n     * @return An instance of [MatchResult] if the entire input matches or `null` otherwise.\n     */\n    public actual fun matchEntire(input: CharSequence): MatchResult? {\n        if (pattern.startsWith('^') && pattern.endsWith('$'))\n            return find(input)\n        else\n            return Regex(\"^${pattern.trimStart('^').trimEnd('$')}$\", options).find(input)\n    }\n\n    /**\n     * Replaces all occurrences of this regular expression in the specified [input] string with specified [replacement] expression.\n     *\n     * @param replacement A replacement expression that can include substitutions. See [String.prototype.replace](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace) function docs for details.\n     */\n    public actual fun replace(input: CharSequence, replacement: String): String = input.toString().nativeReplace(nativePattern, replacement)\n\n    /**\n     * Replaces all occurrences of this regular expression in the specified [input] string with the result of\n     * the given function [transform] that takes [MatchResult] and returns a string to be used as a\n     * replacement for that match.\n     */\n    public actual inline fun replace(input: CharSequence, transform: (MatchResult) -> CharSequence): String {\n        var match = find(input)\n        if (match == null) return input.toString()\n\n        var lastStart = 0\n        val length = input.length\n        val sb = StringBuilder(length)\n        do {\n            val foundMatch = match!!\n            sb.append(input, lastStart, foundMatch.range.start)\n            sb.append(transform(foundMatch))\n            lastStart = foundMatch.range.endInclusive + 1\n            match = foundMatch.next()\n        } while (lastStart < length && match != null)\n\n        if (lastStart < length) {\n            sb.append(input, lastStart, length)\n        }\n\n        return sb.toString()\n    }\n\n    /**\n     * Replaces the first occurrence of this regular expression in the specified [input] string with specified [replacement] expression.\n     *\n     * @param replacement A replacement expression that can include substitutions. See [String.prototype.replace](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace) function docs for details.\n     */\n    public actual fun replaceFirst(input: CharSequence, replacement: String): String {\n        val nonGlobalOptions = options.map { it.value }.joinToString(separator = \"\")\n        return input.toString().nativeReplace(RegExp(pattern, nonGlobalOptions), replacement)\n    }\n\n    /**\n     * Splits the [input] CharSequence around matches of this regular expression.\n     *\n     * @param limit Non-negative value specifying the maximum number of substrings the string can be split to.\n     * Zero by default means no limit is set.\n     */\n    @Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\n    public actual fun split(input: CharSequence, limit: Int = 0): List<String> {\n        require(limit >= 0) { \"Limit must be non-negative, but was $limit\" }\n        val matches = findAll(input).let { if (limit == 0) it else it.take(limit - 1) }\n        val result = mutableListOf<String>()\n        var lastStart = 0\n\n        for (match in matches) {\n            result.add(input.subSequence(lastStart, match.range.start).toString())\n            lastStart = match.range.endInclusive + 1\n        }\n        result.add(input.subSequence(lastStart, input.length).toString())\n        return result\n    }\n\n\n    /**\n     * Returns the string representation of this regular expression, namely the [pattern] of this regular expression.\n     *\n     * Note that another regular expression constructed from the same pattern string may have different [options]\n     * and may match strings differently.\n     */\n    public override fun toString(): String = nativePattern.toString()\n\n    actual companion object {\n        /**\n         * Returns a regular expression that matches the specified [literal] string literally.\n         * No characters of that string will have special meaning when searching for an occurrence of the regular expression.\n         */\n        public actual fun fromLiteral(literal: String): Regex = Regex(escape(literal))\n\n        /**\n         * Returns a regular expression pattern string that matches the specified [literal] string literally.\n         * No characters of that string will have special meaning when searching for an occurrence of the regular expression.\n         */\n        public actual fun escape(literal: String): String = literal.nativeReplace(patternEscape, \"\\\\$&\")\n\n        /**\n         * Returns a literal replacement expression for the specified [literal] string.\n         * No characters of that string will have special meaning when it is used as a replacement string in [Regex.replace] function.\n         */\n        public actual fun escapeReplacement(literal: String): String = literal.nativeReplace(replacementEscape, \"$$$$\")\n\n        private val patternEscape = RegExp(\"\"\"[\\\\^$*+?.()|[\\]{}]\"\"\", \"g\")\n        private val replacementEscape = RegExp(\"\"\"\\$\"\"\", \"g\")\n    }\n}\n\n/** Creates a regular expression from the specified [pattern] string and the specified single [option].  */\n@Deprecated(\"Provided for binary compatibility\", level = DeprecationLevel.HIDDEN)\n@JsName(\"Regex_sb3q2\\$\")\npublic fun Regex_0(pattern: String, option: RegexOption): Regex = Regex(pattern, setOf(option))\n\n/** Creates a regular expression from the specified [pattern] string and the default options.  */\n@Deprecated(\"Provided for binary compatibility\", level = DeprecationLevel.HIDDEN)\n@JsName(\"Regex_61zpoe\\$\")\npublic fun Regex_1(pattern: String): Regex = Regex(pattern, emptySet())\n\n\n\n\nprivate fun RegExp.findNext(input: String, from: Int): MatchResult? {\n    this.lastIndex = from\n    val match = exec(input)\n    if (match == null) return null\n    val range = match.index..lastIndex - 1\n\n    return object : MatchResult {\n        override val range: IntRange = range\n        override val value: String\n            get() = match[0]!!\n\n        override val groups: MatchGroupCollection = object : MatchGroupCollection, AbstractCollection<MatchGroup?>() {\n            override val size: Int get() = match.length\n            override fun iterator(): Iterator<MatchGroup?> = indices.asSequence().map { this[it] }.iterator()\n            override fun get(index: Int): MatchGroup? = match[index]?.let { MatchGroup(it) }\n        }\n\n\n        private var groupValues_: List<String>? = null\n\n        override val groupValues: List<String>\n            get() {\n                if (groupValues_ == null) {\n                    groupValues_ = object : AbstractList<String>() {\n                        override val size: Int get() = match.length\n                        override fun get(index: Int): String = match[index] ?: \"\"\n                    }\n                }\n                return groupValues_!!\n            }\n\n        override fun next(): MatchResult? = this@findNext.findNext(input, if (range.isEmpty()) range.start + 1 else range.endInclusive + 1)\n    }\n}\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StringsKt\")\n\npackage kotlin.text\n\nimport kotlin.contracts.contract\nimport kotlin.jvm.JvmName\n\n/**\n * Returns a copy of this string converted to upper case using the rules of the default locale.\n */\n@Deprecated(\"Use uppercase() instead.\", ReplaceWith(\"uppercase()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic expect fun String.toUpperCase(): String\n\n/**\n * Returns a copy of this string converted to upper case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many and many-to-one character mapping,\n * thus the length of the returned string can be different from the length of the original string.\n *\n * @sample samples.text.Strings.uppercase\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun String.uppercase(): String\n\n/**\n * Returns a copy of this string converted to lower case using the rules of the default locale.\n */\n@Deprecated(\"Use lowercase() instead.\", ReplaceWith(\"lowercase()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic expect fun String.toLowerCase(): String\n\n/**\n * Returns a copy of this string converted to lower case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many and many-to-one character mapping,\n * thus the length of the returned string can be different from the length of the original string.\n *\n * @sample samples.text.Strings.lowercase\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun String.lowercase(): String\n\n/**\n * Returns a copy of this string having its first letter titlecased using the rules of the default locale,\n * or the original string if it's empty or already starts with a title case letter.\n *\n * The title case of a character is usually the same as its upper case with several exceptions.\n * The particular list of characters with the special title case form depends on the underlying platform.\n *\n * @sample samples.text.Strings.capitalize\n */\n@Deprecated(\"Use replaceFirstChar instead.\", ReplaceWith(\"replaceFirstChar { if (it.isLowerCase()) it.titlecase() else it.toString() }\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic expect fun String.capitalize(): String\n\n/**\n * Returns a copy of this string having its first letter lowercased using the rules of the default locale,\n * or the original string if it's empty or already starts with a lower case letter.\n *\n * @sample samples.text.Strings.decapitalize\n */\n@Deprecated(\"Use replaceFirstChar instead.\", ReplaceWith(\"replaceFirstChar { it.lowercase() }\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic expect fun String.decapitalize(): String\n\n/**\n * Returns a sub sequence of this char sequence having leading and trailing characters matching the [predicate] removed.\n */\npublic inline fun CharSequence.trim(predicate: (Char) -> Boolean): CharSequence {\n    var startIndex = 0\n    var endIndex = length - 1\n    var startFound = false\n\n    while (startIndex <= endIndex) {\n        val index = if (!startFound) startIndex else endIndex\n        val match = predicate(this[index])\n\n        if (!startFound) {\n            if (!match)\n                startFound = true\n            else\n                startIndex += 1\n        } else {\n            if (!match)\n                break\n            else\n                endIndex -= 1\n        }\n    }\n\n    return subSequence(startIndex, endIndex + 1)\n}\n\n/**\n * Returns a string having leading and trailing characters matching the [predicate] removed.\n */\npublic inline fun String.trim(predicate: (Char) -> Boolean): String =\n    (this as CharSequence).trim(predicate).toString()\n\n/**\n * Returns a sub sequence of this char sequence having leading characters matching the [predicate] removed.\n */\npublic inline fun CharSequence.trimStart(predicate: (Char) -> Boolean): CharSequence {\n    for (index in this.indices)\n        if (!predicate(this[index]))\n            return subSequence(index, length)\n\n    return \"\"\n}\n\n/**\n * Returns a string having leading characters matching the [predicate] removed.\n */\npublic inline fun String.trimStart(predicate: (Char) -> Boolean): String =\n    (this as CharSequence).trimStart(predicate).toString()\n\n/**\n * Returns a sub sequence of this char sequence having trailing characters matching the [predicate] removed.\n */\npublic inline fun CharSequence.trimEnd(predicate: (Char) -> Boolean): CharSequence {\n    for (index in this.indices.reversed())\n        if (!predicate(this[index]))\n            return subSequence(0, index + 1)\n\n    return \"\"\n}\n\n/**\n * Returns a string having trailing characters matching the [predicate] removed.\n */\npublic inline fun String.trimEnd(predicate: (Char) -> Boolean): String =\n    (this as CharSequence).trimEnd(predicate).toString()\n\n/**\n * Returns a sub sequence of this char sequence having leading and trailing characters from the [chars] array removed.\n */\npublic fun CharSequence.trim(vararg chars: Char): CharSequence = trim { it in chars }\n\n/**\n * Returns a string having leading and trailing characters from the [chars] array removed.\n */\npublic fun String.trim(vararg chars: Char): String = trim { it in chars }\n\n/**\n * Returns a sub sequence of this char sequence having leading characters from the [chars] array removed.\n */\npublic fun CharSequence.trimStart(vararg chars: Char): CharSequence = trimStart { it in chars }\n\n/**\n * Returns a string having leading characters from the [chars] array removed.\n */\npublic fun String.trimStart(vararg chars: Char): String = trimStart { it in chars }\n\n/**\n * Returns a sub sequence of this char sequence having trailing characters from the [chars] array removed.\n */\npublic fun CharSequence.trimEnd(vararg chars: Char): CharSequence = trimEnd { it in chars }\n\n/**\n * Returns a string having trailing characters from the [chars] array removed.\n */\npublic fun String.trimEnd(vararg chars: Char): String = trimEnd { it in chars }\n\n/**\n * Returns a sub sequence of this char sequence having leading and trailing whitespace removed.\n */\npublic fun CharSequence.trim(): CharSequence = trim(Char::isWhitespace)\n\n/**\n * Returns a string having leading and trailing whitespace removed.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.trim(): String = (this as CharSequence).trim().toString()\n\n/**\n * Returns a sub sequence of this char sequence having leading whitespace removed.\n */\npublic fun CharSequence.trimStart(): CharSequence = trimStart(Char::isWhitespace)\n\n/**\n * Returns a string having leading whitespace removed.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.trimStart(): String = (this as CharSequence).trimStart().toString()\n\n/**\n * Returns a sub sequence of this char sequence having trailing whitespace removed.\n */\npublic fun CharSequence.trimEnd(): CharSequence = trimEnd(Char::isWhitespace)\n\n/**\n * Returns a string having trailing whitespace removed.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.trimEnd(): String = (this as CharSequence).trimEnd().toString()\n\n/**\n * Returns a char sequence with content of this char sequence padded at the beginning\n * to the specified [length] with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a char sequence of length at least [length] consisting of `this` char sequence prepended with [padChar] as many times\n * as are necessary to reach that length.\n * @sample samples.text.Strings.padStart\n */\npublic fun CharSequence.padStart(length: Int, padChar: Char = ' '): CharSequence {\n    if (length < 0)\n        throw IllegalArgumentException(\"Desired length $length is less than zero.\")\n    if (length <= this.length)\n        return this.subSequence(0, this.length)\n\n    val sb = StringBuilder(length)\n    for (i in 1..(length - this.length))\n        sb.append(padChar)\n    sb.append(this)\n    return sb\n}\n\n/**\n * Pads the string to the specified [length] at the beginning with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a string of length at least [length] consisting of `this` string prepended with [padChar] as many times\n * as are necessary to reach that length.\n * @sample samples.text.Strings.padStart\n */\npublic fun String.padStart(length: Int, padChar: Char = ' '): String =\n    (this as CharSequence).padStart(length, padChar).toString()\n\n/**\n * Returns a char sequence with content of this char sequence padded at the end\n * to the specified [length] with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a char sequence of length at least [length] consisting of `this` char sequence appended with [padChar] as many times\n * as are necessary to reach that length.\n * @sample samples.text.Strings.padEnd\n */\npublic fun CharSequence.padEnd(length: Int, padChar: Char = ' '): CharSequence {\n    if (length < 0)\n        throw IllegalArgumentException(\"Desired length $length is less than zero.\")\n    if (length <= this.length)\n        return this.subSequence(0, this.length)\n\n    val sb = StringBuilder(length)\n    sb.append(this)\n    for (i in 1..(length - this.length))\n        sb.append(padChar)\n    return sb\n}\n\n/**\n * Pads the string to the specified [length] at the end with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a string of length at least [length] consisting of `this` string appended with [padChar] as many times\n * as are necessary to reach that length.\n * @sample samples.text.Strings.padEnd\n */\npublic fun String.padEnd(length: Int, padChar: Char = ' '): String =\n    (this as CharSequence).padEnd(length, padChar).toString()\n\n/**\n * Returns `true` if this nullable char sequence is either `null` or empty.\n *\n * @sample samples.text.Strings.stringIsNullOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence?.isNullOrEmpty(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrEmpty != null)\n    }\n\n    return this == null || this.length == 0\n}\n\n/**\n * Returns `true` if this char sequence is empty (contains no characters).\n *\n * @sample samples.text.Strings.stringIsEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.isEmpty(): Boolean = length == 0\n\n/**\n * Returns `true` if this char sequence is not empty.\n *\n * @sample samples.text.Strings.stringIsNotEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.isNotEmpty(): Boolean = length > 0\n\n// implemented differently in JVM and JS\n//public fun String.isBlank(): Boolean = length() == 0 || all { it.isWhitespace() }\n\n\n/**\n * Returns `true` if this char sequence is not empty and contains some characters except of whitespace characters.\n *\n * @sample samples.text.Strings.stringIsNotBlank\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.isNotBlank(): Boolean = !isBlank()\n\n/**\n * Returns `true` if this nullable char sequence is either `null` or empty or consists solely of whitespace characters.\n *\n * @sample samples.text.Strings.stringIsNullOrBlank\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence?.isNullOrBlank(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrBlank != null)\n    }\n\n    return this == null || this.isBlank()\n}\n\n/**\n * Iterator for characters of the given char sequence.\n */\npublic operator fun CharSequence.iterator(): CharIterator = object : CharIterator() {\n    private var index = 0\n\n    public override fun nextChar(): Char = get(index++)\n\n    public override fun hasNext(): Boolean = index < length\n}\n\n/** Returns the string if it is not `null`, or the empty string otherwise. */\n@kotlin.internal.InlineOnly\npublic inline fun String?.orEmpty(): String = this ?: \"\"\n\n/**\n * Returns this char sequence if it's not empty\n * or the result of calling [defaultValue] function if the char sequence is empty.\n *\n * @sample samples.text.Strings.stringIfEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <C, R> C.ifEmpty(defaultValue: () -> R): R where C : CharSequence, C : R =\n    if (isEmpty()) defaultValue() else this\n\n/**\n * Returns this char sequence if it is not empty and doesn't consist solely of whitespace characters,\n * or the result of calling [defaultValue] function otherwise.\n *\n * @sample samples.text.Strings.stringIfBlank\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <C, R> C.ifBlank(defaultValue: () -> R): R where C : CharSequence, C : R =\n    if (isBlank()) defaultValue() else this\n\n/**\n * Returns the range of valid character indices for this char sequence.\n */\npublic val CharSequence.indices: IntRange\n    get() = 0..length - 1\n\n/**\n * Returns the index of the last character in the char sequence or -1 if it is empty.\n */\npublic val CharSequence.lastIndex: Int\n    get() = this.length - 1\n\n/**\n * Returns `true` if this CharSequence has Unicode surrogate pair at the specified [index].\n */\npublic fun CharSequence.hasSurrogatePairAt(index: Int): Boolean {\n    return index in 0..length - 2\n            && this[index].isHighSurrogate()\n            && this[index + 1].isLowSurrogate()\n}\n\n/**\n * Returns a substring specified by the given [range] of indices.\n */\npublic fun String.substring(range: IntRange): String = substring(range.start, range.endInclusive + 1)\n\n/**\n * Returns a subsequence of this char sequence specified by the given [range] of indices.\n */\npublic fun CharSequence.subSequence(range: IntRange): CharSequence = subSequence(range.start, range.endInclusive + 1)\n\n/**\n * Returns a subsequence of this char sequence.\n *\n * This extension is chosen only for invocation with old-named parameters.\n * Replace parameter names with the same as those of [CharSequence.subSequence].\n */\n@kotlin.internal.InlineOnly\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning\n@Deprecated(\"Use parameters named startIndex and endIndex.\", ReplaceWith(\"subSequence(startIndex = start, endIndex = end)\"))\npublic inline fun String.subSequence(start: Int, end: Int): CharSequence = subSequence(start, end)\n\n/**\n * Returns a substring of chars from a range of this char sequence starting at the [startIndex] and ending right before the [endIndex].\n *\n * @param startIndex the start index (inclusive).\n * @param endIndex the end index (exclusive). If not specified, the length of the char sequence is used.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.substring(startIndex: Int, endIndex: Int = length): String = subSequence(startIndex, endIndex).toString()\n\n/**\n * Returns a substring of chars at indices from the specified [range] of this char sequence.\n */\npublic fun CharSequence.substring(range: IntRange): String = subSequence(range.start, range.endInclusive + 1).toString()\n\n/**\n * Returns a substring before the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBefore(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring before the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBefore(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring after the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfter(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + 1, length)\n}\n\n/**\n * Returns a substring after the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfter(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + delimiter.length, length)\n}\n\n/**\n * Returns a substring before the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBeforeLast(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring before the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBeforeLast(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring after the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfterLast(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + 1, length)\n}\n\n/**\n * Returns a substring after the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfterLast(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + delimiter.length, length)\n}\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given range\n * is replaced with the [replacement] char sequence.\n * @param startIndex the index of the first character to be replaced.\n * @param endIndex the index of the first character after the replacement to keep in the string.\n */\n@OptIn(ExperimentalStdlibApi::class)\npublic fun CharSequence.replaceRange(startIndex: Int, endIndex: Int, replacement: CharSequence): CharSequence {\n    if (endIndex < startIndex)\n        throw IndexOutOfBoundsException(\"End index ($endIndex) is less than start index ($startIndex).\")\n    val sb = StringBuilder()\n    sb.appendRange(this, 0, startIndex)\n    sb.append(replacement)\n    sb.appendRange(this, endIndex, length)\n    return sb\n}\n\n/**\n * Replaces the part of the string at the given range with the [replacement] char sequence.\n * @param startIndex the index of the first character to be replaced.\n * @param endIndex the index of the first character after the replacement to keep in the string.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.replaceRange(startIndex: Int, endIndex: Int, replacement: CharSequence): String =\n    (this as CharSequence).replaceRange(startIndex, endIndex, replacement).toString()\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given [range]\n * is replaced with the [replacement] char sequence.\n *\n * The end index of the [range] is included in the part to be replaced.\n */\npublic fun CharSequence.replaceRange(range: IntRange, replacement: CharSequence): CharSequence =\n    replaceRange(range.start, range.endInclusive + 1, replacement)\n\n/**\n * Replace the part of string at the given [range] with the [replacement] string.\n *\n * The end index of the [range] is included in the part to be replaced.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.replaceRange(range: IntRange, replacement: CharSequence): String =\n    (this as CharSequence).replaceRange(range, replacement).toString()\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given range is removed.\n *\n * @param startIndex the index of the first character to be removed.\n * @param endIndex the index of the first character after the removed part to keep in the string.\n *\n * [endIndex] is not included in the removed part.\n */\n@OptIn(ExperimentalStdlibApi::class)\npublic fun CharSequence.removeRange(startIndex: Int, endIndex: Int): CharSequence {\n    if (endIndex < startIndex)\n        throw IndexOutOfBoundsException(\"End index ($endIndex) is less than start index ($startIndex).\")\n\n    if (endIndex == startIndex)\n        return this.subSequence(0, length)\n\n    val sb = StringBuilder(length - (endIndex - startIndex))\n    sb.appendRange(this, 0, startIndex)\n    sb.appendRange(this, endIndex, length)\n    return sb\n}\n\n/**\n * Removes the part of a string at a given range.\n * @param startIndex the index of the first character to be removed.\n * @param endIndex the index of the first character after the removed part to keep in the string.\n *\n *  [endIndex] is not included in the removed part.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.removeRange(startIndex: Int, endIndex: Int): String =\n    (this as CharSequence).removeRange(startIndex, endIndex).toString()\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given [range] is removed.\n *\n * The end index of the [range] is included in the removed part.\n */\npublic fun CharSequence.removeRange(range: IntRange): CharSequence = removeRange(range.start, range.endInclusive + 1)\n\n/**\n * Removes the part of a string at the given [range].\n *\n * The end index of the [range] is included in the removed part.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.removeRange(range: IntRange): String =\n    (this as CharSequence).removeRange(range).toString()\n\n/**\n * If this char sequence starts with the given [prefix], returns a new char sequence\n * with the prefix removed. Otherwise, returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removePrefix(prefix: CharSequence): CharSequence {\n    if (startsWith(prefix)) {\n        return subSequence(prefix.length, length)\n    }\n    return subSequence(0, length)\n}\n\n/**\n * If this string starts with the given [prefix], returns a copy of this string\n * with the prefix removed. Otherwise, returns this string.\n */\npublic fun String.removePrefix(prefix: CharSequence): String {\n    if (startsWith(prefix)) {\n        return substring(prefix.length)\n    }\n    return this\n}\n\n/**\n * If this char sequence ends with the given [suffix], returns a new char sequence\n * with the suffix removed. Otherwise, returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removeSuffix(suffix: CharSequence): CharSequence {\n    if (endsWith(suffix)) {\n        return subSequence(0, length - suffix.length)\n    }\n    return subSequence(0, length)\n}\n\n/**\n * If this string ends with the given [suffix], returns a copy of this string\n * with the suffix removed. Otherwise, returns this string.\n */\npublic fun String.removeSuffix(suffix: CharSequence): String {\n    if (endsWith(suffix)) {\n        return substring(0, length - suffix.length)\n    }\n    return this\n}\n\n/**\n * When this char sequence starts with the given [prefix] and ends with the given [suffix],\n * returns a new char sequence having both the given [prefix] and [suffix] removed.\n * Otherwise returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removeSurrounding(prefix: CharSequence, suffix: CharSequence): CharSequence {\n    if ((length >= prefix.length + suffix.length) && startsWith(prefix) && endsWith(suffix)) {\n        return subSequence(prefix.length, length - suffix.length)\n    }\n    return subSequence(0, length)\n}\n\n/**\n * Removes from a string both the given [prefix] and [suffix] if and only if\n * it starts with the [prefix] and ends with the [suffix].\n * Otherwise returns this string unchanged.\n */\npublic fun String.removeSurrounding(prefix: CharSequence, suffix: CharSequence): String {\n    if ((length >= prefix.length + suffix.length) && startsWith(prefix) && endsWith(suffix)) {\n        return substring(prefix.length, length - suffix.length)\n    }\n    return this\n}\n\n/**\n * When this char sequence starts with and ends with the given [delimiter],\n * returns a new char sequence having this [delimiter] removed both from the start and end.\n * Otherwise returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removeSurrounding(delimiter: CharSequence): CharSequence = removeSurrounding(delimiter, delimiter)\n\n/**\n * Removes the given [delimiter] string from both the start and the end of this string\n * if and only if it starts with and ends with the [delimiter].\n * Otherwise returns this string unchanged.\n */\npublic fun String.removeSurrounding(delimiter: CharSequence): String = removeSurrounding(delimiter, delimiter)\n\n/**\n * Replace part of string before the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBefore(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n/**\n * Replace part of string before the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBefore(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n/**\n * Replace part of string after the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfter(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + 1, length, replacement)\n}\n\n/**\n * Replace part of string after the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfter(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + delimiter.length, length, replacement)\n}\n\n/**\n * Replace part of string after the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfterLast(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + delimiter.length, length, replacement)\n}\n\n/**\n * Replace part of string after the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfterLast(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + 1, length, replacement)\n}\n\n/**\n * Replace part of string before the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBeforeLast(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n/**\n * Replace part of string before the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBeforeLast(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n\n// public fun String.replace(oldChar: Char, newChar: Char, ignoreCase: Boolean): String // JVM- and JS-specific\n// public fun String.replace(oldValue: String, newValue: String, ignoreCase: Boolean): String // JVM- and JS-specific\n\n/**\n * Returns a new string obtained by replacing each substring of this char sequence that matches the given regular expression\n * with the given [replacement].\n *\n * The [replacement] can consist of any combination of literal text and $-substitutions. To treat the replacement string\n * literally escape it with the [kotlin.text.Regex.Companion.escapeReplacement] method.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.replace(regex: Regex, replacement: String): String = regex.replace(this, replacement)\n\n/**\n * Returns a new string obtained by replacing each substring of this char sequence that matches the given regular expression\n * with the result of the given function [transform] that takes [MatchResult] and returns a string to be used as a\n * replacement for that match.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.replace(regex: Regex, noinline transform: (MatchResult) -> CharSequence): String =\n    regex.replace(this, transform)\n\n/**\n * Replaces the first occurrence of the given regular expression [regex] in this char sequence with specified [replacement] expression.\n *\n * @param replacement A replacement expression that can include substitutions. See [Regex.replaceFirst] for details.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.replaceFirst(regex: Regex, replacement: String): String = regex.replaceFirst(this, replacement)\n\n/**\n * Returns a copy of this string having its first character replaced with the result of the specified [transform],\n * or the original string if it's empty.\n *\n * @param transform function that takes the first character and returns the result of the transform applied to the character.\n *\n * @sample samples.text.Strings.replaceFirstChar\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@JvmName(\"replaceFirstCharWithChar\")\n@kotlin.internal.InlineOnly\npublic inline fun String.replaceFirstChar(transform: (Char) -> Char): String {\n    return if (isNotEmpty()) transform(this[0]) + substring(1) else this\n}\n\n/**\n * Returns a copy of this string having its first character replaced with the result of the specified [transform],\n * or the original string if it's empty.\n *\n * @param transform function that takes the first character and returns the result of the transform applied to the character.\n *\n * @sample samples.text.Strings.replaceFirstChar\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@JvmName(\"replaceFirstCharWithCharSequence\")\n@kotlin.internal.InlineOnly\npublic inline fun String.replaceFirstChar(transform: (Char) -> CharSequence): String {\n    return if (isNotEmpty()) transform(this[0]).toString() + substring(1) else this\n}\n\n\n/**\n * Returns `true` if this char sequence matches the given regular expression.\n */\n@kotlin.internal.InlineOnly\npublic inline infix fun CharSequence.matches(regex: Regex): Boolean = regex.matches(this)\n\n/**\n * Implementation of [regionMatches] for CharSequences.\n * Invoked when it's already known that arguments are not Strings, so that no additional type checks are performed.\n */\ninternal fun CharSequence.regionMatchesImpl(thisOffset: Int, other: CharSequence, otherOffset: Int, length: Int, ignoreCase: Boolean): Boolean {\n    if ((otherOffset < 0) || (thisOffset < 0) || (thisOffset > this.length - length) || (otherOffset > other.length - length)) {\n        return false\n    }\n\n    for (index in 0 until length) {\n        if (!this[thisOffset + index].equals(other[otherOffset + index], ignoreCase))\n            return false\n    }\n    return true\n}\n\n/**\n * Returns `true` if this char sequence starts with the specified character.\n */\npublic fun CharSequence.startsWith(char: Char, ignoreCase: Boolean = false): Boolean =\n    this.length > 0 && this[0].equals(char, ignoreCase)\n\n/**\n * Returns `true` if this char sequence ends with the specified character.\n */\npublic fun CharSequence.endsWith(char: Char, ignoreCase: Boolean = false): Boolean =\n    this.length > 0 && this[lastIndex].equals(char, ignoreCase)\n\n/**\n * Returns `true` if this char sequence starts with the specified prefix.\n */\npublic fun CharSequence.startsWith(prefix: CharSequence, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase && this is String && prefix is String)\n        return this.startsWith(prefix)\n    else\n        return regionMatchesImpl(0, prefix, 0, prefix.length, ignoreCase)\n}\n\n/**\n * Returns `true` if a substring of this char sequence starting at the specified offset [startIndex] starts with the specified prefix.\n */\npublic fun CharSequence.startsWith(prefix: CharSequence, startIndex: Int, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase && this is String && prefix is String)\n        return this.startsWith(prefix, startIndex)\n    else\n        return regionMatchesImpl(startIndex, prefix, 0, prefix.length, ignoreCase)\n}\n\n/**\n * Returns `true` if this char sequence ends with the specified suffix.\n */\npublic fun CharSequence.endsWith(suffix: CharSequence, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase && this is String && suffix is String)\n        return this.endsWith(suffix)\n    else\n        return regionMatchesImpl(length - suffix.length, suffix, 0, suffix.length, ignoreCase)\n}\n\n\n// common prefix and suffix\n\n/**\n * Returns the longest string `prefix` such that this char sequence and [other] char sequence both start with this prefix,\n * taking care not to split surrogate pairs.\n * If this and [other] have no common prefix, returns the empty string.\n\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @sample samples.text.Strings.commonPrefixWith\n */\npublic fun CharSequence.commonPrefixWith(other: CharSequence, ignoreCase: Boolean = false): String {\n    val shortestLength = minOf(this.length, other.length)\n\n    var i = 0\n    while (i < shortestLength && this[i].equals(other[i], ignoreCase = ignoreCase)) {\n        i++\n    }\n    if (this.hasSurrogatePairAt(i - 1) || other.hasSurrogatePairAt(i - 1)) {\n        i--\n    }\n    return subSequence(0, i).toString()\n}\n\n/**\n * Returns the longest string `suffix` such that this char sequence and [other] char sequence both end with this suffix,\n * taking care not to split surrogate pairs.\n * If this and [other] have no common suffix, returns the empty string.\n\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @sample samples.text.Strings.commonSuffixWith\n */\npublic fun CharSequence.commonSuffixWith(other: CharSequence, ignoreCase: Boolean = false): String {\n    val thisLength = this.length\n    val otherLength = other.length\n    val shortestLength = minOf(thisLength, otherLength)\n\n    var i = 0\n    while (i < shortestLength && this[thisLength - i - 1].equals(other[otherLength - i - 1], ignoreCase = ignoreCase)) {\n        i++\n    }\n    if (this.hasSurrogatePairAt(thisLength - i - 1) || other.hasSurrogatePairAt(otherLength - i - 1)) {\n        i--\n    }\n    return subSequence(thisLength - i, thisLength).toString()\n}\n\n\n// indexOfAny()\n\n/**\n * Finds the index of the first occurrence of any of the specified [chars] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the first occurrence of matched character from [chars] or -1 if none of [chars] are found.\n *\n */\npublic fun CharSequence.indexOfAny(chars: CharArray, startIndex: Int = 0, ignoreCase: Boolean = false): Int {\n    if (!ignoreCase && chars.size == 1 && this is String) {\n        val char = chars.single()\n        return nativeIndexOf(char, startIndex)\n    }\n\n    for (index in startIndex.coerceAtLeast(0)..lastIndex) {\n        val charAtIndex = get(index)\n        if (chars.any { it.equals(charAtIndex, ignoreCase) })\n            return index\n    }\n    return -1\n}\n\n/**\n * Finds the index of the last occurrence of any of the specified [chars] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the last occurrence of matched character from [chars] or -1 if none of [chars] are found.\n *\n */\npublic fun CharSequence.lastIndexOfAny(chars: CharArray, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int {\n    if (!ignoreCase && chars.size == 1 && this is String) {\n        val char = chars.single()\n        return nativeLastIndexOf(char, startIndex)\n    }\n\n\n    for (index in startIndex.coerceAtMost(lastIndex) downTo 0) {\n        val charAtIndex = get(index)\n        if (chars.any { it.equals(charAtIndex, ignoreCase) })\n            return index\n    }\n\n    return -1\n}\n\n\nprivate fun CharSequence.indexOf(other: CharSequence, startIndex: Int, endIndex: Int, ignoreCase: Boolean, last: Boolean = false): Int {\n    val indices = if (!last)\n        startIndex.coerceAtLeast(0)..endIndex.coerceAtMost(length)\n    else\n        startIndex.coerceAtMost(lastIndex) downTo endIndex.coerceAtLeast(0)\n\n    if (this is String && other is String) { // smart cast\n        for (index in indices) {\n            if (other.regionMatches(0, this, index, other.length, ignoreCase))\n                return index\n        }\n    } else {\n        for (index in indices) {\n            if (other.regionMatchesImpl(0, this, index, other.length, ignoreCase))\n                return index\n        }\n    }\n    return -1\n}\n\nprivate fun CharSequence.findAnyOf(strings: Collection<String>, startIndex: Int, ignoreCase: Boolean, last: Boolean): Pair<Int, String>? {\n    if (!ignoreCase && strings.size == 1) {\n        val string = strings.single()\n        val index = if (!last) indexOf(string, startIndex) else lastIndexOf(string, startIndex)\n        return if (index < 0) null else index to string\n    }\n\n    val indices = if (!last) startIndex.coerceAtLeast(0)..length else startIndex.coerceAtMost(lastIndex) downTo 0\n\n    if (this is String) {\n        for (index in indices) {\n            val matchingString = strings.firstOrNull { it.regionMatches(0, this, index, it.length, ignoreCase) }\n            if (matchingString != null)\n                return index to matchingString\n        }\n    } else {\n        for (index in indices) {\n            val matchingString = strings.firstOrNull { it.regionMatchesImpl(0, this, index, it.length, ignoreCase) }\n            if (matchingString != null)\n                return index to matchingString\n        }\n    }\n\n    return null\n}\n\n/**\n * Finds the first occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return A pair of an index of the first occurrence of matched string from [strings] and the string matched\n * or `null` if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.findAnyOf(strings: Collection<String>, startIndex: Int = 0, ignoreCase: Boolean = false): Pair<Int, String>? =\n    findAnyOf(strings, startIndex, ignoreCase, last = false)\n\n/**\n * Finds the last occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return A pair of an index of the last occurrence of matched string from [strings] and the string matched or `null` if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the end toward the beginning of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.findLastAnyOf(strings: Collection<String>, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Pair<Int, String>? =\n    findAnyOf(strings, startIndex, ignoreCase, last = true)\n\n/**\n * Finds the index of the first occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the first occurrence of matched string from [strings] or -1 if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.indexOfAny(strings: Collection<String>, startIndex: Int = 0, ignoreCase: Boolean = false): Int =\n    findAnyOf(strings, startIndex, ignoreCase, last = false)?.first ?: -1\n\n/**\n * Finds the index of the last occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the last occurrence of matched string from [strings] or -1 if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the end toward the beginning of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.lastIndexOfAny(strings: Collection<String>, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int =\n    findAnyOf(strings, startIndex, ignoreCase, last = true)?.first ?: -1\n\n\n// indexOf\n\n/**\n * Returns the index within this string of the first occurrence of the specified character, starting from the specified [startIndex].\n *\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the first occurrence of [char] or -1 if none is found.\n */\npublic fun CharSequence.indexOf(char: Char, startIndex: Int = 0, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        indexOfAny(charArrayOf(char), startIndex, ignoreCase)\n    else\n        nativeIndexOf(char, startIndex)\n}\n\n/**\n * Returns the index within this char sequence of the first occurrence of the specified [string],\n * starting from the specified [startIndex].\n *\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the first occurrence of [string] or `-1` if none is found.\n * @sample samples.text.Strings.indexOf\n */\npublic fun CharSequence.indexOf(string: String, startIndex: Int = 0, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        indexOf(string, startIndex, length, ignoreCase)\n    else\n        nativeIndexOf(string, startIndex)\n}\n\n/**\n * Returns the index within this char sequence of the last occurrence of the specified character,\n * starting from the specified [startIndex].\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the last occurrence of [char] or -1 if none is found.\n */\npublic fun CharSequence.lastIndexOf(char: Char, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        lastIndexOfAny(charArrayOf(char), startIndex, ignoreCase)\n    else\n        nativeLastIndexOf(char, startIndex)\n}\n\n/**\n * Returns the index within this char sequence of the last occurrence of the specified [string],\n * starting from the specified [startIndex].\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the last occurrence of [string] or -1 if none is found.\n */\npublic fun CharSequence.lastIndexOf(string: String, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        indexOf(string, startIndex, 0, ignoreCase, last = true)\n    else\n        nativeLastIndexOf(string, startIndex)\n}\n\n/**\n * Returns `true` if this char sequence contains the specified [other] sequence of characters as a substring.\n *\n * @param ignoreCase `true` to ignore character case when comparing strings. By default `false`.\n */\n@Suppress(\"INAPPLICABLE_OPERATOR_MODIFIER\")\npublic operator fun CharSequence.contains(other: CharSequence, ignoreCase: Boolean = false): Boolean =\n    if (other is String)\n        indexOf(other, ignoreCase = ignoreCase) >= 0\n    else\n        indexOf(other, 0, length, ignoreCase) >= 0\n\n\n\n/**\n * Returns `true` if this char sequence contains the specified character [char].\n *\n * @param ignoreCase `true` to ignore character case when comparing characters. By default `false`.\n */\n@Suppress(\"INAPPLICABLE_OPERATOR_MODIFIER\")\npublic operator fun CharSequence.contains(char: Char, ignoreCase: Boolean = false): Boolean =\n    indexOf(char, ignoreCase = ignoreCase) >= 0\n\n/**\n * Returns `true` if this char sequence contains at least one match of the specified regular expression [regex].\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharSequence.contains(regex: Regex): Boolean = regex.containsMatchIn(this)\n\n\n// rangesDelimitedBy\n\n\nprivate class DelimitedRangesSequence(\n    private val input: CharSequence,\n    private val startIndex: Int,\n    private val limit: Int,\n    private val getNextMatch: CharSequence.(currentIndex: Int) -> Pair<Int, Int>?\n) : Sequence<IntRange> {\n\n    override fun iterator(): Iterator<IntRange> = object : Iterator<IntRange> {\n        var nextState: Int = -1 // -1 for unknown, 0 for done, 1 for continue\n        var currentStartIndex: Int = startIndex.coerceIn(0, input.length)\n        var nextSearchIndex: Int = currentStartIndex\n        var nextItem: IntRange? = null\n        var counter: Int = 0\n\n        private fun calcNext() {\n            if (nextSearchIndex < 0) {\n                nextState = 0\n                nextItem = null\n            } else {\n                if (limit > 0 && ++counter >= limit || nextSearchIndex > input.length) {\n                    nextItem = currentStartIndex..input.lastIndex\n                    nextSearchIndex = -1\n                } else {\n                    val match = input.getNextMatch(nextSearchIndex)\n                    if (match == null) {\n                        nextItem = currentStartIndex..input.lastIndex\n                        nextSearchIndex = -1\n                    } else {\n                        val (index, length) = match\n                        nextItem = currentStartIndex until index\n                        currentStartIndex = index + length\n                        nextSearchIndex = currentStartIndex + if (length == 0) 1 else 0\n                    }\n                }\n                nextState = 1\n            }\n        }\n\n        override fun next(): IntRange {\n            if (nextState == -1)\n                calcNext()\n            if (nextState == 0)\n                throw NoSuchElementException()\n            val result = nextItem as IntRange\n            // Clean next to avoid keeping reference on yielded instance\n            nextItem = null\n            nextState = -1\n            return result\n        }\n\n        override fun hasNext(): Boolean {\n            if (nextState == -1)\n                calcNext()\n            return nextState == 1\n        }\n    }\n}\n\n/**\n * Returns a sequence of index ranges of substrings in this char sequence around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more characters to be used as delimiters.\n * @param startIndex The index to start searching delimiters from.\n *  No range having its start value less than [startIndex] is returned.\n *  [startIndex] is coerced to be non-negative and not greater than length of this string.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n */\nprivate fun CharSequence.rangesDelimitedBy(delimiters: CharArray, startIndex: Int = 0, ignoreCase: Boolean = false, limit: Int = 0): Sequence<IntRange> {\n    require(limit >= 0, { \"Limit must be non-negative, but was $limit.\" })\n\n    return DelimitedRangesSequence(this, startIndex, limit, { currentIndex ->\n        indexOfAny(delimiters, currentIndex, ignoreCase = ignoreCase).let { if (it < 0) null else it to 1 }\n    })\n}\n\n\n/**\n * Returns a sequence of index ranges of substrings in this char sequence around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more strings to be used as delimiters.\n * @param startIndex The index to start searching delimiters from.\n *  No range having its start value less than [startIndex] is returned.\n *  [startIndex] is coerced to be non-negative and not greater than length of this string.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n *\n * To avoid ambiguous results when strings in [delimiters] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [delimiters]\n * that matches this string at that position.\n */\nprivate fun CharSequence.rangesDelimitedBy(delimiters: Array<out String>, startIndex: Int = 0, ignoreCase: Boolean = false, limit: Int = 0): Sequence<IntRange> {\n    require(limit >= 0, { \"Limit must be non-negative, but was $limit.\" } )\n    val delimitersList = delimiters.asList()\n\n    return DelimitedRangesSequence(this, startIndex, limit, { currentIndex -> findAnyOf(delimitersList, currentIndex, ignoreCase = ignoreCase, last = false)?.let { it.first to it.second.length } })\n\n}\n\n\n// split\n\n/**\n * Splits this char sequence to a sequence of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more strings to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n *\n * To avoid ambiguous results when strings in [delimiters] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [delimiters]\n * that matches this string at that position.\n */\npublic fun CharSequence.splitToSequence(vararg delimiters: String, ignoreCase: Boolean = false, limit: Int = 0): Sequence<String> =\n    rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).map { substring(it) }\n\n/**\n * Splits this char sequence to a list of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more strings to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n *\n * To avoid ambiguous results when strings in [delimiters] have characters in common, this method proceeds from\n * the beginning to the end of this string, and matches at each position the first element in [delimiters]\n * that is equal to a delimiter in this instance at that position.\n */\npublic fun CharSequence.split(vararg delimiters: String, ignoreCase: Boolean = false, limit: Int = 0): List<String> {\n    if (delimiters.size == 1) {\n        val delimiter = delimiters[0]\n        if (!delimiter.isEmpty()) {\n            return split(delimiter, ignoreCase, limit)\n        }\n    }\n\n    return rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).asIterable().map { substring(it) }\n}\n\n/**\n * Splits this char sequence to a sequence of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more characters to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return.\n */\npublic fun CharSequence.splitToSequence(vararg delimiters: Char, ignoreCase: Boolean = false, limit: Int = 0): Sequence<String> =\n    rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).map { substring(it) }\n\n/**\n * Splits this char sequence to a list of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more characters to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return.\n */\npublic fun CharSequence.split(vararg delimiters: Char, ignoreCase: Boolean = false, limit: Int = 0): List<String> {\n    if (delimiters.size == 1) {\n        return split(delimiters[0].toString(), ignoreCase, limit)\n    }\n\n    return rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).asIterable().map { substring(it) }\n}\n\n/**\n * Splits this char sequence to a list of strings around occurrences of the specified [delimiter].\n * This is specialized version of split which receives single non-empty delimiter and offers better performance\n *\n * @param delimiter String used as delimiter\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return.\n */\nprivate fun CharSequence.split(delimiter: String, ignoreCase: Boolean, limit: Int): List<String> {\n    require(limit >= 0, { \"Limit must be non-negative, but was $limit.\" })\n\n    var currentOffset = 0\n    var nextIndex = indexOf(delimiter, currentOffset, ignoreCase)\n    if (nextIndex == -1 || limit == 1) {\n        return listOf(this.toString())\n    }\n\n    val isLimited = limit > 0\n    val result = ArrayList<String>(if (isLimited) limit.coerceAtMost(10) else 10)\n    do {\n        result.add(substring(currentOffset, nextIndex))\n        currentOffset = nextIndex + delimiter.length\n        // Do not search for next occurrence if we're reaching limit\n        if (isLimited && result.size == limit - 1) break\n        nextIndex = indexOf(delimiter, currentOffset, ignoreCase)\n    } while (nextIndex != -1)\n\n    result.add(substring(currentOffset, length))\n    return result\n}\n\n/**\n * Splits this char sequence around matches of the given regular expression.\n *\n * @param limit Non-negative value specifying the maximum number of substrings to return.\n * Zero by default means no limit is set.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.split(regex: Regex, limit: Int = 0): List<String> = regex.split(this, limit)\n\n/**\n * Splits this char sequence to a sequence of lines delimited by any of the following character sequences: CRLF, LF or CR.\n *\n * The lines returned do not include terminating line separators.\n */\npublic fun CharSequence.lineSequence(): Sequence<String> = splitToSequence(\"\\r\\n\", \"\\n\", \"\\r\")\n\n/**\n * Splits this char sequence to a list of lines delimited by any of the following character sequences: CRLF, LF or CR.\n *\n * The lines returned do not include terminating line separators.\n */\npublic fun CharSequence.lines(): List<String> = lineSequence().toList()\n\n/**\n * Returns `true` if the contents of this char sequence are equal to the contents of the specified [other],\n * i.e. both char sequences contain the same number of the same characters in the same order.\n *\n * @sample samples.text.Strings.contentEquals\n */\n@SinceKotlin(\"1.5\")\npublic expect infix fun CharSequence?.contentEquals(other: CharSequence?): Boolean\n\n/**\n * Returns `true` if the contents of this char sequence are equal to the contents of the specified [other], optionally ignoring case difference.\n *\n * @param ignoreCase `true` to ignore character case when comparing contents.\n *\n * @sample samples.text.Strings.contentEquals\n */\n@SinceKotlin(\"1.5\")\npublic expect fun CharSequence?.contentEquals(other: CharSequence?, ignoreCase: Boolean): Boolean\n\ninternal fun CharSequence?.contentEqualsIgnoreCaseImpl(other: CharSequence?): Boolean {\n    if (this is String && other is String) {\n        return this.equals(other, ignoreCase = true)\n    }\n\n    if (this === other) return true\n    if (this == null || other == null || this.length != other.length) return false\n\n    for (i in 0 until length) {\n        if (!this[i].equals(other[i], ignoreCase = true)) {\n            return false\n        }\n    }\n\n    return true\n}\n\ninternal fun CharSequence?.contentEqualsImpl(other: CharSequence?): Boolean {\n    if (this is String && other is String) {\n        return this == other\n    }\n\n    if (this === other) return true\n    if (this == null || other == null || this.length != other.length) return false\n\n    for (i in 0 until length) {\n        if (this[i] != other[i]) {\n            return false\n        }\n    }\n\n    return true\n}\n\n/**\n * Returns `true` if the content of this string is equal to the word \"true\", `false` if it is equal to \"false\",\n * and throws an exception otherwise.\n *\n * There is also a lenient version of the function available on nullable String, [String?.toBoolean].\n * Note that this function is case-sensitive.\n *\n * @sample samples.text.Strings.toBooleanStrict\n */\n@SinceKotlin(\"1.5\")\npublic fun String.toBooleanStrict(): Boolean = when (this) {\n    \"true\" -> true\n    \"false\" -> false\n    else -> throw IllegalArgumentException(\"The string doesn't represent a boolean value: $this\")\n}\n\n/**\n * Returns `true` if the content of this string is equal to the word \"true\", `false` if it is equal to \"false\",\n * and `null` otherwise.\n *\n * There is also a lenient version of the function available on nullable String, [String?.toBoolean].\n * Note that this function is case-sensitive.\n *\n * @sample samples.text.Strings.toBooleanStrictOrNull\n */\n@SinceKotlin(\"1.5\")\npublic fun String.toBooleanStrictOrNull(): Boolean? = when (this) {\n    \"true\" -> true\n    \"false\" -> false\n    else -> null\n}","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.comparisons\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.js.*\n\n/**\n * Returns the greater of two values.\n * \n * If values are equal, returns the first one.\n */\n@SinceKotlin(\"1.1\")\npublic actual fun <T : Comparable<T>> maxOf(a: T, b: T): T {\n    return if (a >= b) a else b\n}\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Byte, b: Byte): Byte {\n    return maxOf(a.toInt(), b.toInt()).unsafeCast<Byte>()\n}\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Short, b: Short): Short {\n    return maxOf(a.toInt(), b.toInt()).unsafeCast<Short>()\n}\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Int, b: Int): Int {\n    return JsMath.max(a, b)\n}\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.1\")\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun maxOf(a: Long, b: Long): Long {\n    return if (a >= b) a else b\n}\n\n/**\n * Returns the greater of two values.\n * \n * If either value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Float, b: Float): Float {\n    return JsMath.max(a, b)\n}\n\n/**\n * Returns the greater of two values.\n * \n * If either value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Double, b: Double): Double {\n    return JsMath.max(a, b)\n}\n\n/**\n * Returns the greater of three values.\n * \n * If there are multiple equal maximal values, returns the first of them.\n */\n@SinceKotlin(\"1.1\")\npublic actual fun <T : Comparable<T>> maxOf(a: T, b: T, c: T): T {\n    return maxOf(a, maxOf(b, c))\n}\n\n/**\n * Returns the greater of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Byte, b: Byte, c: Byte): Byte {\n    return JsMath.max(a.toInt(), b.toInt(), c.toInt()).unsafeCast<Byte>()\n}\n\n/**\n * Returns the greater of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Short, b: Short, c: Short): Short {\n    return JsMath.max(a.toInt(), b.toInt(), c.toInt()).unsafeCast<Short>()\n}\n\n/**\n * Returns the greater of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Int, b: Int, c: Int): Int {\n    return JsMath.max(a, b, c)\n}\n\n/**\n * Returns the greater of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Long, b: Long, c: Long): Long {\n    return maxOf(a, maxOf(b, c))\n}\n\n/**\n * Returns the greater of three values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Float, b: Float, c: Float): Float {\n    return JsMath.max(a, b, c)\n}\n\n/**\n * Returns the greater of three values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Double, b: Double, c: Double): Double {\n    return JsMath.max(a, b, c)\n}\n\n/**\n * Returns the greater of the given values.\n * \n * If there are multiple equal maximal values, returns the first of them.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun <T : Comparable<T>> maxOf(a: T, vararg other: T): T {\n    var max = a\n    for (e in other) max = maxOf(max, e)\n    return max\n}\n\n/**\n * Returns the greater of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun maxOf(a: Byte, vararg other: Byte): Byte {\n    var max = a\n    for (e in other) max = maxOf(max, e)\n    return max\n}\n\n/**\n * Returns the greater of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun maxOf(a: Short, vararg other: Short): Short {\n    var max = a\n    for (e in other) max = maxOf(max, e)\n    return max\n}\n\n/**\n * Returns the greater of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun maxOf(a: Int, vararg other: Int): Int {\n    var max = a\n    for (e in other) max = maxOf(max, e)\n    return max\n}\n\n/**\n * Returns the greater of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun maxOf(a: Long, vararg other: Long): Long {\n    var max = a\n    for (e in other) max = maxOf(max, e)\n    return max\n}\n\n/**\n * Returns the greater of the given values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun maxOf(a: Float, vararg other: Float): Float {\n    var max = a\n    for (e in other) max = maxOf(max, e)\n    return max\n}\n\n/**\n * Returns the greater of the given values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun maxOf(a: Double, vararg other: Double): Double {\n    var max = a\n    for (e in other) max = maxOf(max, e)\n    return max\n}\n\n/**\n * Returns the smaller of two values.\n * \n * If values are equal, returns the first one.\n */\n@SinceKotlin(\"1.1\")\npublic actual fun <T : Comparable<T>> minOf(a: T, b: T): T {\n    return if (a <= b) a else b\n}\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Byte, b: Byte): Byte {\n    return minOf(a.toInt(), b.toInt()).unsafeCast<Byte>()\n}\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Short, b: Short): Short {\n    return minOf(a.toInt(), b.toInt()).unsafeCast<Short>()\n}\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Int, b: Int): Int {\n    return JsMath.min(a, b)\n}\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.1\")\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun minOf(a: Long, b: Long): Long {\n    return if (a <= b) a else b\n}\n\n/**\n * Returns the smaller of two values.\n * \n * If either value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Float, b: Float): Float {\n    return JsMath.min(a, b)\n}\n\n/**\n * Returns the smaller of two values.\n * \n * If either value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Double, b: Double): Double {\n    return JsMath.min(a, b)\n}\n\n/**\n * Returns the smaller of three values.\n * \n * If there are multiple equal minimal values, returns the first of them.\n */\n@SinceKotlin(\"1.1\")\npublic actual fun <T : Comparable<T>> minOf(a: T, b: T, c: T): T {\n    return minOf(a, minOf(b, c))\n}\n\n/**\n * Returns the smaller of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Byte, b: Byte, c: Byte): Byte {\n    return JsMath.min(a.toInt(), b.toInt(), c.toInt()).unsafeCast<Byte>()\n}\n\n/**\n * Returns the smaller of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Short, b: Short, c: Short): Short {\n    return JsMath.min(a.toInt(), b.toInt(), c.toInt()).unsafeCast<Short>()\n}\n\n/**\n * Returns the smaller of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Int, b: Int, c: Int): Int {\n    return JsMath.min(a, b, c)\n}\n\n/**\n * Returns the smaller of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Long, b: Long, c: Long): Long {\n    return minOf(a, minOf(b, c))\n}\n\n/**\n * Returns the smaller of three values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Float, b: Float, c: Float): Float {\n    return JsMath.min(a, b, c)\n}\n\n/**\n * Returns the smaller of three values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Double, b: Double, c: Double): Double {\n    return JsMath.min(a, b, c)\n}\n\n/**\n * Returns the smaller of the given values.\n * \n * If there are multiple equal minimal values, returns the first of them.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun <T : Comparable<T>> minOf(a: T, vararg other: T): T {\n    var min = a\n    for (e in other) min = minOf(min, e)\n    return min\n}\n\n/**\n * Returns the smaller of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun minOf(a: Byte, vararg other: Byte): Byte {\n    var min = a\n    for (e in other) min = minOf(min, e)\n    return min\n}\n\n/**\n * Returns the smaller of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun minOf(a: Short, vararg other: Short): Short {\n    var min = a\n    for (e in other) min = minOf(min, e)\n    return min\n}\n\n/**\n * Returns the smaller of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun minOf(a: Int, vararg other: Int): Int {\n    var min = a\n    for (e in other) min = minOf(min, e)\n    return min\n}\n\n/**\n * Returns the smaller of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun minOf(a: Long, vararg other: Long): Long {\n    var min = a\n    for (e in other) min = minOf(min, e)\n    return min\n}\n\n/**\n * Returns the smaller of the given values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun minOf(a: Float, vararg other: Float): Float {\n    var min = a\n    for (e in other) min = minOf(min, e)\n    return min\n}\n\n/**\n * Returns the smaller of the given values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun minOf(a: Double, vararg other: Double): Double {\n    var min = a\n    for (e in other) min = minOf(min, e)\n    return min\n}\n\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\nimport kotlin.js.RegExp\n\n@kotlin.internal.InlineOnly\ninternal actual inline fun String.nativeIndexOf(ch: Char, fromIndex: Int): Int = nativeIndexOf(ch.toString(), fromIndex)\n\n@kotlin.internal.InlineOnly\ninternal actual inline fun String.nativeLastIndexOf(ch: Char, fromIndex: Int): Int = nativeLastIndexOf(ch.toString(), fromIndex)\n\n/**\n * Returns `true` if this string starts with the specified prefix.\n */\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.startsWith(prefix: String, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase)\n        return nativeStartsWith(prefix, 0)\n    else\n        return regionMatches(0, prefix, 0, prefix.length, ignoreCase)\n}\n\n/**\n * Returns `true` if a substring of this string starting at the specified offset [startIndex] starts with the specified prefix.\n */\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.startsWith(prefix: String, startIndex: Int, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase)\n        return nativeStartsWith(prefix, startIndex)\n    else\n        return regionMatches(startIndex, prefix, 0, prefix.length, ignoreCase)\n}\n\n/**\n * Returns `true` if this string ends with the specified suffix.\n */\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.endsWith(suffix: String, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase)\n        return nativeEndsWith(suffix)\n    else\n        return regionMatches(length - suffix.length, suffix, 0, suffix.length, ignoreCase)\n}\n\n\npublic fun String.matches(regex: String): Boolean {\n    val result = this.match(regex)\n    return result != null && result.size != 0\n}\n\npublic actual fun CharSequence.isBlank(): Boolean = length == 0 || (if (this is String) this else this.toString()).matches(\"^[\\\\s\\\\xA0]+$\")\n\n@OptIn(ExperimentalStdlibApi::class)\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String?.equals(other: String?, ignoreCase: Boolean = false): Boolean =\n    when {\n        this == null -> other == null\n        !ignoreCase -> this == other\n        other == null -> false\n        else -> {\n            val thisLower = this.lowercase()\n            val otherLower = other.lowercase()\n            thisLower == otherLower || (thisLower.uppercase() == otherLower.uppercase())\n        }\n    }\n\n\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun CharSequence.regionMatches(thisOffset: Int, other: CharSequence, otherOffset: Int, length: Int, ignoreCase: Boolean = false): Boolean =\n    regionMatchesImpl(thisOffset, other, otherOffset, length, ignoreCase)\n\n\n/**\n * Returns a copy of this string having its first letter titlecased using the rules of the default locale,\n * or the original string if it's empty or already starts with a title case letter.\n *\n * The title case of a character is usually the same as its upper case with several exceptions.\n * The particular list of characters with the special title case form depends on the underlying platform.\n *\n * @sample samples.text.Strings.capitalize\n */\n@Deprecated(\"Use replaceFirstChar instead.\", ReplaceWith(\"replaceFirstChar { if (it.isLowerCase()) it.titlecase() else it.toString() }\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic actual fun String.capitalize(): String {\n    return if (isNotEmpty()) substring(0, 1).toUpperCase() + substring(1) else this\n}\n\n/**\n * Returns a copy of this string having its first letter lowercased using the rules of the default locale,\n * or the original string if it's empty or already starts with a lower case letter.\n *\n * @sample samples.text.Strings.decapitalize\n */\n@Deprecated(\"Use replaceFirstChar instead.\", ReplaceWith(\"replaceFirstChar { it.lowercase() }\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic actual fun String.decapitalize(): String {\n    return if (isNotEmpty()) substring(0, 1).toLowerCase() + substring(1) else this\n}\n\n/**\n * Returns a string containing this char sequence repeated [n] times.\n * @throws [IllegalArgumentException] when n < 0.\n * @sample samples.text.Strings.repeat\n */\npublic actual fun CharSequence.repeat(n: Int): String {\n    require(n >= 0) { \"Count 'n' must be non-negative, but was $n.\" }\n    return when (n) {\n        0 -> \"\"\n        1 -> this.toString()\n        else -> {\n            var result = \"\"\n            if (!isEmpty()) {\n                var s = this.toString()\n                var count = n\n                while (true) {\n                    if ((count and 1) == 1) {\n                        result += s\n                    }\n                    count = count ushr 1\n                    if (count == 0) {\n                        break\n                    }\n                    s += s\n                }\n            }\n            return result\n        }\n    }\n}\n\n/**\n * Returns a new string obtained by replacing all occurrences of the [oldValue] substring in this string\n * with the specified [newValue] string.\n *\n * @sample samples.text.Strings.replace\n */\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.replace(oldValue: String, newValue: String, ignoreCase: Boolean = false): String =\n    nativeReplace(RegExp(Regex.escape(oldValue), if (ignoreCase) \"gui\" else \"gu\"), Regex.escapeReplacement(newValue))\n\n/**\n * Returns a new string with all occurrences of [oldChar] replaced with [newChar].\n *\n * @sample samples.text.Strings.replace\n */\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.replace(oldChar: Char, newChar: Char, ignoreCase: Boolean = false): String =\n    nativeReplace(RegExp(Regex.escape(oldChar.toString()), if (ignoreCase) \"gui\" else \"gu\"), newChar.toString())\n\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.replaceFirst(oldValue: String, newValue: String, ignoreCase: Boolean = false): String =\n    nativeReplace(RegExp(Regex.escape(oldValue), if (ignoreCase) \"ui\" else \"u\"), Regex.escapeReplacement(newValue))\n\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.replaceFirst(oldChar: Char, newChar: Char, ignoreCase: Boolean = false): String =\n    nativeReplace(RegExp(Regex.escape(oldChar.toString()), if (ignoreCase) \"ui\" else \"u\"), newChar.toString())\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\npackage kotlin.collections\n\nimport kotlin.js.JsName\n\n/**\n * Provides a skeletal implementation of the read-only [Collection] interface.\n *\n * @param E the type of elements contained in the collection. The collection is covariant in its element type.\n */\n@SinceKotlin(\"1.1\")\npublic abstract class AbstractCollection<out E> protected constructor() : Collection<E> {\n    abstract override val size: Int\n    abstract override fun iterator(): Iterator<E>\n\n    override fun contains(element: @UnsafeVariance E): Boolean = any { it == element }\n\n    override fun containsAll(elements: Collection<@UnsafeVariance E>): Boolean =\n        elements.all { contains(it) } // use when js will support bound refs: elements.all(this::contains)\n\n    override fun isEmpty(): Boolean = size == 0\n\n    override fun toString(): String = joinToString(\", \", \"[\", \"]\") {\n        if (it === this) \"(this Collection)\" else it.toString()\n    }\n\n    /**\n     * Returns new array of type `Array<Any?>` with the elements of this collection.\n     */\n    @JsName(\"toArray\")\n    protected open fun toArray(): Array<Any?> = copyToArrayImpl(this)\n\n    /**\n     * Fills the provided [array] or creates new array of the same type\n     * and fills it with the elements of this collection.\n     */\n    protected open fun <T> toArray(array: Array<T>): Array<T> = copyToArrayImpl(this, array)\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n/*\n * Based on GWT AbstractList\n * Copyright 2007 Google Inc.\n*/\n\npackage kotlin.collections\n\n/**\n * Provides a skeletal implementation of the read-only [List] interface.\n *\n * This class is intended to help implementing read-only lists so it doesn't support concurrent modification tracking.\n *\n * @param E the type of elements contained in the list. The list is covariant in its element type.\n */\n@SinceKotlin(\"1.1\")\npublic abstract class AbstractList<out E> protected constructor() : AbstractCollection<E>(), List<E> {\n    abstract override val size: Int\n    abstract override fun get(index: Int): E\n\n    override fun iterator(): Iterator<E> = IteratorImpl()\n\n    override fun indexOf(element: @UnsafeVariance E): Int = indexOfFirst { it == element }\n\n    override fun lastIndexOf(element: @UnsafeVariance E): Int = indexOfLast { it == element }\n\n    override fun listIterator(): ListIterator<E> = ListIteratorImpl(0)\n\n    override fun listIterator(index: Int): ListIterator<E> = ListIteratorImpl(index)\n\n    override fun subList(fromIndex: Int, toIndex: Int): List<E> = SubList(this, fromIndex, toIndex)\n\n    private class SubList<out E>(private val list: AbstractList<E>, private val fromIndex: Int, toIndex: Int) : AbstractList<E>(), RandomAccess {\n        private var _size: Int = 0\n\n        init {\n            checkRangeIndexes(fromIndex, toIndex, list.size)\n            this._size = toIndex - fromIndex\n        }\n\n        override fun get(index: Int): E {\n            checkElementIndex(index, _size)\n\n            return list[fromIndex + index]\n        }\n\n        override val size: Int get() = _size\n    }\n\n    /**\n     * Compares this list with other list instance with the ordered structural equality.\n     *\n     * @return true, if [other] instance is a [List] of the same size, which contains the same elements in the same order.\n     */\n    override fun equals(other: Any?): Boolean {\n        if (other === this) return true\n        if (other !is List<*>) return false\n\n        return orderedEquals(this, other)\n    }\n\n    /**\n     * Returns the hash code value for this list.\n     */\n    override fun hashCode(): Int = orderedHashCode(this)\n\n    private open inner class IteratorImpl : Iterator<E> {\n        /** the index of the item that will be returned on the next call to [next]`()` */\n        protected var index = 0\n\n        override fun hasNext(): Boolean = index < size\n\n        override fun next(): E {\n            if (!hasNext()) throw NoSuchElementException()\n            return get(index++)\n        }\n    }\n\n    /**\n     * Implementation of [ListIterator] for abstract lists.\n     */\n    private open inner class ListIteratorImpl(index: Int) : IteratorImpl(), ListIterator<E> {\n\n        init {\n            checkPositionIndex(index, this@AbstractList.size)\n            this.index = index\n        }\n\n        override fun hasPrevious(): Boolean = index > 0\n\n        override fun nextIndex(): Int = index\n\n        override fun previous(): E {\n            if (!hasPrevious()) throw NoSuchElementException()\n            return get(--index)\n        }\n\n        override fun previousIndex(): Int = index - 1\n    }\n\n    internal companion object {\n        internal fun checkElementIndex(index: Int, size: Int) {\n            if (index < 0 || index >= size) {\n                throw IndexOutOfBoundsException(\"index: $index, size: $size\")\n            }\n        }\n\n        internal fun checkPositionIndex(index: Int, size: Int) {\n            if (index < 0 || index > size) {\n                throw IndexOutOfBoundsException(\"index: $index, size: $size\")\n            }\n        }\n\n        internal fun checkRangeIndexes(fromIndex: Int, toIndex: Int, size: Int) {\n            if (fromIndex < 0 || toIndex > size) {\n                throw IndexOutOfBoundsException(\"fromIndex: $fromIndex, toIndex: $toIndex, size: $size\")\n            }\n            if (fromIndex > toIndex) {\n                throw IllegalArgumentException(\"fromIndex: $fromIndex > toIndex: $toIndex\")\n            }\n        }\n\n        internal fun checkBoundsIndexes(startIndex: Int, endIndex: Int, size: Int) {\n            if (startIndex < 0 || endIndex > size) {\n                throw IndexOutOfBoundsException(\"startIndex: $startIndex, endIndex: $endIndex, size: $size\")\n            }\n            if (startIndex > endIndex) {\n                throw IllegalArgumentException(\"startIndex: $startIndex > endIndex: $endIndex\")\n            }\n        }\n\n        internal fun orderedHashCode(c: Collection<*>): Int {\n            var hashCode = 1\n            for (e in c) {\n                hashCode = 31 * hashCode + (e?.hashCode() ?: 0)\n            }\n            return hashCode\n        }\n\n        internal fun orderedEquals(c: Collection<*>, other: Collection<*>): Boolean {\n            if (c.size != other.size) return false\n\n            val otherIterator = other.iterator()\n            for (elem in c) {\n                val elemOther = otherIterator.next()\n                if (elem != elemOther) {\n                    return false\n                }\n            }\n            return true\n        }\n    }\n}","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n/*\n * Based on GWT AbstractMap\n * Copyright 2007 Google Inc.\n */\n\npackage kotlin.collections\n\n/**\n * Provides a skeletal implementation of the read-only [Map] interface.\n *\n * The implementor is required to implement [entries] property, which should return read-only set of map entries.\n *\n * @param K the type of map keys. The map is invariant in its key type.\n * @param V the type of map values. The map is covariant in its value type.\n */\n@SinceKotlin(\"1.1\")\npublic abstract class AbstractMap<K, out V> protected constructor() : Map<K, V> {\n\n    override fun containsKey(key: K): Boolean {\n        return implFindEntry(key) != null\n    }\n\n    override fun containsValue(value: @UnsafeVariance V): Boolean = entries.any { it.value == value }\n\n    internal fun containsEntry(entry: Map.Entry<*, *>?): Boolean {\n        // since entry comes from @UnsafeVariance parameters it can be virtually anything\n        if (entry !is Map.Entry<*, *>) return false\n        val key = entry.key\n        val value = entry.value\n        val ourValue = get(key)\n\n        if (value != ourValue) {\n            return false\n        }\n\n        // Perhaps it was null and we don't contain the key?\n        if (ourValue == null && !containsKey(key)) {\n            return false\n        }\n\n        return true\n    }\n\n\n    /**\n     * Compares this map with other instance with the ordered structural equality.\n     *\n     * @return true, if [other] instance is a [Map] of the same size, all entries of which are contained in the [entries] set of this map.\n     */\n    override fun equals(other: Any?): Boolean {\n        if (other === this) return true\n        if (other !is Map<*, *>) return false\n        if (size != other.size) return false\n\n        return other.entries.all { containsEntry(it) }\n    }\n\n    override operator fun get(key: K): V? = implFindEntry(key)?.value\n\n\n    /**\n     * Returns the hash code value for this map.\n     *\n     * It is the same as the hashCode of [entries] set.\n     */\n    override fun hashCode(): Int = entries.hashCode()\n\n    override fun isEmpty(): Boolean = size == 0\n    override val size: Int get() = entries.size\n\n    /**\n     * Returns a read-only [Set] of all keys in this map.\n     *\n     * Accessing this property first time creates a keys view from [entries].\n     * All subsequent accesses just return the created instance.\n     */\n    override val keys: Set<K>\n        get() {\n            if (_keys == null) {\n                _keys = object : AbstractSet<K>() {\n                    override operator fun contains(element: K): Boolean = containsKey(element)\n\n                    override operator fun iterator(): Iterator<K> {\n                        val entryIterator = entries.iterator()\n                        return object : Iterator<K> {\n                            override fun hasNext(): Boolean = entryIterator.hasNext()\n                            override fun next(): K = entryIterator.next().key\n                        }\n                    }\n\n                    override val size: Int get() = this@AbstractMap.size\n                }\n            }\n            return _keys!!\n        }\n\n    @kotlin.jvm.Volatile\n    private var _keys: Set<K>? = null\n\n\n    override fun toString(): String = entries.joinToString(\", \", \"{\", \"}\") { toString(it) }\n\n    private fun toString(entry: Map.Entry<K, V>): String = toString(entry.key) + \"=\" + toString(entry.value)\n\n    private fun toString(o: Any?): String = if (o === this) \"(this Map)\" else o.toString()\n\n    /**\n     * Returns a read-only [Collection] of all values in this map.\n     *\n     * Accessing this property first time creates a values view from [entries].\n     * All subsequent accesses just return the created instance.\n     */\n    override val values: Collection<V>\n        get() {\n            if (_values == null) {\n                _values = object : AbstractCollection<V>() {\n                    override operator fun contains(element: @UnsafeVariance V): Boolean = containsValue(element)\n\n                    override operator fun iterator(): Iterator<V> {\n                        val entryIterator = entries.iterator()\n                        return object : Iterator<V> {\n                            override fun hasNext(): Boolean = entryIterator.hasNext()\n                            override fun next(): V = entryIterator.next().value\n                        }\n                    }\n\n                    override val size: Int get() = this@AbstractMap.size\n                }\n            }\n            return _values!!\n        }\n\n    @kotlin.jvm.Volatile\n    private var _values: Collection<V>? = null\n\n    private fun implFindEntry(key: K): Map.Entry<K, V>? = entries.firstOrNull { it.key == key }\n\n    internal companion object {\n\n        internal fun entryHashCode(e: Map.Entry<*, *>): Int = with(e) { (key?.hashCode() ?: 0) xor (value?.hashCode() ?: 0) }\n        internal fun entryToString(e: Map.Entry<*, *>): String = with(e) { \"$key=$value\" }\n        internal fun entryEquals(e: Map.Entry<*, *>, other: Any?): Boolean {\n            if (other !is Map.Entry<*, *>) return false\n            return e.key == other.key && e.value == other.value\n        }\n    }\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\npackage kotlin.collections\n\n/**\n * Provides a skeletal implementation of the read-only [Set] interface.\n *\n * This class is intended to help implementing read-only sets so it doesn't support concurrent modification tracking.\n *\n * @param E the type of elements contained in the set. The set is covariant in its element type.\n */\n@SinceKotlin(\"1.1\")\npublic abstract class AbstractSet<out E> protected constructor() : AbstractCollection<E>(), Set<E> {\n\n    /**\n     * Compares this set with other set instance with the unordered structural equality.\n     *\n     * @return true, if [other] instance is a [Set] of the same size, all elements of which are contained in this set.\n     */\n    override fun equals(other: Any?): Boolean {\n        if (other === this) return true\n        if (other !is Set<*>) return false\n        return setEquals(this, other)\n    }\n\n    /**\n     * Returns the hash code value for this set.\n     */\n    override fun hashCode(): Int = unorderedHashCode(this)\n\n    internal companion object {\n        internal fun unorderedHashCode(c: Collection<*>): Int {\n            var hashCode = 0\n            for (element in c) {\n                hashCode += (element?.hashCode() ?: 0)\n            }\n            return hashCode\n        }\n\n        internal fun setEquals(c: Set<*>, other: Set<*>): Boolean {\n            if (c.size != other.size) return false\n            return c.containsAll(other)\n        }\n    }\n\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.collections\n\n/**\n * Data class representing a value from a collection or sequence, along with its index in that collection or sequence.\n *\n * @property value the underlying value.\n * @property index the index of the value in the collection or sequence.\n */\npublic data class IndexedValue<out T>(public val index: Int, public val value: T)\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n\npackage kotlin.collections\n\n/**\n * Given an [iterator] function constructs an [Iterable] instance that returns values through the [Iterator]\n * provided by that function.\n * @sample samples.collections.Iterables.Building.iterable\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable(crossinline iterator: () -> Iterator<T>): Iterable<T> = object : Iterable<T> {\n    override fun iterator(): Iterator<T> = iterator()\n}\n\n/**\n * A wrapper over another [Iterable] (or any other object that can produce an [Iterator]) that returns\n * an indexing iterator.\n */\ninternal class IndexingIterable<out T>(private val iteratorFactory: () -> Iterator<T>) : Iterable<IndexedValue<T>> {\n    override fun iterator(): Iterator<IndexedValue<T>> = IndexingIterator(iteratorFactory())\n}\n\n\n/**\n * Returns the size of this iterable if it is known, or `null` otherwise.\n */\n@PublishedApi\ninternal fun <T> Iterable<T>.collectionSizeOrNull(): Int? = if (this is Collection<*>) this.size else null\n\n/**\n * Returns the size of this iterable if it is known, or the specified [default] value otherwise.\n */\n@PublishedApi\ninternal fun <T> Iterable<T>.collectionSizeOrDefault(default: Int): Int = if (this is Collection<*>) this.size else default\n\n/** Returns true when it's safe to convert this collection to a set without changing contains method behavior. */\nprivate fun <T> Collection<T>.safeToConvertToSet() = size > 2 && this is ArrayList\n\n/** Converts this collection to a set, when it's worth so and it doesn't change contains method behavior. */\ninternal fun <T> Iterable<T>.convertToSetForSetOperationWith(source: Iterable<T>): Collection<T> =\n    when (this) {\n        is Set -> this\n        is Collection ->\n            when {\n                source is Collection && source.size < 2 -> this\n                else -> if (this.safeToConvertToSet()) toHashSet() else this\n            }\n        else -> toHashSet()\n    }\n\n/** Converts this collection to a set, when it's worth so and it doesn't change contains method behavior. */\ninternal fun <T> Iterable<T>.convertToSetForSetOperation(): Collection<T> =\n    when (this) {\n        is Set -> this\n        is Collection -> if (this.safeToConvertToSet()) toHashSet() else this\n        else -> toHashSet()\n    }\n\n\n/**\n * Returns a single list of all elements from all collections in the given collection.\n * @sample samples.collections.Iterables.Operations.flattenIterable\n */\npublic fun <T> Iterable<Iterable<T>>.flatten(): List<T> {\n    val result = ArrayList<T>()\n    for (element in this) {\n        result.addAll(element)\n    }\n    return result\n}\n\n/**\n * Returns a pair of lists, where\n * *first* list is built from the first values of each pair from this collection,\n * *second* list is built from the second values of each pair from this collection.\n * @sample samples.collections.Iterables.Operations.unzipIterable\n */\npublic fun <T, R> Iterable<Pair<T, R>>.unzip(): Pair<List<T>, List<R>> {\n    val expectedSize = collectionSizeOrDefault(10)\n    val listT = ArrayList<T>(expectedSize)\n    val listR = ArrayList<R>(expectedSize)\n    for (pair in this) {\n        listT.add(pair.first)\n        listR.add(pair.second)\n    }\n    return listT to listR\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n\npackage kotlin.collections\n\n\n/**\n * Returns the given iterator itself. This allows to use an instance of iterator in a `for` loop.\n * @sample samples.collections.Iterators.iterator\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> Iterator<T>.iterator(): Iterator<T> = this\n\n/**\n * Returns an [Iterator] that wraps each element produced by the original iterator\n * into an [IndexedValue] containing the index of that element and the element itself.\n *\n * @sample samples.collections.Iterators.withIndexIterator\n */\npublic fun <T> Iterator<T>.withIndex(): Iterator<IndexedValue<T>> = IndexingIterator(this)\n\n/**\n * Performs the given [operation] on each element of this [Iterator].\n * @sample samples.collections.Iterators.forEachIterator\n */\npublic inline fun <T> Iterator<T>.forEach(operation: (T) -> Unit): Unit {\n    for (element in this) operation(element)\n}\n\n/**\n * Iterator transforming original `iterator` into iterator of [IndexedValue], counting index from zero.\n */\ninternal class IndexingIterator<out T>(private val iterator: Iterator<T>) : Iterator<IndexedValue<T>> {\n    private var index = 0\n    final override fun hasNext(): Boolean = iterator.hasNext()\n    final override fun next(): IndexedValue<T> = IndexedValue(checkIndexOverflow(index++), iterator.next())\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"MapsKt\")\n\npackage kotlin.collections\n\n/**\n * Returns the value for the given key, or the implicit default value for this map.\n * By default no implicit value is provided for maps and a [NoSuchElementException] is thrown.\n * To create a map with implicit default value use [withDefault] method.\n *\n * @throws NoSuchElementException when the map doesn't contain a value for the specified key and no implicit default was provided for that map.\n */\n@kotlin.jvm.JvmName(\"getOrImplicitDefaultNullable\")\n@PublishedApi\ninternal fun <K, V> Map<K, V>.getOrImplicitDefault(key: K): V {\n    if (this is MapWithDefault)\n        return this.getOrImplicitDefault(key)\n\n    return getOrElseNullable(key, { throw NoSuchElementException(\"Key $key is missing in the map.\") })\n}\n\n/**\n * Returns a wrapper of this read-only map, having the implicit default value provided with the specified function [defaultValue].\n *\n * This implicit default value is used when the original map doesn't contain a value for the key specified\n * and a value is obtained with [Map.getValue] function, for example when properties are delegated to the map.\n *\n * When this map already has an implicit default value provided with a former call to [withDefault], it is being replaced by this call.\n */\npublic fun <K, V> Map<K, V>.withDefault(defaultValue: (key: K) -> V): Map<K, V> =\n    when (this) {\n        is MapWithDefault -> this.map.withDefault(defaultValue)\n        else -> MapWithDefaultImpl(this, defaultValue)\n    }\n\n/**\n * Returns a wrapper of this mutable map, having the implicit default value provided with the specified function [defaultValue].\n *\n * This implicit default value is used when the original map doesn't contain a value for the key specified\n * and a value is obtained with [Map.getValue] function, for example when properties are delegated to the map.\n *\n * When this map already has an implicit default value provided with a former call to [withDefault], it is being replaced by this call.\n */\n@kotlin.jvm.JvmName(\"withDefaultMutable\")\npublic fun <K, V> MutableMap<K, V>.withDefault(defaultValue: (key: K) -> V): MutableMap<K, V> =\n    when (this) {\n        is MutableMapWithDefault -> this.map.withDefault(defaultValue)\n        else -> MutableMapWithDefaultImpl(this, defaultValue)\n    }\n\n\nprivate interface MapWithDefault<K, out V> : Map<K, V> {\n    public val map: Map<K, V>\n    public fun getOrImplicitDefault(key: K): V\n}\n\nprivate interface MutableMapWithDefault<K, V> : MutableMap<K, V>, MapWithDefault<K, V> {\n    public override val map: MutableMap<K, V>\n}\n\n\nprivate class MapWithDefaultImpl<K, out V>(public override val map: Map<K, V>, private val default: (key: K) -> V) : MapWithDefault<K, V> {\n    override fun equals(other: Any?): Boolean = map.equals(other)\n    override fun hashCode(): Int = map.hashCode()\n    override fun toString(): String = map.toString()\n    override val size: Int get() = map.size\n    override fun isEmpty(): Boolean = map.isEmpty()\n    override fun containsKey(key: K): Boolean = map.containsKey(key)\n    override fun containsValue(value: @UnsafeVariance V): Boolean = map.containsValue(value)\n    override fun get(key: K): V? = map.get(key)\n    override val keys: Set<K> get() = map.keys\n    override val values: Collection<V> get() = map.values\n    override val entries: Set<Map.Entry<K, V>> get() = map.entries\n\n    override fun getOrImplicitDefault(key: K): V = map.getOrElseNullable(key, { default(key) })\n}\n\nprivate class MutableMapWithDefaultImpl<K, V>(public override val map: MutableMap<K, V>, private val default: (key: K) -> V) : MutableMapWithDefault<K, V> {\n    override fun equals(other: Any?): Boolean = map.equals(other)\n    override fun hashCode(): Int = map.hashCode()\n    override fun toString(): String = map.toString()\n    override val size: Int get() = map.size\n    override fun isEmpty(): Boolean = map.isEmpty()\n    override fun containsKey(key: K): Boolean = map.containsKey(key)\n    override fun containsValue(value: @UnsafeVariance V): Boolean = map.containsValue(value)\n    override fun get(key: K): V? = map.get(key)\n    override val keys: MutableSet<K> get() = map.keys\n    override val values: MutableCollection<V> get() = map.values\n    override val entries: MutableSet<MutableMap.MutableEntry<K, V>> get() = map.entries\n\n    override fun put(key: K, value: V): V? = map.put(key, value)\n    override fun remove(key: K): V? = map.remove(key)\n    override fun putAll(from: Map<out K, V>) = map.putAll(from)\n    override fun clear() = map.clear()\n\n    override fun getOrImplicitDefault(key: K): V = map.getOrElseNullable(key, { default(key) })\n}\n\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n\npackage kotlin.collections\n\nimport kotlin.random.Random\n\n/**\n * Removes a single instance of the specified element from this\n * collection, if it is present.\n *\n * Allows to overcome type-safety restriction of `remove` that requires to pass an element of type `E`.\n *\n * @return `true` if the element has been successfully removed; `false` if it was not present in the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes T> MutableCollection<out T>.remove(element: T): Boolean =\n    @Suppress(\"UNCHECKED_CAST\") (this as MutableCollection<T>).remove(element)\n\n/**\n * Removes all of this collection's elements that are also contained in the specified collection.\n\n * Allows to overcome type-safety restriction of `removeAll` that requires to pass a collection of type `Collection<E>`.\n *\n * @return `true` if any of the specified elements was removed from the collection, `false` if the collection was not modified.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes T> MutableCollection<out T>.removeAll(elements: Collection<T>): Boolean =\n    @Suppress(\"UNCHECKED_CAST\") (this as MutableCollection<T>).removeAll(elements)\n\n/**\n * Retains only the elements in this collection that are contained in the specified collection.\n *\n * Allows to overcome type-safety restriction of `retainAll` that requires to pass a collection of type `Collection<E>`.\n *\n * @return `true` if any element was removed from the collection, `false` if the collection was not modified.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes T> MutableCollection<out T>.retainAll(elements: Collection<T>): Boolean =\n    @Suppress(\"UNCHECKED_CAST\") (this as MutableCollection<T>).retainAll(elements)\n\n/**\n * Adds the specified [element] to this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.plusAssign(element: T) {\n    this.add(element)\n}\n\n/**\n * Adds all elements of the given [elements] collection to this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.plusAssign(elements: Iterable<T>) {\n    this.addAll(elements)\n}\n\n/**\n * Adds all elements of the given [elements] array to this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.plusAssign(elements: Array<T>) {\n    this.addAll(elements)\n}\n\n/**\n * Adds all elements of the given [elements] sequence to this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.plusAssign(elements: Sequence<T>) {\n    this.addAll(elements)\n}\n\n/**\n * Removes a single instance of the specified [element] from this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.minusAssign(element: T) {\n    this.remove(element)\n}\n\n/**\n * Removes all elements contained in the given [elements] collection from this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.minusAssign(elements: Iterable<T>) {\n    this.removeAll(elements)\n}\n\n/**\n * Removes all elements contained in the given [elements] array from this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.minusAssign(elements: Array<T>) {\n    this.removeAll(elements)\n}\n\n/**\n * Removes all elements contained in the given [elements] sequence from this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.minusAssign(elements: Sequence<T>) {\n    this.removeAll(elements)\n}\n\n/**\n * Adds all elements of the given [elements] collection to this [MutableCollection].\n */\npublic fun <T> MutableCollection<in T>.addAll(elements: Iterable<T>): Boolean {\n    when (elements) {\n        is Collection -> return addAll(elements)\n        else -> {\n            var result: Boolean = false\n            for (item in elements)\n                if (add(item)) result = true\n            return result\n        }\n    }\n}\n\n/**\n * Adds all elements of the given [elements] sequence to this [MutableCollection].\n */\npublic fun <T> MutableCollection<in T>.addAll(elements: Sequence<T>): Boolean {\n    var result: Boolean = false\n    for (item in elements) {\n        if (add(item)) result = true\n    }\n    return result\n}\n\n/**\n * Adds all elements of the given [elements] array to this [MutableCollection].\n */\npublic fun <T> MutableCollection<in T>.addAll(elements: Array<out T>): Boolean {\n    return addAll(elements.asList())\n}\n\n/**\n * Removes all elements from this [MutableCollection] that are also contained in the given [elements] collection.\n */\npublic fun <T> MutableCollection<in T>.removeAll(elements: Iterable<T>): Boolean {\n    return removeAll(elements.convertToSetForSetOperationWith(this))\n}\n\n/**\n * Removes all elements from this [MutableCollection] that are also contained in the given [elements] sequence.\n */\npublic fun <T> MutableCollection<in T>.removeAll(elements: Sequence<T>): Boolean {\n    val set = elements.toHashSet()\n    return set.isNotEmpty() && removeAll(set)\n}\n\n/**\n * Removes all elements from this [MutableCollection] that are also contained in the given [elements] array.\n */\npublic fun <T> MutableCollection<in T>.removeAll(elements: Array<out T>): Boolean {\n    return elements.isNotEmpty() && removeAll(elements.toHashSet())\n}\n\n/**\n * Retains only elements of this [MutableCollection] that are contained in the given [elements] collection.\n */\npublic fun <T> MutableCollection<in T>.retainAll(elements: Iterable<T>): Boolean {\n    return retainAll(elements.convertToSetForSetOperationWith(this))\n}\n\n/**\n * Retains only elements of this [MutableCollection] that are contained in the given [elements] array.\n */\npublic fun <T> MutableCollection<in T>.retainAll(elements: Array<out T>): Boolean {\n    if (elements.isNotEmpty())\n        return retainAll(elements.toHashSet())\n    else\n        return retainNothing()\n}\n\n/**\n * Retains only elements of this [MutableCollection] that are contained in the given [elements] sequence.\n */\npublic fun <T> MutableCollection<in T>.retainAll(elements: Sequence<T>): Boolean {\n    val set = elements.toHashSet()\n    if (set.isNotEmpty())\n        return retainAll(set)\n    else\n        return retainNothing()\n}\n\nprivate fun MutableCollection<*>.retainNothing(): Boolean {\n    val result = isNotEmpty()\n    clear()\n    return result\n}\n\n\n/**\n * Removes all elements from this [MutableIterable] that match the given [predicate].\n *\n * @return `true` if any element was removed from this collection, or `false` when no elements were removed and collection was not modified.\n */\npublic fun <T> MutableIterable<T>.removeAll(predicate: (T) -> Boolean): Boolean = filterInPlace(predicate, true)\n\n/**\n * Retains only elements of this [MutableIterable] that match the given [predicate].\n *\n * @return `true` if any element was removed from this collection, or `false` when all elements were retained and collection was not modified.\n */\npublic fun <T> MutableIterable<T>.retainAll(predicate: (T) -> Boolean): Boolean = filterInPlace(predicate, false)\n\nprivate fun <T> MutableIterable<T>.filterInPlace(predicate: (T) -> Boolean, predicateResultToRemove: Boolean): Boolean {\n    var result = false\n    with(iterator()) {\n        while (hasNext())\n            if (predicate(next()) == predicateResultToRemove) {\n                remove()\n                result = true\n            }\n    }\n    return result\n}\n\n\n/**\n * Removes the element at the specified [index] from this list.\n * In Kotlin one should use the [MutableList.removeAt] function instead.\n */\n@Deprecated(\"Use removeAt(index) instead.\", ReplaceWith(\"removeAt(index)\"), level = DeprecationLevel.ERROR)\n@kotlin.internal.InlineOnly\npublic inline fun <T> MutableList<T>.remove(index: Int): T = removeAt(index)\n\n/**\n * Removes the first element from this mutable list and returns that removed element, or throws [NoSuchElementException] if this list is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <T> MutableList<T>.removeFirst(): T = if (isEmpty()) throw NoSuchElementException(\"List is empty.\") else removeAt(0)\n\n/**\n * Removes the first element from this mutable list and returns that removed element, or returns `null` if this list is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <T> MutableList<T>.removeFirstOrNull(): T? = if (isEmpty()) null else removeAt(0)\n\n/**\n * Removes the last element from this mutable list and returns that removed element, or throws [NoSuchElementException] if this list is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <T> MutableList<T>.removeLast(): T = if (isEmpty()) throw NoSuchElementException(\"List is empty.\") else removeAt(lastIndex)\n\n/**\n * Removes the last element from this mutable list and returns that removed element, or returns `null` if this list is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <T> MutableList<T>.removeLastOrNull(): T? = if (isEmpty()) null else removeAt(lastIndex)\n\n/**\n * Removes all elements from this [MutableList] that match the given [predicate].\n *\n * @return `true` if any element was removed from this collection, or `false` when no elements were removed and collection was not modified.\n */\npublic fun <T> MutableList<T>.removeAll(predicate: (T) -> Boolean): Boolean = filterInPlace(predicate, true)\n\n/**\n * Retains only elements of this [MutableList] that match the given [predicate].\n *\n * @return `true` if any element was removed from this collection, or `false` when all elements were retained and collection was not modified.\n */\npublic fun <T> MutableList<T>.retainAll(predicate: (T) -> Boolean): Boolean = filterInPlace(predicate, false)\n\nprivate fun <T> MutableList<T>.filterInPlace(predicate: (T) -> Boolean, predicateResultToRemove: Boolean): Boolean {\n    if (this !is RandomAccess)\n        return (this as MutableIterable<T>).filterInPlace(predicate, predicateResultToRemove)\n\n    var writeIndex: Int = 0\n    for (readIndex in 0..lastIndex) {\n        val element = this[readIndex]\n        if (predicate(element) == predicateResultToRemove)\n            continue\n\n        if (writeIndex != readIndex)\n            this[writeIndex] = element\n\n        writeIndex++\n    }\n    if (writeIndex < size) {\n        for (removeIndex in lastIndex downTo writeIndex)\n            removeAt(removeIndex)\n\n        return true\n    } else {\n        return false\n    }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.coroutines\n\n/**\n * Marks coroutine context element that intercepts coroutine continuations.\n * The coroutines framework uses [ContinuationInterceptor.Key] to retrieve the interceptor and\n * intercepts all coroutine continuations with [interceptContinuation] invocations.\n *\n * [ContinuationInterceptor] behaves like a [polymorphic element][AbstractCoroutineContextKey], meaning that\n * its implementation delegates [get][CoroutineContext.Element.get] and [minusKey][CoroutineContext.Element.minusKey]\n * to [getPolymorphicElement] and [minusPolymorphicKey] respectively.\n * [ContinuationInterceptor] subtypes can be extracted from the coroutine context using either [ContinuationInterceptor.Key]\n * or subtype key if it extends [AbstractCoroutineContextKey].\n */\n@SinceKotlin(\"1.3\")\npublic interface ContinuationInterceptor : CoroutineContext.Element {\n    /**\n     * The key that defines *the* context interceptor.\n     */\n    companion object Key : CoroutineContext.Key<ContinuationInterceptor>\n\n    /**\n     * Returns continuation that wraps the original [continuation], thus intercepting all resumptions.\n     * This function is invoked by coroutines framework when needed and the resulting continuations are\n     * cached internally per each instance of the original [continuation].\n     *\n     * This function may simply return original [continuation] if it does not want to intercept this particular continuation.\n     *\n     * When the original [continuation] completes, coroutine framework invokes [releaseInterceptedContinuation]\n     * with the resulting continuation if it was intercepted, that is if `interceptContinuation` had previously\n     * returned a different continuation instance.\n     */\n    public fun <T> interceptContinuation(continuation: Continuation<T>): Continuation<T>\n\n    /**\n     * Invoked for the continuation instance returned by [interceptContinuation] when the original\n     * continuation completes and will not be used anymore. This function is invoked only if [interceptContinuation]\n     * had returned a different continuation instance from the one it was invoked with.\n     *\n     * Default implementation does nothing.\n     *\n     * @param continuation Continuation instance returned by this interceptor's [interceptContinuation] invocation.\n     */\n    public fun releaseInterceptedContinuation(continuation: Continuation<*>) {\n        /* do nothing by default */\n    }\n\n    public override operator fun <E : CoroutineContext.Element> get(key: CoroutineContext.Key<E>): E? {\n        // getPolymorphicKey specialized for ContinuationInterceptor key\n        @OptIn(ExperimentalStdlibApi::class)\n        if (key is AbstractCoroutineContextKey<*, *>) {\n            @Suppress(\"UNCHECKED_CAST\")\n            return if (key.isSubKey(this.key)) key.tryCast(this) as? E else null\n        }\n        @Suppress(\"UNCHECKED_CAST\")\n        return if (ContinuationInterceptor === key) this as E else null\n    }\n\n\n    public override fun minusKey(key: CoroutineContext.Key<*>): CoroutineContext {\n        // minusPolymorphicKey specialized for ContinuationInterceptor key\n        @OptIn(ExperimentalStdlibApi::class)\n        if (key is AbstractCoroutineContextKey<*, *>) {\n            return if (key.isSubKey(this.key) && key.tryCast(this) != null) EmptyCoroutineContext else this\n        }\n        return if (ContinuationInterceptor === key) EmptyCoroutineContext else this\n    }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.coroutines\n\n/**\n * Persistent context for the coroutine. It is an indexed set of [Element] instances.\n * An indexed set is a mix between a set and a map.\n * Every element in this set has a unique [Key].\n */\n@SinceKotlin(\"1.3\")\npublic interface CoroutineContext {\n    /**\n     * Returns the element with the given [key] from this context or `null`.\n     */\n    public operator fun <E : Element> get(key: Key<E>): E?\n\n    /**\n     * Accumulates entries of this context starting with [initial] value and applying [operation]\n     * from left to right to current accumulator value and each element of this context.\n     */\n    public fun <R> fold(initial: R, operation: (R, Element) -> R): R\n\n    /**\n     * Returns a context containing elements from this context and elements from  other [context].\n     * The elements from this context with the same key as in the other one are dropped.\n     */\n    public operator fun plus(context: CoroutineContext): CoroutineContext =\n        if (context === EmptyCoroutineContext) this else // fast path -- avoid lambda creation\n            context.fold(this) { acc, element ->\n                val removed = acc.minusKey(element.key)\n                if (removed === EmptyCoroutineContext) element else {\n                    // make sure interceptor is always last in the context (and thus is fast to get when present)\n                    val interceptor = removed[ContinuationInterceptor]\n                    if (interceptor == null) CombinedContext(removed, element) else {\n                        val left = removed.minusKey(ContinuationInterceptor)\n                        if (left === EmptyCoroutineContext) CombinedContext(element, interceptor) else\n                            CombinedContext(CombinedContext(left, element), interceptor)\n                    }\n                }\n            }\n\n    /**\n     * Returns a context containing elements from this context, but without an element with\n     * the specified [key].\n     */\n    public fun minusKey(key: Key<*>): CoroutineContext\n\n    /**\n     * Key for the elements of [CoroutineContext]. [E] is a type of element with this key.\n     */\n    public interface Key<E : Element>\n\n    /**\n     * An element of the [CoroutineContext]. An element of the coroutine context is a singleton context by itself.\n     */\n    public interface Element : CoroutineContext {\n        /**\n         * A key of this coroutine context element.\n         */\n        public val key: Key<*>\n\n        public override operator fun <E : Element> get(key: Key<E>): E? =\n            @Suppress(\"UNCHECKED_CAST\")\n            if (this.key == key) this as E else null\n\n        public override fun <R> fold(initial: R, operation: (R, Element) -> R): R =\n            operation(initial, this)\n\n        public override fun minusKey(key: Key<*>): CoroutineContext =\n            if (this.key == key) EmptyCoroutineContext else this\n    }\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.coroutines\n\nimport kotlin.coroutines.CoroutineContext.Element\nimport kotlin.coroutines.CoroutineContext.Key\n\n/**\n * Base class for [CoroutineContext.Element] implementations.\n */\n@SinceKotlin(\"1.3\")\npublic abstract class AbstractCoroutineContextElement(public override val key: Key<*>) : Element\n\n/**\n * Base class for [CoroutineContext.Key] associated with polymorphic [CoroutineContext.Element] implementation.\n * Polymorphic element implementation implies delegating its [get][Element.get] and [minusKey][Element.minusKey]\n * to [getPolymorphicElement] and [minusPolymorphicKey] respectively.\n *\n * Polymorphic elements can be extracted from the coroutine context using both element key and its supertype key.\n * Example of polymorphic elements:\n * ```\n * open class BaseElement : CoroutineContext.Element {\n *     companion object Key : CoroutineContext.Key<BaseElement>\n *     override val key: CoroutineContext.Key<*> get() = Key\n *     // It is important to use getPolymorphicKey and minusPolymorphicKey\n *     override fun <E : CoroutineContext.Element> get(key: CoroutineContext.Key<E>): E? = getPolymorphicElement(key)\n *     override fun minusKey(key: CoroutineContext.Key<*>): CoroutineContext = minusPolymorphicKey(key)\n * }\n *\n * class DerivedElement : BaseElement() {\n *     companion object Key : AbstractCoroutineContextKey<BaseElement, DerivedElement>(BaseElement, { it as? DerivedElement })\n * }\n * // Now it is possible to query both `BaseElement` and `DerivedElement`\n * someContext[BaseElement] // Returns BaseElement?, non-null both for BaseElement and DerivedElement instances\n * someContext[DerivedElement] // Returns DerivedElement?, non-null only for DerivedElement instance\n * ```\n * @param B base class of a polymorphic element\n * @param baseKey an instance of base key\n * @param E element type associated with the current key\n * @param safeCast a function that can safely cast abstract [CoroutineContext.Element] to the concrete [E] type\n *                 and return the element if it is a subtype of [E] or `null` otherwise.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic abstract class AbstractCoroutineContextKey<B : Element, E : B>(\n    baseKey: Key<B>,\n    private val safeCast: (element: Element) -> E?\n) : Key<E> {\n    private val topmostKey: Key<*> = if (baseKey is AbstractCoroutineContextKey<*, *>) baseKey.topmostKey else baseKey\n\n    internal fun tryCast(element: Element): E? = safeCast(element)\n    internal fun isSubKey(key: Key<*>): Boolean = key === this || topmostKey === key\n}\n\n/**\n * Returns the current element if it is associated with the given [key] in a polymorphic manner or `null` otherwise.\n * This method returns non-null value if either [Element.key] is equal to the given [key] or if the [key] is associated\n * with [Element.key] via [AbstractCoroutineContextKey].\n * See [AbstractCoroutineContextKey] for the example of usage.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic fun <E : Element> Element.getPolymorphicElement(key: Key<E>): E? {\n    if (key is AbstractCoroutineContextKey<*, *>) {\n        @Suppress(\"UNCHECKED_CAST\")\n        return if (key.isSubKey(this.key)) key.tryCast(this) as? E else null\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return if (this.key === key) this as E else null\n}\n\n/**\n * Returns empty coroutine context if the element is associated with the given [key] in a polymorphic manner\n * or `null` otherwise.\n * This method returns empty context if either [Element.key] is equal to the given [key] or if the [key] is associated\n * with [Element.key] via [AbstractCoroutineContextKey].\n * See [AbstractCoroutineContextKey] for the example of usage.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic fun Element.minusPolymorphicKey(key: Key<*>): CoroutineContext {\n    if (key is AbstractCoroutineContextKey<*, *>) {\n        return if (key.isSubKey(this.key) && key.tryCast(this) != null) EmptyCoroutineContext else this\n    }\n    return if (this.key === key) EmptyCoroutineContext else this\n}\n\n/**\n * An empty coroutine context.\n */\n@SinceKotlin(\"1.3\")\npublic object EmptyCoroutineContext : CoroutineContext, Serializable {\n    private const val serialVersionUID: Long = 0\n    private fun readResolve(): Any = EmptyCoroutineContext\n\n    public override fun <E : Element> get(key: Key<E>): E? = null\n    public override fun <R> fold(initial: R, operation: (R, Element) -> R): R = initial\n    public override fun plus(context: CoroutineContext): CoroutineContext = context\n    public override fun minusKey(key: Key<*>): CoroutineContext = this\n    public override fun hashCode(): Int = 0\n    public override fun toString(): String = \"EmptyCoroutineContext\"\n}\n\n//--------------------- internal impl ---------------------\n\n// this class is not exposed, but is hidden inside implementations\n// this is a left-biased list, so that `plus` works naturally\n@SinceKotlin(\"1.3\")\ninternal class CombinedContext(\n    private val left: CoroutineContext,\n    private val element: Element\n) : CoroutineContext, Serializable {\n\n    override fun <E : Element> get(key: Key<E>): E? {\n        var cur = this\n        while (true) {\n            cur.element[key]?.let { return it }\n            val next = cur.left\n            if (next is CombinedContext) {\n                cur = next\n            } else {\n                return next[key]\n            }\n        }\n    }\n\n    public override fun <R> fold(initial: R, operation: (R, Element) -> R): R =\n        operation(left.fold(initial, operation), element)\n\n    public override fun minusKey(key: Key<*>): CoroutineContext {\n        element[key]?.let { return left }\n        val newLeft = left.minusKey(key)\n        return when {\n            newLeft === left -> this\n            newLeft === EmptyCoroutineContext -> element\n            else -> CombinedContext(newLeft, element)\n        }\n    }\n\n    private fun size(): Int {\n        var cur = this\n        var size = 2\n        while (true) {\n            cur = cur.left as? CombinedContext ?: return size\n            size++\n        }\n    }\n\n    private fun contains(element: Element): Boolean =\n        get(element.key) == element\n\n    private fun containsAll(context: CombinedContext): Boolean {\n        var cur = context\n        while (true) {\n            if (!contains(cur.element)) return false\n            val next = cur.left\n            if (next is CombinedContext) {\n                cur = next\n            } else {\n                return contains(next as Element)\n            }\n        }\n    }\n\n    override fun equals(other: Any?): Boolean =\n        this === other || other is CombinedContext && other.size() == size() && other.containsAll(this)\n\n    override fun hashCode(): Int = left.hashCode() + element.hashCode()\n\n    override fun toString(): String =\n        \"[\" + fold(\"\") { acc, element ->\n            if (acc.isEmpty()) element.toString() else \"$acc, $element\"\n        } + \"]\"\n\n    private fun writeReplace(): Any {\n        val n = size()\n        val elements = arrayOfNulls<CoroutineContext>(n)\n        var index = 0\n        fold(Unit) { _, element -> elements[index++] = element }\n        check(index == n)\n        @Suppress(\"UNCHECKED_CAST\")\n        return Serialized(elements as Array<CoroutineContext>)\n    }\n\n    private class Serialized(val elements: Array<CoroutineContext>) : Serializable {\n        companion object {\n            private const val serialVersionUID: Long = 0L\n        }\n\n        private fun readResolve(): Any = elements.fold(EmptyCoroutineContext, CoroutineContext::plus)\n    }\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmName(\"IntrinsicsKt\")\n@file:kotlin.jvm.JvmMultifileClass\n\npackage kotlin.coroutines.intrinsics\n\nimport kotlin.contracts.*\nimport kotlin.coroutines.*\nimport kotlin.internal.InlineOnly\n\n/**\n * Obtains the current continuation instance inside suspend functions and either suspends\n * currently running coroutine or returns result immediately without suspension.\n *\n * If the [block] returns the special [COROUTINE_SUSPENDED] value, it means that suspend function did suspend the execution and will\n * not return any result immediately. In this case, the [Continuation] provided to the [block] shall be\n * resumed by invoking [Continuation.resumeWith] at some moment in the\n * future when the result becomes available to resume the computation.\n *\n * Otherwise, the return value of the [block] must have a type assignable to [T] and represents the result of this suspend function.\n * It means that the execution was not suspended and the [Continuation] provided to the [block] shall not be invoked.\n * As the result type of the [block] is declared as `Any?` and cannot be correctly type-checked,\n * its proper return type remains on the conscience of the suspend function's author.\n *\n * Invocation of [Continuation.resumeWith] resumes coroutine directly in the invoker's thread without going through the\n * [ContinuationInterceptor] that might be present in the coroutine's [CoroutineContext].\n * It is the invoker's responsibility to ensure that a proper invocation context is established.\n * [Continuation.intercepted] can be used to acquire the intercepted continuation.\n *\n * Note that it is not recommended to call either [Continuation.resume] nor [Continuation.resumeWithException] functions synchronously\n * in the same stackframe where suspension function is run. Use [suspendCoroutine] as a safer way to obtain current\n * continuation instance.\n */\n@SinceKotlin(\"1.3\")\n@InlineOnly\n@Suppress(\"UNUSED_PARAMETER\", \"RedundantSuspendModifier\")\npublic suspend inline fun <T> suspendCoroutineUninterceptedOrReturn(crossinline block: (Continuation<T>) -> Any?): T {\n    contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }\n    throw NotImplementedError(\"Implementation of suspendCoroutineUninterceptedOrReturn is intrinsic\")\n}\n\n/**\n * This value is used as a return value of [suspendCoroutineUninterceptedOrReturn] `block` argument to state that\n * the execution was suspended and will not return any result immediately.\n *\n * **Note: this value should not be used in general code.** Using it outside of the context of\n * `suspendCoroutineUninterceptedOrReturn` function return value  (including, but not limited to,\n * storing this value in other properties, returning it from other functions, etc)\n * can lead to unspecified behavior of the code.\n */\n// It is implemented as property with getter to avoid ProGuard <clinit> problem with multifile IntrinsicsKt class\n@SinceKotlin(\"1.3\")\npublic val COROUTINE_SUSPENDED: Any get() = CoroutineSingletons.COROUTINE_SUSPENDED\n\n// Using enum here ensures two important properties:\n//  1. It makes SafeContinuation serializable with all kinds of serialization frameworks (since all of them natively support enums)\n//  2. It improves debugging experience, since you clearly see toString() value of those objects and what package they come from\n@SinceKotlin(\"1.3\")\n@PublishedApi // This class is Published API via serialized representation of SafeContinuation, don't rename/move\ninternal enum class CoroutineSingletons { COROUTINE_SUSPENDED, UNDECIDED, RESUMED }\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"RangesKt\")\n\npackage kotlin.ranges\n\n/**\n * Represents a range of [Comparable] values.\n */\nprivate open class ComparableRange<T : Comparable<T>>(\n    override val start: T,\n    override val endInclusive: T\n) : ClosedRange<T> {\n\n    override fun equals(other: Any?): Boolean {\n        return other is ComparableRange<*> && (isEmpty() && other.isEmpty() ||\n                start == other.start && endInclusive == other.endInclusive)\n    }\n\n    override fun hashCode(): Int {\n        return if (isEmpty()) -1 else 31 * start.hashCode() + endInclusive.hashCode()\n    }\n\n    override fun toString(): String = \"$start..$endInclusive\"\n}\n\n/**\n * Creates a range from this [Comparable] value to the specified [that] value.\n *\n * This value needs to be smaller than or equal to [that] value, otherwise the returned range will be empty.\n * @sample samples.ranges.Ranges.rangeFromComparable\n */\npublic operator fun <T : Comparable<T>> T.rangeTo(that: T): ClosedRange<T> = ComparableRange(this, that)\n\n\n/**\n * Represents a range of floating point numbers.\n * Extends [ClosedRange] interface providing custom operation [lessThanOrEquals] for comparing values of range domain type.\n *\n * This interface is implemented by floating point ranges returned by [Float.rangeTo] and [Double.rangeTo] operators to\n * achieve IEEE-754 comparison order instead of total order of floating point numbers.\n */\n@SinceKotlin(\"1.1\")\npublic interface ClosedFloatingPointRange<T : Comparable<T>> : ClosedRange<T> {\n    override fun contains(value: T): Boolean = lessThanOrEquals(start, value) && lessThanOrEquals(value, endInclusive)\n    override fun isEmpty(): Boolean = !lessThanOrEquals(start, endInclusive)\n\n    /**\n     * Compares two values of range domain type and returns true if first is less than or equal to second.\n     */\n    fun lessThanOrEquals(a: T, b: T): Boolean\n}\n\n\n/**\n * A closed range of values of type `Double`.\n *\n * Numbers are compared with the ends of this range according to IEEE-754.\n */\nprivate class ClosedDoubleRange(\n    start: Double,\n    endInclusive: Double\n) : ClosedFloatingPointRange<Double> {\n    private val _start = start\n    private val _endInclusive = endInclusive\n    override val start: Double get() = _start\n    override val endInclusive: Double get() = _endInclusive\n\n    override fun lessThanOrEquals(a: Double, b: Double): Boolean = a <= b\n\n    override fun contains(value: Double): Boolean = value >= _start && value <= _endInclusive\n    override fun isEmpty(): Boolean = !(_start <= _endInclusive)\n\n    override fun equals(other: Any?): Boolean {\n        return other is ClosedDoubleRange && (isEmpty() && other.isEmpty() ||\n                _start == other._start && _endInclusive == other._endInclusive)\n    }\n\n    override fun hashCode(): Int {\n        return if (isEmpty()) -1 else 31 * _start.hashCode() + _endInclusive.hashCode()\n    }\n\n    override fun toString(): String = \"$_start..$_endInclusive\"\n}\n\n/**\n * Creates a range from this [Double] value to the specified [that] value.\n *\n * Numbers are compared with the ends of this range according to IEEE-754.\n * @sample samples.ranges.Ranges.rangeFromDouble\n */\n@SinceKotlin(\"1.1\")\npublic operator fun Double.rangeTo(that: Double): ClosedFloatingPointRange<Double> = ClosedDoubleRange(this, that)\n\n\n/**\n * A closed range of values of type `Float`.\n *\n * Numbers are compared with the ends of this range according to IEEE-754.\n */\nprivate class ClosedFloatRange(\n    start: Float,\n    endInclusive: Float\n) : ClosedFloatingPointRange<Float> {\n    private val _start = start\n    private val _endInclusive = endInclusive\n    override val start: Float get() = _start\n    override val endInclusive: Float get() = _endInclusive\n\n    override fun lessThanOrEquals(a: Float, b: Float): Boolean = a <= b\n\n    override fun contains(value: Float): Boolean = value >= _start && value <= _endInclusive\n    override fun isEmpty(): Boolean = !(_start <= _endInclusive)\n\n    override fun equals(other: Any?): Boolean {\n        return other is ClosedFloatRange && (isEmpty() && other.isEmpty() ||\n                _start == other._start && _endInclusive == other._endInclusive)\n    }\n\n    override fun hashCode(): Int {\n        return if (isEmpty()) -1 else 31 * _start.hashCode() + _endInclusive.hashCode()\n    }\n\n    override fun toString(): String = \"$_start..$_endInclusive\"\n}\n\n/**\n * Creates a range from this [Float] value to the specified [that] value.\n *\n * Numbers are compared with the ends of this range according to IEEE-754.\n * @sample samples.ranges.Ranges.rangeFromFloat\n */\n@SinceKotlin(\"1.1\")\npublic operator fun Float.rangeTo(that: Float): ClosedFloatingPointRange<Float> = ClosedFloatRange(this, that)\n\n\n/**\n * Returns `true` if this iterable range contains the specified [element].\n *\n * Always returns `false` if the [element] is `null`.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <T, R> R.contains(element: T?): Boolean where T : Any, R : Iterable<T>, R : ClosedRange<T> =\n    element != null && contains(element)\n\n\ninternal fun checkStepIsPositive(isPositive: Boolean, step: Number) {\n    if (!isPositive) throw IllegalArgumentException(\"Step must be positive, was: $step.\")\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.reflect\n\nimport kotlin.jvm.JvmField\nimport kotlin.jvm.JvmStatic\n\n\n\n/**\n * Represents a type projection. Type projection is usually the argument to another type in a type usage.\n * For example, in the type `Array<out Number>`, `out Number` is the covariant projection of the type represented by the class `Number`.\n *\n * Type projection is either the star projection, or an entity consisting of a specific type plus optional variance.\n *\n * See the [Kotlin language documentation](https://kotlinlang.org/docs/reference/generics.html#type-projections)\n * for more information.\n */\n@SinceKotlin(\"1.1\")\npublic data class KTypeProjection constructor(\n    /**\n     * The use-site variance specified in the projection, or `null` if this is a star projection.\n     */\n    public val variance: KVariance?,\n    /**\n     * The type specified in the projection, or `null` if this is a star projection.\n     */\n    public val type: KType?\n) {\n\n    init {\n        require((variance == null) == (type == null)) {\n            if (variance == null)\n                \"Star projection must have no type specified.\"\n            else\n                \"The projection variance $variance requires type to be specified.\"\n        }\n    }\n\n    override fun toString(): String = when (variance) {\n        null -> \"*\"\n        KVariance.INVARIANT -> type.toString()\n        KVariance.IN -> \"in $type\"\n        KVariance.OUT -> \"out $type\"\n    }\n\n    public companion object {\n        // provided for compiler access\n        @JvmField\n        @PublishedApi\n        internal val star: KTypeProjection = KTypeProjection(null, null)\n\n        /**\n         * Star projection, denoted by the `*` character.\n         * For example, in the type `KClass<*>`, `*` is the star projection.\n         * See the [Kotlin language documentation](https://kotlinlang.org/docs/reference/generics.html#star-projections)\n         * for more information.\n         */\n        public val STAR: KTypeProjection get() = star\n\n        /**\n         * Creates an invariant projection of a given type. Invariant projection is just the type itself,\n         * without any use-site variance modifiers applied to it.\n         * For example, in the type `Set<String>`, `String` is an invariant projection of the type represented by the class `String`.\n         */\n        @JvmStatic\n        public fun invariant(type: KType): KTypeProjection =\n            KTypeProjection(KVariance.INVARIANT, type)\n\n        /**\n         * Creates a contravariant projection of a given type, denoted by the `in` modifier applied to a type.\n         * For example, in the type `MutableList<in Number>`, `in Number` is a contravariant projection of the type of class `Number`.\n         */\n        @JvmStatic\n        public fun contravariant(type: KType): KTypeProjection =\n            KTypeProjection(KVariance.IN, type)\n\n        /**\n         * Creates a covariant projection of a given type, denoted by the `out` modifier applied to a type.\n         * For example, in the type `Array<out Number>`, `out Number` is a covariant projection of the type of class `Number`.\n         */\n        @JvmStatic\n        public fun covariant(type: KType): KTypeProjection =\n            KTypeProjection(KVariance.OUT, type)\n    }\n}","/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.reflect\n\n/**\n * Represents variance applied to a type parameter on the declaration site (*declaration-site variance*),\n * or to a type in a projection (*use-site variance*).\n *\n * See the [Kotlin language documentation](https://kotlinlang.org/docs/reference/generics.html#variance)\n * for more information.\n *\n * @see [KTypeParameter.variance]\n * @see [KTypeProjection]\n */\n@SinceKotlin(\"1.1\")\nenum class KVariance {\n    /**\n     * The affected type parameter or type is *invariant*, which means it has no variance applied to it.\n     */\n    INVARIANT,\n\n    /**\n     * The affected type parameter or type is *contravariant*. Denoted by the `in` modifier in the source code.\n     */\n    IN,\n\n    /**\n     * The affected type parameter or type is *covariant*. Denoted by the `out` modifier in the source code.\n     */\n    OUT,\n}","/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StringsKt\")\n\npackage kotlin.text\n\n/**\n * An object to which char sequences and values can be appended.\n */\nexpect interface Appendable {\n    /**\n     * Appends the specified character [value] to this Appendable and returns this instance.\n     *\n     * @param value the character to append.\n     */\n    fun append(value: Char): Appendable\n\n    /**\n     * Appends the specified character sequence [value] to this Appendable and returns this instance.\n     *\n     * @param value the character sequence to append. If [value] is `null`, then the four characters `\"null\"` are appended to this Appendable.\n     */\n    fun append(value: CharSequence?): Appendable\n\n    /**\n     * Appends a subsequence of the specified character sequence [value] to this Appendable and returns this instance.\n     *\n     * @param value the character sequence from which a subsequence is appended. If [value] is `null`,\n     *  then characters are appended as if [value] contained the four characters `\"null\"`.\n     * @param startIndex the beginning (inclusive) of the subsequence to append.\n     * @param endIndex the end (exclusive) of the subsequence to append.\n     *\n     * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] character sequence indices or when `startIndex > endIndex`.\n     */\n    fun append(value: CharSequence?, startIndex: Int, endIndex: Int): Appendable\n}\n\n/**\n * Appends a subsequence of the specified character sequence [value] to this Appendable and returns this instance.\n *\n * @param value the character sequence from which a subsequence is appended.\n * @param startIndex the beginning (inclusive) of the subsequence to append.\n * @param endIndex the end (exclusive) of the subsequence to append.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] character sequence indices or when `startIndex > endIndex`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <T : Appendable> T.appendRange(value: CharSequence, startIndex: Int, endIndex: Int): T {\n    @Suppress(\"UNCHECKED_CAST\")\n    return append(value, startIndex, endIndex) as T\n}\n\n/**\n * Appends all arguments to the given [Appendable].\n */\npublic fun <T : Appendable> T.append(vararg value: CharSequence?): T {\n    for (item in value)\n        append(item)\n    return this\n}\n\n/** Appends a line feed character (`\\n`) to this Appendable. */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun Appendable.appendLine(): Appendable = append('\\n')\n\n/** Appends value to the given Appendable and a line feed character (`\\n`) after it. */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun Appendable.appendLine(value: CharSequence?): Appendable = append(value).appendLine()\n\n/** Appends value to the given Appendable and a line feed character (`\\n`) after it. */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun Appendable.appendLine(value: Char): Appendable = append(value).appendLine()\n\n\ninternal fun <T> Appendable.appendElement(element: T, transform: ((T) -> CharSequence)?) {\n    when {\n        transform != null -> append(transform(element))\n        element is CharSequence? -> append(element)\n        element is Char -> append(element)\n        else -> append(element.toString())\n    }\n}\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CharsKt\")\n\npackage kotlin.text\n\n/**\n * Returns the numeric value of the decimal digit that this Char represents.\n * Throws an exception if this Char is not a valid decimal digit.\n *\n * A Char is considered to represent a decimal digit if [isDigit] is true for the Char.\n * In this case, the Unicode decimal digit value of the character is returned.\n *\n * @sample samples.text.Chars.digitToInt\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun Char.digitToInt(): Int {\n    return digitOf(this, 10).also {\n        if (it < 0) throw IllegalArgumentException(\"Char $this is not a decimal digit\")\n    }\n}\n\n/**\n * Returns the numeric value of the digit that this Char represents in the specified [radix].\n * Throws an exception if the [radix] is not in the range `2..36` or if this Char is not a valid digit in the specified [radix].\n *\n * A Char is considered to represent a digit in the specified [radix] if at least one of the following is true:\n *  - [isDigit] is `true` for the Char and the Unicode decimal digit value of the character is less than the specified [radix]. In this case the decimal digit value is returned.\n *  - The Char is one of the uppercase Latin letters 'A' through 'Z' and its [code] is less than `radix + 'A'.code - 10`. In this case, `this.code - 'A'.code + 10` is returned.\n *  - The Char is one of the lowercase Latin letters 'a' through 'z' and its [code] is less than `radix + 'a'.code - 10`. In this case, `this.code - 'a'.code + 10` is returned.\n *\n * @sample samples.text.Chars.digitToInt\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun Char.digitToInt(radix: Int): Int {\n    return digitToIntOrNull(radix) ?: throw IllegalArgumentException(\"Char $this is not a digit in the given radix=$radix\")\n}\n\n/**\n *\n * Returns the numeric value of the decimal digit that this Char represents, or `null` if this Char is not a valid decimal digit.\n *\n * A Char is considered to represent a decimal digit if [isDigit] is true for the Char.\n * In this case, the Unicode decimal digit value of the character is returned.\n *\n * @sample samples.text.Chars.digitToIntOrNull\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun Char.digitToIntOrNull(): Int? {\n    return digitOf(this, 10).takeIf { it >= 0 }\n}\n\n/**\n * Returns the numeric value of the digit that this Char represents in the specified [radix], or `null` if this Char is not a valid digit in the specified [radix].\n * Throws an exception if the [radix] is not in the range `2..36`.\n *\n * A Char is considered to represent a digit in the specified [radix] if at least one of the following is true:\n *  - [isDigit] is `true` for the Char and the Unicode decimal digit value of the character is less than the specified [radix]. In this case the decimal digit value is returned.\n *  - The Char is one of the uppercase Latin letters 'A' through 'Z' and its [code] is less than `radix + 'A'.code - 10`. In this case, `this.code - 'A'.code + 10` is returned.\n *  - The Char is one of the lowercase Latin letters 'a' through 'z' and its [code] is less than `radix + 'a'.code - 10`. In this case, `this.code - 'a'.code + 10` is returned.\n *\n * @sample samples.text.Chars.digitToIntOrNull\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun Char.digitToIntOrNull(radix: Int): Int? {\n    checkRadix(radix)\n    return digitOf(this, radix).takeIf { it >= 0 }\n}\n\n/**\n * Returns the Char that represents this decimal digit.\n * Throws an exception if this value is not in the range `0..9`.\n *\n * If this value is in `0..9`, the decimal digit Char with code `'0'.code + this` is returned.\n *\n * @sample samples.text.Chars.digitToChar\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun Int.digitToChar(): Char {\n    if (this in 0..9) {\n        return '0' + this\n    }\n    throw IllegalArgumentException(\"Int $this is not a decimal digit\")\n}\n\n/**\n * Returns the Char that represents this numeric digit value in the specified [radix].\n * Throws an exception if the [radix] is not in the range `2..36` or if this value is not in the range `0 until radix`.\n *\n * If this value is less than `10`, the decimal digit Char with code `'0'.code + this` is returned.\n * Otherwise, the uppercase Latin letter with code `'A'.code + this - 10` is returned.\n *\n * @sample samples.text.Chars.digitToChar\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun Int.digitToChar(radix: Int): Char {\n    if (radix !in 2..36) {\n        throw IllegalArgumentException(\"Invalid radix: $radix. Valid radix values are in range 2..36\")\n    }\n    if (this < 0 || this >= radix) {\n        throw IllegalArgumentException(\"Digit $this does not represent a valid digit in radix $radix\")\n    }\n    return if (this < 10) {\n        '0' + this\n    } else {\n        'A' + this - 10\n    }\n}\n\n/**\n * Converts this character to lower case using Unicode mapping rules of the invariant locale.\n */\n@Deprecated(\"Use lowercaseChar() instead.\", ReplaceWith(\"lowercaseChar()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic expect fun Char.toLowerCase(): Char\n\n/**\n * Converts this character to lower case using Unicode mapping rules of the invariant locale.\n *\n * This function performs one-to-one character mapping.\n * To support one-to-many character mapping use the [lowercase] function.\n * If this character has no mapping equivalent, the character itself is returned.\n *\n * @sample samples.text.Chars.lowercase\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun Char.lowercaseChar(): Char\n\n/**\n * Converts this character to lower case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many character mapping, thus the length of the returned string can be greater than one.\n * For example, `'\\u0130'.lowercase()` returns `\"\\u0069\\u0307\"`,\n * where `'\\u0130'` is the LATIN CAPITAL LETTER I WITH DOT ABOVE character (`İ`).\n * If this character has no lower case mapping, the result of `toString()` of this char is returned.\n *\n * @sample samples.text.Chars.lowercase\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun Char.lowercase(): String\n\n/**\n * Converts this character to upper case using Unicode mapping rules of the invariant locale.\n */\n@Deprecated(\"Use uppercaseChar() instead.\", ReplaceWith(\"uppercaseChar()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic expect fun Char.toUpperCase(): Char\n\n/**\n * Converts this character to upper case using Unicode mapping rules of the invariant locale.\n *\n * This function performs one-to-one character mapping.\n * To support one-to-many character mapping use the [uppercase] function.\n * If this character has no mapping equivalent, the character itself is returned.\n *\n * @sample samples.text.Chars.uppercase\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun Char.uppercaseChar(): Char\n\n/**\n * Converts this character to upper case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many character mapping, thus the length of the returned string can be greater than one.\n * For example, `'\\uFB00'.uppercase()` returns `\"\\u0046\\u0046\"`,\n * where `'\\uFB00'` is the LATIN SMALL LIGATURE FF character (`ﬀ`).\n * If this character has no upper case mapping, the result of `toString()` of this char is returned.\n *\n * @sample samples.text.Chars.uppercase\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun Char.uppercase(): String\n\n/**\n * Converts this character to title case using Unicode mapping rules of the invariant locale.\n *\n * This function performs one-to-one character mapping.\n * To support one-to-many character mapping use the [titlecase] function.\n * If this character has no mapping equivalent, the result of calling [uppercaseChar] is returned.\n *\n * @sample samples.text.Chars.titlecase\n */\n@SinceKotlin(\"1.5\")\npublic expect fun Char.titlecaseChar(): Char\n\n/**\n * Converts this character to title case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many character mapping, thus the length of the returned string can be greater than one.\n * For example, `'\\uFB00'.titlecase()` returns `\"\\u0046\\u0066\"`,\n * where `'\\uFB00'` is the LATIN SMALL LIGATURE FF character (`ﬀ`).\n * If this character has no title case mapping, the result of [uppercase] is returned instead.\n *\n * @sample samples.text.Chars.titlecase\n */\n@SinceKotlin(\"1.5\")\npublic fun Char.titlecase(): String = titlecaseImpl()\n\n/**\n * Concatenates this Char and a String.\n *\n * @sample samples.text.Chars.plus\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun Char.plus(other: String): String = this.toString() + other\n\n/**\n * Returns `true` if this character is equal to the [other] character, optionally ignoring character case.\n *\n * @param ignoreCase `true` to ignore character case when comparing characters. By default `false`.\n *\n * Two characters are considered the same ignoring case if at least one of the following is `true`:\n *   - The two characters are the same (as compared by the == operator)\n *   - Applying the method [uppercaseChar] to each character produces the same result\n *   - Applying the method [lowercaseChar] to each character produces the same result\n *\n * @sample samples.text.Chars.equals\n */\npublic fun Char.equals(other: Char, ignoreCase: Boolean = false): Boolean {\n    if (this == other) return true\n    if (!ignoreCase) return false\n\n    val thisUpper = this.uppercaseChar()\n    val otherUpper = other.uppercaseChar()\n\n    return thisUpper == otherUpper || thisUpper.lowercaseChar() == otherUpper.lowercaseChar()\n}\n\n/**\n * Returns `true` if this character is a Unicode surrogate code unit.\n */\npublic fun Char.isSurrogate(): Boolean = this in Char.MIN_SURROGATE..Char.MAX_SURROGATE\n\n/**\n * Returns the Unicode general category of this character.\n */\n@SinceKotlin(\"1.5\")\npublic expect val Char.category: CharCategory\n\n/**\n * Returns `true` if this character (Unicode code point) is defined in Unicode.\n *\n * A character is considered to be defined in Unicode if its [category] is not [CharCategory.UNASSIGNED].\n */\n@SinceKotlin(\"1.5\")\npublic expect fun Char.isDefined(): Boolean\n\n/**\n * Returns `true` if this character is a letter.\n *\n * A character is considered to be a letter if its [category] is [CharCategory.UPPERCASE_LETTER],\n * [CharCategory.LOWERCASE_LETTER], [CharCategory.TITLECASE_LETTER], [CharCategory.MODIFIER_LETTER], or [CharCategory.OTHER_LETTER].\n *\n * @sample samples.text.Chars.isLetter\n */\n@SinceKotlin(\"1.5\")\npublic expect fun Char.isLetter(): Boolean\n\n/**\n * Returns `true` if this character is a letter or digit.\n *\n * @see isLetter\n * @see isDigit\n *\n * @sample samples.text.Chars.isLetterOrDigit\n */\n@SinceKotlin(\"1.5\")\npublic expect fun Char.isLetterOrDigit(): Boolean\n\n/**\n * Returns `true` if this character is a digit.\n *\n * A character is considered to be a digit if its [category] is [CharCategory.DECIMAL_DIGIT_NUMBER].\n *\n * @sample samples.text.Chars.isDigit\n */\n@SinceKotlin(\"1.5\")\npublic expect fun Char.isDigit(): Boolean\n\n/**\n * Returns `true` if this character is an upper case letter.\n *\n * A character is considered to be an upper case letter if its [category] is [CharCategory.UPPERCASE_LETTER].\n *\n * @sample samples.text.Chars.isUpperCase\n */\n@SinceKotlin(\"1.5\")\npublic expect fun Char.isUpperCase(): Boolean\n\n/**\n * Returns `true` if this character is a lower case letter.\n *\n * A character is considered to be a lower case letter if its [category] is [CharCategory.LOWERCASE_LETTER].\n *\n * @sample samples.text.Chars.isLowerCase\n */\n@SinceKotlin(\"1.5\")\npublic expect fun Char.isLowerCase(): Boolean\n\n/**\n * Returns `true` if this character is a title case letter.\n *\n * A character is considered to be a title case letter if its [category] is [CharCategory.TITLECASE_LETTER].\n *\n * @sample samples.text.Chars.isTitleCase\n */\n@SinceKotlin(\"1.5\")\npublic expect fun Char.isTitleCase(): Boolean\n\n/**\n * Returns `true` if this character is an ISO control character.\n *\n * A character is considered to be an ISO control character if its [category] is [CharCategory.CONTROL],\n * meaning the Char is in the range `'\\u0000'..'\\u001F'` or in the range `'\\u007F'..'\\u009F'`.\n *\n * @sample samples.text.Chars.isISOControl\n */\n@SinceKotlin(\"1.5\")\npublic expect fun Char.isISOControl(): Boolean\n\n/**\n * Determines whether a character is whitespace according to the Unicode standard.\n * Returns `true` if the character is whitespace.\n *\n * @sample samples.text.Chars.isWhitespace\n */\npublic expect fun Char.isWhitespace(): Boolean\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StringsKt\")\n\npackage kotlin.text\n\n/**\n * Trims leading whitespace characters followed by [marginPrefix] from every line of a source string and removes\n * the first and the last lines if they are blank (notice difference blank vs empty).\n *\n * Doesn't affect a line if it doesn't contain [marginPrefix] except the first and the last blank lines.\n *\n * Doesn't preserve the original line endings.\n *\n * @param marginPrefix non-blank string, which is used as a margin delimiter. Default is `|` (pipe character).\n *\n * @sample samples.text.Strings.trimMargin\n * @see trimIndent\n * @see kotlin.text.isWhitespace\n */\npublic fun String.trimMargin(marginPrefix: String = \"|\"): String =\n    replaceIndentByMargin(\"\", marginPrefix)\n\n/**\n * Detects indent by [marginPrefix] as it does [trimMargin] and replace it with [newIndent].\n *\n * @param marginPrefix non-blank string, which is used as a margin delimiter. Default is `|` (pipe character).\n */\npublic fun String.replaceIndentByMargin(newIndent: String = \"\", marginPrefix: String = \"|\"): String {\n    require(marginPrefix.isNotBlank()) { \"marginPrefix must be non-blank string.\" }\n    val lines = lines()\n\n    return lines.reindent(length + newIndent.length * lines.size, getIndentFunction(newIndent), { line ->\n        val firstNonWhitespaceIndex = line.indexOfFirst { !it.isWhitespace() }\n\n        when {\n            firstNonWhitespaceIndex == -1 -> null\n            line.startsWith(marginPrefix, firstNonWhitespaceIndex) -> line.substring(firstNonWhitespaceIndex + marginPrefix.length)\n            else -> null\n        }\n    })\n}\n\n/**\n * Detects a common minimal indent of all the input lines, removes it from every line and also removes the first and the last\n * lines if they are blank (notice difference blank vs empty).\n *\n * Note that blank lines do not affect the detected indent level.\n *\n * In case if there are non-blank lines with no leading whitespace characters (no indent at all) then the\n * common indent is 0, and therefore this function doesn't change the indentation.\n *\n * Doesn't preserve the original line endings.\n *\n * @sample samples.text.Strings.trimIndent\n * @see trimMargin\n * @see kotlin.text.isBlank\n */\npublic fun String.trimIndent(): String = replaceIndent(\"\")\n\n/**\n * Detects a common minimal indent like it does [trimIndent] and replaces it with the specified [newIndent].\n */\npublic fun String.replaceIndent(newIndent: String = \"\"): String {\n    val lines = lines()\n\n    val minCommonIndent = lines\n        .filter(String::isNotBlank)\n        .map(String::indentWidth)\n        .minOrNull() ?: 0\n\n    return lines.reindent(length + newIndent.length * lines.size, getIndentFunction(newIndent), { line -> line.drop(minCommonIndent) })\n}\n\n/**\n * Prepends [indent] to every line of the original string.\n *\n * Doesn't preserve the original line endings.\n */\npublic fun String.prependIndent(indent: String = \"    \"): String =\n    lineSequence()\n        .map {\n            when {\n                it.isBlank() -> {\n                    when {\n                        it.length < indent.length -> indent\n                        else -> it\n                    }\n                }\n                else -> indent + it\n            }\n        }\n        .joinToString(\"\\n\")\n\nprivate fun String.indentWidth(): Int = indexOfFirst { !it.isWhitespace() }.let { if (it == -1) length else it }\n\nprivate fun getIndentFunction(indent: String) = when {\n    indent.isEmpty() -> { line: String -> line }\n    else -> { line: String -> indent + line }\n}\n\nprivate inline fun List<String>.reindent(\n    resultSizeEstimate: Int,\n    indentAddFunction: (String) -> String,\n    indentCutFunction: (String) -> String?\n): String {\n    val lastIndex = lastIndex\n    return mapIndexedNotNull { index, value ->\n        if ((index == 0 || index == lastIndex) && value.isBlank())\n            null\n        else\n            indentCutFunction(value)?.let(indentAddFunction) ?: value\n    }\n        .joinTo(StringBuilder(resultSizeEstimate), \"\\n\")\n        .toString()\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\n/**\n * Represents a collection of captured groups in a single match of a regular expression.\n *\n * This collection has size of `groupCount + 1` where `groupCount` is the count of groups in the regular expression.\n * Groups are indexed from 1 to `groupCount` and group with the index 0 corresponds to the entire match.\n *\n * An element of the collection at the particular index can be `null`,\n * if the corresponding group in the regular expression is optional and\n * there was no match captured by that group.\n */\npublic interface MatchGroupCollection : Collection<MatchGroup?> {\n\n    /** Returns a group with the specified [index].\n     *\n     * @return An instance of [MatchGroup] if the group with the specified [index] was matched or `null` otherwise.\n     *\n     * Groups are indexed from 1 to the count of groups in the regular expression. A group with the index 0\n     * corresponds to the entire match.\n     */\n    public operator fun get(index: Int): MatchGroup?\n}\n\n/**\n * Extends [MatchGroupCollection] by introducing a way to get matched groups by name, when regex supports it.\n */\n@SinceKotlin(\"1.1\")\npublic interface MatchNamedGroupCollection : MatchGroupCollection {\n    /**\n     * Returns a named group with the specified [name].\n     * @return An instance of [MatchGroup] if the group with the specified [name] was matched or `null` otherwise.\n     * @throws IllegalArgumentException if there is no group with the specified [name] defined in the regex pattern.\n     * @throws UnsupportedOperationException if getting named groups isn't supported on the current platform.\n     */\n    public operator fun get(name: String): MatchGroup?\n}\n\n/**\n * Represents the results from a single regular expression match.\n */\npublic interface MatchResult {\n    /** The range of indices in the original string where match was captured. */\n    public val range: IntRange\n    /** The substring from the input string captured by this match. */\n    public val value: String\n    /**\n     * A collection of groups matched by the regular expression.\n     *\n     * This collection has size of `groupCount + 1` where `groupCount` is the count of groups in the regular expression.\n     * Groups are indexed from 1 to `groupCount` and group with the index 0 corresponds to the entire match.\n     */\n    public val groups: MatchGroupCollection\n    /**\n     * A list of matched indexed group values.\n     *\n     * This list has size of `groupCount + 1` where `groupCount` is the count of groups in the regular expression.\n     * Groups are indexed from 1 to `groupCount` and group with the index 0 corresponds to the entire match.\n     *\n     * If the group in the regular expression is optional and there were no match captured by that group,\n     * corresponding item in [groupValues] is an empty string.\n     *\n     * @sample samples.text.Regexps.matchDestructuringToGroupValues\n     */\n    public val groupValues: List<String>\n\n    /**\n     * An instance of [MatchResult.Destructured] wrapper providing components for destructuring assignment of group values.\n     *\n     * component1 corresponds to the value of the first group, component2 — of the second, and so on.\n     *\n     * @sample samples.text.Regexps.matchDestructuringToGroupValues\n     */\n    public val destructured: Destructured get() = Destructured(this)\n\n    /** Returns a new [MatchResult] with the results for the next match, starting at the position\n     *  at which the last match ended (at the character after the last matched character).\n     */\n    public fun next(): MatchResult?\n\n    /**\n     * Provides components for destructuring assignment of group values.\n     *\n     * [component1] corresponds to the value of the first group, [component2] — of the second, and so on.\n     *\n     * If the group in the regular expression is optional and there were no match captured by that group,\n     * corresponding component value is an empty string.\n     *\n     * @sample samples.text.Regexps.matchDestructuringToGroupValues\n     */\n    public class Destructured internal constructor(public val match: MatchResult) {\n        @kotlin.internal.InlineOnly\n        public operator inline fun component1():  String = match.groupValues[1]\n        @kotlin.internal.InlineOnly\n        public operator inline fun component2():  String = match.groupValues[2]\n        @kotlin.internal.InlineOnly\n        public operator inline fun component3():  String = match.groupValues[3]\n        @kotlin.internal.InlineOnly\n        public operator inline fun component4():  String = match.groupValues[4]\n        @kotlin.internal.InlineOnly\n        public operator inline fun component5():  String = match.groupValues[5]\n        @kotlin.internal.InlineOnly\n        public operator inline fun component6():  String = match.groupValues[6]\n        @kotlin.internal.InlineOnly\n        public operator inline fun component7():  String = match.groupValues[7]\n        @kotlin.internal.InlineOnly\n        public operator inline fun component8():  String = match.groupValues[8]\n        @kotlin.internal.InlineOnly\n        public operator inline fun component9():  String = match.groupValues[9]\n        @kotlin.internal.InlineOnly\n        public operator inline fun component10(): String = match.groupValues[10]\n\n        /**\n         *  Returns destructured group values as a list of strings.\n         *  First value in the returned list corresponds to the value of the first group, and so on.\n         *\n         * @sample samples.text.Regexps.matchDestructuringToGroupValues\n         */\n        public fun toList(): List<String> = match.groupValues.subList(1, match.groupValues.size)\n    }\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmName(\"LazyKt\")\n@file:kotlin.jvm.JvmMultifileClass\n\npackage kotlin\n\nimport kotlin.reflect.KProperty\n\n/**\n * Represents a value with lazy initialization.\n *\n * To create an instance of [Lazy] use the [lazy] function.\n */\npublic interface Lazy<out T> {\n    /**\n     * Gets the lazily initialized value of the current Lazy instance.\n     * Once the value was initialized it must not change during the rest of lifetime of this Lazy instance.\n     */\n    public val value: T\n\n    /**\n     * Returns `true` if a value for this Lazy instance has been already initialized, and `false` otherwise.\n     * Once this function has returned `true` it stays `true` for the rest of lifetime of this Lazy instance.\n     */\n    public fun isInitialized(): Boolean\n}\n\n/**\n * Creates a new instance of the [Lazy] that is already initialized with the specified [value].\n */\npublic fun <T> lazyOf(value: T): Lazy<T> = InitializedLazyImpl(value)\n\n/**\n * An extension to delegate a read-only property of type [T] to an instance of [Lazy].\n *\n * This extension allows to use instances of Lazy for property delegation:\n * `val property: String by lazy { initializer }`\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> Lazy<T>.getValue(thisRef: Any?, property: KProperty<*>): T = value\n\n/**\n * Specifies how a [Lazy] instance synchronizes initialization among multiple threads.\n */\npublic enum class LazyThreadSafetyMode {\n\n    /**\n     * Locks are used to ensure that only a single thread can initialize the [Lazy] instance.\n     */\n    SYNCHRONIZED,\n\n    /**\n     * Initializer function can be called several times on concurrent access to uninitialized [Lazy] instance value,\n     * but only the first returned value will be used as the value of [Lazy] instance.\n     */\n    PUBLICATION,\n\n    /**\n     * No locks are used to synchronize an access to the [Lazy] instance value; if the instance is accessed from multiple threads, its behavior is undefined.\n     *\n     * This mode should not be used unless the [Lazy] instance is guaranteed never to be initialized from more than one thread.\n     */\n    NONE,\n}\n\n\ninternal object UNINITIALIZED_VALUE\n\n// internal to be called from lazy in JS\ninternal class UnsafeLazyImpl<out T>(initializer: () -> T) : Lazy<T>, Serializable {\n    private var initializer: (() -> T)? = initializer\n    private var _value: Any? = UNINITIALIZED_VALUE\n\n    override val value: T\n        get() {\n            if (_value === UNINITIALIZED_VALUE) {\n                _value = initializer!!()\n                initializer = null\n            }\n            @Suppress(\"UNCHECKED_CAST\")\n            return _value as T\n        }\n\n    override fun isInitialized(): Boolean = _value !== UNINITIALIZED_VALUE\n\n    override fun toString(): String = if (isInitialized()) value.toString() else \"Lazy value not initialized yet.\"\n\n    private fun writeReplace(): Any = InitializedLazyImpl(value)\n}\n\ninternal class InitializedLazyImpl<out T>(override val value: T) : Lazy<T>, Serializable {\n\n    override fun isInitialized(): Boolean = true\n\n    override fun toString(): String = value.toString()\n\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmName(\"TuplesKt\")\n\npackage kotlin\n\n\n/**\n * Represents a generic pair of two values.\n *\n * There is no meaning attached to values in this class, it can be used for any purpose.\n * Pair exhibits value semantics, i.e. two pairs are equal if both components are equal.\n *\n * An example of decomposing it into values:\n * @sample samples.misc.Tuples.pairDestructuring\n *\n * @param A type of the first value.\n * @param B type of the second value.\n * @property first First value.\n * @property second Second value.\n * @constructor Creates a new instance of Pair.\n */\npublic data class Pair<out A, out B>(\n    public val first: A,\n    public val second: B\n) : Serializable {\n\n    /**\n     * Returns string representation of the [Pair] including its [first] and [second] values.\n     */\n    public override fun toString(): String = \"($first, $second)\"\n}\n\n/**\n * Creates a tuple of type [Pair] from this and [that].\n *\n * This can be useful for creating [Map] literals with less noise, for example:\n * @sample samples.collections.Maps.Instantiation.mapFromPairs\n */\npublic infix fun <A, B> A.to(that: B): Pair<A, B> = Pair(this, that)\n\n/**\n * Converts this pair into a list.\n * @sample samples.misc.Tuples.pairToList\n */\npublic fun <T> Pair<T, T>.toList(): List<T> = listOf(first, second)\n\n/**\n * Represents a triad of values\n *\n * There is no meaning attached to values in this class, it can be used for any purpose.\n * Triple exhibits value semantics, i.e. two triples are equal if all three components are equal.\n * An example of decomposing it into values:\n * @sample samples.misc.Tuples.tripleDestructuring\n *\n * @param A type of the first value.\n * @param B type of the second value.\n * @param C type of the third value.\n * @property first First value.\n * @property second Second value.\n * @property third Third value.\n */\npublic data class Triple<out A, out B, out C>(\n    public val first: A,\n    public val second: B,\n    public val third: C\n) : Serializable {\n\n    /**\n     * Returns string representation of the [Triple] including its [first], [second] and [third] values.\n     */\n    public override fun toString(): String = \"($first, $second, $third)\"\n}\n\n/**\n * Converts this triple into a list.\n * @sample samples.misc.Tuples.tripleToList\n */\npublic fun <T> Triple<T, T, T>.toList(): List<T> = listOf(first, second, third)\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin\n\nimport kotlin.experimental.*\nimport kotlin.jvm.*\n\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@JvmInline\npublic value class ULong @PublishedApi internal constructor(@PublishedApi internal val data: Long) : Comparable<ULong> {\n\n    companion object {\n        /**\n         * A constant holding the minimum value an instance of ULong can have.\n         */\n        public const val MIN_VALUE: ULong = ULong(0)\n\n        /**\n         * A constant holding the maximum value an instance of ULong can have.\n         */\n        public const val MAX_VALUE: ULong = ULong(-1)\n\n        /**\n         * The number of bytes used to represent an instance of ULong in a binary form.\n         */\n        public const val SIZE_BYTES: Int = 8\n\n        /**\n         * The number of bits used to represent an instance of ULong in a binary form.\n         */\n        public const val SIZE_BITS: Int = 64\n    }\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UByte): Int = this.compareTo(other.toULong())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UShort): Int = this.compareTo(other.toULong())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UInt): Int = this.compareTo(other.toULong())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    @Suppress(\"OVERRIDE_BY_INLINE\")\n    public override inline operator fun compareTo(other: ULong): Int = ulongCompare(this.data, other.data)\n\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UByte): ULong = this.plus(other.toULong())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UShort): ULong = this.plus(other.toULong())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UInt): ULong = this.plus(other.toULong())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: ULong): ULong = ULong(this.data.plus(other.data))\n\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UByte): ULong = this.minus(other.toULong())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UShort): ULong = this.minus(other.toULong())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UInt): ULong = this.minus(other.toULong())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: ULong): ULong = ULong(this.data.minus(other.data))\n\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UByte): ULong = this.times(other.toULong())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UShort): ULong = this.times(other.toULong())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UInt): ULong = this.times(other.toULong())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: ULong): ULong = ULong(this.data.times(other.data))\n\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UByte): ULong = this.div(other.toULong())\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UShort): ULong = this.div(other.toULong())\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UInt): ULong = this.div(other.toULong())\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: ULong): ULong = ulongDivide(this, other)\n\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UByte): ULong = this.rem(other.toULong())\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UShort): ULong = this.rem(other.toULong())\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UInt): ULong = this.rem(other.toULong())\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: ULong): ULong = ulongRemainder(this, other)\n\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: UByte): ULong = this.floorDiv(other.toULong())\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: UShort): ULong = this.floorDiv(other.toULong())\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: UInt): ULong = this.floorDiv(other.toULong())\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: ULong): ULong = div(other)\n\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: UByte): UByte = this.mod(other.toULong()).toUByte()\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: UShort): UShort = this.mod(other.toULong()).toUShort()\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: UInt): UInt = this.mod(other.toULong()).toUInt()\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: ULong): ULong = rem(other)\n\n    /** Increments this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun inc(): ULong = ULong(data.inc())\n    /** Decrements this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun dec(): ULong = ULong(data.dec())\n\n    /** Creates a range from this value to the specified [other] value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rangeTo(other: ULong): ULongRange = ULongRange(this, other)\n\n    /**\n     * Shifts this value left by the [bitCount] number of bits.\n     *\n     * Note that only the six lowest-order bits of the [bitCount] are used as the shift distance.\n     * The shift distance actually used is therefore always in the range `0..63`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline infix fun shl(bitCount: Int): ULong = ULong(data shl bitCount)\n\n    /**\n     * Shifts this value right by the [bitCount] number of bits, filling the leftmost bits with zeros.\n     *\n     * Note that only the six lowest-order bits of the [bitCount] are used as the shift distance.\n     * The shift distance actually used is therefore always in the range `0..63`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline infix fun shr(bitCount: Int): ULong = ULong(data ushr bitCount)\n\n    /** Performs a bitwise AND operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun and(other: ULong): ULong = ULong(this.data and other.data)\n    /** Performs a bitwise OR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun or(other: ULong): ULong = ULong(this.data or other.data)\n    /** Performs a bitwise XOR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun xor(other: ULong): ULong = ULong(this.data xor other.data)\n    /** Inverts the bits in this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun inv(): ULong = ULong(data.inv())\n\n    /**\n     * Converts this [ULong] value to [Byte].\n     *\n     * If this value is less than or equals to [Byte.MAX_VALUE], the resulting `Byte` value represents\n     * the same numerical value as this `ULong`.\n     *\n     * The resulting `Byte` value is represented by the least significant 8 bits of this `ULong` value.\n     * Note that the resulting `Byte` value may be negative.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toByte(): Byte = data.toByte()\n    /**\n     * Converts this [ULong] value to [Short].\n     *\n     * If this value is less than or equals to [Short.MAX_VALUE], the resulting `Short` value represents\n     * the same numerical value as this `ULong`.\n     *\n     * The resulting `Short` value is represented by the least significant 16 bits of this `ULong` value.\n     * Note that the resulting `Short` value may be negative.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toShort(): Short = data.toShort()\n    /**\n     * Converts this [ULong] value to [Int].\n     *\n     * If this value is less than or equals to [Int.MAX_VALUE], the resulting `Int` value represents\n     * the same numerical value as this `ULong`.\n     *\n     * The resulting `Int` value is represented by the least significant 32 bits of this `ULong` value.\n     * Note that the resulting `Int` value may be negative.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toInt(): Int = data.toInt()\n    /**\n     * Converts this [ULong] value to [Long].\n     *\n     * If this value is less than or equals to [Long.MAX_VALUE], the resulting `Long` value represents\n     * the same numerical value as this `ULong`. Otherwise the result is negative.\n     *\n     * The resulting `Long` value has the same binary representation as this `ULong` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toLong(): Long = data\n\n    /**\n     * Converts this [ULong] value to [UByte].\n     *\n     * If this value is less than or equals to [UByte.MAX_VALUE], the resulting `UByte` value represents\n     * the same numerical value as this `ULong`.\n     *\n     * The resulting `UByte` value is represented by the least significant 8 bits of this `ULong` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUByte(): UByte = data.toUByte()\n    /**\n     * Converts this [ULong] value to [UShort].\n     *\n     * If this value is less than or equals to [UShort.MAX_VALUE], the resulting `UShort` value represents\n     * the same numerical value as this `ULong`.\n     *\n     * The resulting `UShort` value is represented by the least significant 16 bits of this `ULong` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUShort(): UShort = data.toUShort()\n    /**\n     * Converts this [ULong] value to [UInt].\n     *\n     * If this value is less than or equals to [UInt.MAX_VALUE], the resulting `UInt` value represents\n     * the same numerical value as this `ULong`.\n     *\n     * The resulting `UInt` value is represented by the least significant 32 bits of this `ULong` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUInt(): UInt = data.toUInt()\n    /** Returns this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun toULong(): ULong = this\n\n    /**\n     * Converts this [ULong] value to [Float].\n     *\n     * The resulting value is the closest `Float` to this `ULong` value.\n     * In case when this `ULong` value is exactly between two `Float`s,\n     * the one with zero at least significant bit of mantissa is selected.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toFloat(): Float = this.toDouble().toFloat()\n    /**\n     * Converts this [ULong] value to [Double].\n     *\n     * The resulting value is the closest `Double` to this `ULong` value.\n     * In case when this `ULong` value is exactly between two `Double`s,\n     * the one with zero at least significant bit of mantissa is selected.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toDouble(): Double = ulongToDouble(data)\n\n    public override fun toString(): String = ulongToString(data)\n\n}\n\n/**\n * Converts this [Byte] value to [ULong].\n *\n * If this value is positive, the resulting `ULong` value represents the same numerical value as this `Byte`.\n *\n * The least significant 8 bits of the resulting `ULong` value are the same as the bits of this `Byte` value,\n * whereas the most significant 56 bits are filled with the sign bit of this value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Byte.toULong(): ULong = ULong(this.toLong())\n/**\n * Converts this [Short] value to [ULong].\n *\n * If this value is positive, the resulting `ULong` value represents the same numerical value as this `Short`.\n *\n * The least significant 16 bits of the resulting `ULong` value are the same as the bits of this `Short` value,\n * whereas the most significant 48 bits are filled with the sign bit of this value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Short.toULong(): ULong = ULong(this.toLong())\n/**\n * Converts this [Int] value to [ULong].\n *\n * If this value is positive, the resulting `ULong` value represents the same numerical value as this `Int`.\n *\n * The least significant 32 bits of the resulting `ULong` value are the same as the bits of this `Int` value,\n * whereas the most significant 32 bits are filled with the sign bit of this value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Int.toULong(): ULong = ULong(this.toLong())\n/**\n * Converts this [Long] value to [ULong].\n *\n * If this value is positive, the resulting `ULong` value represents the same numerical value as this `Long`.\n *\n * The resulting `ULong` value has the same binary representation as this `Long` value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Long.toULong(): ULong = ULong(this)\n\n/**\n * Converts this [Float] value to [ULong].\n *\n * The fractional part, if any, is rounded down towards zero.\n * Returns zero if this `Float` value is negative or `NaN`, [ULong.MAX_VALUE] if it's bigger than `ULong.MAX_VALUE`.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Float.toULong(): ULong = doubleToULong(this.toDouble())\n/**\n * Converts this [Double] value to [ULong].\n *\n * The fractional part, if any, is rounded down towards zero.\n * Returns zero if this `Double` value is negative or `NaN`, [ULong.MAX_VALUE] if it's bigger than `ULong.MAX_VALUE`.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Double.toULong(): ULong = doubleToULong(this)\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.experimental\n\n/** Performs a bitwise AND operation between the two values. */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline infix fun Byte.and(other: Byte): Byte = (this.toInt() and other.toInt()).toByte()\n\n/** Performs a bitwise OR operation between the two values. */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline infix fun Byte.or(other: Byte): Byte = (this.toInt() or other.toInt()).toByte()\n\n/** Performs a bitwise XOR operation between the two values. */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline infix fun Byte.xor(other: Byte): Byte = (this.toInt() xor other.toInt()).toByte()\n\n/** Inverts the bits in this value. */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun Byte.inv(): Byte = (this.toInt().inv()).toByte()\n\n\n/** Performs a bitwise AND operation between the two values. */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline infix fun Short.and(other: Short): Short = (this.toInt() and other.toInt()).toShort()\n\n/** Performs a bitwise OR operation between the two values. */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline infix fun Short.or(other: Short): Short = (this.toInt() or other.toInt()).toShort()\n\n/** Performs a bitwise XOR operation between the two values. */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline infix fun Short.xor(other: Short): Short = (this.toInt() xor other.toInt()).toShort()\n\n/** Inverts the bits in this value. */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun Short.inv(): Short = (this.toInt().inv()).toShort()\n\n\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin.ranges\n\n\n\nimport kotlin.internal.*\n\n/**\n * A range of values of type `UInt`.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\npublic class UIntRange(start: UInt, endInclusive: UInt) : UIntProgression(start, endInclusive, 1), ClosedRange<UInt> {\n    override val start: UInt get() = first\n    override val endInclusive: UInt get() = last\n\n    override fun contains(value: UInt): Boolean = first <= value && value <= last\n\n    override fun isEmpty(): Boolean = first > last\n\n    override fun equals(other: Any?): Boolean =\n        other is UIntRange && (isEmpty() && other.isEmpty() ||\n                first == other.first && last == other.last)\n\n    override fun hashCode(): Int =\n        if (isEmpty()) -1 else (31 * first.toInt() + last.toInt())\n\n    override fun toString(): String = \"$first..$last\"\n\n    companion object {\n        /** An empty range of values of type UInt. */\n        public val EMPTY: UIntRange = UIntRange(UInt.MAX_VALUE, UInt.MIN_VALUE)\n    }\n}\n\n/**\n * A progression of values of type `UInt`.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\npublic open class UIntProgression\ninternal constructor(\n    start: UInt,\n    endInclusive: UInt,\n    step: Int\n) : Iterable<UInt> {\n    init {\n        if (step == 0.toInt()) throw kotlin.IllegalArgumentException(\"Step must be non-zero.\")\n        if (step == Int.MIN_VALUE) throw kotlin.IllegalArgumentException(\"Step must be greater than Int.MIN_VALUE to avoid overflow on negation.\")\n    }\n\n    /**\n     * The first element in the progression.\n     */\n    public val first: UInt = start\n\n    /**\n     * The last element in the progression.\n     */\n    public val last: UInt = getProgressionLastElement(start, endInclusive, step)\n\n    /**\n     * The step of the progression.\n     */\n    public val step: Int = step\n\n    final override fun iterator(): Iterator<UInt> = UIntProgressionIterator(first, last, step)\n\n    /** Checks if the progression is empty. */\n    public open fun isEmpty(): Boolean = if (step > 0) first > last else first < last\n\n    override fun equals(other: Any?): Boolean =\n        other is UIntProgression && (isEmpty() && other.isEmpty() ||\n                first == other.first && last == other.last && step == other.step)\n\n    override fun hashCode(): Int =\n        if (isEmpty()) -1 else (31 * (31 * first.toInt() + last.toInt()) + step.toInt())\n\n    override fun toString(): String = if (step > 0) \"$first..$last step $step\" else \"$first downTo $last step ${-step}\"\n\n    companion object {\n        /**\n         * Creates UIntProgression within the specified bounds of a closed range.\n\n         * The progression starts with the [rangeStart] value and goes toward the [rangeEnd] value not excluding it, with the specified [step].\n         * In order to go backwards the [step] must be negative.\n         *\n         * [step] must be greater than `Int.MIN_VALUE` and not equal to zero.\n         */\n        public fun fromClosedRange(rangeStart: UInt, rangeEnd: UInt, step: Int): UIntProgression = UIntProgression(rangeStart, rangeEnd, step)\n    }\n}\n\n\n/**\n * An iterator over a progression of values of type `UInt`.\n * @property step the number by which the value is incremented on each step.\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"DEPRECATION_ERROR\")\nprivate class UIntProgressionIterator(first: UInt, last: UInt, step: Int) : UIntIterator() {\n    private val finalElement = last\n    private var hasNext: Boolean = if (step > 0) first <= last else first >= last\n    private val step = step.toUInt() // use 2-complement math for negative steps\n    private var next = if (hasNext) first else finalElement\n\n    override fun hasNext(): Boolean = hasNext\n\n    override fun nextUInt(): UInt {\n        val value = next\n        if (value == finalElement) {\n            if (!hasNext) throw kotlin.NoSuchElementException()\n            hasNext = false\n        } else {\n            next += step\n        }\n        return value\n    }\n}\n\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin.collections\n\n/** An iterator over a sequence of values of type `UByte`. */\n@Deprecated(\"This class is not going to be stabilized and is to be removed soon.\", level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\npublic abstract class UByteIterator : Iterator<UByte> {\n    final override fun next() = nextUByte()\n\n    /** Returns the next value in the sequence without boxing. */\n    public abstract fun nextUByte(): UByte\n}\n\n/** An iterator over a sequence of values of type `UShort`. */\n@Deprecated(\"This class is not going to be stabilized and is to be removed soon.\", level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\npublic abstract class UShortIterator : Iterator<UShort> {\n    final override fun next() = nextUShort()\n\n    /** Returns the next value in the sequence without boxing. */\n    public abstract fun nextUShort(): UShort\n}\n\n/** An iterator over a sequence of values of type `UInt`. */\n@Deprecated(\"This class is not going to be stabilized and is to be removed soon.\", level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\npublic abstract class UIntIterator : Iterator<UInt> {\n    final override fun next() = nextUInt()\n\n    /** Returns the next value in the sequence without boxing. */\n    public abstract fun nextUInt(): UInt\n}\n\n/** An iterator over a sequence of values of type `ULong`. */\n@Deprecated(\"This class is not going to be stabilized and is to be removed soon.\", level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\npublic abstract class ULongIterator : Iterator<ULong> {\n    final override fun next() = nextULong()\n\n    /** Returns the next value in the sequence without boxing. */\n    public abstract fun nextULong(): ULong\n}\n\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin.ranges\n\n\n\nimport kotlin.internal.*\n\n/**\n * A range of values of type `ULong`.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\npublic class ULongRange(start: ULong, endInclusive: ULong) : ULongProgression(start, endInclusive, 1), ClosedRange<ULong> {\n    override val start: ULong get() = first\n    override val endInclusive: ULong get() = last\n\n    override fun contains(value: ULong): Boolean = first <= value && value <= last\n\n    override fun isEmpty(): Boolean = first > last\n\n    override fun equals(other: Any?): Boolean =\n        other is ULongRange && (isEmpty() && other.isEmpty() ||\n                first == other.first && last == other.last)\n\n    override fun hashCode(): Int =\n        if (isEmpty()) -1 else (31 * (first xor (first shr 32)).toInt() + (last xor (last shr 32)).toInt())\n\n    override fun toString(): String = \"$first..$last\"\n\n    companion object {\n        /** An empty range of values of type ULong. */\n        public val EMPTY: ULongRange = ULongRange(ULong.MAX_VALUE, ULong.MIN_VALUE)\n    }\n}\n\n/**\n * A progression of values of type `ULong`.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\npublic open class ULongProgression\ninternal constructor(\n    start: ULong,\n    endInclusive: ULong,\n    step: Long\n) : Iterable<ULong> {\n    init {\n        if (step == 0.toLong()) throw kotlin.IllegalArgumentException(\"Step must be non-zero.\")\n        if (step == Long.MIN_VALUE) throw kotlin.IllegalArgumentException(\"Step must be greater than Long.MIN_VALUE to avoid overflow on negation.\")\n    }\n\n    /**\n     * The first element in the progression.\n     */\n    public val first: ULong = start\n\n    /**\n     * The last element in the progression.\n     */\n    public val last: ULong = getProgressionLastElement(start, endInclusive, step)\n\n    /**\n     * The step of the progression.\n     */\n    public val step: Long = step\n\n    final override fun iterator(): Iterator<ULong> = ULongProgressionIterator(first, last, step)\n\n    /** Checks if the progression is empty. */\n    public open fun isEmpty(): Boolean = if (step > 0) first > last else first < last\n\n    override fun equals(other: Any?): Boolean =\n        other is ULongProgression && (isEmpty() && other.isEmpty() ||\n                first == other.first && last == other.last && step == other.step)\n\n    override fun hashCode(): Int =\n        if (isEmpty()) -1 else (31 * (31 * (first xor (first shr 32)).toInt() + (last xor (last shr 32)).toInt()) + (step xor (step ushr 32)).toInt())\n\n    override fun toString(): String = if (step > 0) \"$first..$last step $step\" else \"$first downTo $last step ${-step}\"\n\n    companion object {\n        /**\n         * Creates ULongProgression within the specified bounds of a closed range.\n\n         * The progression starts with the [rangeStart] value and goes toward the [rangeEnd] value not excluding it, with the specified [step].\n         * In order to go backwards the [step] must be negative.\n         *\n         * [step] must be greater than `Long.MIN_VALUE` and not equal to zero.\n         */\n        public fun fromClosedRange(rangeStart: ULong, rangeEnd: ULong, step: Long): ULongProgression = ULongProgression(rangeStart, rangeEnd, step)\n    }\n}\n\n\n/**\n * An iterator over a progression of values of type `ULong`.\n * @property step the number by which the value is incremented on each step.\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"DEPRECATION_ERROR\")\nprivate class ULongProgressionIterator(first: ULong, last: ULong, step: Long) : ULongIterator() {\n    private val finalElement = last\n    private var hasNext: Boolean = if (step > 0) first <= last else first >= last\n    private val step = step.toULong() // use 2-complement math for negative steps\n    private var next = if (hasNext) first else finalElement\n\n    override fun hasNext(): Boolean = hasNext\n\n    override fun nextULong(): ULong {\n        val value = next\n        if (value == finalElement) {\n            if (!hasNext) throw kotlin.NoSuchElementException()\n            hasNext = false\n        } else {\n            next += step\n        }\n        return value\n    }\n}\n\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.internal\n\n// (a - b) mod c\nprivate fun differenceModulo(a: UInt, b: UInt, c: UInt): UInt {\n    val ac = a % c\n    val bc = b % c\n    return if (ac >= bc) ac - bc else ac - bc + c\n}\n\nprivate fun differenceModulo(a: ULong, b: ULong, c: ULong): ULong {\n    val ac = a % c\n    val bc = b % c\n    return if (ac >= bc) ac - bc else ac - bc + c\n}\n\n/**\n * Calculates the final element of a bounded arithmetic progression, i.e. the last element of the progression which is in the range\n * from [start] to [end] in case of a positive [step], or from [end] to [start] in case of a negative\n * [step].\n *\n * No validation on passed parameters is performed. The given parameters should satisfy the condition:\n *\n * - either `step > 0` and `start <= end`,\n * - or `step < 0` and `start >= end`.\n *\n * @param start first element of the progression\n * @param end ending bound for the progression\n * @param step increment, or difference of successive elements in the progression\n * @return the final element of the progression\n * @suppress\n */\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun getProgressionLastElement(start: UInt, end: UInt, step: Int): UInt = when {\n    step > 0 -> if (start >= end) end else end - differenceModulo(end, start, step.toUInt())\n    step < 0 -> if (start <= end) end else end + differenceModulo(start, end, (-step).toUInt())\n    else -> throw kotlin.IllegalArgumentException(\"Step is zero.\")\n}\n\n/**\n * Calculates the final element of a bounded arithmetic progression, i.e. the last element of the progression which is in the range\n * from [start] to [end] in case of a positive [step], or from [end] to [start] in case of a negative\n * [step].\n *\n * No validation on passed parameters is performed. The given parameters should satisfy the condition:\n *\n * - either `step > 0` and `start <= end`,\n * - or `step < 0` and `start >= end`.\n *\n * @param start first element of the progression\n * @param end ending bound for the progression\n * @param step increment, or difference of successive elements in the progression\n * @return the final element of the progression\n * @suppress\n */\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun getProgressionLastElement(start: ULong, end: ULong, step: Long): ULong = when {\n    step > 0 -> if (start >= end) end else end - differenceModulo(end, start, step.toULong())\n    step < 0 -> if (start <= end) end else end + differenceModulo(start, end, (-step).toULong())\n    else -> throw kotlin.IllegalArgumentException(\"Step is zero.\")\n}\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmName(\"UStringsKt\")  // string representation of unsigned numbers\n\npackage kotlin.text\n\n/**\n * Returns a string representation of this [Byte] value in the specified [radix].\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for number to string conversion.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n//@kotlin.internal.InlineOnly\npublic /*inline*/ fun UByte.toString(radix: Int): String = this.toInt().toString(radix)\n\n/**\n * Returns a string representation of this [Short] value in the specified [radix].\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for number to string conversion.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n//@kotlin.internal.InlineOnly\npublic /*inline*/ fun UShort.toString(radix: Int): String = this.toInt().toString(radix)\n\n\n/**\n * Returns a string representation of this [Int] value in the specified [radix].\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for number to string conversion.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n//@kotlin.internal.InlineOnly\npublic /*inline*/ fun UInt.toString(radix: Int): String = this.toLong().toString(radix)\n\n/**\n * Returns a string representation of this [Long] value in the specified [radix].\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for number to string conversion.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\npublic fun ULong.toString(radix: Int): String = ulongToString(this.toLong(), checkRadix(radix))\n\n\n/**\n * Parses the string as a signed [UByte] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\npublic fun String.toUByte(): UByte = toUByteOrNull() ?: numberFormatError(this)\n\n/**\n * Parses the string as a signed [UByte] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\npublic fun String.toUByte(radix: Int): UByte = toUByteOrNull(radix) ?: numberFormatError(this)\n\n\n/**\n * Parses the string as a [UShort] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\npublic fun String.toUShort(): UShort = toUShortOrNull() ?: numberFormatError(this)\n\n/**\n * Parses the string as a [UShort] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\npublic fun String.toUShort(radix: Int): UShort = toUShortOrNull(radix) ?: numberFormatError(this)\n\n/**\n * Parses the string as an [UInt] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\npublic fun String.toUInt(): UInt = toUIntOrNull() ?: numberFormatError(this)\n\n/**\n * Parses the string as an [UInt] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\npublic fun String.toUInt(radix: Int): UInt = toUIntOrNull(radix) ?: numberFormatError(this)\n\n/**\n * Parses the string as a [ULong] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\npublic fun String.toULong(): ULong = toULongOrNull() ?: numberFormatError(this)\n\n/**\n * Parses the string as a [ULong] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\npublic fun String.toULong(radix: Int): ULong = toULongOrNull(radix) ?: numberFormatError(this)\n\n\n\n\n\n/**\n * Parses the string as an [UByte] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\npublic fun String.toUByteOrNull(): UByte? = toUByteOrNull(radix = 10)\n\n/**\n * Parses the string as an [UByte] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\npublic fun String.toUByteOrNull(radix: Int): UByte? {\n    val int = this.toUIntOrNull(radix) ?: return null\n    if (int > UByte.MAX_VALUE) return null\n    return int.toUByte()\n}\n\n/**\n * Parses the string as an [UShort] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\npublic fun String.toUShortOrNull(): UShort? = toUShortOrNull(radix = 10)\n\n/**\n * Parses the string as an [UShort] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\npublic fun String.toUShortOrNull(radix: Int): UShort? {\n    val int = this.toUIntOrNull(radix) ?: return null\n    if (int > UShort.MAX_VALUE) return null\n    return int.toUShort()\n}\n\n/**\n * Parses the string as an [UInt] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\npublic fun String.toUIntOrNull(): UInt? = toUIntOrNull(radix = 10)\n\n/**\n * Parses the string as an [UInt] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\npublic fun String.toUIntOrNull(radix: Int): UInt? {\n    checkRadix(radix)\n\n    val length = this.length\n    if (length == 0) return null\n\n    val limit: UInt = UInt.MAX_VALUE\n    val start: Int\n\n    val firstChar = this[0]\n    if (firstChar < '0') {\n        if (length == 1 || firstChar != '+') return null\n        start = 1\n    } else {\n        start = 0\n    }\n\n    val limitForMaxRadix = 119304647u  //  limit / 36\n\n    var limitBeforeMul = limitForMaxRadix\n    val uradix = radix.toUInt()\n    var result = 0u\n    for (i in start until length) {\n        val digit = digitOf(this[i], radix)\n\n        if (digit < 0) return null\n        if (result > limitBeforeMul) {\n            if (limitBeforeMul == limitForMaxRadix) {\n                limitBeforeMul = limit / uradix\n\n                if (result > limitBeforeMul) {\n                    return null\n                }\n            } else {\n                return null\n            }\n        }\n\n        result *= uradix\n\n        val beforeAdding = result\n        result += digit.toUInt()\n        if (result < beforeAdding) return null // overflow has happened\n    }\n\n    return result\n}\n\n/**\n * Parses the string as an [ULong] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\npublic fun String.toULongOrNull(): ULong? = toULongOrNull(radix = 10)\n\n/**\n * Parses the string as an [ULong] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\npublic fun String.toULongOrNull(radix: Int): ULong? {\n    checkRadix(radix)\n\n    val length = this.length\n    if (length == 0) return null\n\n    val limit: ULong = ULong.MAX_VALUE\n    val start: Int\n\n    val firstChar = this[0]\n    if (firstChar < '0') {\n        if (length == 1 || firstChar != '+') return null\n        start = 1\n    } else {\n        start = 0\n    }\n\n\n    val limitForMaxRadix = 512409557603043100uL  //  limit / 36\n\n    var limitBeforeMul = limitForMaxRadix\n    val uradix = radix.toULong()\n    var result = 0uL\n    for (i in start until length) {\n        val digit = digitOf(this[i], radix)\n\n        if (digit < 0) return null\n        if (result > limitBeforeMul) {\n            if (limitBeforeMul == limitForMaxRadix) {\n                limitBeforeMul = limit / uradix\n\n                if (result > limitBeforeMul) {\n                    return null\n                }\n            } else {\n                return null\n            }\n        }\n\n        result *= uradix\n\n        val beforeAdding = result\n        result += digit.toUInt()\n        if (result < beforeAdding) return null // overflow has happened\n    }\n\n    return result\n}\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"SetsKt\")\n\npackage kotlin.collections\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.random.*\nimport kotlin.ranges.contains\nimport kotlin.ranges.reversed\n\n/**\n * Returns a set containing all elements of the original set except the given [element].\n * \n * The returned set preserves the element iteration order of the original set.\n */\npublic operator fun <T> Set<T>.minus(element: T): Set<T> {\n    val result = LinkedHashSet<T>(mapCapacity(size))\n    var removed = false\n    return this.filterTo(result) { if (!removed && it == element) { removed = true; false } else true }\n}\n\n/**\n * Returns a set containing all elements of the original set except the elements contained in the given [elements] array.\n * \n * The returned set preserves the element iteration order of the original set.\n * \n * The [elements] array may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Set<T>.minus(elements: Array<out T>): Set<T> {\n    val result = LinkedHashSet<T>(this)\n    result.removeAll(elements)\n    return result\n}\n\n/**\n * Returns a set containing all elements of the original set except the elements contained in the given [elements] collection.\n * \n * The returned set preserves the element iteration order of the original set.\n * \n * The [elements] collection may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Set<T>.minus(elements: Iterable<T>): Set<T> {\n    val other = elements.convertToSetForSetOperationWith(this)\n    if (other.isEmpty())\n        return this.toSet()\n    if (other is Set)\n        return this.filterNotTo(LinkedHashSet<T>()) { it in other }\n    val result = LinkedHashSet<T>(this)\n    result.removeAll(other)\n    return result\n}\n\n/**\n * Returns a set containing all elements of the original set except the elements contained in the given [elements] sequence.\n * \n * The returned set preserves the element iteration order of the original set.\n * \n * The [elements] sequence may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Set<T>.minus(elements: Sequence<T>): Set<T> {\n    val result = LinkedHashSet<T>(this)\n    result.removeAll(elements)\n    return result\n}\n\n/**\n * Returns a set containing all elements of the original set except the given [element].\n * \n * The returned set preserves the element iteration order of the original set.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Set<T>.minusElement(element: T): Set<T> {\n    return minus(element)\n}\n\n/**\n * Returns a set containing all elements of the original set and then the given [element] if it isn't already in this set.\n * \n * The returned set preserves the element iteration order of the original set.\n */\npublic operator fun <T> Set<T>.plus(element: T): Set<T> {\n    val result = LinkedHashSet<T>(mapCapacity(size + 1))\n    result.addAll(this)\n    result.add(element)\n    return result\n}\n\n/**\n * Returns a set containing all elements of the original set and the given [elements] array,\n * which aren't already in this set.\n * \n * The returned set preserves the element iteration order of the original set.\n */\npublic operator fun <T> Set<T>.plus(elements: Array<out T>): Set<T> {\n    val result = LinkedHashSet<T>(mapCapacity(this.size + elements.size))\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a set containing all elements of the original set and the given [elements] collection,\n * which aren't already in this set.\n * The returned set preserves the element iteration order of the original set.\n */\npublic operator fun <T> Set<T>.plus(elements: Iterable<T>): Set<T> {\n    val result = LinkedHashSet<T>(mapCapacity(elements.collectionSizeOrNull()?.let { this.size + it } ?: this.size * 2))\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a set containing all elements of the original set and the given [elements] sequence,\n * which aren't already in this set.\n * \n * The returned set preserves the element iteration order of the original set.\n */\npublic operator fun <T> Set<T>.plus(elements: Sequence<T>): Set<T> {\n    val result = LinkedHashSet<T>(mapCapacity(this.size * 2))\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a set containing all elements of the original set and then the given [element] if it isn't already in this set.\n * \n * The returned set preserves the element iteration order of the original set.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Set<T>.plusElement(element: T): Set<T> {\n    return plus(element)\n}\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.coroutines.intrinsics\n\nimport kotlin.coroutines.*\nimport kotlin.internal.InlineOnly\n\n/**\n * Starts an unintercepted coroutine without a receiver and with result type [T] and executes it until its first suspension.\n * Returns the result of the coroutine or throws its exception if it does not suspend or [COROUTINE_SUSPENDED] if it suspends.\n * In the latter case, the [completion] continuation is invoked when the coroutine completes with a result or an exception.\n *\n * The coroutine is started directly in the invoker's thread without going through the [ContinuationInterceptor] that might\n * be present in the completion's [CoroutineContext]. It is the invoker's responsibility to ensure that a proper invocation\n * context is established.\n *\n * This function is designed to be used from inside of [suspendCoroutineUninterceptedOrReturn] to resume the execution of the suspended\n * coroutine using a reference to the suspending function.\n */\n@SinceKotlin(\"1.3\")\n@InlineOnly\npublic actual inline fun <T> (suspend () -> T).startCoroutineUninterceptedOrReturn(\n    completion: Continuation<T>\n): Any? = this.asDynamic()(completion, false)\n\n/**\n * Starts an unintercepted coroutine with receiver type [R] and result type [T] and executes it until its first suspension.\n * Returns the result of the coroutine or throws its exception if it does not suspend or [COROUTINE_SUSPENDED] if it suspends.\n * In the latter case, the [completion] continuation is invoked when the coroutine completes with a result or an exception.\n *\n * The coroutine is started directly in the invoker's thread without going through the [ContinuationInterceptor] that might\n * be present in the completion's [CoroutineContext]. It is the invoker's responsibility to ensure that a proper invocation\n * context is established.\n *\n * This function is designed to be used from inside of [suspendCoroutineUninterceptedOrReturn] to resume the execution of the suspended\n * coroutine using a reference to the suspending function.\n */\n@SinceKotlin(\"1.3\")\n@InlineOnly\npublic actual inline fun <R, T> (suspend R.() -> T).startCoroutineUninterceptedOrReturn(\n    receiver: R,\n    completion: Continuation<T>\n): Any? = this.asDynamic()(receiver, completion, false)\n\n@InlineOnly\ninternal actual inline fun <R, P, T> (suspend R.(P) -> T).startCoroutineUninterceptedOrReturn(\n    receiver: R,\n    param: P,\n    completion: Continuation<T>\n): Any? = this.asDynamic()(receiver, param, completion, false)\n\n/**\n * Creates unintercepted coroutine without receiver and with result type [T].\n * This function creates a new, fresh instance of suspendable computation every time it is invoked.\n *\n * To start executing the created coroutine, invoke `resume(Unit)` on the returned [Continuation] instance.\n * The [completion] continuation is invoked when coroutine completes with result or exception.\n *\n * This function returns unintercepted continuation.\n * Invocation of `resume(Unit)` starts coroutine immediately in the invoker's call stack without going through the\n * [ContinuationInterceptor] that might be present in the completion's [CoroutineContext].\n * It is the invoker's responsibility to ensure that a proper invocation context is established.\n * Note that [completion] of this function may get invoked in an arbitrary context.\n *\n * [Continuation.intercepted] can be used to acquire the intercepted continuation.\n * Invocation of `resume(Unit)` on intercepted continuation guarantees that execution of\n * both the coroutine and [completion] happens in the invocation context established by\n * [ContinuationInterceptor].\n *\n * Repeated invocation of any resume function on the resulting continuation corrupts the\n * state machine of the coroutine and may result in arbitrary behaviour or exception.\n */\n@SinceKotlin(\"1.3\")\npublic actual fun <T> (suspend () -> T).createCoroutineUnintercepted(\n    completion: Continuation<T>\n): Continuation<Unit> =\n    // Kotlin/JS suspend lambdas have an extra parameter `suspended`\n    if (this.asDynamic().length == 2) {\n        // When `suspended` is true the continuation is created, but not executed\n        this.asDynamic()(completion, true)\n    } else {\n        createCoroutineFromSuspendFunction(completion) {\n            this.asDynamic()(completion)\n        }\n    }\n\n/**\n * Creates unintercepted coroutine with receiver type [R] and result type [T].\n * This function creates a new, fresh instance of suspendable computation every time it is invoked.\n *\n * To start executing the created coroutine, invoke `resume(Unit)` on the returned [Continuation] instance.\n * The [completion] continuation is invoked when coroutine completes with result or exception.\n *\n * This function returns unintercepted continuation.\n * Invocation of `resume(Unit)` starts coroutine immediately in the invoker's call stack without going through the\n * [ContinuationInterceptor] that might be present in the completion's [CoroutineContext].\n * It is the invoker's responsibility to ensure that a proper invocation context is established.\n * Note that [completion] of this function may get invoked in an arbitrary context.\n *\n * [Continuation.intercepted] can be used to acquire the intercepted continuation.\n * Invocation of `resume(Unit)` on intercepted continuation guarantees that execution of\n * both the coroutine and [completion] happens in the invocation context established by\n * [ContinuationInterceptor].\n *\n * Repeated invocation of any resume function on the resulting continuation corrupts the\n * state machine of the coroutine and may result in arbitrary behaviour or exception.\n */\n@SinceKotlin(\"1.3\")\npublic actual fun <R, T> (suspend R.() -> T).createCoroutineUnintercepted(\n    receiver: R,\n    completion: Continuation<T>\n): Continuation<Unit> =\n    // Kotlin/JS suspend lambdas have an extra parameter `suspended`\n    if (this.asDynamic().length == 3) {\n        // When `suspended` is true the continuation is created, but not executed\n        this.asDynamic()(receiver, completion, true)\n    } else {\n        createCoroutineFromSuspendFunction(completion) {\n            this.asDynamic()(receiver, completion)\n        }\n    }\n\n/**\n * Intercepts this continuation with [ContinuationInterceptor].\n *\n * This function shall be used on the immediate result of [createCoroutineUnintercepted] or [suspendCoroutineUninterceptedOrReturn],\n * in which case it checks for [ContinuationInterceptor] in the continuation's [context][Continuation.context],\n * invokes [ContinuationInterceptor.interceptContinuation], caches and returns the result.\n *\n * If this function is invoked on other [Continuation] instances it returns `this` continuation unchanged.\n */\n@SinceKotlin(\"1.3\")\npublic actual fun <T> Continuation<T>.intercepted(): Continuation<T> =\n    (this as? CoroutineImpl)?.intercepted() ?: this\n\n\nprivate inline fun <T> createCoroutineFromSuspendFunction(\n    completion: Continuation<T>,\n    crossinline block: () -> Any?\n): Continuation<Unit> {\n    @Suppress(\"UNCHECKED_CAST\")\n    return object : CoroutineImpl(completion as Continuation<Any?>) {\n        override fun doResume(): Any? {\n            exception?.let { throw it }\n            return block()\n        }\n    }\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\nimport kotlin.reflect.KClass\n\n@PublishedApi\ninternal fun <T : Annotation> KClass<*>.findAssociatedObject(@Suppress(\"UNUSED_PARAMETER\") annotationClass: KClass<T>): Any? {\n    // This API is not supported in js-v1. Return `null` to be source-compatible with js-ir.\n    return null\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlinx.dom\n\nimport org.w3c.dom.*\n\n/** Removes all the children from this node. */\n@SinceKotlin(\"1.4\")\npublic fun Node.clear() {\n    while (hasChildNodes()) {\n        removeChild(firstChild!!)\n    }\n}\n\n/**\n * Creates text node and append it to the element.\n *\n * @return this element\n */\n@SinceKotlin(\"1.4\")\nfun Element.appendText(text: String): Element {\n    appendChild(ownerDocument!!.createTextNode(text))\n    return this\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.js\n\nimport getKClass\nimport kotlin.reflect.KClass\nimport kotlin.reflect.js.internal.KClassImpl\n\n/**\n * Represents the constructor of a class. Instances of `JsClass` can be passed to JavaScript APIs that expect a constructor reference.\n */\nexternal interface JsClass<T : Any> {\n    /**\n     * Returns the unqualified name of the class represented by this instance.\n     */\n    val name: String\n}\n\n/**\n * Obtains a constructor reference for the given `KClass`.\n */\nval <T : Any> KClass<T>.js: JsClass<T>\n    get() = (this as KClassImpl<T>).jClass\n\n/**\n * Obtains a `KClass` instance for the given constructor reference.\n */\nval <T : Any> JsClass<T>.kotlin: KClass<T>\n    get() = getKClass(this)\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// a package is omitted to get declarations directly under the module\n\n// TODO: Remove once JsReflectionAPICallChecker supports more reflection types\n@file:Suppress(\"Unsupported\")\n\nimport kotlin.reflect.*\nimport kotlin.reflect.js.internal.*\n\n@JsName(\"createKType\")\ninternal fun createKType(\n    classifier: KClassifier,\n    arguments: Array<KTypeProjection>,\n    isMarkedNullable: Boolean\n) =\n    KTypeImpl(classifier, arguments.asList(), isMarkedNullable)\n\n@JsName(\"createDynamicKType\")\ninternal fun createDynamicKType(): KType = DynamicKType\n\n@JsName(\"markKTypeNullable\")\ninternal fun markKTypeNullable(kType: KType) = KTypeImpl(kType.classifier!!, kType.arguments, true)\n\n@JsName(\"createKTypeParameter\")\ninternal fun createKTypeParameter(\n    name: String,\n    upperBounds: Array<KType>,\n    variance: String\n): KTypeParameter {\n    val kVariance = when (variance) {\n        \"in\" -> KVariance.IN\n        \"out\" -> KVariance.OUT\n        else -> KVariance.INVARIANT\n    }\n\n    return KTypeParameterImpl(name, upperBounds.asList(), kVariance, false)\n}\n\n@JsName(\"getStarKTypeProjection\")\ninternal fun getStarKTypeProjection(): KTypeProjection =\n    KTypeProjection.STAR\n\n@JsName(\"createCovariantKTypeProjection\")\ninternal fun createCovariantKTypeProjection(type: KType): KTypeProjection =\n    KTypeProjection.covariant(type)\n\n@JsName(\"createInvariantKTypeProjection\")\ninternal fun createInvariantKTypeProjection(type: KType): KTypeProjection =\n    KTypeProjection.invariant(type)\n\n@JsName(\"createContravariantKTypeProjection\")\ninternal fun createContravariantKTypeProjection(type: KType): KTypeProjection =\n    KTypeProjection.contravariant(type)\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.coroutines.js.internal\n\nimport kotlin.coroutines.Continuation\nimport kotlin.coroutines.EmptyCoroutineContext\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal val EmptyContinuation = Continuation<Any?>(EmptyCoroutineContext) { result ->\n    result.getOrThrow()\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.random\n\nimport kotlin.math.pow\n\ninternal actual fun defaultPlatformRandom(): Random =\n    Random(js(\"(Math.random() * Math.pow(2, 32)) | 0\").unsafeCast<Int>())\n\n\nprivate val INV_2_26: Double = 2.0.pow(-26)\nprivate val INV_2_53: Double = 2.0.pow(-53)\ninternal actual fun doubleFromParts(hi26: Int, low27: Int): Double =\n    hi26 * INV_2_26 + low27 * INV_2_53","/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\n/** Returns the negative [size] if [throwOnMalformed] is false, throws [CharacterCodingException] otherwise. */\n@OptIn(ExperimentalStdlibApi::class)\nprivate fun malformed(size: Int, index: Int, throwOnMalformed: Boolean): Int {\n    if (throwOnMalformed) throw CharacterCodingException(\"Malformed sequence starting at ${index - 1}\")\n    return -size\n}\n\n/**\n * Returns code point corresponding to UTF-16 surrogate pair,\n * where the first of the pair is the [high] and the second is in the [string] at the [index].\n * Returns zero if the pair is malformed and [throwOnMalformed] is false.\n *\n * @throws CharacterCodingException if the pair is malformed and [throwOnMalformed] is true.\n */\nprivate fun codePointFromSurrogate(string: String, high: Int, index: Int, endIndex: Int, throwOnMalformed: Boolean): Int {\n    if (high !in 0xD800..0xDBFF || index >= endIndex) {\n        return malformed(0, index, throwOnMalformed)\n    }\n    val low = string[index].code\n    if (low !in 0xDC00..0xDFFF) {\n        return malformed(0, index, throwOnMalformed)\n    }\n    return 0x10000 + ((high and 0x3FF) shl 10) or (low and 0x3FF)\n}\n\n/**\n * Returns code point corresponding to UTF-8 sequence of two bytes,\n * where the first byte of the sequence is the [byte1] and the second byte is in the [bytes] array at the [index].\n * Returns zero if the sequence is malformed and [throwOnMalformed] is false.\n *\n * @throws CharacterCodingException if the sequence of two bytes is malformed and [throwOnMalformed] is true.\n */\nprivate fun codePointFrom2(bytes: ByteArray, byte1: Int, index: Int, endIndex: Int, throwOnMalformed: Boolean): Int {\n    if (byte1 and 0x1E == 0 || index >= endIndex) {\n        return malformed(0, index, throwOnMalformed)\n    }\n    val byte2 = bytes[index].toInt()\n    if (byte2 and 0xC0 != 0x80) {\n        return malformed(0, index, throwOnMalformed)\n    }\n    return (byte1 shl 6) xor byte2 xor 0xF80\n}\n\n/**\n * Returns code point corresponding to UTF-8 sequence of three bytes,\n * where the first byte of the sequence is the [byte1] and the others are in the [bytes] array starting from the [index].\n * Returns a non-positive value indicating number of bytes from [bytes] included in malformed sequence\n * if the sequence is malformed and [throwOnMalformed] is false.\n *\n * @throws CharacterCodingException if the sequence of three bytes is malformed and [throwOnMalformed] is true.\n */\nprivate fun codePointFrom3(bytes: ByteArray, byte1: Int, index: Int, endIndex: Int, throwOnMalformed: Boolean): Int {\n    if (index >= endIndex) {\n        return malformed(0, index, throwOnMalformed)\n    }\n\n    val byte2 = bytes[index].toInt()\n    if (byte1 and 0xF == 0) {\n        if (byte2 and 0xE0 != 0xA0) {\n            // Non-shortest form\n            return malformed(0, index, throwOnMalformed)\n        }\n    } else if (byte1 and 0xF == 0xD) {\n        if (byte2 and 0xE0 != 0x80) {\n            // Surrogate code point\n            return malformed(0, index, throwOnMalformed)\n        }\n    } else if (byte2 and 0xC0 != 0x80) {\n        return malformed(0, index, throwOnMalformed)\n    }\n\n    if (index + 1 == endIndex) {\n        return malformed(1, index, throwOnMalformed)\n    }\n    val byte3 = bytes[index + 1].toInt()\n    if (byte3 and 0xC0 != 0x80) {\n        return malformed(1, index, throwOnMalformed)\n    }\n\n    return (byte1 shl 12) xor (byte2 shl 6) xor byte3 xor -0x1E080\n}\n\n/**\n * Returns code point corresponding to UTF-8 sequence of four bytes,\n * where the first byte of the sequence is the [byte1] and the others are in the [bytes] array starting from the [index].\n * Returns a non-positive value indicating number of bytes from [bytes] included in malformed sequence\n * if the sequence is malformed and [throwOnMalformed] is false.\n *\n * @throws CharacterCodingException if the sequence of four bytes is malformed and [throwOnMalformed] is true.\n */\nprivate fun codePointFrom4(bytes: ByteArray, byte1: Int, index: Int, endIndex: Int, throwOnMalformed: Boolean): Int {\n    if (index >= endIndex) {\n        malformed(0, index, throwOnMalformed)\n    }\n\n    val byte2 = bytes[index].toInt()\n    if (byte1 and 0xF == 0x0) {\n        if (byte2 and 0xF0 <= 0x80) {\n            // Non-shortest form\n            return malformed(0, index, throwOnMalformed)\n        }\n    } else if (byte1 and 0xF == 0x4) {\n        if (byte2 and 0xF0 != 0x80) {\n            // Out of Unicode code points domain (larger than U+10FFFF)\n            return malformed(0, index, throwOnMalformed)\n        }\n    } else if (byte1 and 0xF > 0x4) {\n        return malformed(0, index, throwOnMalformed)\n    } else if (byte2 and 0xC0 != 0x80) {\n        return malformed(0, index, throwOnMalformed)\n    }\n\n    if (index + 1 == endIndex) {\n        return malformed(1, index, throwOnMalformed)\n    }\n    val byte3 = bytes[index + 1].toInt()\n    if (byte3 and 0xC0 != 0x80) {\n        return malformed(1, index, throwOnMalformed)\n    }\n\n    if (index + 2 == endIndex) {\n        return malformed(2, index, throwOnMalformed)\n    }\n    val byte4 = bytes[index + 2].toInt()\n    if (byte4 and 0xC0 != 0x80) {\n        return malformed(2, index, throwOnMalformed)\n    }\n    return (byte1 shl 18) xor (byte2 shl 12) xor (byte3 shl 6) xor byte4 xor 0x381F80\n}\n\n/**\n * Maximum number of bytes needed to encode a single char.\n *\n * Code points in `0..0x7F` are encoded in a single byte.\n * Code points in `0x80..0x7FF` are encoded in two bytes.\n * Code points in `0x800..0xD7FF` or in `0xE000..0xFFFF` are encoded in three bytes.\n * Surrogate code points in `0xD800..0xDFFF` are not Unicode scalar values, therefore aren't encoded.\n * Code points in `0x10000..0x10FFFF` are represented by a pair of surrogate `Char`s and are encoded in four bytes.\n */\nprivate const val MAX_BYTES_PER_CHAR = 3\n\n/**\n * The byte sequence a malformed UTF-16 char sequence is replaced by.\n */\nprivate val REPLACEMENT_BYTE_SEQUENCE: ByteArray = byteArrayOf(0xEF.toByte(), 0xBF.toByte(), 0xBD.toByte())\n\n/**\n * Encodes the [string] using UTF-8 and returns the resulting [ByteArray].\n *\n * @param string the string to encode.\n * @param startIndex the start offset (inclusive) of the substring to encode.\n * @param endIndex the end offset (exclusive) of the substring to encode.\n * @param throwOnMalformed whether to throw on malformed char sequence or replace by the [REPLACEMENT_BYTE_SEQUENCE].\n *\n * @throws CharacterCodingException if the char sequence is malformed and [throwOnMalformed] is true.\n */\ninternal fun encodeUtf8(string: String, startIndex: Int, endIndex: Int, throwOnMalformed: Boolean): ByteArray {\n    require(startIndex >= 0 && endIndex <= string.length && startIndex <= endIndex)\n\n    val bytes = ByteArray((endIndex - startIndex) * MAX_BYTES_PER_CHAR)\n    var byteIndex = 0\n    var charIndex = startIndex\n\n    while (charIndex < endIndex) {\n        val code = string[charIndex++].code\n        when {\n            code < 0x80 ->\n                bytes[byteIndex++] = code.toByte()\n            code < 0x800 -> {\n                bytes[byteIndex++] = ((code shr 6) or 0xC0).toByte()\n                bytes[byteIndex++] = ((code and 0x3F) or 0x80).toByte()\n            }\n            code < 0xD800 || code >= 0xE000 -> {\n                bytes[byteIndex++] = ((code shr 12) or 0xE0).toByte()\n                bytes[byteIndex++] = (((code shr 6) and 0x3F) or 0x80).toByte()\n                bytes[byteIndex++] = ((code and 0x3F) or 0x80).toByte()\n            }\n            else -> { // Surrogate char value\n                val codePoint = codePointFromSurrogate(string, code, charIndex, endIndex, throwOnMalformed)\n                if (codePoint <= 0) {\n                    bytes[byteIndex++] = REPLACEMENT_BYTE_SEQUENCE[0]\n                    bytes[byteIndex++] = REPLACEMENT_BYTE_SEQUENCE[1]\n                    bytes[byteIndex++] = REPLACEMENT_BYTE_SEQUENCE[2]\n                } else {\n                    bytes[byteIndex++] = ((codePoint shr 18) or 0xF0).toByte()\n                    bytes[byteIndex++] = (((codePoint shr 12) and 0x3F) or 0x80).toByte()\n                    bytes[byteIndex++] = (((codePoint shr 6) and 0x3F) or 0x80).toByte()\n                    bytes[byteIndex++] = ((codePoint and 0x3F) or 0x80).toByte()\n                    charIndex++\n                }\n            }\n        }\n    }\n\n    return if (bytes.size == byteIndex) bytes else bytes.copyOf(byteIndex)\n}\n\n/**\n * The character a malformed UTF-8 byte sequence is replaced by.\n */\nprivate const val REPLACEMENT_CHAR = '\\uFFFD'\n\n/**\n * Decodes the UTF-8 [bytes] array and returns the resulting [String].\n *\n * @param bytes the byte array to decode.\n * @param startIndex the start offset (inclusive) of the array to be decoded.\n * @param endIndex the end offset (exclusive) of the array to be encoded.\n * @param throwOnMalformed whether to throw on malformed byte sequence or replace by the [REPLACEMENT_CHAR].\n *\n * @throws CharacterCodingException if the array is malformed UTF-8 byte sequence and [throwOnMalformed] is true.\n */\ninternal fun decodeUtf8(bytes: ByteArray, startIndex: Int, endIndex: Int, throwOnMalformed: Boolean): String {\n    require(startIndex >= 0 && endIndex <= bytes.size && startIndex <= endIndex)\n\n    var byteIndex = startIndex\n    val stringBuilder = StringBuilder()\n\n    while (byteIndex < endIndex) {\n        val byte = bytes[byteIndex++].toInt()\n        when {\n            byte >= 0 ->\n                stringBuilder.append(byte.toChar())\n            byte shr 5 == -2 -> {\n                val code = codePointFrom2(bytes, byte, byteIndex, endIndex, throwOnMalformed)\n                if (code <= 0) {\n                    stringBuilder.append(REPLACEMENT_CHAR)\n                    byteIndex += -code\n                } else {\n                    stringBuilder.append(code.toChar())\n                    byteIndex += 1\n                }\n            }\n            byte shr 4 == -2 -> {\n                val code = codePointFrom3(bytes, byte, byteIndex, endIndex, throwOnMalformed)\n                if (code <= 0) {\n                    stringBuilder.append(REPLACEMENT_CHAR)\n                    byteIndex += -code\n                } else {\n                    stringBuilder.append(code.toChar())\n                    byteIndex += 2\n                }\n            }\n            byte shr 3 == -2 -> {\n                val code = codePointFrom4(bytes, byte, byteIndex, endIndex, throwOnMalformed)\n                if (code <= 0) {\n                    stringBuilder.append(REPLACEMENT_CHAR)\n                    byteIndex += -code\n                } else {\n                    val high = (code - 0x10000) shr 10 or 0xD800\n                    val low = (code and 0x3FF) or 0xDC00\n                    stringBuilder.append(high.toChar())\n                    stringBuilder.append(low.toChar())\n                    byteIndex += 3\n                }\n            }\n            else -> {\n                malformed(0, byteIndex, throwOnMalformed)\n                stringBuilder.append(REPLACEMENT_CHAR)\n            }\n        }\n    }\n\n    return stringBuilder.toString()\n}","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin\n\nimport kotlin.coroutines.*\nimport kotlin.coroutines.intrinsics.*\nimport kotlin.native.concurrent.SharedImmutable\n\n/**\n * Defines deep recursive function that keeps its stack on the heap,\n * which allows very deep recursive computations that do not use the actual call stack.\n * To initiate a call to this deep recursive function use its [invoke] function.\n * As a rule of thumb, it should be used if recursion goes deeper than a thousand calls.\n *\n * The [DeepRecursiveFunction] takes one parameter of type [T] and returns a result of type [R].\n * The [block] of code defines the body of a recursive function. In this block\n * [callRecursive][DeepRecursiveScope.callRecursive] function can be used to make a recursive call\n * to the declared function. Other instances of [DeepRecursiveFunction] can be called\n * in this scope with `callRecursive` extension, too.\n *\n * For example, take a look at the following recursive tree class and a deeply\n * recursive instance of this tree with 100K nodes:\n *\n * ```\n * class Tree(val left: Tree? = null, val right: Tree? = null)\n * val deepTree = generateSequence(Tree()) { Tree(it) }.take(100_000).last()\n * ```\n *\n * A regular recursive function can be defined to compute a depth of a tree:\n *\n * ```\n * fun depth(t: Tree?): Int =\n *     if (t == null) 0 else max(depth(t.left), depth(t.right)) + 1\n * println(depth(deepTree)) // StackOverflowError\n * ```\n *\n * If this `depth` function is called for a `deepTree` it produces [StackOverflowError] because of deep recursion.\n * However, the `depth` function can be rewritten using `DeepRecursiveFunction` in the following way, and then\n * it successfully computes [`depth(deepTree)`][DeepRecursiveFunction.invoke] expression:\n *\n * ```\n * val depth = DeepRecursiveFunction<Tree?, Int> { t ->\n *     if (t == null) 0 else max(callRecursive(t.left), callRecursive(t.right)) + 1\n * }\n * println(depth(deepTree)) // Ok\n * ```\n *\n * Deep recursive functions can also mutually call each other using a heap for the stack via\n * [callRecursive][DeepRecursiveScope.callRecursive] extension. For example, the\n * following pair of mutually recursive functions computes the number of tree nodes at even depth in the tree.\n *\n * ```\n * val mutualRecursion = object {\n *     val even: DeepRecursiveFunction<Tree?, Int> = DeepRecursiveFunction { t ->\n *         if (t == null) 0 else odd.callRecursive(t.left) + odd.callRecursive(t.right) + 1\n *     }\n *     val odd: DeepRecursiveFunction<Tree?, Int> = DeepRecursiveFunction { t ->\n *         if (t == null) 0 else even.callRecursive(t.left) + even.callRecursive(t.right)\n *     }\n * }\n * ```\n *\n * @param [T] the function parameter type.\n * @param [R] the function result type.\n * @param block the function body.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalStdlibApi\npublic class DeepRecursiveFunction<T, R>(\n    internal val block: suspend DeepRecursiveScope<T, R>.(T) -> R\n)\n\n/**\n * Initiates a call to this deep recursive function, forming a root of the call tree.\n *\n * This operator should not be used from inside of [DeepRecursiveScope] as it uses the call stack slot for\n * initial recursive invocation. From inside of [DeepRecursiveScope] use\n * [callRecursive][DeepRecursiveScope.callRecursive].\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalStdlibApi\npublic operator fun <T, R> DeepRecursiveFunction<T, R>.invoke(value: T): R =\n    DeepRecursiveScopeImpl<T, R>(block, value).runCallLoop()\n\n/**\n * A scope class for [DeepRecursiveFunction] function declaration that defines [callRecursive] methods to\n * recursively call this function or another [DeepRecursiveFunction] putting the call activation frame on the heap.\n *\n * @param [T] function parameter type.\n * @param [R] function result type.\n */\n@RestrictsSuspension\n@SinceKotlin(\"1.4\")\n@ExperimentalStdlibApi\npublic sealed class DeepRecursiveScope<T, R> {\n    /**\n     * Makes recursive call to this [DeepRecursiveFunction] function putting the call activation frame on the heap,\n     * as opposed to the actual call stack that is used by a regular recursive call.\n     */\n    public abstract suspend fun callRecursive(value: T): R\n\n    /**\n     * Makes call to the specified [DeepRecursiveFunction] function putting the call activation frame on the heap,\n     * as opposed to the actual call stack that is used by a regular call.\n     */\n    public abstract suspend fun <U, S> DeepRecursiveFunction<U, S>.callRecursive(value: U): S\n\n    @Deprecated(\n        level = DeprecationLevel.ERROR,\n        message =\n        \"'invoke' should not be called from DeepRecursiveScope. \" +\n                \"Use 'callRecursive' to do recursion in the heap instead of the call stack.\",\n        replaceWith = ReplaceWith(\"this.callRecursive(value)\")\n    )\n    @Suppress(\"UNUSED_PARAMETER\")\n    public operator fun DeepRecursiveFunction<*, *>.invoke(value: Any?): Nothing =\n        throw UnsupportedOperationException(\"Should not be called from DeepRecursiveScope\")\n}\n\n// ================== Implementation ==================\n\n@ExperimentalStdlibApi\nprivate typealias DeepRecursiveFunctionBlock = suspend DeepRecursiveScope<*, *>.(Any?) -> Any?\n\n@SharedImmutable\nprivate val UNDEFINED_RESULT = Result.success(COROUTINE_SUSPENDED)\n\n@Suppress(\"UNCHECKED_CAST\")\n@ExperimentalStdlibApi\nprivate class DeepRecursiveScopeImpl<T, R>(\n    block: suspend DeepRecursiveScope<T, R>.(T) -> R,\n    value: T\n) : DeepRecursiveScope<T, R>(), Continuation<R> {\n    // Active function block\n    private var function: DeepRecursiveFunctionBlock = block as DeepRecursiveFunctionBlock\n\n    // Value to call function with\n    private var value: Any? = value\n\n    // Continuation of the current call\n    private var cont: Continuation<Any?>? = this as Continuation<Any?>\n\n    // Completion result (completion of the whole call stack)\n    private var result: Result<Any?> = UNDEFINED_RESULT\n\n    override val context: CoroutineContext\n        get() = EmptyCoroutineContext\n\n    override fun resumeWith(result: Result<R>) {\n        this.cont = null\n        this.result = result\n    }\n\n    override suspend fun callRecursive(value: T): R = suspendCoroutineUninterceptedOrReturn { cont ->\n        // calling the same function that is currently active\n        this.cont = cont as Continuation<Any?>\n        this.value = value\n        COROUTINE_SUSPENDED\n    }\n\n    override suspend fun <U, S> DeepRecursiveFunction<U, S>.callRecursive(value: U): S = suspendCoroutineUninterceptedOrReturn { cont ->\n        // calling another recursive function\n        val function = block as DeepRecursiveFunctionBlock\n        with(this@DeepRecursiveScopeImpl) {\n            val currentFunction = this.function\n            if (function !== currentFunction) {\n                // calling a different function -- create a trampoline to restore function ref\n                this.function = function\n                this.cont = crossFunctionCompletion(currentFunction, cont as Continuation<Any?>)\n            } else {\n                // calling the same function -- direct\n                this.cont = cont as Continuation<Any?>\n            }\n            this.value = value\n        }\n        COROUTINE_SUSPENDED\n    }\n\n    private fun crossFunctionCompletion(\n        currentFunction: DeepRecursiveFunctionBlock,\n        cont: Continuation<Any?>\n    ): Continuation<Any?> = Continuation(EmptyCoroutineContext) {\n        this.function = currentFunction\n        // When going back from a trampoline we cannot just call cont.resume (stack usage!)\n        // We delegate the cont.resumeWith(it) call to runCallLoop\n        this.cont = cont\n        this.result = it\n    }\n\n    @Suppress(\"UNCHECKED_CAST\")\n    fun runCallLoop(): R {\n        while (true) {\n            // Note: cont is set to null in DeepRecursiveScopeImpl.resumeWith when the whole computation completes\n            val result = this.result\n            val cont = this.cont\n                ?: return (result as Result<R>).getOrThrow() // done -- final result\n            // The order of comparison is important here for that case of rogue class with broken equals\n            if (UNDEFINED_RESULT == result) {\n                // call \"function\" with \"value\" using \"cont\" as completion\n                val r = try {\n                    // This is block.startCoroutine(this, value, cont)\n                    function.startCoroutineUninterceptedOrReturn(this, value, cont)\n                } catch (e: Throwable) {\n                    cont.resumeWithException(e)\n                    continue\n                }\n                // If the function returns without suspension -- calls its continuation immediately\n                if (r !== COROUTINE_SUSPENDED)\n                    cont.resume(r as R)\n            } else {\n                // we returned from a crossFunctionCompletion trampoline -- call resume here\n                this.result = UNDEFINED_RESULT // reset result back\n                cont.resumeWith(result)\n            }\n        }\n    }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StringsKt\")\n\npackage kotlin.text\n\n/**\n * Converts the string into a regular expression [Regex] with the default options.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.toRegex(): Regex = Regex(this)\n\n/**\n * Converts the string into a regular expression [Regex] with the specified single [option].\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.toRegex(option: RegexOption): Regex = Regex(this, option)\n\n/**\n * Converts the string into a regular expression [Regex] with the specified set of [options].\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.toRegex(options: Set<RegexOption>): Regex = Regex(this, options)\n","package kotlinx.html\n\nimport org.w3c.dom.events.*\n\ninterface TagConsumer<out R> {\n    fun onTagStart(tag: Tag)\n    fun onTagAttributeChange(tag: Tag, attribute: String, value: String?)\n    fun onTagEvent(tag: Tag, event: String, value: (Event) -> Unit)\n    fun onTagEnd(tag: Tag)\n    fun onTagContent(content: CharSequence)\n    fun onTagContentEntity(entity: Entities)\n    fun onTagContentUnsafe(block: Unsafe.() -> Unit)\n    fun onTagComment(content: CharSequence)\n    fun onTagError(tag: Tag, exception: Throwable): Unit = throw exception\n    fun finalize(): R\n}\n\n@HtmlTagMarker\ninterface Tag {\n    val tagName: String\n    val consumer: TagConsumer<*>\n    val namespace: String?\n\n    val attributes: MutableMap<String, String>\n    val attributesEntries: Collection<Map.Entry<String, String>>\n\n    val inlineTag: Boolean\n    val emptyTag: Boolean\n\n    operator fun Entities.unaryPlus(): Unit {\n        entity(this)\n    }\n\n    operator fun String.unaryPlus(): Unit {\n        text(this)\n    }\n\n    fun text(s: String) {\n        consumer.onTagContent(s)\n    }\n\n    fun text(n: Number) {\n        text(n.toString())\n    }\n\n    fun entity(e: Entities) {\n        consumer.onTagContentEntity(e)\n    }\n\n    fun comment(s: String) {\n        consumer.onTagComment(s)\n    }\n}\n\n@HtmlTagMarker\ninterface Unsafe {\n    operator fun String.unaryPlus()\n    operator fun Entities.unaryPlus() = +text\n\n    fun raw(s: String) {\n        +s\n    }\n\n    fun raw(entity: Entities) {\n        +entity\n    }\n\n    fun raw(n: Number) {\n        +n.toString()\n    }\n}\n\ninterface AttributeEnum {\n    val realValue: String\n}\n\ninline fun <T : Tag> T.visit(crossinline block: T.() -> Unit) = visitTag { block() }\n\ninline fun <T : Tag, R> T.visitAndFinalize(consumer: TagConsumer<R>, crossinline block: T.() -> Unit): R\n        = visitTagAndFinalize(consumer) { block() }\n\nfun attributesMapOf() = emptyMap\nfun attributesMapOf(key: String, value: String?): Map<String, String> = when (value) {\n    null -> emptyMap\n    else -> singletonMapOf(key, value)\n}\n\nfun attributesMapOf(vararg pairs: String?): Map<String, String> {\n    var result: MutableMap<String, String>? = null\n\n    for (i in 0..pairs.size - 1 step 2) {\n        val k = pairs[i]\n        val v = pairs[i + 1]\n        if (k != null && v != null) {\n            if (result == null) {\n                result = linkedMapOf()\n            }\n            result.put(k, v)\n        }\n    }\n\n    return result ?: emptyMap\n}\n\nfun singletonMapOf(key: String, value: String): Map<String, String> = SingletonStringMap(key, value)\n\nfun HTMLTag.unsafe(block: Unsafe.() -> Unit): Unit = consumer.onTagContentUnsafe(block)\n\nval emptyMap: Map<String, String> = emptyMap()\n\nclass DefaultUnsafe : Unsafe {\n    private val sb = StringBuilder()\n\n    override fun String.unaryPlus() {\n        sb.append(this)\n    }\n\n    override fun toString(): String = sb.toString()\n}\n\n@DslMarker\nannotation class HtmlTagMarker\n\ntypealias HtmlContent = FlowOrPhrasingContent\n\nprivate data class SingletonStringMap(override val key: String, override val value: String) : Map<String, String>, Map.Entry<String, String> {\n    override val entries: Set<Map.Entry<String, String>>\n        get() = setOf(this)\n\n    override val keys: Set<String>\n        get() = setOf(key)\n\n    override val size: Int\n        get() = 1\n\n    override val values: Collection<String>\n        get() = listOf(value)\n\n    override fun containsKey(key: String) = key == this.key\n    override fun containsValue(value: String) = value == this.value\n    override fun get(key: String): String? = if (key == this.key) value else null\n    override fun isEmpty() = false\n}\n","package kotlinx.html.attributes\n\nimport kotlinx.html.*\n\ninterface AttributeEncoder<T> {\n    fun encode(attributeName: String, value : T) : String\n    fun decode(attributeName: String, value : String) : T\n    fun empty(attributeName: String, tag: Tag) : T = throw IllegalStateException(\"Attribute $attributeName is not yet defined for tag ${tag.tagName}\")\n}\n\nabstract class Attribute<T>(val encoder : AttributeEncoder<T>) {\n    open operator fun get(thisRef: Tag, attributeName: String) : T =\n            thisRef.attributes[attributeName]?.let {\n                encoder.decode(attributeName, it)\n            } ?: encoder.empty(attributeName, thisRef)\n\n    open operator fun set(thisRef: Tag, attributeName: String, value : T) {\n        thisRef.attributes.put(attributeName, encoder.encode(attributeName, value))\n    }\n}\n\nobject StringEncoder : AttributeEncoder<String> {\n    override fun encode(attributeName: String, value: String): String = value\n    override fun decode(attributeName: String, value: String): String = value\n}\n\nclass StringAttribute : Attribute<String>(StringEncoder)\n\n//public class IntAttribute : Attribute<Int>() {\n//    override fun encode(desc: PropertyMetadata, value: Int): String = value.toString()\n//    override fun decode(desc: PropertyMetadata, value: String): Int = value.toInt()\n//}\n\nfun Boolean.booleanEncode() = toString()\nclass BooleanEncoder(val trueValue: String = \"true\", val falseValue: String = \"false\") : AttributeEncoder<Boolean> {\n    override fun encode(attributeName: String, value : Boolean): String = if (value) trueValue else falseValue\n    override fun decode(attributeName: String, value: String): Boolean = when (value) {\n        trueValue -> true\n        falseValue -> false\n        else -> throw IllegalArgumentException(\"Unknown value $value for $attributeName\")\n    }\n}\n\nclass BooleanAttribute(trueValue: String = \"true\", falseValue: String = \"false\") : Attribute<Boolean>(BooleanEncoder(trueValue, falseValue))\n\nfun Boolean.tickerEncode(attributeName: String) : String = if (this) attributeName else \"\"\nobject TickerEncoder : AttributeEncoder<Boolean> {\n    override fun encode(attributeName: String, value: Boolean): String = value.tickerEncode(attributeName)\n    override fun decode(attributeName: String, value: String): Boolean = value == attributeName\n}\n\nclass TickerAttribute : Attribute<Boolean>(TickerEncoder) {\n    override fun set(thisRef: Tag, attributeName: String, value: Boolean) {\n        if (value) {\n            thisRef.attributes.put(attributeName, attributeName)\n        } else {\n            thisRef.attributes.remove(attributeName)\n        }\n    }\n}\n\nclass EnumEncoder<T : AttributeEnum>(val valuesMap : Map<String, T>) : AttributeEncoder<T> {\n    override fun encode(attributeName: String, value: T): String = value.realValue\n    override fun decode(attributeName: String, value: String): T = valuesMap[value] ?: throw IllegalArgumentException(\"Unknown value $value for $attributeName\")\n}\n\nfun AttributeEnum.enumEncode() : String = realValue\nclass EnumAttribute<T : AttributeEnum>(val values : Map<String, T>) : Attribute<T>(EnumEncoder(values))\n\nfun stringSetDecode(value: String?): Set<String>? = value?.split(\"\\\\s+\".toRegex())?.filterNot {it.isEmpty()}?.toSet()\nfun Set<String>.stringSetEncode() = joinToString(\" \")\nobject StringSetEncoder : AttributeEncoder<Set<String>> {\n    override fun encode(attributeName: String, value: Set<String>): String = value.joinToString(\" \")\n    override fun decode(attributeName: String, value: String): Set<String> = stringSetDecode(value)!!\n    override fun empty(attributeName: String, tag: Tag) = emptySet<String>()\n}\nclass StringSetAttribute : Attribute<Set<String>>(StringSetEncoder)","package kotlinx.html.impl\n\nimport kotlinx.html.*\n\nclass DelegatingMap(initialValues : Map<String, String>, private val tag : Tag, private val consumer : () -> TagConsumer<*>) : MutableMap<String, String> {\n    private var backing: Map<String, String> = initialValues\n    private var backingMutable = false\n\n    override val size: Int\n        get() = backing.size\n\n    override fun isEmpty(): Boolean = backing.isEmpty()\n\n    override fun containsKey(key: String): Boolean = backing.containsKey(key)\n    override fun containsValue(value: String): Boolean = backing.containsValue(value)\n    override fun get(key: String): String? = backing[key]\n\n    override fun put(key: String, value: String): String? {\n        val mutable = switchToMutable()\n\n        val old = mutable.put(key, value)\n        if (old != value) {\n            consumer().onTagAttributeChange(tag, key, value)\n        }\n\n        return old\n    }\n\n    override fun remove(key: String): String? {\n        val mutable = switchToMutable()\n\n        return mutable.remove(key)?.let { removed ->\n            consumer().onTagAttributeChange(tag, key, null)\n            removed\n        }\n    }\n\n    override fun putAll(from: Map<out String, String>) {\n        if (from.isEmpty()) return\n\n        val consumer = consumer()\n        val mutable = switchToMutable()\n\n        from.entries.forEach { e ->\n            if (mutable.put(e.key, e.value) != e.value) {\n                consumer.onTagAttributeChange(tag, e.key, e.value)\n            }\n        }\n    }\n\n    override fun clear() {\n        backing.forEach { e -> consumer().onTagAttributeChange(tag, e.key, null) }\n        backing = emptyMap()\n        backingMutable = false\n    }\n\n    val immutableEntries: Collection<Map.Entry<String, String>>\n        get() = backing.entries\n\n    private fun switchToMutable(): MutableMap<String, String> = if (backingMutable) {\n        backing\n    } else {\n        backingMutable = true\n        backing = LinkedHashMap(backing)\n        backing\n    } as MutableMap\n\n    override val keys: MutableSet<String>\n        get() = switchToMutable().keys  // TODO we need to handle changes too\n\n    override val values: MutableCollection<String>\n        get() = switchToMutable().values  // TODO we need to handle changes too\n\n    override val entries: MutableSet<MutableMap.MutableEntry<String, String>>\n        get() = switchToMutable().entries   // TODO we need to handle changes too\n}\n","package kotlinx.html.consumers\n\nimport kotlinx.html.*\nimport org.w3c.dom.events.*\n\nclass FinalizeConsumer<F, T>(val downstream : TagConsumer<F>, val block : (F, Boolean) -> T) : TagConsumer<T> {\n    private var level = 0\n\n    override fun onTagStart(tag: Tag) {\n        downstream.onTagStart(tag)\n        level ++\n    }\n    override fun onTagEnd(tag: Tag) {\n        downstream.onTagEnd(tag)\n        level --\n    }\n\n    override fun onTagAttributeChange(tag: Tag, attribute: String, value: String?) = downstream.onTagAttributeChange(tag, attribute, value)\n    override fun onTagEvent(tag: Tag, event: String, value: (Event) -> Unit) = downstream.onTagEvent(tag, event, value)\n    override fun onTagContent(content: CharSequence) = downstream.onTagContent(content)\n    override fun onTagContentEntity(entity: Entities) = downstream.onTagContentEntity(entity)\n    override fun onTagContentUnsafe(block: Unsafe.() -> Unit) = downstream.onTagContentUnsafe(block)\n    override fun onTagError(tag: Tag, exception: Throwable) = downstream.onTagError(tag, exception)\n    override fun onTagComment(content: CharSequence) = downstream.onTagComment(content)\n\n    override fun finalize() = block(downstream.finalize(), level > 0)\n}\n\npublic fun <T> TagConsumer<T>.onFinalize(block : (from : T, partial : Boolean) -> Unit) : TagConsumer<T> = FinalizeConsumer(this) { to, partial -> block(to, partial); to }\npublic fun <F, T> TagConsumer<F>.onFinalizeMap(block : (from : F, partial : Boolean) -> T) : TagConsumer<T> = FinalizeConsumer(this, block)","package kotlinx.html\n\nimport kotlinx.html.*\n\n/*******************************************************************************\n    DO NOT EDIT\n    This file was generated by module generate\n*******************************************************************************/\n\n@Suppress(\"unused\")\nenum class Dir(override val realValue : String) : AttributeEnum {\n    ltr(\"ltr\"),\n    rtl(\"rtl\")\n}\n\ninternal val dirValues : Map<String, Dir> = Dir.values().associateBy { it.realValue }\n@Suppress(\"unused\")\nenum class Draggable(override val realValue : String) : AttributeEnum {\n    htmlTrue(\"true\"),\n    htmlFalse(\"false\"),\n    auto(\"auto\")\n}\n\ninternal val draggableValues : Map<String, Draggable> = Draggable.values().associateBy { it.realValue }\n@Suppress(\"unused\")\nenum class RunAt(override val realValue : String) : AttributeEnum {\n    server(\"server\")\n}\n\ninternal val runAtValues : Map<String, RunAt> = RunAt.values().associateBy { it.realValue }\n@Suppress(\"unused\")\nobject ATarget {\n    val blank : String = \"_blank\"\n    val parent : String = \"_parent\"\n    val self : String = \"_self\"\n    val top : String = \"_top\"\n\n    val values : List<String> = listOf(\"blank\", \"parent\", \"self\", \"top\")\n}\n\n@Suppress(\"unused\")\nobject ARel {\n    val alternate : String = \"Alternate\"\n    val appEndIx : String = \"Appendix\"\n    val bookmark : String = \"Bookmark\"\n    val chapter : String = \"Chapter\"\n    val contentS : String = \"Contents\"\n    val copyright : String = \"Copyright\"\n    val glossary : String = \"Glossary\"\n    val help : String = \"Help\"\n    val index : String = \"Index\"\n    val next : String = \"Next\"\n    val prev : String = \"Prev\"\n    val section : String = \"Section\"\n    val start : String = \"Start\"\n    val stylesheet : String = \"Stylesheet\"\n    val subsection : String = \"Subsection\"\n\n    val values : List<String> = listOf(\"alternate\", \"appEndIx\", \"bookmark\", \"chapter\", \"contentS\", \"copyright\", \"glossary\", \"help\", \"index\", \"next\", \"prev\", \"section\", \"start\", \"stylesheet\", \"subsection\")\n}\n\n@Suppress(\"unused\")\nobject AType {\n    val textAsp : String = \"text/asp\"\n    val textAsa : String = \"text/asa\"\n    val textCss : String = \"text/css\"\n    val textHtml : String = \"text/html\"\n    val textJavaScript : String = \"text/javascript\"\n    val textPlain : String = \"text/plain\"\n    val textScriptLet : String = \"text/scriptlet\"\n    val textXComponent : String = \"text/x-component\"\n    val textXHtmlInsertion : String = \"text/x-html-insertion\"\n    val textXml : String = \"text/xml\"\n\n    val values : List<String> = listOf(\"textAsp\", \"textAsa\", \"textCss\", \"textHtml\", \"textJavaScript\", \"textPlain\", \"textScriptLet\", \"textXComponent\", \"textXHtmlInsertion\", \"textXml\")\n}\n\n@Suppress(\"unused\")\nenum class AreaShape(override val realValue : String) : AttributeEnum {\n    rect(\"rect\"),\n    circle(\"circle\"),\n    poly(\"poly\"),\n    default(\"default\")\n}\n\ninternal val areaShapeValues : Map<String, AreaShape> = AreaShape.values().associateBy { it.realValue }\n@Suppress(\"unused\")\nobject AreaTarget {\n    val blank : String = \"_blank\"\n    val parent : String = \"_parent\"\n    val self : String = \"_self\"\n    val top : String = \"_top\"\n\n    val values : List<String> = listOf(\"blank\", \"parent\", \"self\", \"top\")\n}\n\n@Suppress(\"unused\")\nobject AreaRel {\n    val alternate : String = \"Alternate\"\n    val appEndIx : String = \"Appendix\"\n    val bookmark : String = \"Bookmark\"\n    val chapter : String = \"Chapter\"\n    val contentS : String = \"Contents\"\n    val copyright : String = \"Copyright\"\n    val glossary : String = \"Glossary\"\n    val help : String = \"Help\"\n    val index : String = \"Index\"\n    val next : String = \"Next\"\n    val prev : String = \"Prev\"\n    val section : String = \"Section\"\n    val start : String = \"Start\"\n    val stylesheet : String = \"Stylesheet\"\n    val subsection : String = \"Subsection\"\n\n    val values : List<String> = listOf(\"alternate\", \"appEndIx\", \"bookmark\", \"chapter\", \"contentS\", \"copyright\", \"glossary\", \"help\", \"index\", \"next\", \"prev\", \"section\", \"start\", \"stylesheet\", \"subsection\")\n}\n\n@Suppress(\"unused\")\nobject BaseTarget {\n    val blank : String = \"_blank\"\n    val parent : String = \"_parent\"\n    val self : String = \"_self\"\n    val top : String = \"_top\"\n\n    val values : List<String> = listOf(\"blank\", \"parent\", \"self\", \"top\")\n}\n\n@Suppress(\"unused\")\nenum class ButtonFormEncType(override val realValue : String) : AttributeEnum {\n    multipartFormData(\"multipart/form-data\"),\n    applicationXWwwFormUrlEncoded(\"application/x-www-form-urlencoded\"),\n    textPlain(\"text/plain\")\n}\n\ninternal val buttonFormEncTypeValues : Map<String, ButtonFormEncType> = ButtonFormEncType.values().associateBy { it.realValue }\n@Suppress(\"unused\")\nenum class ButtonFormMethod(override val realValue : String) : AttributeEnum {\n    get(\"get\"),\n    post(\"post\"),\n    @Deprecated(\"method is not allowed in browsers\") put(\"put\"),\n    @Deprecated(\"method is not allowed in browsers\") delete(\"delete\"),\n    @Deprecated(\"method is not allowed in browsers\") patch(\"patch\")\n}\n\ninternal val buttonFormMethodValues : Map<String, ButtonFormMethod> = ButtonFormMethod.values().associateBy { it.realValue }\n@Suppress(\"unused\")\nobject ButtonFormTarget {\n    val blank : String = \"_blank\"\n    val parent : String = \"_parent\"\n    val self : String = \"_self\"\n    val top : String = \"_top\"\n\n    val values : List<String> = listOf(\"blank\", \"parent\", \"self\", \"top\")\n}\n\n@Suppress(\"unused\")\nenum class ButtonType(override val realValue : String) : AttributeEnum {\n    button(\"button\"),\n    reset(\"reset\"),\n    submit(\"submit\")\n}\n\ninternal val buttonTypeValues : Map<String, ButtonType> = ButtonType.values().associateBy { it.realValue }\n@Suppress(\"unused\")\nenum class CommandType(override val realValue : String) : AttributeEnum {\n    command(\"command\"),\n    checkBox(\"checkbox\"),\n    radio(\"radio\")\n}\n\ninternal val commandTypeValues : Map<String, CommandType> = CommandType.values().associateBy { it.realValue }\n@Suppress(\"unused\")\nenum class FormEncType(override val realValue : String) : AttributeEnum {\n    multipartFormData(\"multipart/form-data\"),\n    applicationXWwwFormUrlEncoded(\"application/x-www-form-urlencoded\"),\n    textPlain(\"text/plain\")\n}\n\ninternal val formEncTypeValues : Map<String, FormEncType> = FormEncType.values().associateBy { it.realValue }\n@Suppress(\"unused\")\nenum class FormMethod(override val realValue : String) : AttributeEnum {\n    get(\"get\"),\n    post(\"post\"),\n    @Deprecated(\"method is not allowed in browsers\") put(\"put\"),\n    @Deprecated(\"method is not allowed in browsers\") delete(\"delete\"),\n    @Deprecated(\"method is not allowed in browsers\") patch(\"patch\")\n}\n\ninternal val formMethodValues : Map<String, FormMethod> = FormMethod.values().associateBy { it.realValue }\n@Suppress(\"unused\")\nobject FormTarget {\n    val blank : String = \"_blank\"\n    val parent : String = \"_parent\"\n    val self : String = \"_self\"\n    val top : String = \"_top\"\n\n    val values : List<String> = listOf(\"blank\", \"parent\", \"self\", \"top\")\n}\n\n@Suppress(\"unused\")\nobject IframeName {\n    val blank : String = \"_blank\"\n    val parent : String = \"_parent\"\n    val self : String = \"_self\"\n    val top : String = \"_top\"\n\n    val values : List<String> = listOf(\"blank\", \"parent\", \"self\", \"top\")\n}\n\n@Suppress(\"unused\")\nenum class IframeSandbox(override val realValue : String) : AttributeEnum {\n    allowSameOrigin(\"allow-same-origin\"),\n    allowFormS(\"allow-forms\"),\n    allowScripts(\"allow-scripts\")\n}\n\ninternal val iframeSandboxValues : Map<String, IframeSandbox> = IframeSandbox.values().associateBy { it.realValue }\n@Suppress(\"unused\")\nenum class InputType(override val realValue : String) : AttributeEnum {\n    button(\"button\"),\n    checkBox(\"checkbox\"),\n    color(\"color\"),\n    date(\"date\"),\n    dateTime(\"datetime\"),\n    dateTimeLocal(\"datetime-local\"),\n    email(\"email\"),\n    file(\"file\"),\n    hidden(\"hidden\"),\n    image(\"image\"),\n    month(\"month\"),\n    number(\"number\"),\n    password(\"password\"),\n    radio(\"radio\"),\n    range(\"range\"),\n    reset(\"reset\"),\n    search(\"search\"),\n    submit(\"submit\"),\n    text(\"text\"),\n    tel(\"tel\"),\n    time(\"time\"),\n    url(\"url\"),\n    week(\"week\")\n}\n\ninternal val inputTypeValues : Map<String, InputType> = InputType.values().associateBy { it.realValue }\n@Suppress(\"unused\")\nenum class InputFormEncType(override val realValue : String) : AttributeEnum {\n    multipartFormData(\"multipart/form-data\"),\n    applicationXWwwFormUrlEncoded(\"application/x-www-form-urlencoded\"),\n    textPlain(\"text/plain\")\n}\n\ninternal val inputFormEncTypeValues : Map<String, InputFormEncType> = InputFormEncType.values().associateBy { it.realValue }\n@Suppress(\"unused\")\nenum class InputFormMethod(override val realValue : String) : AttributeEnum {\n    get(\"get\"),\n    post(\"post\"),\n    @Deprecated(\"method is not allowed in browsers\") put(\"put\"),\n    @Deprecated(\"method is not allowed in browsers\") delete(\"delete\"),\n    @Deprecated(\"method is not allowed in browsers\") patch(\"patch\")\n}\n\ninternal val inputFormMethodValues : Map<String, InputFormMethod> = InputFormMethod.values().associateBy { it.realValue }\n@Suppress(\"unused\")\nobject InputFormTarget {\n    val blank : String = \"_blank\"\n    val parent : String = \"_parent\"\n    val self : String = \"_self\"\n    val top : String = \"_top\"\n\n    val values : List<String> = listOf(\"blank\", \"parent\", \"self\", \"top\")\n}\n\n@Suppress(\"unused\")\nenum class KeyGenKeyType(override val realValue : String) : AttributeEnum {\n    rsa(\"rsa\")\n}\n\ninternal val keyGenKeyTypeValues : Map<String, KeyGenKeyType> = KeyGenKeyType.values().associateBy { it.realValue }\n@Suppress(\"unused\")\nobject LinkRel {\n    val alternate : String = \"Alternate\"\n    val appEndIx : String = \"Appendix\"\n    val bookmark : String = \"Bookmark\"\n    val chapter : String = \"Chapter\"\n    val contentS : String = \"Contents\"\n    val copyright : String = \"Copyright\"\n    val glossary : String = \"Glossary\"\n    val help : String = \"Help\"\n    val index : String = \"Index\"\n    val next : String = \"Next\"\n    val prev : String = \"Prev\"\n    val section : String = \"Section\"\n    val start : String = \"Start\"\n    val stylesheet : String = \"Stylesheet\"\n    val subsection : String = \"Subsection\"\n\n    val values : List<String> = listOf(\"alternate\", \"appEndIx\", \"bookmark\", \"chapter\", \"contentS\", \"copyright\", \"glossary\", \"help\", \"index\", \"next\", \"prev\", \"section\", \"start\", \"stylesheet\", \"subsection\")\n}\n\n@Suppress(\"unused\")\nobject LinkMedia {\n    val screen : String = \"screen\"\n    val print : String = \"print\"\n    val tty : String = \"tty\"\n    val tv : String = \"tv\"\n    val projection : String = \"projection\"\n    val handheld : String = \"handheld\"\n    val braille : String = \"braille\"\n    val aural : String = \"aural\"\n    val all : String = \"all\"\n\n    val values : List<String> = listOf(\"screen\", \"print\", \"tty\", \"tv\", \"projection\", \"handheld\", \"braille\", \"aural\", \"all\")\n}\n\n@Suppress(\"unused\")\nobject LinkType {\n    val textAsp : String = \"text/asp\"\n    val textAsa : String = \"text/asa\"\n    val textCss : String = \"text/css\"\n    val textHtml : String = \"text/html\"\n    val textJavaScript : String = \"text/javascript\"\n    val textPlain : String = \"text/plain\"\n    val textScriptLet : String = \"text/scriptlet\"\n    val textXComponent : String = \"text/x-component\"\n    val textXHtmlInsertion : String = \"text/x-html-insertion\"\n    val textXml : String = \"text/xml\"\n\n    val values : List<String> = listOf(\"textAsp\", \"textAsa\", \"textCss\", \"textHtml\", \"textJavaScript\", \"textPlain\", \"textScriptLet\", \"textXComponent\", \"textXHtmlInsertion\", \"textXml\")\n}\n\n@Suppress(\"unused\")\nobject MetaHttpEquiv {\n    val contentLanguage : String = \"content-language\"\n    val contentType : String = \"content-type\"\n    val defaultStyle : String = \"default-style\"\n    val refresh : String = \"refresh\"\n\n    val values : List<String> = listOf(\"contentLanguage\", \"contentType\", \"defaultStyle\", \"refresh\")\n}\n\n@Suppress(\"unused\")\nobject ObjectName {\n    val blank : String = \"_blank\"\n    val parent : String = \"_parent\"\n    val self : String = \"_self\"\n    val top : String = \"_top\"\n\n    val values : List<String> = listOf(\"blank\", \"parent\", \"self\", \"top\")\n}\n\n@Suppress(\"unused\")\nobject ScriptType {\n    val textEcmaScript : String = \"text/ecmascript\"\n    val textJavaScript : String = \"text/javascript\"\n    val textJavaScript10 : String = \"text/javascript1.0\"\n    val textJavaScript11 : String = \"text/javascript1.1\"\n    val textJavaScript12 : String = \"text/javascript1.2\"\n    val textJavaScript13 : String = \"text/javascript1.3\"\n    val textJavaScript14 : String = \"text/javascript1.4\"\n    val textJavaScript15 : String = \"text/javascript1.5\"\n    val textJScript : String = \"text/jscript\"\n    val textXJavaScript : String = \"text/x-javascript\"\n    val textXEcmaScript : String = \"text/x-ecmascript\"\n    val textVbScript : String = \"text/vbscript\"\n\n    val values : List<String> = listOf(\"textEcmaScript\", \"textJavaScript\", \"textJavaScript10\", \"textJavaScript11\", \"textJavaScript12\", \"textJavaScript13\", \"textJavaScript14\", \"textJavaScript15\", \"textJScript\", \"textXJavaScript\", \"textXEcmaScript\", \"textVbScript\")\n}\n\n@Suppress(\"unused\")\nobject StyleType {\n    val textCss : String = \"text/css\"\n\n    val values : List<String> = listOf(\"textCss\")\n}\n\n@Suppress(\"unused\")\nobject StyleMedia {\n    val screen : String = \"screen\"\n    val print : String = \"print\"\n    val tty : String = \"tty\"\n    val tv : String = \"tv\"\n    val projection : String = \"projection\"\n    val handheld : String = \"handheld\"\n    val braille : String = \"braille\"\n    val aural : String = \"aural\"\n    val all : String = \"all\"\n\n    val values : List<String> = listOf(\"screen\", \"print\", \"tty\", \"tv\", \"projection\", \"handheld\", \"braille\", \"aural\", \"all\")\n}\n\n@Suppress(\"unused\")\nenum class TextAreaWrap(override val realValue : String) : AttributeEnum {\n    hard(\"hard\"),\n    soft(\"soft\")\n}\n\ninternal val textAreaWrapValues : Map<String, TextAreaWrap> = TextAreaWrap.values().associateBy { it.realValue }\n@Suppress(\"unused\")\nenum class ThScope(override val realValue : String) : AttributeEnum {\n    col(\"col\"),\n    colGroup(\"colgroup\"),\n    row(\"row\"),\n    rowGroup(\"rowgroup\")\n}\n\ninternal val thScopeValues : Map<String, ThScope> = ThScope.values().associateBy { it.realValue }\n","package kotlinx.html\n\nimport kotlinx.html.*\nimport kotlinx.html.impl.*\nimport kotlinx.html.attributes.*\n\n/*******************************************************************************\n    DO NOT EDIT\n    This file was generated by module generate\n*******************************************************************************/\n\n@Suppress(\"unused\")\nopen class B(initialAttributes : Map<String, String>, override val consumer : TagConsumer<*>) : HTMLTag(\"b\", consumer, initialAttributes, null, true, false), HtmlBlockInlineTag {\n\n}\nval B.asFlowContent : FlowContent\n    get()  = this\n\nval B.asPhrasingContent : PhrasingContent\n    get()  = this\n\n\n@Suppress(\"unused\")\nopen class BASE(initialAttributes : Map<String, String>, override val consumer : TagConsumer<*>) : HTMLTag(\"base\", consumer, initialAttributes, null, true, true), HtmlHeadTag {\n    var href : String\n        get()  = attributeStringString.get(this, \"href\")\n        set(newValue) {attributeStringString.set(this, \"href\", newValue)}\n\n    var target : String\n        get()  = attributeStringString.get(this, \"target\")\n        set(newValue) {attributeStringString.set(this, \"target\", newValue)}\n\n\n}\n\n@Suppress(\"unused\")\nopen class BDI(initialAttributes : Map<String, String>, override val consumer : TagConsumer<*>) : HTMLTag(\"bdi\", consumer, initialAttributes, null, true, false), HtmlBlockInlineTag {\n\n}\nval BDI.asFlowContent : FlowContent\n    get()  = this\n\nval BDI.asPhrasingContent : PhrasingContent\n    get()  = this\n\n\n@Suppress(\"unused\")\nopen class BDO(initialAttributes : Map<String, String>, override val consumer : TagConsumer<*>) : HTMLTag(\"bdo\", consumer, initialAttributes, null, true, false), HtmlBlockInlineTag {\n\n}\nval BDO.asFlowContent : FlowContent\n    get()  = this\n\nval BDO.asPhrasingContent : PhrasingContent\n    get()  = this\n\n\n@Suppress(\"unused\")\nopen class BLOCKQUOTE(initialAttributes : Map<String, String>, override val consumer : TagConsumer<*>) : HTMLTag(\"blockquote\", consumer, initialAttributes, null, false, false), HtmlBlockTag {\n    var cite : String\n        get()  = attributeStringString.get(this, \"cite\")\n        set(newValue) {attributeStringString.set(this, \"cite\", newValue)}\n\n\n}\n\n@Suppress(\"unused\")\nopen class BODY(initialAttributes : Map<String, String>, override val consumer : TagConsumer<*>) : HTMLTag(\"body\", consumer, initialAttributes, null, false, false), HtmlBlockTag {\n    var onAfterprint : String\n        get()  = attributeStringString.get(this, \"onafterprint\")\n        set(newValue) {attributeStringString.set(this, \"onafterprint\", newValue)}\n\n    var onBeforeprint : String\n        get()  = attributeStringString.get(this, \"onbeforeprint\")\n        set(newValue) {attributeStringString.set(this, \"onbeforeprint\", newValue)}\n\n    var onBeforeunLoad : String\n        get()  = attributeStringString.get(this, \"onbeforeunload\")\n        set(newValue) {attributeStringString.set(this, \"onbeforeunload\", newValue)}\n\n    var onHashChange : String\n        get()  = attributeStringString.get(this, \"onhashchange\")\n        set(newValue) {attributeStringString.set(this, \"onhashchange\", newValue)}\n\n    var onMessage : String\n        get()  = attributeStringString.get(this, \"onmessage\")\n        set(newValue) {attributeStringString.set(this, \"onmessage\", newValue)}\n\n    var onOffline : String\n        get()  = attributeStringString.get(this, \"onoffline\")\n        set(newValue) {attributeStringString.set(this, \"onoffline\", newValue)}\n\n    var onOnline : String\n        get()  = attributeStringString.get(this, \"ononline\")\n        set(newValue) {attributeStringString.set(this, \"ononline\", newValue)}\n\n    var onPopstate : String\n        get()  = attributeStringString.get(this, \"onpopstate\")\n        set(newValue) {attributeStringString.set(this, \"onpopstate\", newValue)}\n\n    var onRedo : String\n        get()  = attributeStringString.get(this, \"onredo\")\n        set(newValue) {attributeStringString.set(this, \"onredo\", newValue)}\n\n    var onResize : String\n        get()  = attributeStringString.get(this, \"onresize\")\n        set(newValue) {attributeStringString.set(this, \"onresize\", newValue)}\n\n    var onStorage : String\n        get()  = attributeStringString.get(this, \"onstorage\")\n        set(newValue) {attributeStringString.set(this, \"onstorage\", newValue)}\n\n    var onUndo : String\n        get()  = attributeStringString.get(this, \"onundo\")\n        set(newValue) {attributeStringString.set(this, \"onundo\", newValue)}\n\n    var onUnLoad : String\n        get()  = attributeStringString.get(this, \"onunload\")\n        set(newValue) {attributeStringString.set(this, \"onunload\", newValue)}\n\n\n}\n\n@Suppress(\"unused\")\nopen class BR(initialAttributes : Map<String, String>, override val consumer : TagConsumer<*>) : HTMLTag(\"br\", consumer, initialAttributes, null, true, true), HtmlBlockInlineTag {\n\n}\nval BR.asFlowContent : FlowContent\n    get()  = this\n\nval BR.asPhrasingContent : PhrasingContent\n    get()  = this\n\n\n@Suppress(\"unused\")\nopen class BUTTON(initialAttributes : Map<String, String>, override val consumer : TagConsumer<*>) : HTMLTag(\"button\", consumer, initialAttributes, null, true, false), CommonAttributeGroupFacadeFlowInteractivePhrasingContent {\n    var autoFocus : Boolean\n        get()  = attributeBooleanTicker.get(this, \"autofocus\")\n        set(newValue) {attributeBooleanTicker.set(this, \"autofocus\", newValue)}\n\n    var disabled : Boolean\n        get()  = attributeBooleanTicker.get(this, \"disabled\")\n        set(newValue) {attributeBooleanTicker.set(this, \"disabled\", newValue)}\n\n    var form : String\n        get()  = attributeStringString.get(this, \"form\")\n        set(newValue) {attributeStringString.set(this, \"form\", newValue)}\n\n    var formAction : String\n        get()  = attributeStringString.get(this, \"formaction\")\n        set(newValue) {attributeStringString.set(this, \"formaction\", newValue)}\n\n    var formEncType : ButtonFormEncType\n        get()  = attributeButtonFormEncTypeEnumButtonFormEncTypeValues.get(this, \"formenctype\")\n        set(newValue) {attributeButtonFormEncTypeEnumButtonFormEncTypeValues.set(this, \"formenctype\", newValue)}\n\n    var formMethod : ButtonFormMethod\n        get()  = attributeButtonFormMethodEnumButtonFormMethodValues.get(this, \"formmethod\")\n        set(newValue) {attributeButtonFormMethodEnumButtonFormMethodValues.set(this, \"formmethod\", newValue)}\n\n    var formNovalidate : Boolean\n        get()  = attributeBooleanTicker.get(this, \"formnovalidate\")\n        set(newValue) {attributeBooleanTicker.set(this, \"formnovalidate\", newValue)}\n\n    var formTarget : String\n        get()  = attributeStringString.get(this, \"formtarget\")\n        set(newValue) {attributeStringString.set(this, \"formtarget\", newValue)}\n\n    var name : String\n        get()  = attributeStringString.get(this, \"name\")\n        set(newValue) {attributeStringString.set(this, \"name\", newValue)}\n\n    var value : String\n        get()  = attributeStringString.get(this, \"value\")\n        set(newValue) {attributeStringString.set(this, \"value\", newValue)}\n\n    var type : ButtonType\n        get()  = attributeButtonTypeEnumButtonTypeValues.get(this, \"type\")\n        set(newValue) {attributeButtonTypeEnumButtonTypeValues.set(this, \"type\", newValue)}\n\n\n}\nval BUTTON.asFlowContent : FlowContent\n    get()  = this\n\nval BUTTON.asInteractiveContent : InteractiveContent\n    get()  = this\n\nval BUTTON.asPhrasingContent : PhrasingContent\n    get()  = this\n\n\n","package kotlinx.html\n\nimport kotlinx.html.*\nimport kotlinx.html.impl.*\nimport kotlinx.html.attributes.*\n\n/*******************************************************************************\n    DO NOT EDIT\n    This file was generated by module generate\n*******************************************************************************/\n\n@Suppress(\"unused\")\nopen class I(initialAttributes : Map<String, String>, override val consumer : TagConsumer<*>) : HTMLTag(\"i\", consumer, initialAttributes, null, true, false), HtmlBlockInlineTag {\n\n}\nval I.asFlowContent : FlowContent\n    get()  = this\n\nval I.asPhrasingContent : PhrasingContent\n    get()  = this\n\n\n@Suppress(\"unused\")\nopen class IFRAME(initialAttributes : Map<String, String>, override val consumer : TagConsumer<*>) : HTMLTag(\"iframe\", consumer, initialAttributes, null, true, false), CommonAttributeGroupFacadeFlowInteractivePhrasingContent {\n    var name : String\n        get()  = attributeStringString.get(this, \"name\")\n        set(newValue) {attributeStringString.set(this, \"name\", newValue)}\n\n    var src : String\n        get()  = attributeStringString.get(this, \"src\")\n        set(newValue) {attributeStringString.set(this, \"src\", newValue)}\n\n    var height : String\n        get()  = attributeStringString.get(this, \"height\")\n        set(newValue) {attributeStringString.set(this, \"height\", newValue)}\n\n    var width : String\n        get()  = attributeStringString.get(this, \"width\")\n        set(newValue) {attributeStringString.set(this, \"width\", newValue)}\n\n    var sandbox : IframeSandbox\n        get()  = attributeIframeSandboxEnumIframeSandboxValues.get(this, \"sandbox\")\n        set(newValue) {attributeIframeSandboxEnumIframeSandboxValues.set(this, \"sandbox\", newValue)}\n\n    var seamless : Boolean\n        get()  = attributeBooleanTicker.get(this, \"seamless\")\n        set(newValue) {attributeBooleanTicker.set(this, \"seamless\", newValue)}\n\n\n}\nval IFRAME.asFlowContent : FlowContent\n    get()  = this\n\nval IFRAME.asInteractiveContent : InteractiveContent\n    get()  = this\n\nval IFRAME.asPhrasingContent : PhrasingContent\n    get()  = this\n\n\n@Suppress(\"unused\")\nopen class IMG(initialAttributes : Map<String, String>, override val consumer : TagConsumer<*>) : HTMLTag(\"img\", consumer, initialAttributes, null, true, true), CommonAttributeGroupFacadeFlowInteractivePhrasingContent {\n    var alt : String\n        get()  = attributeStringString.get(this, \"alt\")\n        set(newValue) {attributeStringString.set(this, \"alt\", newValue)}\n\n    var src : String\n        get()  = attributeStringString.get(this, \"src\")\n        set(newValue) {attributeStringString.set(this, \"src\", newValue)}\n\n    var height : String\n        get()  = attributeStringString.get(this, \"height\")\n        set(newValue) {attributeStringString.set(this, \"height\", newValue)}\n\n    var width : String\n        get()  = attributeStringString.get(this, \"width\")\n        set(newValue) {attributeStringString.set(this, \"width\", newValue)}\n\n    var usemap : String\n        get()  = attributeStringString.get(this, \"usemap\")\n        set(newValue) {attributeStringString.set(this, \"usemap\", newValue)}\n\n    var ismap : Boolean\n        get()  = attributeBooleanTicker.get(this, \"ismap\")\n        set(newValue) {attributeBooleanTicker.set(this, \"ismap\", newValue)}\n\n\n}\nval IMG.asFlowContent : FlowContent\n    get()  = this\n\nval IMG.asInteractiveContent : InteractiveContent\n    get()  = this\n\nval IMG.asPhrasingContent : PhrasingContent\n    get()  = this\n\n\n@Suppress(\"unused\")\nopen class INPUT(initialAttributes : Map<String, String>, override val consumer : TagConsumer<*>) : HTMLTag(\"input\", consumer, initialAttributes, null, true, true), CommonAttributeGroupFacadeFlowInteractivePhrasingContent {\n    var type : InputType\n        get()  = attributeInputTypeEnumInputTypeValues.get(this, \"type\")\n        set(newValue) {attributeInputTypeEnumInputTypeValues.set(this, \"type\", newValue)}\n\n    var accept : String\n        get()  = attributeStringString.get(this, \"accept\")\n        set(newValue) {attributeStringString.set(this, \"accept\", newValue)}\n\n    var alt : String\n        get()  = attributeStringString.get(this, \"alt\")\n        set(newValue) {attributeStringString.set(this, \"alt\", newValue)}\n\n    var autoFocus : Boolean\n        get()  = attributeBooleanTicker.get(this, \"autofocus\")\n        set(newValue) {attributeBooleanTicker.set(this, \"autofocus\", newValue)}\n\n    var autoComplete : Boolean\n        get()  = attributeBooleanBooleanOnOff.get(this, \"autocomplete\")\n        set(newValue) {attributeBooleanBooleanOnOff.set(this, \"autocomplete\", newValue)}\n\n    var checked : Boolean\n        get()  = attributeBooleanTicker.get(this, \"checked\")\n        set(newValue) {attributeBooleanTicker.set(this, \"checked\", newValue)}\n\n    var disabled : Boolean\n        get()  = attributeBooleanTicker.get(this, \"disabled\")\n        set(newValue) {attributeBooleanTicker.set(this, \"disabled\", newValue)}\n\n    var form : String\n        get()  = attributeStringString.get(this, \"form\")\n        set(newValue) {attributeStringString.set(this, \"form\", newValue)}\n\n    var formAction : String\n        get()  = attributeStringString.get(this, \"formaction\")\n        set(newValue) {attributeStringString.set(this, \"formaction\", newValue)}\n\n    var formEncType : InputFormEncType\n        get()  = attributeInputFormEncTypeEnumInputFormEncTypeValues.get(this, \"formenctype\")\n        set(newValue) {attributeInputFormEncTypeEnumInputFormEncTypeValues.set(this, \"formenctype\", newValue)}\n\n    var formMethod : InputFormMethod\n        get()  = attributeInputFormMethodEnumInputFormMethodValues.get(this, \"formmethod\")\n        set(newValue) {attributeInputFormMethodEnumInputFormMethodValues.set(this, \"formmethod\", newValue)}\n\n    var formNovalidate : Boolean\n        get()  = attributeBooleanTicker.get(this, \"formnovalidate\")\n        set(newValue) {attributeBooleanTicker.set(this, \"formnovalidate\", newValue)}\n\n    var formTarget : String\n        get()  = attributeStringString.get(this, \"formtarget\")\n        set(newValue) {attributeStringString.set(this, \"formtarget\", newValue)}\n\n    var height : String\n        get()  = attributeStringString.get(this, \"height\")\n        set(newValue) {attributeStringString.set(this, \"height\", newValue)}\n\n    var list : String\n        get()  = attributeStringString.get(this, \"list\")\n        set(newValue) {attributeStringString.set(this, \"list\", newValue)}\n\n    var max : String\n        get()  = attributeStringString.get(this, \"max\")\n        set(newValue) {attributeStringString.set(this, \"max\", newValue)}\n\n    var maxLength : String\n        get()  = attributeStringString.get(this, \"maxlength\")\n        set(newValue) {attributeStringString.set(this, \"maxlength\", newValue)}\n\n    var minLength : String\n        get()  = attributeStringString.get(this, \"minlength\")\n        set(newValue) {attributeStringString.set(this, \"minlength\", newValue)}\n\n    var min : String\n        get()  = attributeStringString.get(this, \"min\")\n        set(newValue) {attributeStringString.set(this, \"min\", newValue)}\n\n    var multiple : Boolean\n        get()  = attributeBooleanTicker.get(this, \"multiple\")\n        set(newValue) {attributeBooleanTicker.set(this, \"multiple\", newValue)}\n\n    var pattern : String\n        get()  = attributeStringString.get(this, \"pattern\")\n        set(newValue) {attributeStringString.set(this, \"pattern\", newValue)}\n\n    var placeholder : String\n        get()  = attributeStringString.get(this, \"placeholder\")\n        set(newValue) {attributeStringString.set(this, \"placeholder\", newValue)}\n\n    var readonly : Boolean\n        get()  = attributeBooleanTicker.get(this, \"readonly\")\n        set(newValue) {attributeBooleanTicker.set(this, \"readonly\", newValue)}\n\n    var required : Boolean\n        get()  = attributeBooleanTicker.get(this, \"required\")\n        set(newValue) {attributeBooleanTicker.set(this, \"required\", newValue)}\n\n    var size : String\n        get()  = attributeStringString.get(this, \"size\")\n        set(newValue) {attributeStringString.set(this, \"size\", newValue)}\n\n    var src : String\n        get()  = attributeStringString.get(this, \"src\")\n        set(newValue) {attributeStringString.set(this, \"src\", newValue)}\n\n    var step : String\n        get()  = attributeStringString.get(this, \"step\")\n        set(newValue) {attributeStringString.set(this, \"step\", newValue)}\n\n    var width : String\n        get()  = attributeStringString.get(this, \"width\")\n        set(newValue) {attributeStringString.set(this, \"width\", newValue)}\n\n    var files : String\n        get()  = attributeStringString.get(this, \"files\")\n        set(newValue) {attributeStringString.set(this, \"files\", newValue)}\n\n    var value : String\n        get()  = attributeStringString.get(this, \"value\")\n        set(newValue) {attributeStringString.set(this, \"value\", newValue)}\n\n    var name : String\n        get()  = attributeStringString.get(this, \"name\")\n        set(newValue) {attributeStringString.set(this, \"name\", newValue)}\n\n\n}\nval INPUT.asFlowContent : FlowContent\n    get()  = this\n\nval INPUT.asInteractiveContent : InteractiveContent\n    get()  = this\n\nval INPUT.asPhrasingContent : PhrasingContent\n    get()  = this\n\n\n@Suppress(\"unused\")\nopen class INS(initialAttributes : Map<String, String>, override val consumer : TagConsumer<*>) : HTMLTag(\"ins\", consumer, initialAttributes, null, false, false), HtmlBlockInlineTag {\n    var cite : String\n        get()  = attributeStringString.get(this, \"cite\")\n        set(newValue) {attributeStringString.set(this, \"cite\", newValue)}\n\n    var dateTime : String\n        get()  = attributeStringString.get(this, \"datetime\")\n        set(newValue) {attributeStringString.set(this, \"datetime\", newValue)}\n\n\n}\nval INS.asFlowContent : FlowContent\n    get()  = this\n\nval INS.asPhrasingContent : PhrasingContent\n    get()  = this\n\n\n","package kotlinx.html\n\nimport kotlinx.html.*\nimport kotlinx.html.impl.*\nimport kotlinx.html.attributes.*\n\n/*******************************************************************************\n    DO NOT EDIT\n    This file was generated by module generate\n*******************************************************************************/\n\n@Suppress(\"unused\")\nopen class OBJECT(initialAttributes : Map<String, String>, override val consumer : TagConsumer<*>) : HTMLTag(\"object\", consumer, initialAttributes, null, true, false), CommonAttributeGroupFacadeFlowInteractivePhrasingContent {\n    var data : String\n        get()  = attributeStringString.get(this, \"data\")\n        set(newValue) {attributeStringString.set(this, \"data\", newValue)}\n\n    var type : String\n        get()  = attributeStringString.get(this, \"type\")\n        set(newValue) {attributeStringString.set(this, \"type\", newValue)}\n\n    var height : String\n        get()  = attributeStringString.get(this, \"height\")\n        set(newValue) {attributeStringString.set(this, \"height\", newValue)}\n\n    var width : String\n        get()  = attributeStringString.get(this, \"width\")\n        set(newValue) {attributeStringString.set(this, \"width\", newValue)}\n\n    var usemap : String\n        get()  = attributeStringString.get(this, \"usemap\")\n        set(newValue) {attributeStringString.set(this, \"usemap\", newValue)}\n\n    var name : String\n        get()  = attributeStringString.get(this, \"name\")\n        set(newValue) {attributeStringString.set(this, \"name\", newValue)}\n\n    var form : String\n        get()  = attributeStringString.get(this, \"form\")\n        set(newValue) {attributeStringString.set(this, \"form\", newValue)}\n\n    var classId : String\n        get()  = attributeStringString.get(this, \"classid\")\n        set(newValue) {attributeStringString.set(this, \"classid\", newValue)}\n\n\n}\n/**\n * Named property value\n */\n@HtmlTagMarker\ninline fun OBJECT.param(name : String? = null, value : String? = null, crossinline block : PARAM.() -> Unit = {}) : Unit = PARAM(attributesMapOf(\"name\", name,\"value\", value), consumer).visit(block)\n\nval OBJECT.asFlowContent : FlowContent\n    get()  = this\n\nval OBJECT.asInteractiveContent : InteractiveContent\n    get()  = this\n\nval OBJECT.asPhrasingContent : PhrasingContent\n    get()  = this\n\n\n@Suppress(\"unused\")\nopen class OL(initialAttributes : Map<String, String>, override val consumer : TagConsumer<*>) : HTMLTag(\"ol\", consumer, initialAttributes, null, false, false), HtmlBlockTag {\n    var start : String\n        get()  = attributeStringString.get(this, \"start\")\n        set(newValue) {attributeStringString.set(this, \"start\", newValue)}\n\n    var reversed : Boolean\n        get()  = attributeBooleanTicker.get(this, \"reversed\")\n        set(newValue) {attributeBooleanTicker.set(this, \"reversed\", newValue)}\n\n\n}\n/**\n * List item\n */\n@HtmlTagMarker\ninline fun OL.li(classes : String? = null, crossinline block : LI.() -> Unit = {}) : Unit = LI(attributesMapOf(\"class\", classes), consumer).visit(block)\n\n\n@Suppress(\"unused\")\nopen class OPTGROUP(initialAttributes : Map<String, String>, override val consumer : TagConsumer<*>) : HTMLTag(\"optgroup\", consumer, initialAttributes, null, true, false), CommonAttributeGroupFacade {\n    var disabled : Boolean\n        get()  = attributeBooleanTicker.get(this, \"disabled\")\n        set(newValue) {attributeBooleanTicker.set(this, \"disabled\", newValue)}\n\n    var label : String\n        get()  = attributeStringString.get(this, \"label\")\n        set(newValue) {attributeStringString.set(this, \"label\", newValue)}\n\n\n}\n/**\n * Selectable choice\n */\n@HtmlTagMarker\ninline fun OPTGROUP.option(classes : String? = null, crossinline block : OPTION.() -> Unit = {}) : Unit = OPTION(attributesMapOf(\"class\", classes), consumer).visit(block)\n/**\n * Selectable choice\n */\n@HtmlTagMarker\nfun OPTGROUP.option(classes : String? = null, content : String = \"\") : Unit = OPTION(attributesMapOf(\"class\", classes), consumer).visit({+content})\n\n\n@Suppress(\"unused\")\nopen class OPTION(initialAttributes : Map<String, String>, override val consumer : TagConsumer<*>) : HTMLTag(\"option\", consumer, initialAttributes, null, true, false), CommonAttributeGroupFacade {\n    var disabled : Boolean\n        get()  = attributeBooleanTicker.get(this, \"disabled\")\n        set(newValue) {attributeBooleanTicker.set(this, \"disabled\", newValue)}\n\n    var selected : Boolean\n        get()  = attributeBooleanTicker.get(this, \"selected\")\n        set(newValue) {attributeBooleanTicker.set(this, \"selected\", newValue)}\n\n    var label : String\n        get()  = attributeStringString.get(this, \"label\")\n        set(newValue) {attributeStringString.set(this, \"label\", newValue)}\n\n    var value : String\n        get()  = attributeStringString.get(this, \"value\")\n        set(newValue) {attributeStringString.set(this, \"value\", newValue)}\n\n\n}\n\n@Suppress(\"unused\")\nopen class OUTPUT(initialAttributes : Map<String, String>, override val consumer : TagConsumer<*>) : HTMLTag(\"output\", consumer, initialAttributes, null, true, false), HtmlBlockInlineTag {\n    var htmlFor : String\n        get()  = attributeStringString.get(this, \"for\")\n        set(newValue) {attributeStringString.set(this, \"for\", newValue)}\n\n    var form : String\n        get()  = attributeStringString.get(this, \"form\")\n        set(newValue) {attributeStringString.set(this, \"form\", newValue)}\n\n    var name : String\n        get()  = attributeStringString.get(this, \"name\")\n        set(newValue) {attributeStringString.set(this, \"name\", newValue)}\n\n\n}\nval OUTPUT.asFlowContent : FlowContent\n    get()  = this\n\nval OUTPUT.asPhrasingContent : PhrasingContent\n    get()  = this\n\n\n","package kotlinx.html\n\nimport kotlinx.html.*\nimport kotlinx.html.impl.*\nimport kotlinx.html.attributes.*\n\n/*******************************************************************************\n    DO NOT EDIT\n    This file was generated by module generate\n*******************************************************************************/\n\n@Suppress(\"unused\")\nopen class TABLE(initialAttributes : Map<String, String>, override val consumer : TagConsumer<*>) : HTMLTag(\"table\", consumer, initialAttributes, null, false, false), HtmlBlockTag {\n    var summary : String\n        get()  = attributeStringString.get(this, \"summary\")\n        set(newValue) {attributeStringString.set(this, \"summary\", newValue)}\n\n\n}\n/**\n * Table caption\n */\n@HtmlTagMarker\ninline fun TABLE.caption(classes : String? = null, crossinline block : CAPTION.() -> Unit = {}) : Unit = CAPTION(attributesMapOf(\"class\", classes), consumer).visit(block)\n\n/**\n * Table column group\n */\n@HtmlTagMarker\ninline fun TABLE.colGroup(classes : String? = null, crossinline block : COLGROUP.() -> Unit = {}) : Unit = COLGROUP(attributesMapOf(\"class\", classes), consumer).visit(block)\n\n/**\n * Table header\n */\n@HtmlTagMarker\ninline fun TABLE.thead(classes : String? = null, crossinline block : THEAD.() -> Unit = {}) : Unit = THEAD(attributesMapOf(\"class\", classes), consumer).visit(block)\n\n/**\n * Table footer\n */\n@HtmlTagMarker\ninline fun TABLE.tfoot(classes : String? = null, crossinline block : TFOOT.() -> Unit = {}) : Unit = TFOOT(attributesMapOf(\"class\", classes), consumer).visit(block)\n\n/**\n * Table body\n */\n@HtmlTagMarker\ninline fun TABLE.tbody(classes : String? = null, crossinline block : TBODY.() -> Unit = {}) : Unit = TBODY(attributesMapOf(\"class\", classes), consumer).visit(block)\n\n/**\n * Table row\n */\n@HtmlTagMarker\ninline fun TABLE.tr(classes : String? = null, crossinline block : TR.() -> Unit = {}) : Unit = TR(attributesMapOf(\"class\", classes), consumer).visit(block)\n\n\n@Suppress(\"unused\")\nopen class TBODY(initialAttributes : Map<String, String>, override val consumer : TagConsumer<*>) : HTMLTag(\"tbody\", consumer, initialAttributes, null, false, false), CommonAttributeGroupFacade {\n\n}\n/**\n * Table row\n */\n@HtmlTagMarker\ninline fun TBODY.tr(classes : String? = null, crossinline block : TR.() -> Unit = {}) : Unit = TR(attributesMapOf(\"class\", classes), consumer).visit(block)\n\n\n@Suppress(\"unused\")\nopen class TD(initialAttributes : Map<String, String>, override val consumer : TagConsumer<*>) : HTMLTag(\"td\", consumer, initialAttributes, null, false, false), HtmlBlockTag {\n    var headers : String\n        get()  = attributeStringString.get(this, \"headers\")\n        set(newValue) {attributeStringString.set(this, \"headers\", newValue)}\n\n    var rowSpan : String\n        get()  = attributeStringString.get(this, \"rowspan\")\n        set(newValue) {attributeStringString.set(this, \"rowspan\", newValue)}\n\n    var colSpan : String\n        get()  = attributeStringString.get(this, \"colspan\")\n        set(newValue) {attributeStringString.set(this, \"colspan\", newValue)}\n\n\n}\n\n@Suppress(\"unused\")\nopen class TEXTAREA(initialAttributes : Map<String, String>, override val consumer : TagConsumer<*>) : HTMLTag(\"textarea\", consumer, initialAttributes, null, true, false), CommonAttributeGroupFacadeFlowInteractivePhrasingContent {\n    var autoFocus : Boolean\n        get()  = attributeBooleanTicker.get(this, \"autofocus\")\n        set(newValue) {attributeBooleanTicker.set(this, \"autofocus\", newValue)}\n\n    var disabled : Boolean\n        get()  = attributeBooleanTicker.get(this, \"disabled\")\n        set(newValue) {attributeBooleanTicker.set(this, \"disabled\", newValue)}\n\n    var form : String\n        get()  = attributeStringString.get(this, \"form\")\n        set(newValue) {attributeStringString.set(this, \"form\", newValue)}\n\n    var maxLength : String\n        get()  = attributeStringString.get(this, \"maxlength\")\n        set(newValue) {attributeStringString.set(this, \"maxlength\", newValue)}\n\n    var minLength : String\n        get()  = attributeStringString.get(this, \"minlength\")\n        set(newValue) {attributeStringString.set(this, \"minlength\", newValue)}\n\n    var name : String\n        get()  = attributeStringString.get(this, \"name\")\n        set(newValue) {attributeStringString.set(this, \"name\", newValue)}\n\n    var placeholder : String\n        get()  = attributeStringString.get(this, \"placeholder\")\n        set(newValue) {attributeStringString.set(this, \"placeholder\", newValue)}\n\n    var readonly : Boolean\n        get()  = attributeBooleanTicker.get(this, \"readonly\")\n        set(newValue) {attributeBooleanTicker.set(this, \"readonly\", newValue)}\n\n    var required : Boolean\n        get()  = attributeBooleanTicker.get(this, \"required\")\n        set(newValue) {attributeBooleanTicker.set(this, \"required\", newValue)}\n\n    var rows : String\n        get()  = attributeStringString.get(this, \"rows\")\n        set(newValue) {attributeStringString.set(this, \"rows\", newValue)}\n\n    var cols : String\n        get()  = attributeStringString.get(this, \"cols\")\n        set(newValue) {attributeStringString.set(this, \"cols\", newValue)}\n\n    var wrap : TextAreaWrap\n        get()  = attributeTextAreaWrapEnumTextAreaWrapValues.get(this, \"wrap\")\n        set(newValue) {attributeTextAreaWrapEnumTextAreaWrapValues.set(this, \"wrap\", newValue)}\n\n\n}\nval TEXTAREA.asFlowContent : FlowContent\n    get()  = this\n\nval TEXTAREA.asInteractiveContent : InteractiveContent\n    get()  = this\n\nval TEXTAREA.asPhrasingContent : PhrasingContent\n    get()  = this\n\n\n@Suppress(\"unused\")\nopen class TFOOT(initialAttributes : Map<String, String>, override val consumer : TagConsumer<*>) : HTMLTag(\"tfoot\", consumer, initialAttributes, null, false, false), CommonAttributeGroupFacade {\n\n}\n/**\n * Table row\n */\n@HtmlTagMarker\ninline fun TFOOT.tr(classes : String? = null, crossinline block : TR.() -> Unit = {}) : Unit = TR(attributesMapOf(\"class\", classes), consumer).visit(block)\n\n\n@Suppress(\"unused\")\nopen class TH(initialAttributes : Map<String, String>, override val consumer : TagConsumer<*>) : HTMLTag(\"th\", consumer, initialAttributes, null, false, false), HtmlInlineTag {\n    var headers : String\n        get()  = attributeStringString.get(this, \"headers\")\n        set(newValue) {attributeStringString.set(this, \"headers\", newValue)}\n\n    var rowSpan : String\n        get()  = attributeStringString.get(this, \"rowspan\")\n        set(newValue) {attributeStringString.set(this, \"rowspan\", newValue)}\n\n    var colSpan : String\n        get()  = attributeStringString.get(this, \"colspan\")\n        set(newValue) {attributeStringString.set(this, \"colspan\", newValue)}\n\n    var scope : ThScope\n        get()  = attributeThScopeEnumThScopeValues.get(this, \"scope\")\n        set(newValue) {attributeThScopeEnumThScopeValues.set(this, \"scope\", newValue)}\n\n\n}\n\n@Suppress(\"unused\")\nopen class THEAD(initialAttributes : Map<String, String>, override val consumer : TagConsumer<*>) : HTMLTag(\"thead\", consumer, initialAttributes, null, false, false), CommonAttributeGroupFacade {\n\n}\n/**\n * Table row\n */\n@HtmlTagMarker\ninline fun THEAD.tr(classes : String? = null, crossinline block : TR.() -> Unit = {}) : Unit = TR(attributesMapOf(\"class\", classes), consumer).visit(block)\n\n\n@Suppress(\"unused\")\nopen class TIME(initialAttributes : Map<String, String>, override val consumer : TagConsumer<*>) : HTMLTag(\"time\", consumer, initialAttributes, null, true, false), HtmlBlockInlineTag {\n    var dateTime : String\n        get()  = attributeStringString.get(this, \"datetime\")\n        set(newValue) {attributeStringString.set(this, \"datetime\", newValue)}\n\n\n}\nval TIME.asFlowContent : FlowContent\n    get()  = this\n\nval TIME.asPhrasingContent : PhrasingContent\n    get()  = this\n\n\n@Suppress(\"unused\")\nopen class TITLE(initialAttributes : Map<String, String>, override val consumer : TagConsumer<*>) : HTMLTag(\"title\", consumer, initialAttributes, null, false, false), HtmlHeadTag {\n\n}\n\n@Suppress(\"unused\")\nopen class TR(initialAttributes : Map<String, String>, override val consumer : TagConsumer<*>) : HTMLTag(\"tr\", consumer, initialAttributes, null, false, false), CommonAttributeGroupFacade {\n\n}\n/**\n * Table header cell\n */\n@HtmlTagMarker\ninline fun TR.th(scope : ThScope? = null, classes : String? = null, crossinline block : TH.() -> Unit = {}) : Unit = TH(attributesMapOf(\"scope\", scope?.enumEncode(),\"class\", classes), consumer).visit(block)\n@HtmlTagMarker\ninline fun TR.colTh(classes : String? = null, crossinline block : TH.() -> Unit = {}) : Unit = TH(attributesMapOf(\"scope\", ThScope.col.realValue,\"class\", classes), consumer).visit(block)\n@HtmlTagMarker\ninline fun TR.colGroupTh(classes : String? = null, crossinline block : TH.() -> Unit = {}) : Unit = TH(attributesMapOf(\"scope\", ThScope.colGroup.realValue,\"class\", classes), consumer).visit(block)\n@HtmlTagMarker\ninline fun TR.rowTh(classes : String? = null, crossinline block : TH.() -> Unit = {}) : Unit = TH(attributesMapOf(\"scope\", ThScope.row.realValue,\"class\", classes), consumer).visit(block)\n@HtmlTagMarker\ninline fun TR.rowGroupTh(classes : String? = null, crossinline block : TH.() -> Unit = {}) : Unit = TH(attributesMapOf(\"scope\", ThScope.rowGroup.realValue,\"class\", classes), consumer).visit(block)\n\n/**\n * Table data cell\n */\n@HtmlTagMarker\ninline fun TR.td(classes : String? = null, crossinline block : TD.() -> Unit = {}) : Unit = TD(attributesMapOf(\"class\", classes), consumer).visit(block)\n\n\n","package kotlinx.html\n\nimport kotlinx.html.impl.*\n\nopen class HTMLTag(\n        override val tagName : String,\n        override val consumer : TagConsumer<*>,\n        initialAttributes : Map<String, String>,\n        override val namespace : String? = null,\n        override val inlineTag: Boolean,\n        override val emptyTag: Boolean) : Tag {\n\n    override val attributes : DelegatingMap = DelegatingMap(initialAttributes, this) { consumer }\n\n    override val attributesEntries: Collection<Map.Entry<String, String>>\n        get() = attributes.immutableEntries\n}\n","package kotlinx.html.stream\n\nimport kotlinx.html.*\nimport kotlinx.html.consumers.*\nimport org.w3c.dom.events.*\n\nclass HTMLStreamBuilder<out O : Appendable>(val out : O, val prettyPrint : Boolean, val xhtmlCompatible: Boolean) : TagConsumer<O> {\n    private var level = 0\n    private var ln = true\n\n    override fun onTagStart(tag: Tag) {\n        if (prettyPrint && !tag.inlineTag) {\n            indent()\n        }\n        level++\n\n        out.append(\"<\")\n        out.append(tag.tagName)\n\n        if (tag.namespace != null) {\n            out.append(\" xmlns=\\\"\")\n            out.append(tag.namespace)\n            out.append(\"\\\"\")\n        }\n\n        if (tag.attributes.isNotEmpty()) {\n            tag.attributesEntries.forEachIndexed { _, e ->\n                if (!e.key.isValidXmlAttributeName()) {\n                    throw IllegalArgumentException(\"Tag ${tag.tagName} has invalid attribute name ${e.key}\")\n                }\n\n                out.append(' ')\n                out.append(e.key)\n                out.append(\"=\\\"\")\n                out.escapeAppend(e.value)\n                out.append('\\\"')\n            }\n        }\n\n        if (xhtmlCompatible && tag.emptyTag) {\n            out.append(\"/\")\n        }\n\n        out.append(\">\")\n        ln = false\n    }\n\n    override fun onTagAttributeChange(tag : Tag, attribute: String, value: String?) {\n        throw UnsupportedOperationException(\"tag attribute can't be changed as it was already written to the stream. Use with DelayedConsumer to be able to modify attributes\")\n    }\n\n    override fun onTagEvent(tag: Tag, event: String, value: (Event) -> Unit) {\n        throw UnsupportedOperationException(\"you can't assign lambda event handler when building text\")\n    }\n\n    override fun onTagEnd(tag: Tag) {\n        level--\n        if (ln) {\n            indent()\n        }\n\n        if (!tag.emptyTag) {\n            out.append(\"</\")\n            out.append(tag.tagName)\n            out.append(\">\")\n        }\n\n        if (prettyPrint && !tag.inlineTag) {\n            appendln()\n        }\n    }\n\n    override fun onTagContent(content: CharSequence) {\n        out.escapeAppend(content)\n        ln = false\n    }\n\n    override fun onTagContentEntity(entity: Entities) {\n        out.append(entity.text)\n        ln = false\n    }\n\n    override fun finalize(): O = out\n\n    override fun onTagContentUnsafe(block: Unsafe.() -> Unit) {\n        UnsafeImpl.block()\n    }\n\n    override fun onTagComment(content: CharSequence) {\n        if (prettyPrint) {\n            indent()\n        }\n\n        out.append(\"<!--\")\n        out.escapeComment(content)\n        out.append(\"-->\")\n\n        ln = false\n    }\n\n    val UnsafeImpl = object : Unsafe {\n        override operator fun String.unaryPlus() {\n            out.append(this)\n        }\n    }\n\n    private fun appendln() {\n        if (prettyPrint && !ln) {\n            out.append(\"\\n\")\n            ln = true\n        }\n    }\n\n    private fun indent() {\n        if (prettyPrint) {\n            if (!ln) {\n                out.append(\"\\n\")\n            }\n            var remaining = level\n            while (remaining >= 4) {\n                out.append(\"        \")\n                remaining -= 4\n            }\n            while (remaining >= 2) {\n                out.append(\"    \")\n                remaining -= 2\n            }\n            if (remaining > 0) {\n                out.append(\"  \")\n            }\n            ln = false\n        }\n    }\n}\n\nprivate val AVERAGE_PAGE_SIZE = 32768\n\nfun createHTML(prettyPrint: Boolean = true, xhtmlCompatible: Boolean = false): TagConsumer<String> =\n        HTMLStreamBuilder(StringBuilder(AVERAGE_PAGE_SIZE), prettyPrint, xhtmlCompatible).onFinalizeMap { sb, _ -> sb.toString() }.delayed()\n\nfun <O : Appendable> O.appendHTML(prettyPrint: Boolean = true, xhtmlCompatible: Boolean = false): TagConsumer<O> =\n        HTMLStreamBuilder(this, prettyPrint, xhtmlCompatible).delayed()\n\n@Deprecated(\"Should be resolved to the previous implementation\", level = DeprecationLevel.HIDDEN)\nfun <O : Appendable> O.appendHTML(prettyPrint: Boolean = true): TagConsumer<O> =\n        appendHTML(prettyPrint, false)\n\nprivate val escapeMap = mapOf(\n        '<' to \"&lt;\",\n        '>' to \"&gt;\",\n        '&' to \"&amp;\",\n        '\\\"' to \"&quot;\"\n).let { mappings ->\n    val maxCode = mappings.keys.map { it.toInt() }.max() ?: -1\n\n    Array(maxCode + 1) { mappings[it.toChar()] }\n}\n\nprivate val letterRangeLowerCase = 'a' .. 'z'\nprivate val letterRangeUpperCase = 'A' .. 'Z'\nprivate val digitRange = '0' .. '9'\n\nprivate fun Char._isLetter() = this in letterRangeLowerCase || this in letterRangeUpperCase\nprivate fun Char._isDigit() = this in digitRange\n\nprivate fun String.isValidXmlAttributeName() =\n        !startsWithXml()\n                && this.isNotEmpty()\n                && (this[0]._isLetter() || this[0] == '_')\n                && this.all { it._isLetter() || it._isDigit() || it in \"._:-\" }\n\nprivate fun String.startsWithXml() = length >= 3\n        && (this[0].let { it == 'x' || it == 'X' })\n        && (this[1].let { it == 'm' || it == 'M' })\n        && (this[2].let { it == 'l' || it == 'L' })\n\nprivate fun Appendable.escapeAppend(s : CharSequence) {\n    var lastIndex = 0\n    val mappings = escapeMap\n    val size = mappings.size\n\n    for (idx in 0 .. s.length - 1) {\n        val ch = s[idx].toInt()\n        if (ch < 0 || ch >= size) continue\n        val escape = mappings[ch]\n        if (escape != null) {\n            append(s.substring(lastIndex, idx))\n            append(escape)\n            lastIndex = idx + 1\n        }\n    }\n\n    if (lastIndex < s.length) {\n        append(s.substring(lastIndex, s.length))\n    }\n}\n\nprivate fun Appendable.escapeComment(s: CharSequence) {\n    var start = 0\n    while (start < s.length) {\n        val index = s.indexOf(\"--\")\n        if (index == -1) {\n            if (start == 0) {\n                append(s)\n            } else {\n                append(s, start, s.length)\n            }\n            break\n        }\n\n        append(s, start, index)\n        start += 2\n    }\n}","package kotlinx.html.dom\n\nimport kotlinx.html.*\nimport kotlinx.html.consumers.*\nimport org.w3c.dom.*\nimport org.w3c.dom.events.*\n\n@Suppress(\"NOTHING_TO_INLINE\")\nprivate inline fun HTMLElement.setEvent(name: String, noinline callback : (Event) -> Unit) : Unit {\n    asDynamic()[name] = callback\n}\n\nclass JSDOMBuilder<out R : HTMLElement>(val document : Document) : TagConsumer<R> {\n    private val path = arrayListOf<HTMLElement>()\n    private var lastLeaved : HTMLElement? = null\n\n    override fun onTagStart(tag: Tag) {\n        val element: HTMLElement = when {\n            tag.namespace != null -> document.createElementNS(tag.namespace!!, tag.tagName).asDynamic()\n            else -> document.createElement(tag.tagName) as HTMLElement\n        }\n\n        tag.attributesEntries.forEach {\n            element.setAttribute(it.key, it.value)\n        }\n\n        if (path.isNotEmpty()) {\n            path.last().appendChild(element)\n        }\n\n        path.add(element)\n    }\n\n    override fun onTagAttributeChange(tag: Tag, attribute: String, value: String?) {\n        when {\n            path.isEmpty() -> throw IllegalStateException(\"No current tag\")\n            path.last().tagName.toLowerCase() != tag.tagName.toLowerCase() -> throw IllegalStateException(\"Wrong current tag\")\n            else -> path.last().let { node ->\n                if (value == null) {\n                    node.removeAttribute(attribute)\n                } else {\n                    node.setAttribute(attribute, value)\n                }\n            }\n        }\n    }\n\n    override fun onTagEvent(tag: Tag, event: String, value: (Event) -> Unit) {\n        when {\n            path.isEmpty() -> throw IllegalStateException(\"No current tag\")\n            path.last().tagName.toLowerCase() != tag.tagName.toLowerCase() -> throw IllegalStateException(\"Wrong current tag\")\n            else -> path.last().setEvent(event, value)\n        }\n    }\n\n    override fun onTagEnd(tag: Tag) {\n        if (path.isEmpty() || path.last().tagName.toLowerCase() != tag.tagName.toLowerCase()) {\n            throw IllegalStateException(\"We haven't entered tag ${tag.tagName} but trying to leave\")\n        }\n\n        lastLeaved = path.removeAt(path.lastIndex)\n    }\n\n    override fun onTagContent(content: CharSequence) {\n        if (path.isEmpty()) {\n            throw IllegalStateException(\"No current DOM node\")\n        }\n\n        path.last().appendChild(document.createTextNode(content.toString()))\n    }\n\n    override fun onTagContentEntity(entity: Entities) {\n        if (path.isEmpty()) {\n            throw IllegalStateException(\"No current DOM node\")\n        }\n\n        // stupid hack as browsers doesn't support createEntityReference\n        val s = document.createElement(\"span\") as HTMLElement\n        s.innerHTML = entity.text\n        path.last().appendChild(s.childNodes.asList().filter { it.nodeType == Node.TEXT_NODE }.first())\n\n        // other solution would be\n//        pathLast().innerHTML += entity.text\n    }\n\n    override fun onTagContentUnsafe(block: Unsafe.() -> Unit) {\n        with(DefaultUnsafe()) {\n            block()\n\n            path.last().innerHTML += toString()\n        }\n    }\n\n\n    override fun onTagComment(content: CharSequence) {\n        if (path.isEmpty()) {\n            throw IllegalStateException(\"No current DOM node\")\n        }\n\n        path.last().appendChild(document.createComment(content.toString()))\n    }\n\n    override fun finalize(): R = lastLeaved?.asR() ?: throw IllegalStateException(\"We can't finalize as there was no tags\")\n\n    @Suppress(\"UNCHECKED_CAST\")\n    private fun HTMLElement.asR(): R = this.asDynamic()\n\n}\n\n\n fun Document.createTree() : TagConsumer<HTMLElement> = JSDOMBuilder(this)\n val Document.create : TagConsumer<HTMLElement>\n    get() = JSDOMBuilder(this)\n\nfun Node.append(block: TagConsumer<HTMLElement>.() -> Unit): List<HTMLElement> =\n    ArrayList<HTMLElement>().let { result ->\n        ownerDocumentExt.createTree().onFinalize { it, partial ->\n            if (!partial) {\n                result.add(it); appendChild(it)\n            }\n        }.block()\n\n        result\n    }\n\nfun Node.prepend(block: TagConsumer<HTMLElement>.() -> Unit): List<HTMLElement> =\n    ArrayList<HTMLElement>().let { result ->\n        ownerDocumentExt.createTree().onFinalize { it, partial ->\n            if (!partial) {\n                result.add(it)\n                insertBefore(it, firstChild)\n            }\n        }.block()\n\n        result\n    }\n\nval HTMLElement.append: TagConsumer<HTMLElement>\n    get() = ownerDocumentExt.createTree().onFinalize { element, partial ->\n        if (!partial) {\n            this@append.appendChild(element)\n        }\n    }\n\nval HTMLElement.prepend: TagConsumer<HTMLElement>\n    get() = ownerDocumentExt.createTree().onFinalize { element, partial ->\n        if (!partial) {\n            this@prepend.insertBefore(element, this@prepend.firstChild)\n        }\n    }\n\nprivate val Node.ownerDocumentExt: Document\n    get() = when {\n        this is Document -> this\n        else -> ownerDocument ?: throw IllegalStateException(\"Node has no ownerDocument\")\n    }\n","package kotlinx.html\n\nactual fun <T : Tag> T.visitTag(block: T.() -> Unit) {\n    consumer.onTagStart(this)\n    try {\n        this.block()\n    } catch (err: Throwable) {\n        consumer.onTagError(this, err)\n    } finally {\n        consumer.onTagEnd(this)\n    }\n}\n\nactual fun <T : Tag, R> T.visitTagAndFinalize(consumer: TagConsumer<R>, block: T.() -> Unit): R {\n    if (this.consumer !== consumer) {\n        throw IllegalArgumentException(\"Wrong exception\")\n    }\n\n    visitTag(block)\n    return consumer.finalize()\n}","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"MapsKt\")\n\npackage kotlin.collections\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.random.*\nimport kotlin.ranges.contains\nimport kotlin.ranges.reversed\n\n/**\n * Returns the first non-null value produced by [transform] function being applied to entries of this map in iteration order,\n * or throws [NoSuchElementException] if no non-null value was produced.\n * \n * @sample samples.collections.Collections.Transformations.firstNotNullOf\n */\n@SinceKotlin(\"1.5\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, R : Any> Map<out K, V>.firstNotNullOf(transform: (Map.Entry<K, V>) -> R?): R {\n    return firstNotNullOfOrNull(transform) ?: throw NoSuchElementException(\"No element of the map was transformed to a non-null value.\")\n}\n\n/**\n * Returns the first non-null value produced by [transform] function being applied to entries of this map in iteration order,\n * or `null` if no non-null value was produced.\n * \n * @sample samples.collections.Collections.Transformations.firstNotNullOf\n */\n@SinceKotlin(\"1.5\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, R : Any> Map<out K, V>.firstNotNullOfOrNull(transform: (Map.Entry<K, V>) -> R?): R? {\n    for (element in this) {\n        val result = transform(element)\n        if (result != null) {\n            return result\n        }\n    }\n    return null\n}\n\n/**\n * Returns a [List] containing all key-value pairs.\n */\npublic fun <K, V> Map<out K, V>.toList(): List<Pair<K, V>> {\n    if (size == 0)\n        return emptyList()\n    val iterator = entries.iterator()\n    if (!iterator.hasNext())\n        return emptyList()\n    val first = iterator.next()\n    if (!iterator.hasNext())\n        return listOf(first.toPair())\n    val result = ArrayList<Pair<K, V>>(size)\n    result.add(first.toPair())\n    do {\n        result.add(iterator.next().toPair())\n    } while (iterator.hasNext())\n    return result\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each entry of original map.\n * \n * @sample samples.collections.Maps.Transformations.flatMap\n */\npublic inline fun <K, V, R> Map<out K, V>.flatMap(transform: (Map.Entry<K, V>) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each entry of original map.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapSequence\")\npublic inline fun <K, V, R> Map<out K, V>.flatMap(transform: (Map.Entry<K, V>) -> Sequence<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each entry of original map, to the given [destination].\n */\npublic inline fun <K, V, R, C : MutableCollection<in R>> Map<out K, V>.flatMapTo(destination: C, transform: (Map.Entry<K, V>) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each entry of original map, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapSequenceTo\")\npublic inline fun <K, V, R, C : MutableCollection<in R>> Map<out K, V>.flatMapTo(destination: C, transform: (Map.Entry<K, V>) -> Sequence<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each entry in the original map.\n * \n * @sample samples.collections.Maps.Transformations.mapToList\n */\npublic inline fun <K, V, R> Map<out K, V>.map(transform: (Map.Entry<K, V>) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each entry in the original map.\n * \n * @sample samples.collections.Maps.Transformations.mapNotNull\n */\npublic inline fun <K, V, R : Any> Map<out K, V>.mapNotNull(transform: (Map.Entry<K, V>) -> R?): List<R> {\n    return mapNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each entry in the original map\n * and appends only the non-null results to the given [destination].\n */\npublic inline fun <K, V, R : Any, C : MutableCollection<in R>> Map<out K, V>.mapNotNullTo(destination: C, transform: (Map.Entry<K, V>) -> R?): C {\n    forEach { element -> transform(element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each entry of the original map\n * and appends the results to the given [destination].\n */\npublic inline fun <K, V, R, C : MutableCollection<in R>> Map<out K, V>.mapTo(destination: C, transform: (Map.Entry<K, V>) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Returns `true` if all entries match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun <K, V> Map<out K, V>.all(predicate: (Map.Entry<K, V>) -> Boolean): Boolean {\n    if (isEmpty()) return true\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if map has at least one entry.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun <K, V> Map<out K, V>.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if at least one entry matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun <K, V> Map<out K, V>.any(predicate: (Map.Entry<K, V>) -> Boolean): Boolean {\n    if (isEmpty()) return false\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns the number of entries in this map.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of entries matching the given [predicate].\n */\npublic inline fun <K, V> Map<out K, V>.count(predicate: (Map.Entry<K, V>) -> Boolean): Int {\n    if (isEmpty()) return 0\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Performs the given [action] on each entry.\n */\n@kotlin.internal.HidesMembers\npublic inline fun <K, V> Map<out K, V>.forEach(action: (Map.Entry<K, V>) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, R : Comparable<R>> Map<out K, V>.maxBy(selector: (Map.Entry<K, V>) -> R): Map.Entry<K, V>? {\n    return maxByOrNull(selector)\n}\n\n/**\n * Returns the first entry yielding the largest value of the given function or `null` if there are no entries.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, R : Comparable<R>> Map<out K, V>.maxByOrNull(selector: (Map.Entry<K, V>) -> R): Map.Entry<K, V>? {\n    return entries.maxByOrNull(selector)\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each entry in the map.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the map is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.maxOf(selector: (Map.Entry<K, V>) -> Double): Double {\n    return entries.maxOf(selector)\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each entry in the map.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the map is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.maxOf(selector: (Map.Entry<K, V>) -> Float): Float {\n    return entries.maxOf(selector)\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each entry in the map.\n * \n * @throws NoSuchElementException if the map is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, R : Comparable<R>> Map<out K, V>.maxOf(selector: (Map.Entry<K, V>) -> R): R {\n    return entries.maxOf(selector)\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each entry in the map or `null` if there are no entries.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.maxOfOrNull(selector: (Map.Entry<K, V>) -> Double): Double? {\n    return entries.maxOfOrNull(selector)\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each entry in the map or `null` if there are no entries.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.maxOfOrNull(selector: (Map.Entry<K, V>) -> Float): Float? {\n    return entries.maxOfOrNull(selector)\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each entry in the map or `null` if there are no entries.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, R : Comparable<R>> Map<out K, V>.maxOfOrNull(selector: (Map.Entry<K, V>) -> R): R? {\n    return entries.maxOfOrNull(selector)\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each entry in the map.\n * \n * @throws NoSuchElementException if the map is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, R> Map<out K, V>.maxOfWith(comparator: Comparator<in R>, selector: (Map.Entry<K, V>) -> R): R {\n    return entries.maxOfWith(comparator, selector)\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each entry in the map or `null` if there are no entries.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, R> Map<out K, V>.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Map.Entry<K, V>) -> R): R? {\n    return entries.maxOfWithOrNull(comparator, selector)\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.maxWith(comparator: Comparator<in Map.Entry<K, V>>): Map.Entry<K, V>? {\n    return maxWithOrNull(comparator)\n}\n\n/**\n * Returns the first entry having the largest value according to the provided [comparator] or `null` if there are no entries.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.maxWithOrNull(comparator: Comparator<in Map.Entry<K, V>>): Map.Entry<K, V>? {\n    return entries.maxWithOrNull(comparator)\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <K, V, R : Comparable<R>> Map<out K, V>.minBy(selector: (Map.Entry<K, V>) -> R): Map.Entry<K, V>? {\n    return minByOrNull(selector)\n}\n\n/**\n * Returns the first entry yielding the smallest value of the given function or `null` if there are no entries.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, R : Comparable<R>> Map<out K, V>.minByOrNull(selector: (Map.Entry<K, V>) -> R): Map.Entry<K, V>? {\n    return entries.minByOrNull(selector)\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each entry in the map.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the map is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.minOf(selector: (Map.Entry<K, V>) -> Double): Double {\n    return entries.minOf(selector)\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each entry in the map.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the map is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.minOf(selector: (Map.Entry<K, V>) -> Float): Float {\n    return entries.minOf(selector)\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each entry in the map.\n * \n * @throws NoSuchElementException if the map is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, R : Comparable<R>> Map<out K, V>.minOf(selector: (Map.Entry<K, V>) -> R): R {\n    return entries.minOf(selector)\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each entry in the map or `null` if there are no entries.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.minOfOrNull(selector: (Map.Entry<K, V>) -> Double): Double? {\n    return entries.minOfOrNull(selector)\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each entry in the map or `null` if there are no entries.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.minOfOrNull(selector: (Map.Entry<K, V>) -> Float): Float? {\n    return entries.minOfOrNull(selector)\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each entry in the map or `null` if there are no entries.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, R : Comparable<R>> Map<out K, V>.minOfOrNull(selector: (Map.Entry<K, V>) -> R): R? {\n    return entries.minOfOrNull(selector)\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each entry in the map.\n * \n * @throws NoSuchElementException if the map is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, R> Map<out K, V>.minOfWith(comparator: Comparator<in R>, selector: (Map.Entry<K, V>) -> R): R {\n    return entries.minOfWith(comparator, selector)\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each entry in the map or `null` if there are no entries.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, R> Map<out K, V>.minOfWithOrNull(comparator: Comparator<in R>, selector: (Map.Entry<K, V>) -> R): R? {\n    return entries.minOfWithOrNull(comparator, selector)\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun <K, V> Map<out K, V>.minWith(comparator: Comparator<in Map.Entry<K, V>>): Map.Entry<K, V>? {\n    return minWithOrNull(comparator)\n}\n\n/**\n * Returns the first entry having the smallest value according to the provided [comparator] or `null` if there are no entries.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.minWithOrNull(comparator: Comparator<in Map.Entry<K, V>>): Map.Entry<K, V>? {\n    return entries.minWithOrNull(comparator)\n}\n\n/**\n * Returns `true` if the map has no entries.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun <K, V> Map<out K, V>.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if no entries match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun <K, V> Map<out K, V>.none(predicate: (Map.Entry<K, V>) -> Boolean): Boolean {\n    if (isEmpty()) return true\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Performs the given [action] on each entry and returns the map itself afterwards.\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <K, V, M : Map<out K, V>> M.onEach(action: (Map.Entry<K, V>) -> Unit): M {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each entry, providing sequential index with the entry,\n * and returns the map itself afterwards.\n * @param [action] function that takes the index of an entry and the entry itself\n * and performs the action on the entry.\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <K, V, M : Map<out K, V>> M.onEachIndexed(action: (index: Int, Map.Entry<K, V>) -> Unit): M {\n    return apply { entries.forEachIndexed(action) }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original map returning its entries when being iterated.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.asIterable(): Iterable<Map.Entry<K, V>> {\n    return entries\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original map returning its entries when being iterated.\n */\npublic fun <K, V> Map<out K, V>.asSequence(): Sequence<Map.Entry<K, V>> {\n    return entries.asSequence()\n}\n\n","package kotlinx.html\n\nimport kotlinx.html.*\nimport kotlinx.html.impl.*\n\n/*******************************************************************************\n    DO NOT EDIT\n    This file was generated by module generate\n*******************************************************************************/\n\ninterface CommonAttributeGroupFacade : Tag {\n}\nvar CommonAttributeGroupFacade.enableTheming : Boolean\n    get()  = attributeBooleanBoolean.get(this, \"EnableTheming\")\n    set(newValue) {attributeBooleanBoolean.set(this, \"EnableTheming\", newValue)}\n\nvar CommonAttributeGroupFacade.enableViewState : Boolean\n    get()  = attributeBooleanBoolean.get(this, \"EnableViewState\")\n    set(newValue) {attributeBooleanBoolean.set(this, \"EnableViewState\", newValue)}\n\nvar CommonAttributeGroupFacade.skinID : String\n    get()  = attributeStringString.get(this, \"SkinID\")\n    set(newValue) {attributeStringString.set(this, \"SkinID\", newValue)}\n\nvar CommonAttributeGroupFacade.visible : Boolean\n    get()  = attributeBooleanBoolean.get(this, \"Visible\")\n    set(newValue) {attributeBooleanBoolean.set(this, \"Visible\", newValue)}\n\nvar CommonAttributeGroupFacade.accessKey : String\n    get()  = attributeStringString.get(this, \"accesskey\")\n    set(newValue) {attributeStringString.set(this, \"accesskey\", newValue)}\n\nvar CommonAttributeGroupFacade.classes : Set<String>\n    get()  = attributeSetStringStringSet.get(this, \"class\")\n    set(newValue) {attributeSetStringStringSet.set(this, \"class\", newValue)}\n\nvar CommonAttributeGroupFacade.contentEditable : Boolean\n    get()  = attributeBooleanBoolean.get(this, \"contenteditable\")\n    set(newValue) {attributeBooleanBoolean.set(this, \"contenteditable\", newValue)}\n\nvar CommonAttributeGroupFacade.contextMenu : String\n    get()  = attributeStringString.get(this, \"contextmenu\")\n    set(newValue) {attributeStringString.set(this, \"contextmenu\", newValue)}\n\nvar CommonAttributeGroupFacade.dataFolderName : String\n    get()  = attributeStringString.get(this, \"data-FolderName\")\n    set(newValue) {attributeStringString.set(this, \"data-FolderName\", newValue)}\n\nvar CommonAttributeGroupFacade.dataMsgId : String\n    get()  = attributeStringString.get(this, \"data-MsgId\")\n    set(newValue) {attributeStringString.set(this, \"data-MsgId\", newValue)}\n\nvar CommonAttributeGroupFacade.dir : Dir\n    get()  = attributeDirEnumDirValues.get(this, \"dir\")\n    set(newValue) {attributeDirEnumDirValues.set(this, \"dir\", newValue)}\n\nvar CommonAttributeGroupFacade.draggable : Draggable\n    get()  = attributeDraggableEnumDraggableValues.get(this, \"draggable\")\n    set(newValue) {attributeDraggableEnumDraggableValues.set(this, \"draggable\", newValue)}\n\nvar CommonAttributeGroupFacade.hidden : Boolean\n    get()  = attributeBooleanTicker.get(this, \"hidden\")\n    set(newValue) {attributeBooleanTicker.set(this, \"hidden\", newValue)}\n\nvar CommonAttributeGroupFacade.id : String\n    get()  = attributeStringString.get(this, \"id\")\n    set(newValue) {attributeStringString.set(this, \"id\", newValue)}\n\nvar CommonAttributeGroupFacade.itemProp : String\n    get()  = attributeStringString.get(this, \"itemprop\")\n    set(newValue) {attributeStringString.set(this, \"itemprop\", newValue)}\n\nvar CommonAttributeGroupFacade.lang : String\n    get()  = attributeStringString.get(this, \"lang\")\n    set(newValue) {attributeStringString.set(this, \"lang\", newValue)}\n\nvar CommonAttributeGroupFacade.onAbort : String\n    get()  = attributeStringString.get(this, \"onabort\")\n    set(newValue) {attributeStringString.set(this, \"onabort\", newValue)}\n\nvar CommonAttributeGroupFacade.onBlur : String\n    get()  = attributeStringString.get(this, \"onblur\")\n    set(newValue) {attributeStringString.set(this, \"onblur\", newValue)}\n\nvar CommonAttributeGroupFacade.onCanPlay : String\n    get()  = attributeStringString.get(this, \"oncanplay\")\n    set(newValue) {attributeStringString.set(this, \"oncanplay\", newValue)}\n\nvar CommonAttributeGroupFacade.onCanPlayThrough : String\n    get()  = attributeStringString.get(this, \"oncanplaythrough\")\n    set(newValue) {attributeStringString.set(this, \"oncanplaythrough\", newValue)}\n\nvar CommonAttributeGroupFacade.onChange : String\n    get()  = attributeStringString.get(this, \"onchange\")\n    set(newValue) {attributeStringString.set(this, \"onchange\", newValue)}\n\nvar CommonAttributeGroupFacade.onClick : String\n    get()  = attributeStringString.get(this, \"onclick\")\n    set(newValue) {attributeStringString.set(this, \"onclick\", newValue)}\n\nvar CommonAttributeGroupFacade.onContextMenu : String\n    get()  = attributeStringString.get(this, \"oncontextmenu\")\n    set(newValue) {attributeStringString.set(this, \"oncontextmenu\", newValue)}\n\nvar CommonAttributeGroupFacade.onDoubleClick : String\n    get()  = attributeStringString.get(this, \"ondblclick\")\n    set(newValue) {attributeStringString.set(this, \"ondblclick\", newValue)}\n\nvar CommonAttributeGroupFacade.onDrag : String\n    get()  = attributeStringString.get(this, \"ondrag\")\n    set(newValue) {attributeStringString.set(this, \"ondrag\", newValue)}\n\nvar CommonAttributeGroupFacade.onDragEnd : String\n    get()  = attributeStringString.get(this, \"ondragend\")\n    set(newValue) {attributeStringString.set(this, \"ondragend\", newValue)}\n\nvar CommonAttributeGroupFacade.onDragEnter : String\n    get()  = attributeStringString.get(this, \"ondragenter\")\n    set(newValue) {attributeStringString.set(this, \"ondragenter\", newValue)}\n\nvar CommonAttributeGroupFacade.onDragLeave : String\n    get()  = attributeStringString.get(this, \"ondragleave\")\n    set(newValue) {attributeStringString.set(this, \"ondragleave\", newValue)}\n\nvar CommonAttributeGroupFacade.onDragOver : String\n    get()  = attributeStringString.get(this, \"ondragover\")\n    set(newValue) {attributeStringString.set(this, \"ondragover\", newValue)}\n\nvar CommonAttributeGroupFacade.onDragStart : String\n    get()  = attributeStringString.get(this, \"ondragstart\")\n    set(newValue) {attributeStringString.set(this, \"ondragstart\", newValue)}\n\nvar CommonAttributeGroupFacade.onDrop : String\n    get()  = attributeStringString.get(this, \"ondrop\")\n    set(newValue) {attributeStringString.set(this, \"ondrop\", newValue)}\n\nvar CommonAttributeGroupFacade.onDurationChange : String\n    get()  = attributeStringString.get(this, \"ondurationchange\")\n    set(newValue) {attributeStringString.set(this, \"ondurationchange\", newValue)}\n\nvar CommonAttributeGroupFacade.onEmptied : String\n    get()  = attributeStringString.get(this, \"onemptied\")\n    set(newValue) {attributeStringString.set(this, \"onemptied\", newValue)}\n\nvar CommonAttributeGroupFacade.onEnded : String\n    get()  = attributeStringString.get(this, \"onended\")\n    set(newValue) {attributeStringString.set(this, \"onended\", newValue)}\n\nvar CommonAttributeGroupFacade.onError : String\n    get()  = attributeStringString.get(this, \"onerror\")\n    set(newValue) {attributeStringString.set(this, \"onerror\", newValue)}\n\nvar CommonAttributeGroupFacade.onFocus : String\n    get()  = attributeStringString.get(this, \"onfocus\")\n    set(newValue) {attributeStringString.set(this, \"onfocus\", newValue)}\n\nvar CommonAttributeGroupFacade.onFocusIn : String\n    get()  = attributeStringString.get(this, \"onfocusin\")\n    set(newValue) {attributeStringString.set(this, \"onfocusin\", newValue)}\n\nvar CommonAttributeGroupFacade.onFocusOut : String\n    get()  = attributeStringString.get(this, \"onfocusout\")\n    set(newValue) {attributeStringString.set(this, \"onfocusout\", newValue)}\n\nvar CommonAttributeGroupFacade.onFormChange : String\n    get()  = attributeStringString.get(this, \"onformchange\")\n    set(newValue) {attributeStringString.set(this, \"onformchange\", newValue)}\n\nvar CommonAttributeGroupFacade.onFormInput : String\n    get()  = attributeStringString.get(this, \"onforminput\")\n    set(newValue) {attributeStringString.set(this, \"onforminput\", newValue)}\n\nvar CommonAttributeGroupFacade.onInput : String\n    get()  = attributeStringString.get(this, \"oninput\")\n    set(newValue) {attributeStringString.set(this, \"oninput\", newValue)}\n\nvar CommonAttributeGroupFacade.onInvalid : String\n    get()  = attributeStringString.get(this, \"oninvalid\")\n    set(newValue) {attributeStringString.set(this, \"oninvalid\", newValue)}\n\nvar CommonAttributeGroupFacade.onKeyDown : String\n    get()  = attributeStringString.get(this, \"onkeydown\")\n    set(newValue) {attributeStringString.set(this, \"onkeydown\", newValue)}\n\nvar CommonAttributeGroupFacade.onKeyPress : String\n    get()  = attributeStringString.get(this, \"onkeypress\")\n    set(newValue) {attributeStringString.set(this, \"onkeypress\", newValue)}\n\nvar CommonAttributeGroupFacade.onKeyUp : String\n    get()  = attributeStringString.get(this, \"onkeyup\")\n    set(newValue) {attributeStringString.set(this, \"onkeyup\", newValue)}\n\nvar CommonAttributeGroupFacade.onLoad : String\n    get()  = attributeStringString.get(this, \"onload\")\n    set(newValue) {attributeStringString.set(this, \"onload\", newValue)}\n\nvar CommonAttributeGroupFacade.onLoadedData : String\n    get()  = attributeStringString.get(this, \"onloadeddata\")\n    set(newValue) {attributeStringString.set(this, \"onloadeddata\", newValue)}\n\nvar CommonAttributeGroupFacade.onLoadedMetaData : String\n    get()  = attributeStringString.get(this, \"onloadedmetadata\")\n    set(newValue) {attributeStringString.set(this, \"onloadedmetadata\", newValue)}\n\nvar CommonAttributeGroupFacade.onLoadStart : String\n    get()  = attributeStringString.get(this, \"onloadstart\")\n    set(newValue) {attributeStringString.set(this, \"onloadstart\", newValue)}\n\nvar CommonAttributeGroupFacade.onMouseDown : String\n    get()  = attributeStringString.get(this, \"onmousedown\")\n    set(newValue) {attributeStringString.set(this, \"onmousedown\", newValue)}\n\nvar CommonAttributeGroupFacade.onMouseMove : String\n    get()  = attributeStringString.get(this, \"onmousemove\")\n    set(newValue) {attributeStringString.set(this, \"onmousemove\", newValue)}\n\nvar CommonAttributeGroupFacade.onMouseOut : String\n    get()  = attributeStringString.get(this, \"onmouseout\")\n    set(newValue) {attributeStringString.set(this, \"onmouseout\", newValue)}\n\nvar CommonAttributeGroupFacade.onMouseOver : String\n    get()  = attributeStringString.get(this, \"onmouseover\")\n    set(newValue) {attributeStringString.set(this, \"onmouseover\", newValue)}\n\nvar CommonAttributeGroupFacade.onMouseUp : String\n    get()  = attributeStringString.get(this, \"onmouseup\")\n    set(newValue) {attributeStringString.set(this, \"onmouseup\", newValue)}\n\nvar CommonAttributeGroupFacade.onMouseWheel : String\n    get()  = attributeStringString.get(this, \"onmousewheel\")\n    set(newValue) {attributeStringString.set(this, \"onmousewheel\", newValue)}\n\nvar CommonAttributeGroupFacade.onPause : String\n    get()  = attributeStringString.get(this, \"onpause\")\n    set(newValue) {attributeStringString.set(this, \"onpause\", newValue)}\n\nvar CommonAttributeGroupFacade.onPlay : String\n    get()  = attributeStringString.get(this, \"onplay\")\n    set(newValue) {attributeStringString.set(this, \"onplay\", newValue)}\n\nvar CommonAttributeGroupFacade.onPlaying : String\n    get()  = attributeStringString.get(this, \"onplaying\")\n    set(newValue) {attributeStringString.set(this, \"onplaying\", newValue)}\n\nvar CommonAttributeGroupFacade.onProgress : String\n    get()  = attributeStringString.get(this, \"onprogress\")\n    set(newValue) {attributeStringString.set(this, \"onprogress\", newValue)}\n\nvar CommonAttributeGroupFacade.onRateChange : String\n    get()  = attributeStringString.get(this, \"onratechange\")\n    set(newValue) {attributeStringString.set(this, \"onratechange\", newValue)}\n\nvar CommonAttributeGroupFacade.onReadyStateChange : String\n    get()  = attributeStringString.get(this, \"onreadystatechange\")\n    set(newValue) {attributeStringString.set(this, \"onreadystatechange\", newValue)}\n\nvar CommonAttributeGroupFacade.onScroll : String\n    get()  = attributeStringString.get(this, \"onscroll\")\n    set(newValue) {attributeStringString.set(this, \"onscroll\", newValue)}\n\nvar CommonAttributeGroupFacade.onSearch : String\n    get()  = attributeStringString.get(this, \"onsearch\")\n    set(newValue) {attributeStringString.set(this, \"onsearch\", newValue)}\n\nvar CommonAttributeGroupFacade.onSeeked : String\n    get()  = attributeStringString.get(this, \"onseeked\")\n    set(newValue) {attributeStringString.set(this, \"onseeked\", newValue)}\n\nvar CommonAttributeGroupFacade.onSeeking : String\n    get()  = attributeStringString.get(this, \"onseeking\")\n    set(newValue) {attributeStringString.set(this, \"onseeking\", newValue)}\n\nvar CommonAttributeGroupFacade.onSelect : String\n    get()  = attributeStringString.get(this, \"onselect\")\n    set(newValue) {attributeStringString.set(this, \"onselect\", newValue)}\n\nvar CommonAttributeGroupFacade.onShow : String\n    get()  = attributeStringString.get(this, \"onshow\")\n    set(newValue) {attributeStringString.set(this, \"onshow\", newValue)}\n\nvar CommonAttributeGroupFacade.onStalled : String\n    get()  = attributeStringString.get(this, \"onstalled\")\n    set(newValue) {attributeStringString.set(this, \"onstalled\", newValue)}\n\nvar CommonAttributeGroupFacade.onSubmit : String\n    get()  = attributeStringString.get(this, \"onsubmit\")\n    set(newValue) {attributeStringString.set(this, \"onsubmit\", newValue)}\n\nvar CommonAttributeGroupFacade.onSuspend : String\n    get()  = attributeStringString.get(this, \"onsuspend\")\n    set(newValue) {attributeStringString.set(this, \"onsuspend\", newValue)}\n\nvar CommonAttributeGroupFacade.onTimeUpdate : String\n    get()  = attributeStringString.get(this, \"ontimeupdate\")\n    set(newValue) {attributeStringString.set(this, \"ontimeupdate\", newValue)}\n\nvar CommonAttributeGroupFacade.onTouchCancel : String\n    get()  = attributeStringString.get(this, \"ontouchcancel\")\n    set(newValue) {attributeStringString.set(this, \"ontouchcancel\", newValue)}\n\nvar CommonAttributeGroupFacade.onTouchEnd : String\n    get()  = attributeStringString.get(this, \"ontouchend\")\n    set(newValue) {attributeStringString.set(this, \"ontouchend\", newValue)}\n\nvar CommonAttributeGroupFacade.onTouchMove : String\n    get()  = attributeStringString.get(this, \"ontouchmove\")\n    set(newValue) {attributeStringString.set(this, \"ontouchmove\", newValue)}\n\nvar CommonAttributeGroupFacade.onTouchStart : String\n    get()  = attributeStringString.get(this, \"ontouchstart\")\n    set(newValue) {attributeStringString.set(this, \"ontouchstart\", newValue)}\n\nvar CommonAttributeGroupFacade.onVolumeChange : String\n    get()  = attributeStringString.get(this, \"onvolumechange\")\n    set(newValue) {attributeStringString.set(this, \"onvolumechange\", newValue)}\n\nvar CommonAttributeGroupFacade.onWaiting : String\n    get()  = attributeStringString.get(this, \"onwaiting\")\n    set(newValue) {attributeStringString.set(this, \"onwaiting\", newValue)}\n\nvar CommonAttributeGroupFacade.onWheel : String\n    get()  = attributeStringString.get(this, \"onwheel\")\n    set(newValue) {attributeStringString.set(this, \"onwheel\", newValue)}\n\nvar CommonAttributeGroupFacade.role : String\n    get()  = attributeStringString.get(this, \"role\")\n    set(newValue) {attributeStringString.set(this, \"role\", newValue)}\n\nvar CommonAttributeGroupFacade.runAt : RunAt\n    get()  = attributeRunAtEnumRunAtValues.get(this, \"runat\")\n    set(newValue) {attributeRunAtEnumRunAtValues.set(this, \"runat\", newValue)}\n\nvar CommonAttributeGroupFacade.spellCheck : Boolean\n    get()  = attributeBooleanBoolean.get(this, \"spellcheck\")\n    set(newValue) {attributeBooleanBoolean.set(this, \"spellcheck\", newValue)}\n\nvar CommonAttributeGroupFacade.style : String\n    get()  = attributeStringString.get(this, \"style\")\n    set(newValue) {attributeStringString.set(this, \"style\", newValue)}\n\nvar CommonAttributeGroupFacade.subject : String\n    get()  = attributeStringString.get(this, \"subject\")\n    set(newValue) {attributeStringString.set(this, \"subject\", newValue)}\n\nvar CommonAttributeGroupFacade.tabIndex : String\n    get()  = attributeStringString.get(this, \"tabIndex\")\n    set(newValue) {attributeStringString.set(this, \"tabIndex\", newValue)}\n\nvar CommonAttributeGroupFacade.title : String\n    get()  = attributeStringString.get(this, \"title\")\n    set(newValue) {attributeStringString.set(this, \"title\", newValue)}\n\n\ninterface FormServerAttributeGroupFacade : Tag {\n}\nvar FormServerAttributeGroupFacade.defaultButton : String\n    get()  = attributeStringString.get(this, \"DefaultButton\")\n    set(newValue) {attributeStringString.set(this, \"DefaultButton\", newValue)}\n\nvar FormServerAttributeGroupFacade.defaultFocus : String\n    get()  = attributeStringString.get(this, \"DefaultFocus\")\n    set(newValue) {attributeStringString.set(this, \"DefaultFocus\", newValue)}\n\nvar FormServerAttributeGroupFacade.submitDisabledControls : Boolean\n    get()  = attributeBooleanBoolean.get(this, \"SubmitDisabledControls\")\n    set(newValue) {attributeBooleanBoolean.set(this, \"SubmitDisabledControls\", newValue)}\n\n\ninterface InputServerAttributeGroupFacade : Tag {\n}\nvar InputServerAttributeGroupFacade.causesValidation : Boolean\n    get()  = attributeBooleanBoolean.get(this, \"CausesValidation\")\n    set(newValue) {attributeBooleanBoolean.set(this, \"CausesValidation\", newValue)}\n\nvar InputServerAttributeGroupFacade.validationGroup : String\n    get()  = attributeStringString.get(this, \"ValidationGroup\")\n    set(newValue) {attributeStringString.set(this, \"ValidationGroup\", newValue)}\n\n\ninterface SelectServerAttributeGroupFacade : Tag {\n}\nvar SelectServerAttributeGroupFacade.dataSourceID : String\n    get()  = attributeStringString.get(this, \"DataSourceID\")\n    set(newValue) {attributeStringString.set(this, \"DataSourceID\", newValue)}\n\nvar SelectServerAttributeGroupFacade.dataTextField : String\n    get()  = attributeStringString.get(this, \"DataTextField\")\n    set(newValue) {attributeStringString.set(this, \"DataTextField\", newValue)}\n\nvar SelectServerAttributeGroupFacade.dataValueField : String\n    get()  = attributeStringString.get(this, \"DataValueField\")\n    set(newValue) {attributeStringString.set(this, \"DataValueField\", newValue)}\n\n\n","package kotlinx.html.js\n\nimport kotlinx.html.*\nimport kotlinx.html.attributes.*\nimport kotlinx.html.dom.*\nimport org.w3c.dom.events.*\n\n/*******************************************************************************\n    DO NOT EDIT\n    This file was generated by module generate\n*******************************************************************************/\n\nvar CommonAttributeGroupFacade.onAbortFunction : (Event) -> Unit\n    get()  = throw UnsupportedOperationException(\"You can't read variable onAbort\")\n    set(newValue) {consumer.onTagEvent(this, \"onabort\", newValue)}\n\nvar CommonAttributeGroupFacade.onBlurFunction : (Event) -> Unit\n    get()  = throw UnsupportedOperationException(\"You can't read variable onBlur\")\n    set(newValue) {consumer.onTagEvent(this, \"onblur\", newValue)}\n\nvar CommonAttributeGroupFacade.onCanPlayFunction : (Event) -> Unit\n    get()  = throw UnsupportedOperationException(\"You can't read variable onCanPlay\")\n    set(newValue) {consumer.onTagEvent(this, \"oncanplay\", newValue)}\n\nvar CommonAttributeGroupFacade.onCanPlayThroughFunction : (Event) -> Unit\n    get()  = throw UnsupportedOperationException(\"You can't read variable onCanPlayThrough\")\n    set(newValue) {consumer.onTagEvent(this, \"oncanplaythrough\", newValue)}\n\nvar CommonAttributeGroupFacade.onChangeFunction : (Event) -> Unit\n    get()  = throw UnsupportedOperationException(\"You can't read variable onChange\")\n    set(newValue) {consumer.onTagEvent(this, \"onchange\", newValue)}\n\nvar CommonAttributeGroupFacade.onClickFunction : (Event) -> Unit\n    get()  = throw UnsupportedOperationException(\"You can't read variable onClick\")\n    set(newValue) {consumer.onTagEvent(this, \"onclick\", newValue)}\n\nvar CommonAttributeGroupFacade.onContextMenuFunction : (Event) -> Unit\n    get()  = throw UnsupportedOperationException(\"You can't read variable onContextMenu\")\n    set(newValue) {consumer.onTagEvent(this, \"oncontextmenu\", newValue)}\n\nvar CommonAttributeGroupFacade.onDoubleClickFunction : (Event) -> Unit\n    get()  = throw UnsupportedOperationException(\"You can't read variable onDoubleClick\")\n    set(newValue) {consumer.onTagEvent(this, \"ondblclick\", newValue)}\n\nvar CommonAttributeGroupFacade.onDragFunction : (Event) -> Unit\n    get()  = throw UnsupportedOperationException(\"You can't read variable onDrag\")\n    set(newValue) {consumer.onTagEvent(this, \"ondrag\", newValue)}\n\nvar CommonAttributeGroupFacade.onDragEndFunction : (Event) -> Unit\n    get()  = throw UnsupportedOperationException(\"You can't read variable onDragEnd\")\n    set(newValue) {consumer.onTagEvent(this, \"ondragend\", newValue)}\n\nvar CommonAttributeGroupFacade.onDragEnterFunction : (Event) -> Unit\n    get()  = throw UnsupportedOperationException(\"You can't read variable onDragEnter\")\n    set(newValue) {consumer.onTagEvent(this, \"ondragenter\", newValue)}\n\nvar CommonAttributeGroupFacade.onDragLeaveFunction : (Event) -> Unit\n    get()  = throw UnsupportedOperationException(\"You can't read variable onDragLeave\")\n    set(newValue) {consumer.onTagEvent(this, \"ondragleave\", newValue)}\n\nvar CommonAttributeGroupFacade.onDragOverFunction : (Event) -> Unit\n    get()  = throw UnsupportedOperationException(\"You can't read variable onDragOver\")\n    set(newValue) {consumer.onTagEvent(this, \"ondragover\", newValue)}\n\nvar CommonAttributeGroupFacade.onDragStartFunction : (Event) -> Unit\n    get()  = throw UnsupportedOperationException(\"You can't read variable onDragStart\")\n    set(newValue) {consumer.onTagEvent(this, \"ondragstart\", newValue)}\n\nvar CommonAttributeGroupFacade.onDropFunction : (Event) -> Unit\n    get()  = throw UnsupportedOperationException(\"You can't read variable onDrop\")\n    set(newValue) {consumer.onTagEvent(this, \"ondrop\", newValue)}\n\nvar CommonAttributeGroupFacade.onDurationChangeFunction : (Event) -> Unit\n    get()  = throw UnsupportedOperationException(\"You can't read variable onDurationChange\")\n    set(newValue) {consumer.onTagEvent(this, \"ondurationchange\", newValue)}\n\nvar CommonAttributeGroupFacade.onEmptiedFunction : (Event) -> Unit\n    get()  = throw UnsupportedOperationException(\"You can't read variable onEmptied\")\n    set(newValue) {consumer.onTagEvent(this, \"onemptied\", newValue)}\n\nvar CommonAttributeGroupFacade.onEndedFunction : (Event) -> Unit\n    get()  = throw UnsupportedOperationException(\"You can't read variable onEnded\")\n    set(newValue) {consumer.onTagEvent(this, \"onended\", newValue)}\n\nvar CommonAttributeGroupFacade.onErrorFunction : (Event) -> Unit\n    get()  = throw UnsupportedOperationException(\"You can't read variable onError\")\n    set(newValue) {consumer.onTagEvent(this, \"onerror\", newValue)}\n\nvar CommonAttributeGroupFacade.onFocusFunction : (Event) -> Unit\n    get()  = throw UnsupportedOperationException(\"You can't read variable onFocus\")\n    set(newValue) {consumer.onTagEvent(this, \"onfocus\", newValue)}\n\nvar CommonAttributeGroupFacade.onFocusInFunction : (Event) -> Unit\n    get()  = throw UnsupportedOperationException(\"You can't read variable onFocusIn\")\n    set(newValue) {consumer.onTagEvent(this, \"onfocusin\", newValue)}\n\nvar CommonAttributeGroupFacade.onFocusOutFunction : (Event) -> Unit\n    get()  = throw UnsupportedOperationException(\"You can't read variable onFocusOut\")\n    set(newValue) {consumer.onTagEvent(this, \"onfocusout\", newValue)}\n\nvar CommonAttributeGroupFacade.onFormChangeFunction : (Event) -> Unit\n    get()  = throw UnsupportedOperationException(\"You can't read variable onFormChange\")\n    set(newValue) {consumer.onTagEvent(this, \"onformchange\", newValue)}\n\nvar CommonAttributeGroupFacade.onFormInputFunction : (Event) -> Unit\n    get()  = throw UnsupportedOperationException(\"You can't read variable onFormInput\")\n    set(newValue) {consumer.onTagEvent(this, \"onforminput\", newValue)}\n\nvar CommonAttributeGroupFacade.onInputFunction : (Event) -> Unit\n    get()  = throw UnsupportedOperationException(\"You can't read variable onInput\")\n    set(newValue) {consumer.onTagEvent(this, \"oninput\", newValue)}\n\nvar CommonAttributeGroupFacade.onInvalidFunction : (Event) -> Unit\n    get()  = throw UnsupportedOperationException(\"You can't read variable onInvalid\")\n    set(newValue) {consumer.onTagEvent(this, \"oninvalid\", newValue)}\n\nvar CommonAttributeGroupFacade.onKeyDownFunction : (Event) -> Unit\n    get()  = throw UnsupportedOperationException(\"You can't read variable onKeyDown\")\n    set(newValue) {consumer.onTagEvent(this, \"onkeydown\", newValue)}\n\nvar CommonAttributeGroupFacade.onKeyPressFunction : (Event) -> Unit\n    get()  = throw UnsupportedOperationException(\"You can't read variable onKeyPress\")\n    set(newValue) {consumer.onTagEvent(this, \"onkeypress\", newValue)}\n\nvar CommonAttributeGroupFacade.onKeyUpFunction : (Event) -> Unit\n    get()  = throw UnsupportedOperationException(\"You can't read variable onKeyUp\")\n    set(newValue) {consumer.onTagEvent(this, \"onkeyup\", newValue)}\n\nvar CommonAttributeGroupFacade.onLoadFunction : (Event) -> Unit\n    get()  = throw UnsupportedOperationException(\"You can't read variable onLoad\")\n    set(newValue) {consumer.onTagEvent(this, \"onload\", newValue)}\n\nvar CommonAttributeGroupFacade.onLoadedDataFunction : (Event) -> Unit\n    get()  = throw UnsupportedOperationException(\"You can't read variable onLoadedData\")\n    set(newValue) {consumer.onTagEvent(this, \"onloadeddata\", newValue)}\n\nvar CommonAttributeGroupFacade.onLoadedMetaDataFunction : (Event) -> Unit\n    get()  = throw UnsupportedOperationException(\"You can't read variable onLoadedMetaData\")\n    set(newValue) {consumer.onTagEvent(this, \"onloadedmetadata\", newValue)}\n\nvar CommonAttributeGroupFacade.onLoadStartFunction : (Event) -> Unit\n    get()  = throw UnsupportedOperationException(\"You can't read variable onLoadStart\")\n    set(newValue) {consumer.onTagEvent(this, \"onloadstart\", newValue)}\n\nvar CommonAttributeGroupFacade.onMouseDownFunction : (Event) -> Unit\n    get()  = throw UnsupportedOperationException(\"You can't read variable onMouseDown\")\n    set(newValue) {consumer.onTagEvent(this, \"onmousedown\", newValue)}\n\nvar CommonAttributeGroupFacade.onMouseMoveFunction : (Event) -> Unit\n    get()  = throw UnsupportedOperationException(\"You can't read variable onMouseMove\")\n    set(newValue) {consumer.onTagEvent(this, \"onmousemove\", newValue)}\n\nvar CommonAttributeGroupFacade.onMouseOutFunction : (Event) -> Unit\n    get()  = throw UnsupportedOperationException(\"You can't read variable onMouseOut\")\n    set(newValue) {consumer.onTagEvent(this, \"onmouseout\", newValue)}\n\nvar CommonAttributeGroupFacade.onMouseOverFunction : (Event) -> Unit\n    get()  = throw UnsupportedOperationException(\"You can't read variable onMouseOver\")\n    set(newValue) {consumer.onTagEvent(this, \"onmouseover\", newValue)}\n\nvar CommonAttributeGroupFacade.onMouseUpFunction : (Event) -> Unit\n    get()  = throw UnsupportedOperationException(\"You can't read variable onMouseUp\")\n    set(newValue) {consumer.onTagEvent(this, \"onmouseup\", newValue)}\n\nvar CommonAttributeGroupFacade.onMouseWheelFunction : (Event) -> Unit\n    get()  = throw UnsupportedOperationException(\"You can't read variable onMouseWheel\")\n    set(newValue) {consumer.onTagEvent(this, \"onmousewheel\", newValue)}\n\nvar CommonAttributeGroupFacade.onPauseFunction : (Event) -> Unit\n    get()  = throw UnsupportedOperationException(\"You can't read variable onPause\")\n    set(newValue) {consumer.onTagEvent(this, \"onpause\", newValue)}\n\nvar CommonAttributeGroupFacade.onPlayFunction : (Event) -> Unit\n    get()  = throw UnsupportedOperationException(\"You can't read variable onPlay\")\n    set(newValue) {consumer.onTagEvent(this, \"onplay\", newValue)}\n\nvar CommonAttributeGroupFacade.onPlayingFunction : (Event) -> Unit\n    get()  = throw UnsupportedOperationException(\"You can't read variable onPlaying\")\n    set(newValue) {consumer.onTagEvent(this, \"onplaying\", newValue)}\n\nvar CommonAttributeGroupFacade.onProgressFunction : (Event) -> Unit\n    get()  = throw UnsupportedOperationException(\"You can't read variable onProgress\")\n    set(newValue) {consumer.onTagEvent(this, \"onprogress\", newValue)}\n\nvar CommonAttributeGroupFacade.onRateChangeFunction : (Event) -> Unit\n    get()  = throw UnsupportedOperationException(\"You can't read variable onRateChange\")\n    set(newValue) {consumer.onTagEvent(this, \"onratechange\", newValue)}\n\nvar CommonAttributeGroupFacade.onReadyStateChangeFunction : (Event) -> Unit\n    get()  = throw UnsupportedOperationException(\"You can't read variable onReadyStateChange\")\n    set(newValue) {consumer.onTagEvent(this, \"onreadystatechange\", newValue)}\n\nvar CommonAttributeGroupFacade.onScrollFunction : (Event) -> Unit\n    get()  = throw UnsupportedOperationException(\"You can't read variable onScroll\")\n    set(newValue) {consumer.onTagEvent(this, \"onscroll\", newValue)}\n\nvar CommonAttributeGroupFacade.onSearchFunction : (Event) -> Unit\n    get()  = throw UnsupportedOperationException(\"You can't read variable onSearch\")\n    set(newValue) {consumer.onTagEvent(this, \"onsearch\", newValue)}\n\nvar CommonAttributeGroupFacade.onSeekedFunction : (Event) -> Unit\n    get()  = throw UnsupportedOperationException(\"You can't read variable onSeeked\")\n    set(newValue) {consumer.onTagEvent(this, \"onseeked\", newValue)}\n\nvar CommonAttributeGroupFacade.onSeekingFunction : (Event) -> Unit\n    get()  = throw UnsupportedOperationException(\"You can't read variable onSeeking\")\n    set(newValue) {consumer.onTagEvent(this, \"onseeking\", newValue)}\n\nvar CommonAttributeGroupFacade.onSelectFunction : (Event) -> Unit\n    get()  = throw UnsupportedOperationException(\"You can't read variable onSelect\")\n    set(newValue) {consumer.onTagEvent(this, \"onselect\", newValue)}\n\nvar CommonAttributeGroupFacade.onShowFunction : (Event) -> Unit\n    get()  = throw UnsupportedOperationException(\"You can't read variable onShow\")\n    set(newValue) {consumer.onTagEvent(this, \"onshow\", newValue)}\n\nvar CommonAttributeGroupFacade.onStalledFunction : (Event) -> Unit\n    get()  = throw UnsupportedOperationException(\"You can't read variable onStalled\")\n    set(newValue) {consumer.onTagEvent(this, \"onstalled\", newValue)}\n\nvar CommonAttributeGroupFacade.onSubmitFunction : (Event) -> Unit\n    get()  = throw UnsupportedOperationException(\"You can't read variable onSubmit\")\n    set(newValue) {consumer.onTagEvent(this, \"onsubmit\", newValue)}\n\nvar CommonAttributeGroupFacade.onSuspendFunction : (Event) -> Unit\n    get()  = throw UnsupportedOperationException(\"You can't read variable onSuspend\")\n    set(newValue) {consumer.onTagEvent(this, \"onsuspend\", newValue)}\n\nvar CommonAttributeGroupFacade.onTimeUpdateFunction : (Event) -> Unit\n    get()  = throw UnsupportedOperationException(\"You can't read variable onTimeUpdate\")\n    set(newValue) {consumer.onTagEvent(this, \"ontimeupdate\", newValue)}\n\nvar CommonAttributeGroupFacade.onTouchCancelFunction : (Event) -> Unit\n    get()  = throw UnsupportedOperationException(\"You can't read variable onTouchCancel\")\n    set(newValue) {consumer.onTagEvent(this, \"ontouchcancel\", newValue)}\n\nvar CommonAttributeGroupFacade.onTouchEndFunction : (Event) -> Unit\n    get()  = throw UnsupportedOperationException(\"You can't read variable onTouchEnd\")\n    set(newValue) {consumer.onTagEvent(this, \"ontouchend\", newValue)}\n\nvar CommonAttributeGroupFacade.onTouchMoveFunction : (Event) -> Unit\n    get()  = throw UnsupportedOperationException(\"You can't read variable onTouchMove\")\n    set(newValue) {consumer.onTagEvent(this, \"ontouchmove\", newValue)}\n\nvar CommonAttributeGroupFacade.onTouchStartFunction : (Event) -> Unit\n    get()  = throw UnsupportedOperationException(\"You can't read variable onTouchStart\")\n    set(newValue) {consumer.onTagEvent(this, \"ontouchstart\", newValue)}\n\nvar CommonAttributeGroupFacade.onVolumeChangeFunction : (Event) -> Unit\n    get()  = throw UnsupportedOperationException(\"You can't read variable onVolumeChange\")\n    set(newValue) {consumer.onTagEvent(this, \"onvolumechange\", newValue)}\n\nvar CommonAttributeGroupFacade.onWaitingFunction : (Event) -> Unit\n    get()  = throw UnsupportedOperationException(\"You can't read variable onWaiting\")\n    set(newValue) {consumer.onTagEvent(this, \"onwaiting\", newValue)}\n\nvar CommonAttributeGroupFacade.onWheelFunction : (Event) -> Unit\n    get()  = throw UnsupportedOperationException(\"You can't read variable onWheel\")\n    set(newValue) {consumer.onTagEvent(this, \"onwheel\", newValue)}\n\n","package kotlinx.html\n\nimport kotlinx.html.*\nimport kotlinx.html.attributes.*\n\n/*******************************************************************************\n    DO NOT EDIT\n    This file was generated by module generate\n*******************************************************************************/\n\ninternal val attributeStringString : Attribute<String> = StringAttribute()\n\ninternal val attributeSetStringStringSet : Attribute<Set<String>> = StringSetAttribute()\n\ninternal val attributeBooleanBoolean : Attribute<Boolean> = BooleanAttribute()\n\ninternal val attributeBooleanBooleanOnOff : Attribute<Boolean> = BooleanAttribute(\"on\", \"off\")\n\ninternal val attributeBooleanTicker : Attribute<Boolean> = TickerAttribute()\n\ninternal val attributeButtonFormEncTypeEnumButtonFormEncTypeValues : Attribute<ButtonFormEncType> = EnumAttribute(buttonFormEncTypeValues)\n\ninternal val attributeButtonFormMethodEnumButtonFormMethodValues : Attribute<ButtonFormMethod> = EnumAttribute(buttonFormMethodValues)\n\ninternal val attributeButtonTypeEnumButtonTypeValues : Attribute<ButtonType> = EnumAttribute(buttonTypeValues)\n\ninternal val attributeCommandTypeEnumCommandTypeValues : Attribute<CommandType> = EnumAttribute(commandTypeValues)\n\ninternal val attributeDirEnumDirValues : Attribute<Dir> = EnumAttribute(dirValues)\n\ninternal val attributeDraggableEnumDraggableValues : Attribute<Draggable> = EnumAttribute(draggableValues)\n\ninternal val attributeFormEncTypeEnumFormEncTypeValues : Attribute<FormEncType> = EnumAttribute(formEncTypeValues)\n\ninternal val attributeFormMethodEnumFormMethodValues : Attribute<FormMethod> = EnumAttribute(formMethodValues)\n\ninternal val attributeIframeSandboxEnumIframeSandboxValues : Attribute<IframeSandbox> = EnumAttribute(iframeSandboxValues)\n\ninternal val attributeInputFormEncTypeEnumInputFormEncTypeValues : Attribute<InputFormEncType> = EnumAttribute(inputFormEncTypeValues)\n\ninternal val attributeInputFormMethodEnumInputFormMethodValues : Attribute<InputFormMethod> = EnumAttribute(inputFormMethodValues)\n\ninternal val attributeInputTypeEnumInputTypeValues : Attribute<InputType> = EnumAttribute(inputTypeValues)\n\ninternal val attributeKeyGenKeyTypeEnumKeyGenKeyTypeValues : Attribute<KeyGenKeyType> = EnumAttribute(keyGenKeyTypeValues)\n\ninternal val attributeRunAtEnumRunAtValues : Attribute<RunAt> = EnumAttribute(runAtValues)\n\ninternal val attributeTextAreaWrapEnumTextAreaWrapValues : Attribute<TextAreaWrap> = EnumAttribute(textAreaWrapValues)\n\ninternal val attributeThScopeEnumThScopeValues : Attribute<ThScope> = EnumAttribute(thScopeValues)\n\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.reflect\n\nimport findAssociatedObject\n\n/**\n * The experimental marker for associated objects API.\n *\n * Any usage of a declaration annotated with `@ExperimentalAssociatedObjects` must be accepted either by\n * annotating that usage with the [OptIn] annotation, e.g. `@OptIn(ExperimentalAssociatedObjects::class)`,\n * or by using the compiler argument `-Xopt-in=kotlin.reflect.ExperimentalAssociatedObjects`.\n */\n@RequiresOptIn(level = RequiresOptIn.Level.ERROR)\n@Retention(value = AnnotationRetention.BINARY)\npublic annotation class ExperimentalAssociatedObjects\n\n/**\n * Makes the annotated annotation class an associated object key.\n *\n * An associated object key annotation should have single [KClass] parameter.\n * When applied to a class with reference to an object declaration as an argument, it binds\n * the object to the class, making this binding discoverable at runtime using [findAssociatedObject].\n */\n@ExperimentalAssociatedObjects\n@Retention(AnnotationRetention.BINARY)\n@Target(AnnotationTarget.ANNOTATION_CLASS)\npublic annotation class AssociatedObjectKey\n\n/**\n * If [T] is an @[AssociatedObjectKey]-annotated annotation class and [this] class is annotated with @[T] (`S::class`),\n * returns object `S`.\n *\n * Otherwise returns `null`.\n */\n@ExperimentalAssociatedObjects\npublic inline fun <reified T : Annotation> KClass<*>.findAssociatedObject(): Any? =\n    this.findAssociatedObject(T::class)",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin\n\nimport kotlin.internal.InlineOnly\n\n\n/**\n * Returns a hash code value for the object or zero if the object is `null`.\n *\n * @see Any.hashCode\n */\n@SinceKotlin(\"1.3\")\n@InlineOnly\npublic inline fun Any?.hashCode(): Int = this?.hashCode() ?: 0\n",null,null,null,null,null,null,null,null,"/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmName(\"GroupingKt\")\n@file:kotlin.jvm.JvmMultifileClass\n\npackage kotlin.collections\n\n/**\n * Represents a source of elements with a [keyOf] function, which can be applied to each element to get its key.\n *\n * A [Grouping] structure serves as an intermediate step in group-and-fold operations:\n * they group elements by their keys and then fold each group with some aggregating operation.\n *\n * It is created by attaching `keySelector: (T) -> K` function to a source of elements.\n * To get an instance of [Grouping] use one of `groupingBy` extension functions:\n * - [Iterable.groupingBy]\n * - [Sequence.groupingBy]\n * - [Array.groupingBy]\n * - [CharSequence.groupingBy]\n *\n * For the list of group-and-fold operations available, see the [extension functions](#extension-functions) for `Grouping`.\n */\n@SinceKotlin(\"1.1\")\npublic interface Grouping<T, out K> {\n    /** Returns an [Iterator] over the elements of the source of this grouping. */\n    fun sourceIterator(): Iterator<T>\n    /** Extracts the key of an [element]. */\n    fun keyOf(element: T): K\n}\n\n/**\n * Groups elements from the [Grouping] source by key and applies [operation] to the elements of each group sequentially,\n * passing the previously accumulated value and the current element as arguments, and stores the results in a new map.\n *\n * The key for each element is provided by the [Grouping.keyOf] function.\n *\n * @param operation function is invoked on each element with the following parameters:\n *  - `key`: the key of the group this element belongs to;\n *  - `accumulator`: the current value of the accumulator of the group, can be `null` if it's the first `element` encountered in the group;\n *  - `element`: the element from the source being aggregated;\n *  - `first`: indicates whether it's the first `element` encountered in the group.\n *\n * @return a [Map] associating the key of each group with the result of aggregation of the group elements.\n * @sample samples.collections.Grouping.aggregateByRadix\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, K, R> Grouping<T, K>.aggregate(\n    operation: (key: K, accumulator: R?, element: T, first: Boolean) -> R\n): Map<K, R> {\n    return aggregateTo(mutableMapOf<K, R>(), operation)\n}\n\n/**\n * Groups elements from the [Grouping] source by key and applies [operation] to the elements of each group sequentially,\n * passing the previously accumulated value and the current element as arguments,\n * and stores the results in the given [destination] map.\n *\n * The key for each element is provided by the [Grouping.keyOf] function.\n *\n * @param operation a function that is invoked on each element with the following parameters:\n *  - `key`: the key of the group this element belongs to;\n *  - `accumulator`: the current value of the accumulator of the group, can be `null` if it's the first `element` encountered in the group;\n *  - `element`: the element from the source being aggregated;\n *  - `first`: indicates whether it's the first `element` encountered in the group.\n *\n * If the [destination] map already has a value corresponding to some key,\n * then the elements being aggregated for that key are never considered as `first`.\n *\n * @return the [destination] map associating the key of each group with the result of aggregation of the group elements.\n * @sample samples.collections.Grouping.aggregateByRadixTo\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, K, R, M : MutableMap<in K, R>> Grouping<T, K>.aggregateTo(\n    destination: M,\n    operation: (key: K, accumulator: R?, element: T, first: Boolean) -> R\n): M {\n    for (e in this.sourceIterator()) {\n        val key = keyOf(e)\n        val accumulator = destination[key]\n        destination[key] = operation(key, accumulator, e, accumulator == null && !destination.containsKey(key))\n    }\n    return destination\n}\n\n/**\n * Groups elements from the [Grouping] source by key and applies [operation] to the elements of each group sequentially,\n * passing the previously accumulated value and the current element as arguments, and stores the results in a new map.\n * An initial value of accumulator is provided by [initialValueSelector] function.\n *\n * @param initialValueSelector a function that provides an initial value of accumulator for each group.\n *  It's invoked with parameters:\n *  - `key`: the key of the group;\n *  - `element`: the first element being encountered in that group.\n *\n * @param operation a function that is invoked on each element with the following parameters:\n *  - `key`: the key of the group this element belongs to;\n *  - `accumulator`: the current value of the accumulator of the group;\n *  - `element`: the element from the source being accumulated.\n *\n * @return a [Map] associating the key of each group with the result of accumulating the group elements.\n * @sample samples.collections.Grouping.foldByEvenLengthWithComputedInitialValue\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, K, R> Grouping<T, K>.fold(\n    initialValueSelector: (key: K, element: T) -> R,\n    operation: (key: K, accumulator: R, element: T) -> R\n): Map<K, R> =\n    @Suppress(\"UNCHECKED_CAST\")\n    aggregate { key, acc, e, first -> operation(key, if (first) initialValueSelector(key, e) else acc as R, e) }\n\n/**\n * Groups elements from the [Grouping] source by key and applies [operation] to the elements of each group sequentially,\n * passing the previously accumulated value and the current element as arguments,\n * and stores the results in the given [destination] map.\n * An initial value of accumulator is provided by [initialValueSelector] function.\n *\n * @param initialValueSelector a function that provides an initial value of accumulator for each group.\n *  It's invoked with parameters:\n *  - `key`: the key of the group;\n *  - `element`: the first element being encountered in that group.\n *\n * If the [destination] map already has a value corresponding to some key, that value is used as an initial value of\n * the accumulator for that group and the [initialValueSelector] function is not called for that group.\n *\n * @param operation a function that is invoked on each element with the following parameters:\n *  - `key`: the key of the group this element belongs to;\n *  - `accumulator`: the current value of the accumulator of the group;\n *  - `element`: the element from the source being accumulated.\n *\n * @return the [destination] map associating the key of each group with the result of accumulating the group elements.\n * @sample samples.collections.Grouping.foldByEvenLengthWithComputedInitialValueTo\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, K, R, M : MutableMap<in K, R>> Grouping<T, K>.foldTo(\n    destination: M,\n    initialValueSelector: (key: K, element: T) -> R,\n    operation: (key: K, accumulator: R, element: T) -> R\n): M =\n    @Suppress(\"UNCHECKED_CAST\")\n    aggregateTo(destination) { key, acc, e, first -> operation(key, if (first) initialValueSelector(key, e) else acc as R, e) }\n\n\n/**\n * Groups elements from the [Grouping] source by key and applies [operation] to the elements of each group sequentially,\n * passing the previously accumulated value and the current element as arguments, and stores the results in a new map.\n * An initial value of accumulator is the same [initialValue] for each group.\n *\n * @param operation a function that is invoked on each element with the following parameters:\n *  - `accumulator`: the current value of the accumulator of the group;\n *  - `element`: the element from the source being accumulated.\n *\n * @return a [Map] associating the key of each group with the result of accumulating the group elements.\n * @sample samples.collections.Grouping.foldByEvenLengthWithConstantInitialValue\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, K, R> Grouping<T, K>.fold(\n    initialValue: R,\n    operation: (accumulator: R, element: T) -> R\n): Map<K, R> =\n    @Suppress(\"UNCHECKED_CAST\")\n    aggregate { _, acc, e, first -> operation(if (first) initialValue else acc as R, e) }\n\n/**\n * Groups elements from the [Grouping] source by key and applies [operation] to the elements of each group sequentially,\n * passing the previously accumulated value and the current element as arguments,\n * and stores the results in the given [destination] map.\n * An initial value of accumulator is the same [initialValue] for each group.\n *\n * If the [destination] map already has a value corresponding to the key of some group,\n * that value is used as an initial value of the accumulator for that group.\n *\n * @param operation a function that is invoked on each element with the following parameters:\n *  - `accumulator`: the current value of the accumulator of the group;\n *  - `element`: the element from the source being accumulated.\n *\n * @return the [destination] map associating the key of each group with the result of accumulating the group elements.\n * @sample samples.collections.Grouping.foldByEvenLengthWithConstantInitialValueTo\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, K, R, M : MutableMap<in K, R>> Grouping<T, K>.foldTo(\n    destination: M,\n    initialValue: R,\n    operation: (accumulator: R, element: T) -> R\n): M =\n    @Suppress(\"UNCHECKED_CAST\")\n    aggregateTo(destination) { _, acc, e, first -> operation(if (first) initialValue else acc as R, e) }\n\n\n/**\n * Groups elements from the [Grouping] source by key and applies the reducing [operation] to the elements of each group\n * sequentially starting from the second element of the group,\n * passing the previously accumulated value and the current element as arguments,\n * and stores the results in a new map.\n * An initial value of accumulator is the first element of the group.\n *\n * @param operation a function that is invoked on each subsequent element of the group with the following parameters:\n *  - `key`: the key of the group this element belongs to;\n *  - `accumulator`: the current value of the accumulator of the group;\n *  - `element`: the element from the source being accumulated.\n *\n * @return a [Map] associating the key of each group with the result of accumulating the group elements.\n * @sample samples.collections.Grouping.reduceByMaxVowels\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <S, T : S, K> Grouping<T, K>.reduce(\n    operation: (key: K, accumulator: S, element: T) -> S\n): Map<K, S> =\n    aggregate { key, acc, e, first ->\n        @Suppress(\"UNCHECKED_CAST\")\n        if (first) e else operation(key, acc as S, e)\n    }\n\n/**\n * Groups elements from the [Grouping] source by key and applies the reducing [operation] to the elements of each group\n * sequentially starting from the second element of the group,\n * passing the previously accumulated value and the current element as arguments,\n * and stores the results in the given [destination] map.\n * An initial value of accumulator is the first element of the group.\n *\n * If the [destination] map already has a value corresponding to the key of some group,\n * that value is used as an initial value of the accumulator for that group and the first element of that group is also\n * subjected to the [operation].\n\n * @param operation a function that is invoked on each subsequent element of the group with the following parameters:\n *  - `accumulator`: the current value of the accumulator of the group;\n *  - `element`: the element from the source being folded;\n *\n * @return the [destination] map associating the key of each group with the result of accumulating the group elements.\n * @sample samples.collections.Grouping.reduceByMaxVowelsTo\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <S, T : S, K, M : MutableMap<in K, S>> Grouping<T, K>.reduceTo(\n    destination: M,\n    operation: (key: K, accumulator: S, element: T) -> S\n): M =\n    aggregateTo(destination) { key, acc, e, first ->\n        @Suppress(\"UNCHECKED_CAST\")\n        if (first) e else operation(key, acc as S, e)\n    }\n\n\n/**\n * Groups elements from the [Grouping] source by key and counts elements in each group to the given [destination] map.\n *\n * If the [destination] map already has a value corresponding to the key of some group,\n * that value is used as an initial value of the counter for that group.\n *\n * @return the [destination] map associating the key of each group with the count of elements in the group.\n *\n * @sample samples.collections.Grouping.groupingByEachCount\n */\n@SinceKotlin(\"1.1\")\npublic fun <T, K, M : MutableMap<in K, Int>> Grouping<T, K>.eachCountTo(destination: M): M =\n    foldTo(destination, 0) { acc, _ -> acc + 1 }\n\n/*\n/**\n * Groups elements from the [Grouping] source by key and sums values provided by the [valueSelector] function for elements in each group\n * to the given [destination] map.\n *\n *\n * If the [destination] map already has a value corresponding to the key of some group,\n * that value is used as an initial value of the sum for that group.\n *\n * @return the [destination] map associating the key of each group with the sum of elements in the group.\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, K, M : MutableMap<in K, Int>> Grouping<T, K>.eachSumOfTo(destination: M, valueSelector: (T) -> Int): M =\n        foldTo(destination, 0) { acc, e -> acc + valueSelector(e)}\n*/\n\n\n/*\n// TODO: sum by long and by double overloads\n\npublic inline fun <T, K, M : MutableMap<in K, Long>> Grouping<T, K>.sumEachByLongTo(destination: M, valueSelector: (T) -> Long): M =\n        foldTo(destination, 0L) { acc, e -> acc + valueSelector(e)}\n\npublic inline fun <T, K> Grouping<T, K>.sumEachByLong(valueSelector: (T) -> Long): Map<K, Long> =\n        fold(0L) { acc, e -> acc + valueSelector(e)}\n\npublic inline fun <T, K, M : MutableMap<in K, Double>> Grouping<T, K>.sumEachByDoubleTo(destination: M, valueSelector: (T) -> Double): M =\n        foldTo(destination, 0.0) { acc, e -> acc + valueSelector(e)}\n\npublic inline fun <T, K> Grouping<T, K>.sumEachByDouble(valueSelector: (T) -> Double): Map<K, Double> =\n        fold(0.0) { acc, e -> acc + valueSelector(e)}\n*/\n",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"package kotlinx.html\n\nimport kotlinx.html.*\nimport kotlinx.html.impl.*\nimport kotlinx.html.attributes.*\n\n/*******************************************************************************\n    DO NOT EDIT\n    This file was generated by module generate\n*******************************************************************************/\n\n/**\n * Anchor\n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.a(href : String? = null, target : String? = null, classes : String? = null, crossinline block : A.() -> Unit = {}) : T = A(attributesMapOf(\"href\", href,\"target\", target,\"class\", classes), this).visitAndFinalize(this, block)\n\n/**\n * Abbreviated form (e.g., WWW, HTTP,etc.)\n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.abbr(classes : String? = null, crossinline block : ABBR.() -> Unit = {}) : T = ABBR(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\n\n/**\n * Information on author\n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.address(classes : String? = null, crossinline block : ADDRESS.() -> Unit = {}) : T = ADDRESS(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\n\n/**\n * Client-side image map area\n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.area(shape : AreaShape? = null, alt : String? = null, classes : String? = null, crossinline block : AREA.() -> Unit = {}) : T = AREA(attributesMapOf(\"Shape\", shape?.enumEncode(),\"alt\", alt,\"class\", classes), this).visitAndFinalize(this, block)\n\n/**\n * Self-contained syndicatable or reusable composition\n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.article(classes : String? = null, crossinline block : ARTICLE.() -> Unit = {}) : T = ARTICLE(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\n\n/**\n * Sidebar for tangentially related content\n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.aside(classes : String? = null, crossinline block : ASIDE.() -> Unit = {}) : T = ASIDE(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\n\n/**\n * Audio player\n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.audio(classes : String? = null, crossinline block : AUDIO.() -> Unit = {}) : T = AUDIO(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\n\n/**\n * Bold text style\n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.b(classes : String? = null, crossinline block : B.() -> Unit = {}) : T = B(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\n\n/**\n * Document base URI\n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.base(classes : String? = null, crossinline block : BASE.() -> Unit = {}) : T = BASE(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\n\n/**\n * Text directionality isolation\n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.bdi(classes : String? = null, crossinline block : BDI.() -> Unit = {}) : T = BDI(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\n\n/**\n * I18N BiDi over-ride\n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.bdo(classes : String? = null, crossinline block : BDO.() -> Unit = {}) : T = BDO(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\n\n/**\n * Long quotation\n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.blockQuote(classes : String? = null, crossinline block : BLOCKQUOTE.() -> Unit = {}) : T = BLOCKQUOTE(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\n\n/**\n * Document body\n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.body(classes : String? = null, crossinline block : BODY.() -> Unit = {}) : T = BODY(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\n\n/**\n * Forced line break\n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.br(classes : String? = null, crossinline block : BR.() -> Unit = {}) : T = BR(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\n\n/**\n * Push button\n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.button(formEncType : ButtonFormEncType? = null, formMethod : ButtonFormMethod? = null, name : String? = null, type : ButtonType? = null, classes : String? = null, crossinline block : BUTTON.() -> Unit = {}) : T = BUTTON(attributesMapOf(\"formenctype\", formEncType?.enumEncode(),\"formmethod\", formMethod?.enumEncode(),\"name\", name,\"type\", type?.enumEncode(),\"class\", classes), this).visitAndFinalize(this, block)\n\n/**\n * Scriptable bitmap canvas\n */\n@HtmlTagMarker\nfun <T, C : TagConsumer<T>> C.canvas(classes : String? = null, content : String = \"\") : T = CANVAS(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, {+content})\n/**\n * Scriptable bitmap canvas\n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.canvas(classes : String? = null, crossinline block : CANVAS.() -> Unit = {}) : T = CANVAS(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\n\n/**\n * Table caption\n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.caption(classes : String? = null, crossinline block : CAPTION.() -> Unit = {}) : T = CAPTION(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\n\n/**\n * Citation\n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.cite(classes : String? = null, crossinline block : CITE.() -> Unit = {}) : T = CITE(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\n\n/**\n * Computer code fragment\n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.code(classes : String? = null, crossinline block : CODE.() -> Unit = {}) : T = CODE(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\n\n/**\n * Table column\n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.col(classes : String? = null, crossinline block : COL.() -> Unit = {}) : T = COL(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\n\n/**\n * Table column group\n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.colGroup(classes : String? = null, crossinline block : COLGROUP.() -> Unit = {}) : T = COLGROUP(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\n\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.command(type : CommandType? = null, classes : String? = null, crossinline block : COMMAND.() -> Unit = {}) : T = COMMAND(attributesMapOf(\"type\", type?.enumEncode(),\"class\", classes), this).visitAndFinalize(this, block)\n\n/**\n * Container for options for \n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.dataList(classes : String? = null, crossinline block : DATALIST.() -> Unit = {}) : T = DATALIST(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\n\n/**\n * Definition description\n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.dd(classes : String? = null, crossinline block : DD.() -> Unit = {}) : T = DD(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\n\n/**\n * Deleted text\n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.del(classes : String? = null, crossinline block : DEL.() -> Unit = {}) : T = DEL(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\n\n/**\n * Disclosure control for hiding details\n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.details(classes : String? = null, crossinline block : DETAILS.() -> Unit = {}) : T = DETAILS(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\n\n/**\n * Instance definition\n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.dfn(classes : String? = null, crossinline block : DFN.() -> Unit = {}) : T = DFN(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\n\n/**\n * Dialog box or window\n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.dialog(classes : String? = null, crossinline block : DIALOG.() -> Unit = {}) : T = DIALOG(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\n\n/**\n * Generic language/style container\n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.div(classes : String? = null, crossinline block : DIV.() -> Unit = {}) : T = DIV(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\n\n/**\n * Definition list\n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.dl(classes : String? = null, crossinline block : DL.() -> Unit = {}) : T = DL(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\n\n/**\n * Definition term\n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.dt(classes : String? = null, crossinline block : DT.() -> Unit = {}) : T = DT(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\n\n/**\n * Emphasis\n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.em(classes : String? = null, crossinline block : EM.() -> Unit = {}) : T = EM(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\n\n/**\n * Plugin\n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.embed(classes : String? = null, crossinline block : EMBED.() -> Unit = {}) : T = EMBED(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\n\n/**\n * Form control group\n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.fieldSet(classes : String? = null, crossinline block : FIELDSET.() -> Unit = {}) : T = FIELDSET(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\n\n/**\n * Caption for \n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.figcaption(classes : String? = null, crossinline block : FIGCAPTION.() -> Unit = {}) : T = FIGCAPTION(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\n\n/**\n * Figure with optional caption\n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.figure(classes : String? = null, crossinline block : FIGURE.() -> Unit = {}) : T = FIGURE(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\n\n/**\n * Footer for a page or section\n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.footer(classes : String? = null, crossinline block : FOOTER.() -> Unit = {}) : T = FOOTER(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\n\n/**\n * Interactive form\n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.form(action : String? = null, encType : FormEncType? = null, method : FormMethod? = null, classes : String? = null, crossinline block : FORM.() -> Unit = {}) : T = FORM(attributesMapOf(\"action\", action,\"enctype\", encType?.enumEncode(),\"method\", method?.enumEncode(),\"class\", classes), this).visitAndFinalize(this, block)\n\n/**\n * Heading\n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.h1(classes : String? = null, crossinline block : H1.() -> Unit = {}) : T = H1(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\n\n/**\n * Heading\n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.h2(classes : String? = null, crossinline block : H2.() -> Unit = {}) : T = H2(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\n\n/**\n * Heading\n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.h3(classes : String? = null, crossinline block : H3.() -> Unit = {}) : T = H3(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\n\n/**\n * Heading\n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.h4(classes : String? = null, crossinline block : H4.() -> Unit = {}) : T = H4(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\n\n/**\n * Heading\n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.h5(classes : String? = null, crossinline block : H5.() -> Unit = {}) : T = H5(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\n\n/**\n * Heading\n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.h6(classes : String? = null, crossinline block : H6.() -> Unit = {}) : T = H6(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\n\n@Deprecated(\"This tag doesn't support content or requires unsafe (try unsafe {})\")\n@Suppress(\"DEPRECATION\")\n/**\n * Document head\n */\n@HtmlTagMarker\nfun <T, C : TagConsumer<T>> C.head(content : String = \"\") : T = HEAD(emptyMap, this).visitAndFinalize(this, {+content})\n/**\n * Document head\n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.head(crossinline block : HEAD.() -> Unit = {}) : T = HEAD(emptyMap, this).visitAndFinalize(this, block)\n\n/**\n * Introductory or navigational aids for a page or section\n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.header(classes : String? = null, crossinline block : HEADER.() -> Unit = {}) : T = HEADER(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\n\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.hGroup(classes : String? = null, crossinline block : HGROUP.() -> Unit = {}) : T = HGROUP(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\n\n/**\n * Horizontal rule\n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.hr(classes : String? = null, crossinline block : HR.() -> Unit = {}) : T = HR(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\n\n@Deprecated(\"This tag doesn't support content or requires unsafe (try unsafe {})\")\n@Suppress(\"DEPRECATION\")\n/**\n * Document root element\n */\n@HtmlTagMarker\nfun <T, C : TagConsumer<T>> C.html(content : String = \"\", namespace : String? = null) : T = HTML(emptyMap, this, namespace).visitAndFinalize(this, {+content})\n/**\n * Document root element\n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.html(namespace : String? = null, crossinline block : HTML.() -> Unit = {}) : T = HTML(emptyMap, this, namespace).visitAndFinalize(this, block)\n\n/**\n * Italic text style\n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.i(classes : String? = null, crossinline block : I.() -> Unit = {}) : T = I(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\n\n/**\n * Inline subwindow\n */\n@HtmlTagMarker\nfun <T, C : TagConsumer<T>> C.iframe(sandbox : IframeSandbox? = null, classes : String? = null, content : String = \"\") : T = IFRAME(attributesMapOf(\"sandbox\", sandbox?.enumEncode(),\"class\", classes), this).visitAndFinalize(this, {+content})\n/**\n * Inline subwindow\n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.iframe(sandbox : IframeSandbox? = null, classes : String? = null, crossinline block : IFRAME.() -> Unit = {}) : T = IFRAME(attributesMapOf(\"sandbox\", sandbox?.enumEncode(),\"class\", classes), this).visitAndFinalize(this, block)\n\n/**\n * Embedded image\n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.img(alt : String? = null, src : String? = null, classes : String? = null, crossinline block : IMG.() -> Unit = {}) : T = IMG(attributesMapOf(\"alt\", alt,\"src\", src,\"class\", classes), this).visitAndFinalize(this, block)\n\n/**\n * Form control\n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.input(type : InputType? = null, formEncType : InputFormEncType? = null, formMethod : InputFormMethod? = null, name : String? = null, classes : String? = null, crossinline block : INPUT.() -> Unit = {}) : T = INPUT(attributesMapOf(\"type\", type?.enumEncode(),\"formenctype\", formEncType?.enumEncode(),\"formmethod\", formMethod?.enumEncode(),\"name\", name,\"class\", classes), this).visitAndFinalize(this, block)\n\n/**\n * Inserted text\n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.ins(classes : String? = null, crossinline block : INS.() -> Unit = {}) : T = INS(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\n\n/**\n * Text to be entered by the user\n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.kbd(classes : String? = null, crossinline block : KBD.() -> Unit = {}) : T = KBD(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\n\n/**\n * Cryptographic key-pair generator form control\n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.keyGen(keyType : KeyGenKeyType? = null, classes : String? = null, crossinline block : KEYGEN.() -> Unit = {}) : T = KEYGEN(attributesMapOf(\"keytype\", keyType?.enumEncode(),\"class\", classes), this).visitAndFinalize(this, block)\n\n/**\n * Form field label text\n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.label(classes : String? = null, crossinline block : LABEL.() -> Unit = {}) : T = LABEL(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\n\n/**\n * Fieldset legend\n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.legend(classes : String? = null, crossinline block : LEGEND.() -> Unit = {}) : T = LEGEND(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\n\n/**\n * List item\n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.li(classes : String? = null, crossinline block : LI.() -> Unit = {}) : T = LI(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\n\n/**\n * A media-independent link\n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.link(href : String? = null, rel : String? = null, type : String? = null, crossinline block : LINK.() -> Unit = {}) : T = LINK(attributesMapOf(\"href\", href,\"rel\", rel,\"type\", type), this).visitAndFinalize(this, block)\n\n/**\n * Container for the dominant contents of another element\n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.main(classes : String? = null, crossinline block : MAIN.() -> Unit = {}) : T = MAIN(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\n\n/**\n * Client-side image map\n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.map(name : String? = null, classes : String? = null, crossinline block : MAP.() -> Unit = {}) : T = MAP(attributesMapOf(\"name\", name,\"class\", classes), this).visitAndFinalize(this, block)\n\n/**\n * Highlight\n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.mark(classes : String? = null, crossinline block : MARK.() -> Unit = {}) : T = MARK(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\n\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.math(classes : String? = null, crossinline block : MATH.() -> Unit = {}) : T = MATH(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\n\n@HtmlTagMarker\nfun <T, C : TagConsumer<T>> C.mathml(classes : String? = null, content : String = \"\") : T = MATHML(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, {+content})\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.mathml(classes : String? = null, crossinline block : MATHML.() -> Unit = {}) : T = MATHML(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\n\n/**\n * Generic metainformation\n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.meta(name : String? = null, content : String? = null, charset : String? = null, crossinline block : META.() -> Unit = {}) : T = META(attributesMapOf(\"name\", name,\"content\", content,\"charset\", charset), this).visitAndFinalize(this, block)\n\n/**\n * Gauge\n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.meter(classes : String? = null, crossinline block : METER.() -> Unit = {}) : T = METER(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\n\n/**\n * Section with navigational links\n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.nav(classes : String? = null, crossinline block : NAV.() -> Unit = {}) : T = NAV(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\n\n/**\n * Generic metainformation\n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.noScript(classes : String? = null, crossinline block : NOSCRIPT.() -> Unit = {}) : T = NOSCRIPT(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\n\n/**\n * Generic embedded object\n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.htmlObject(classes : String? = null, crossinline block : OBJECT.() -> Unit = {}) : T = OBJECT(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\n\n/**\n * Ordered list\n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.ol(classes : String? = null, crossinline block : OL.() -> Unit = {}) : T = OL(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\n\n/**\n * Option group\n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.optGroup(label : String? = null, classes : String? = null, crossinline block : OPTGROUP.() -> Unit = {}) : T = OPTGROUP(attributesMapOf(\"label\", label,\"class\", classes), this).visitAndFinalize(this, block)\n\n/**\n * Selectable choice\n */\n@HtmlTagMarker\nfun <T, C : TagConsumer<T>> C.option(classes : String? = null, content : String = \"\") : T = OPTION(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, {+content})\n/**\n * Selectable choice\n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.option(classes : String? = null, crossinline block : OPTION.() -> Unit = {}) : T = OPTION(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\n\n/**\n * Calculated output value\n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.output(classes : String? = null, crossinline block : OUTPUT.() -> Unit = {}) : T = OUTPUT(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\n\n/**\n * Paragraph\n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.p(classes : String? = null, crossinline block : P.() -> Unit = {}) : T = P(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\n\n/**\n * Named property value\n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.param(name : String? = null, value : String? = null, crossinline block : PARAM.() -> Unit = {}) : T = PARAM(attributesMapOf(\"name\", name,\"value\", value), this).visitAndFinalize(this, block)\n\n/**\n * Preformatted text\n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.pre(classes : String? = null, crossinline block : PRE.() -> Unit = {}) : T = PRE(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\n\n/**\n * Progress bar\n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.progress(classes : String? = null, crossinline block : PROGRESS.() -> Unit = {}) : T = PROGRESS(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\n\n/**\n * Short inline quotation\n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.q(classes : String? = null, crossinline block : Q.() -> Unit = {}) : T = Q(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\n\n/**\n * Parenthesis for ruby annotation text\n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.rp(classes : String? = null, crossinline block : RP.() -> Unit = {}) : T = RP(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\n\n/**\n * Ruby annotation text\n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.rt(classes : String? = null, crossinline block : RT.() -> Unit = {}) : T = RT(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\n\n/**\n * Ruby annotation(s)\n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.ruby(classes : String? = null, crossinline block : RUBY.() -> Unit = {}) : T = RUBY(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\n\n/**\n * Strike-through text style\n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.samp(classes : String? = null, crossinline block : SAMP.() -> Unit = {}) : T = SAMP(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\n\n@Deprecated(\"This tag doesn't support content or requires unsafe (try unsafe {})\")\n@Suppress(\"DEPRECATION\")\n/**\n * Script statements\n */\n@HtmlTagMarker\nfun <T, C : TagConsumer<T>> C.script(type : String? = null, src : String? = null, content : String = \"\") : T = SCRIPT(attributesMapOf(\"type\", type,\"src\", src), this).visitAndFinalize(this, {+content})\n/**\n * Script statements\n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.script(type : String? = null, src : String? = null, crossinline block : SCRIPT.() -> Unit = {}) : T = SCRIPT(attributesMapOf(\"type\", type,\"src\", src), this).visitAndFinalize(this, block)\n\n/**\n * Generic document or application section\n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.section(classes : String? = null, crossinline block : SECTION.() -> Unit = {}) : T = SECTION(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\n\n/**\n * Option selector\n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.select(classes : String? = null, crossinline block : SELECT.() -> Unit = {}) : T = SELECT(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\n\n/**\n * Small text style\n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.small(classes : String? = null, crossinline block : SMALL.() -> Unit = {}) : T = SMALL(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\n\n/**\n * Media source for \n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.source(classes : String? = null, crossinline block : SOURCE.() -> Unit = {}) : T = SOURCE(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\n\n/**\n * Generic language/style container\n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.span(classes : String? = null, crossinline block : SPAN.() -> Unit = {}) : T = SPAN(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\n\n/**\n * Strong emphasis\n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.strong(classes : String? = null, crossinline block : STRONG.() -> Unit = {}) : T = STRONG(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\n\n@Deprecated(\"This tag doesn't support content or requires unsafe (try unsafe {})\")\n@Suppress(\"DEPRECATION\")\n/**\n * Style info\n */\n@HtmlTagMarker\nfun <T, C : TagConsumer<T>> C.style(type : String? = null, content : String = \"\") : T = STYLE(attributesMapOf(\"type\", type), this).visitAndFinalize(this, {+content})\n/**\n * Style info\n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.style(type : String? = null, crossinline block : STYLE.() -> Unit = {}) : T = STYLE(attributesMapOf(\"type\", type), this).visitAndFinalize(this, block)\n\n/**\n * Subscript\n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.sub(classes : String? = null, crossinline block : SUB.() -> Unit = {}) : T = SUB(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\n\n/**\n * Caption for \n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.summary(classes : String? = null, crossinline block : SUMMARY.() -> Unit = {}) : T = SUMMARY(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\n\n/**\n * Superscript\n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.sup(classes : String? = null, crossinline block : SUP.() -> Unit = {}) : T = SUP(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\n\n@HtmlTagMarker\nfun <T, C : TagConsumer<T>> C.svg(classes : String? = null, content : String = \"\") : T = SVG(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, {+content})\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.svg(classes : String? = null, crossinline block : SVG.() -> Unit = {}) : T = SVG(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\n\n/**\n * \n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.table(classes : String? = null, crossinline block : TABLE.() -> Unit = {}) : T = TABLE(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\n\n/**\n * Table body\n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.tbody(classes : String? = null, crossinline block : TBODY.() -> Unit = {}) : T = TBODY(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\n\n/**\n * Table data cell\n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.td(classes : String? = null, crossinline block : TD.() -> Unit = {}) : T = TD(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\n\n/**\n * Multi-line text field\n */\n@HtmlTagMarker\nfun <T, C : TagConsumer<T>> C.textArea(rows : String? = null, cols : String? = null, wrap : TextAreaWrap? = null, classes : String? = null, content : String = \"\") : T = TEXTAREA(attributesMapOf(\"rows\", rows,\"cols\", cols,\"wrap\", wrap?.enumEncode(),\"class\", classes), this).visitAndFinalize(this, {+content})\n/**\n * Multi-line text field\n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.textArea(rows : String? = null, cols : String? = null, wrap : TextAreaWrap? = null, classes : String? = null, crossinline block : TEXTAREA.() -> Unit = {}) : T = TEXTAREA(attributesMapOf(\"rows\", rows,\"cols\", cols,\"wrap\", wrap?.enumEncode(),\"class\", classes), this).visitAndFinalize(this, block)\n\n/**\n * Table footer\n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.tfoot(classes : String? = null, crossinline block : TFOOT.() -> Unit = {}) : T = TFOOT(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\n\n/**\n * Table header cell\n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.th(scope : ThScope? = null, classes : String? = null, crossinline block : TH.() -> Unit = {}) : T = TH(attributesMapOf(\"scope\", scope?.enumEncode(),\"class\", classes), this).visitAndFinalize(this, block)\n\n/**\n * Table header\n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.thead(classes : String? = null, crossinline block : THEAD.() -> Unit = {}) : T = THEAD(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\n\n/**\n * Machine-readable equivalent of date- or time-related data\n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.time(classes : String? = null, crossinline block : TIME.() -> Unit = {}) : T = TIME(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\n\n/**\n * Document title\n */\n@HtmlTagMarker\nfun <T, C : TagConsumer<T>> C.title(content : String = \"\") : T = TITLE(emptyMap, this).visitAndFinalize(this, {+content})\n/**\n * Document title\n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.title(crossinline block : TITLE.() -> Unit = {}) : T = TITLE(emptyMap, this).visitAndFinalize(this, block)\n\n/**\n * Table row\n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.tr(classes : String? = null, crossinline block : TR.() -> Unit = {}) : T = TR(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\n\n/**\n * Unordered list\n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.ul(classes : String? = null, crossinline block : UL.() -> Unit = {}) : T = UL(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\n\n/**\n * Unordered list\n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.htmlVar(classes : String? = null, crossinline block : VAR.() -> Unit = {}) : T = VAR(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\n\n/**\n * Video player\n */\n@HtmlTagMarker\ninline fun <T, C : TagConsumer<T>> C.video(classes : String? = null, crossinline block : VIDEO.() -> Unit = {}) : T = VIDEO(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\n\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StringsKt\")\n\npackage kotlin.text\n\nimport kotlin.contracts.contract\nimport kotlin.jvm.JvmName\n\n/**\n * Returns a copy of this string converted to upper case using the rules of the default locale.\n */\n@Deprecated(\"Use uppercase() instead.\", ReplaceWith(\"uppercase()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic expect fun String.toUpperCase(): String\n\n/**\n * Returns a copy of this string converted to upper case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many and many-to-one character mapping,\n * thus the length of the returned string can be different from the length of the original string.\n *\n * @sample samples.text.Strings.uppercase\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun String.uppercase(): String\n\n/**\n * Returns a copy of this string converted to lower case using the rules of the default locale.\n */\n@Deprecated(\"Use lowercase() instead.\", ReplaceWith(\"lowercase()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic expect fun String.toLowerCase(): String\n\n/**\n * Returns a copy of this string converted to lower case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many and many-to-one character mapping,\n * thus the length of the returned string can be different from the length of the original string.\n *\n * @sample samples.text.Strings.lowercase\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun String.lowercase(): String\n\n/**\n * Returns a copy of this string having its first letter titlecased using the rules of the default locale,\n * or the original string if it's empty or already starts with a title case letter.\n *\n * The title case of a character is usually the same as its upper case with several exceptions.\n * The particular list of characters with the special title case form depends on the underlying platform.\n *\n * @sample samples.text.Strings.capitalize\n */\n@Deprecated(\"Use replaceFirstChar instead.\", ReplaceWith(\"replaceFirstChar { if (it.isLowerCase()) it.titlecase() else it.toString() }\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic expect fun String.capitalize(): String\n\n/**\n * Returns a copy of this string having its first letter lowercased using the rules of the default locale,\n * or the original string if it's empty or already starts with a lower case letter.\n *\n * @sample samples.text.Strings.decapitalize\n */\n@Deprecated(\"Use replaceFirstChar instead.\", ReplaceWith(\"replaceFirstChar { it.lowercase() }\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic expect fun String.decapitalize(): String\n\n/**\n * Returns a sub sequence of this char sequence having leading and trailing characters matching the [predicate] removed.\n */\npublic inline fun CharSequence.trim(predicate: (Char) -> Boolean): CharSequence {\n    var startIndex = 0\n    var endIndex = length - 1\n    var startFound = false\n\n    while (startIndex <= endIndex) {\n        val index = if (!startFound) startIndex else endIndex\n        val match = predicate(this[index])\n\n        if (!startFound) {\n            if (!match)\n                startFound = true\n            else\n                startIndex += 1\n        } else {\n            if (!match)\n                break\n            else\n                endIndex -= 1\n        }\n    }\n\n    return subSequence(startIndex, endIndex + 1)\n}\n\n/**\n * Returns a string having leading and trailing characters matching the [predicate] removed.\n */\npublic inline fun String.trim(predicate: (Char) -> Boolean): String =\n    (this as CharSequence).trim(predicate).toString()\n\n/**\n * Returns a sub sequence of this char sequence having leading characters matching the [predicate] removed.\n */\npublic inline fun CharSequence.trimStart(predicate: (Char) -> Boolean): CharSequence {\n    for (index in this.indices)\n        if (!predicate(this[index]))\n            return subSequence(index, length)\n\n    return \"\"\n}\n\n/**\n * Returns a string having leading characters matching the [predicate] removed.\n */\npublic inline fun String.trimStart(predicate: (Char) -> Boolean): String =\n    (this as CharSequence).trimStart(predicate).toString()\n\n/**\n * Returns a sub sequence of this char sequence having trailing characters matching the [predicate] removed.\n */\npublic inline fun CharSequence.trimEnd(predicate: (Char) -> Boolean): CharSequence {\n    for (index in this.indices.reversed())\n        if (!predicate(this[index]))\n            return subSequence(0, index + 1)\n\n    return \"\"\n}\n\n/**\n * Returns a string having trailing characters matching the [predicate] removed.\n */\npublic inline fun String.trimEnd(predicate: (Char) -> Boolean): String =\n    (this as CharSequence).trimEnd(predicate).toString()\n\n/**\n * Returns a sub sequence of this char sequence having leading and trailing characters from the [chars] array removed.\n */\npublic fun CharSequence.trim(vararg chars: Char): CharSequence = trim { it in chars }\n\n/**\n * Returns a string having leading and trailing characters from the [chars] array removed.\n */\npublic fun String.trim(vararg chars: Char): String = trim { it in chars }\n\n/**\n * Returns a sub sequence of this char sequence having leading characters from the [chars] array removed.\n */\npublic fun CharSequence.trimStart(vararg chars: Char): CharSequence = trimStart { it in chars }\n\n/**\n * Returns a string having leading characters from the [chars] array removed.\n */\npublic fun String.trimStart(vararg chars: Char): String = trimStart { it in chars }\n\n/**\n * Returns a sub sequence of this char sequence having trailing characters from the [chars] array removed.\n */\npublic fun CharSequence.trimEnd(vararg chars: Char): CharSequence = trimEnd { it in chars }\n\n/**\n * Returns a string having trailing characters from the [chars] array removed.\n */\npublic fun String.trimEnd(vararg chars: Char): String = trimEnd { it in chars }\n\n/**\n * Returns a sub sequence of this char sequence having leading and trailing whitespace removed.\n */\npublic fun CharSequence.trim(): CharSequence = trim(Char::isWhitespace)\n\n/**\n * Returns a string having leading and trailing whitespace removed.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.trim(): String = (this as CharSequence).trim().toString()\n\n/**\n * Returns a sub sequence of this char sequence having leading whitespace removed.\n */\npublic fun CharSequence.trimStart(): CharSequence = trimStart(Char::isWhitespace)\n\n/**\n * Returns a string having leading whitespace removed.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.trimStart(): String = (this as CharSequence).trimStart().toString()\n\n/**\n * Returns a sub sequence of this char sequence having trailing whitespace removed.\n */\npublic fun CharSequence.trimEnd(): CharSequence = trimEnd(Char::isWhitespace)\n\n/**\n * Returns a string having trailing whitespace removed.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.trimEnd(): String = (this as CharSequence).trimEnd().toString()\n\n/**\n * Returns a char sequence with content of this char sequence padded at the beginning\n * to the specified [length] with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a char sequence of length at least [length] consisting of `this` char sequence prepended with [padChar] as many times\n * as are necessary to reach that length.\n * @sample samples.text.Strings.padStart\n */\npublic fun CharSequence.padStart(length: Int, padChar: Char = ' '): CharSequence {\n    if (length < 0)\n        throw IllegalArgumentException(\"Desired length $length is less than zero.\")\n    if (length <= this.length)\n        return this.subSequence(0, this.length)\n\n    val sb = StringBuilder(length)\n    for (i in 1..(length - this.length))\n        sb.append(padChar)\n    sb.append(this)\n    return sb\n}\n\n/**\n * Pads the string to the specified [length] at the beginning with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a string of length at least [length] consisting of `this` string prepended with [padChar] as many times\n * as are necessary to reach that length.\n * @sample samples.text.Strings.padStart\n */\npublic fun String.padStart(length: Int, padChar: Char = ' '): String =\n    (this as CharSequence).padStart(length, padChar).toString()\n\n/**\n * Returns a char sequence with content of this char sequence padded at the end\n * to the specified [length] with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a char sequence of length at least [length] consisting of `this` char sequence appended with [padChar] as many times\n * as are necessary to reach that length.\n * @sample samples.text.Strings.padEnd\n */\npublic fun CharSequence.padEnd(length: Int, padChar: Char = ' '): CharSequence {\n    if (length < 0)\n        throw IllegalArgumentException(\"Desired length $length is less than zero.\")\n    if (length <= this.length)\n        return this.subSequence(0, this.length)\n\n    val sb = StringBuilder(length)\n    sb.append(this)\n    for (i in 1..(length - this.length))\n        sb.append(padChar)\n    return sb\n}\n\n/**\n * Pads the string to the specified [length] at the end with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a string of length at least [length] consisting of `this` string appended with [padChar] as many times\n * as are necessary to reach that length.\n * @sample samples.text.Strings.padEnd\n */\npublic fun String.padEnd(length: Int, padChar: Char = ' '): String =\n    (this as CharSequence).padEnd(length, padChar).toString()\n\n/**\n * Returns `true` if this nullable char sequence is either `null` or empty.\n *\n * @sample samples.text.Strings.stringIsNullOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence?.isNullOrEmpty(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrEmpty != null)\n    }\n\n    return this == null || this.length == 0\n}\n\n/**\n * Returns `true` if this char sequence is empty (contains no characters).\n *\n * @sample samples.text.Strings.stringIsEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.isEmpty(): Boolean = length == 0\n\n/**\n * Returns `true` if this char sequence is not empty.\n *\n * @sample samples.text.Strings.stringIsNotEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.isNotEmpty(): Boolean = length > 0\n\n// implemented differently in JVM and JS\n//public fun String.isBlank(): Boolean = length() == 0 || all { it.isWhitespace() }\n\n\n/**\n * Returns `true` if this char sequence is not empty and contains some characters except of whitespace characters.\n *\n * @sample samples.text.Strings.stringIsNotBlank\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.isNotBlank(): Boolean = !isBlank()\n\n/**\n * Returns `true` if this nullable char sequence is either `null` or empty or consists solely of whitespace characters.\n *\n * @sample samples.text.Strings.stringIsNullOrBlank\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence?.isNullOrBlank(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrBlank != null)\n    }\n\n    return this == null || this.isBlank()\n}\n\n/**\n * Iterator for characters of the given char sequence.\n */\npublic operator fun CharSequence.iterator(): CharIterator = object : CharIterator() {\n    private var index = 0\n\n    public override fun nextChar(): Char = get(index++)\n\n    public override fun hasNext(): Boolean = index < length\n}\n\n/** Returns the string if it is not `null`, or the empty string otherwise. */\n@kotlin.internal.InlineOnly\npublic inline fun String?.orEmpty(): String = this ?: \"\"\n\n/**\n * Returns this char sequence if it's not empty\n * or the result of calling [defaultValue] function if the char sequence is empty.\n *\n * @sample samples.text.Strings.stringIfEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <C, R> C.ifEmpty(defaultValue: () -> R): R where C : CharSequence, C : R =\n    if (isEmpty()) defaultValue() else this\n\n/**\n * Returns this char sequence if it is not empty and doesn't consist solely of whitespace characters,\n * or the result of calling [defaultValue] function otherwise.\n *\n * @sample samples.text.Strings.stringIfBlank\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <C, R> C.ifBlank(defaultValue: () -> R): R where C : CharSequence, C : R =\n    if (isBlank()) defaultValue() else this\n\n/**\n * Returns the range of valid character indices for this char sequence.\n */\npublic val CharSequence.indices: IntRange\n    get() = 0..length - 1\n\n/**\n * Returns the index of the last character in the char sequence or -1 if it is empty.\n */\npublic val CharSequence.lastIndex: Int\n    get() = this.length - 1\n\n/**\n * Returns `true` if this CharSequence has Unicode surrogate pair at the specified [index].\n */\npublic fun CharSequence.hasSurrogatePairAt(index: Int): Boolean {\n    return index in 0..length - 2\n            && this[index].isHighSurrogate()\n            && this[index + 1].isLowSurrogate()\n}\n\n/**\n * Returns a substring specified by the given [range] of indices.\n */\npublic fun String.substring(range: IntRange): String = substring(range.start, range.endInclusive + 1)\n\n/**\n * Returns a subsequence of this char sequence specified by the given [range] of indices.\n */\npublic fun CharSequence.subSequence(range: IntRange): CharSequence = subSequence(range.start, range.endInclusive + 1)\n\n/**\n * Returns a subsequence of this char sequence.\n *\n * This extension is chosen only for invocation with old-named parameters.\n * Replace parameter names with the same as those of [CharSequence.subSequence].\n */\n@kotlin.internal.InlineOnly\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning\n@Deprecated(\"Use parameters named startIndex and endIndex.\", ReplaceWith(\"subSequence(startIndex = start, endIndex = end)\"))\npublic inline fun String.subSequence(start: Int, end: Int): CharSequence = subSequence(start, end)\n\n/**\n * Returns a substring of chars from a range of this char sequence starting at the [startIndex] and ending right before the [endIndex].\n *\n * @param startIndex the start index (inclusive).\n * @param endIndex the end index (exclusive). If not specified, the length of the char sequence is used.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.substring(startIndex: Int, endIndex: Int = length): String = subSequence(startIndex, endIndex).toString()\n\n/**\n * Returns a substring of chars at indices from the specified [range] of this char sequence.\n */\npublic fun CharSequence.substring(range: IntRange): String = subSequence(range.start, range.endInclusive + 1).toString()\n\n/**\n * Returns a substring before the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBefore(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring before the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBefore(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring after the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfter(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + 1, length)\n}\n\n/**\n * Returns a substring after the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfter(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + delimiter.length, length)\n}\n\n/**\n * Returns a substring before the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBeforeLast(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring before the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBeforeLast(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring after the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfterLast(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + 1, length)\n}\n\n/**\n * Returns a substring after the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfterLast(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + delimiter.length, length)\n}\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given range\n * is replaced with the [replacement] char sequence.\n * @param startIndex the index of the first character to be replaced.\n * @param endIndex the index of the first character after the replacement to keep in the string.\n */\n@OptIn(ExperimentalStdlibApi::class)\npublic fun CharSequence.replaceRange(startIndex: Int, endIndex: Int, replacement: CharSequence): CharSequence {\n    if (endIndex < startIndex)\n        throw IndexOutOfBoundsException(\"End index ($endIndex) is less than start index ($startIndex).\")\n    val sb = StringBuilder()\n    sb.appendRange(this, 0, startIndex)\n    sb.append(replacement)\n    sb.appendRange(this, endIndex, length)\n    return sb\n}\n\n/**\n * Replaces the part of the string at the given range with the [replacement] char sequence.\n * @param startIndex the index of the first character to be replaced.\n * @param endIndex the index of the first character after the replacement to keep in the string.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.replaceRange(startIndex: Int, endIndex: Int, replacement: CharSequence): String =\n    (this as CharSequence).replaceRange(startIndex, endIndex, replacement).toString()\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given [range]\n * is replaced with the [replacement] char sequence.\n *\n * The end index of the [range] is included in the part to be replaced.\n */\npublic fun CharSequence.replaceRange(range: IntRange, replacement: CharSequence): CharSequence =\n    replaceRange(range.start, range.endInclusive + 1, replacement)\n\n/**\n * Replace the part of string at the given [range] with the [replacement] string.\n *\n * The end index of the [range] is included in the part to be replaced.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.replaceRange(range: IntRange, replacement: CharSequence): String =\n    (this as CharSequence).replaceRange(range, replacement).toString()\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given range is removed.\n *\n * @param startIndex the index of the first character to be removed.\n * @param endIndex the index of the first character after the removed part to keep in the string.\n *\n * [endIndex] is not included in the removed part.\n */\n@OptIn(ExperimentalStdlibApi::class)\npublic fun CharSequence.removeRange(startIndex: Int, endIndex: Int): CharSequence {\n    if (endIndex < startIndex)\n        throw IndexOutOfBoundsException(\"End index ($endIndex) is less than start index ($startIndex).\")\n\n    if (endIndex == startIndex)\n        return this.subSequence(0, length)\n\n    val sb = StringBuilder(length - (endIndex - startIndex))\n    sb.appendRange(this, 0, startIndex)\n    sb.appendRange(this, endIndex, length)\n    return sb\n}\n\n/**\n * Removes the part of a string at a given range.\n * @param startIndex the index of the first character to be removed.\n * @param endIndex the index of the first character after the removed part to keep in the string.\n *\n *  [endIndex] is not included in the removed part.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.removeRange(startIndex: Int, endIndex: Int): String =\n    (this as CharSequence).removeRange(startIndex, endIndex).toString()\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given [range] is removed.\n *\n * The end index of the [range] is included in the removed part.\n */\npublic fun CharSequence.removeRange(range: IntRange): CharSequence = removeRange(range.start, range.endInclusive + 1)\n\n/**\n * Removes the part of a string at the given [range].\n *\n * The end index of the [range] is included in the removed part.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.removeRange(range: IntRange): String =\n    (this as CharSequence).removeRange(range).toString()\n\n/**\n * If this char sequence starts with the given [prefix], returns a new char sequence\n * with the prefix removed. Otherwise, returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removePrefix(prefix: CharSequence): CharSequence {\n    if (startsWith(prefix)) {\n        return subSequence(prefix.length, length)\n    }\n    return subSequence(0, length)\n}\n\n/**\n * If this string starts with the given [prefix], returns a copy of this string\n * with the prefix removed. Otherwise, returns this string.\n */\npublic fun String.removePrefix(prefix: CharSequence): String {\n    if (startsWith(prefix)) {\n        return substring(prefix.length)\n    }\n    return this\n}\n\n/**\n * If this char sequence ends with the given [suffix], returns a new char sequence\n * with the suffix removed. Otherwise, returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removeSuffix(suffix: CharSequence): CharSequence {\n    if (endsWith(suffix)) {\n        return subSequence(0, length - suffix.length)\n    }\n    return subSequence(0, length)\n}\n\n/**\n * If this string ends with the given [suffix], returns a copy of this string\n * with the suffix removed. Otherwise, returns this string.\n */\npublic fun String.removeSuffix(suffix: CharSequence): String {\n    if (endsWith(suffix)) {\n        return substring(0, length - suffix.length)\n    }\n    return this\n}\n\n/**\n * When this char sequence starts with the given [prefix] and ends with the given [suffix],\n * returns a new char sequence having both the given [prefix] and [suffix] removed.\n * Otherwise returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removeSurrounding(prefix: CharSequence, suffix: CharSequence): CharSequence {\n    if ((length >= prefix.length + suffix.length) && startsWith(prefix) && endsWith(suffix)) {\n        return subSequence(prefix.length, length - suffix.length)\n    }\n    return subSequence(0, length)\n}\n\n/**\n * Removes from a string both the given [prefix] and [suffix] if and only if\n * it starts with the [prefix] and ends with the [suffix].\n * Otherwise returns this string unchanged.\n */\npublic fun String.removeSurrounding(prefix: CharSequence, suffix: CharSequence): String {\n    if ((length >= prefix.length + suffix.length) && startsWith(prefix) && endsWith(suffix)) {\n        return substring(prefix.length, length - suffix.length)\n    }\n    return this\n}\n\n/**\n * When this char sequence starts with and ends with the given [delimiter],\n * returns a new char sequence having this [delimiter] removed both from the start and end.\n * Otherwise returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removeSurrounding(delimiter: CharSequence): CharSequence = removeSurrounding(delimiter, delimiter)\n\n/**\n * Removes the given [delimiter] string from both the start and the end of this string\n * if and only if it starts with and ends with the [delimiter].\n * Otherwise returns this string unchanged.\n */\npublic fun String.removeSurrounding(delimiter: CharSequence): String = removeSurrounding(delimiter, delimiter)\n\n/**\n * Replace part of string before the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBefore(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n/**\n * Replace part of string before the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBefore(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n/**\n * Replace part of string after the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfter(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + 1, length, replacement)\n}\n\n/**\n * Replace part of string after the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfter(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + delimiter.length, length, replacement)\n}\n\n/**\n * Replace part of string after the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfterLast(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + delimiter.length, length, replacement)\n}\n\n/**\n * Replace part of string after the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfterLast(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + 1, length, replacement)\n}\n\n/**\n * Replace part of string before the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBeforeLast(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n/**\n * Replace part of string before the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBeforeLast(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n\n// public fun String.replace(oldChar: Char, newChar: Char, ignoreCase: Boolean): String // JVM- and JS-specific\n// public fun String.replace(oldValue: String, newValue: String, ignoreCase: Boolean): String // JVM- and JS-specific\n\n/**\n * Returns a new string obtained by replacing each substring of this char sequence that matches the given regular expression\n * with the given [replacement].\n *\n * The [replacement] can consist of any combination of literal text and $-substitutions. To treat the replacement string\n * literally escape it with the [kotlin.text.Regex.Companion.escapeReplacement] method.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.replace(regex: Regex, replacement: String): String = regex.replace(this, replacement)\n\n/**\n * Returns a new string obtained by replacing each substring of this char sequence that matches the given regular expression\n * with the result of the given function [transform] that takes [MatchResult] and returns a string to be used as a\n * replacement for that match.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.replace(regex: Regex, noinline transform: (MatchResult) -> CharSequence): String =\n    regex.replace(this, transform)\n\n/**\n * Replaces the first occurrence of the given regular expression [regex] in this char sequence with specified [replacement] expression.\n *\n * @param replacement A replacement expression that can include substitutions. See [Regex.replaceFirst] for details.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.replaceFirst(regex: Regex, replacement: String): String = regex.replaceFirst(this, replacement)\n\n/**\n * Returns a copy of this string having its first character replaced with the result of the specified [transform],\n * or the original string if it's empty.\n *\n * @param transform function that takes the first character and returns the result of the transform applied to the character.\n *\n * @sample samples.text.Strings.replaceFirstChar\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@JvmName(\"replaceFirstCharWithChar\")\n@kotlin.internal.InlineOnly\npublic inline fun String.replaceFirstChar(transform: (Char) -> Char): String {\n    return if (isNotEmpty()) transform(this[0]) + substring(1) else this\n}\n\n/**\n * Returns a copy of this string having its first character replaced with the result of the specified [transform],\n * or the original string if it's empty.\n *\n * @param transform function that takes the first character and returns the result of the transform applied to the character.\n *\n * @sample samples.text.Strings.replaceFirstChar\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@JvmName(\"replaceFirstCharWithCharSequence\")\n@kotlin.internal.InlineOnly\npublic inline fun String.replaceFirstChar(transform: (Char) -> CharSequence): String {\n    return if (isNotEmpty()) transform(this[0]).toString() + substring(1) else this\n}\n\n\n/**\n * Returns `true` if this char sequence matches the given regular expression.\n */\n@kotlin.internal.InlineOnly\npublic inline infix fun CharSequence.matches(regex: Regex): Boolean = regex.matches(this)\n\n/**\n * Implementation of [regionMatches] for CharSequences.\n * Invoked when it's already known that arguments are not Strings, so that no additional type checks are performed.\n */\ninternal fun CharSequence.regionMatchesImpl(thisOffset: Int, other: CharSequence, otherOffset: Int, length: Int, ignoreCase: Boolean): Boolean {\n    if ((otherOffset < 0) || (thisOffset < 0) || (thisOffset > this.length - length) || (otherOffset > other.length - length)) {\n        return false\n    }\n\n    for (index in 0 until length) {\n        if (!this[thisOffset + index].equals(other[otherOffset + index], ignoreCase))\n            return false\n    }\n    return true\n}\n\n/**\n * Returns `true` if this char sequence starts with the specified character.\n */\npublic fun CharSequence.startsWith(char: Char, ignoreCase: Boolean = false): Boolean =\n    this.length > 0 && this[0].equals(char, ignoreCase)\n\n/**\n * Returns `true` if this char sequence ends with the specified character.\n */\npublic fun CharSequence.endsWith(char: Char, ignoreCase: Boolean = false): Boolean =\n    this.length > 0 && this[lastIndex].equals(char, ignoreCase)\n\n/**\n * Returns `true` if this char sequence starts with the specified prefix.\n */\npublic fun CharSequence.startsWith(prefix: CharSequence, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase && this is String && prefix is String)\n        return this.startsWith(prefix)\n    else\n        return regionMatchesImpl(0, prefix, 0, prefix.length, ignoreCase)\n}\n\n/**\n * Returns `true` if a substring of this char sequence starting at the specified offset [startIndex] starts with the specified prefix.\n */\npublic fun CharSequence.startsWith(prefix: CharSequence, startIndex: Int, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase && this is String && prefix is String)\n        return this.startsWith(prefix, startIndex)\n    else\n        return regionMatchesImpl(startIndex, prefix, 0, prefix.length, ignoreCase)\n}\n\n/**\n * Returns `true` if this char sequence ends with the specified suffix.\n */\npublic fun CharSequence.endsWith(suffix: CharSequence, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase && this is String && suffix is String)\n        return this.endsWith(suffix)\n    else\n        return regionMatchesImpl(length - suffix.length, suffix, 0, suffix.length, ignoreCase)\n}\n\n\n// common prefix and suffix\n\n/**\n * Returns the longest string `prefix` such that this char sequence and [other] char sequence both start with this prefix,\n * taking care not to split surrogate pairs.\n * If this and [other] have no common prefix, returns the empty string.\n\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @sample samples.text.Strings.commonPrefixWith\n */\npublic fun CharSequence.commonPrefixWith(other: CharSequence, ignoreCase: Boolean = false): String {\n    val shortestLength = minOf(this.length, other.length)\n\n    var i = 0\n    while (i < shortestLength && this[i].equals(other[i], ignoreCase = ignoreCase)) {\n        i++\n    }\n    if (this.hasSurrogatePairAt(i - 1) || other.hasSurrogatePairAt(i - 1)) {\n        i--\n    }\n    return subSequence(0, i).toString()\n}\n\n/**\n * Returns the longest string `suffix` such that this char sequence and [other] char sequence both end with this suffix,\n * taking care not to split surrogate pairs.\n * If this and [other] have no common suffix, returns the empty string.\n\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @sample samples.text.Strings.commonSuffixWith\n */\npublic fun CharSequence.commonSuffixWith(other: CharSequence, ignoreCase: Boolean = false): String {\n    val thisLength = this.length\n    val otherLength = other.length\n    val shortestLength = minOf(thisLength, otherLength)\n\n    var i = 0\n    while (i < shortestLength && this[thisLength - i - 1].equals(other[otherLength - i - 1], ignoreCase = ignoreCase)) {\n        i++\n    }\n    if (this.hasSurrogatePairAt(thisLength - i - 1) || other.hasSurrogatePairAt(otherLength - i - 1)) {\n        i--\n    }\n    return subSequence(thisLength - i, thisLength).toString()\n}\n\n\n// indexOfAny()\n\n/**\n * Finds the index of the first occurrence of any of the specified [chars] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the first occurrence of matched character from [chars] or -1 if none of [chars] are found.\n *\n */\npublic fun CharSequence.indexOfAny(chars: CharArray, startIndex: Int = 0, ignoreCase: Boolean = false): Int {\n    if (!ignoreCase && chars.size == 1 && this is String) {\n        val char = chars.single()\n        return nativeIndexOf(char, startIndex)\n    }\n\n    for (index in startIndex.coerceAtLeast(0)..lastIndex) {\n        val charAtIndex = get(index)\n        if (chars.any { it.equals(charAtIndex, ignoreCase) })\n            return index\n    }\n    return -1\n}\n\n/**\n * Finds the index of the last occurrence of any of the specified [chars] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the last occurrence of matched character from [chars] or -1 if none of [chars] are found.\n *\n */\npublic fun CharSequence.lastIndexOfAny(chars: CharArray, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int {\n    if (!ignoreCase && chars.size == 1 && this is String) {\n        val char = chars.single()\n        return nativeLastIndexOf(char, startIndex)\n    }\n\n\n    for (index in startIndex.coerceAtMost(lastIndex) downTo 0) {\n        val charAtIndex = get(index)\n        if (chars.any { it.equals(charAtIndex, ignoreCase) })\n            return index\n    }\n\n    return -1\n}\n\n\nprivate fun CharSequence.indexOf(other: CharSequence, startIndex: Int, endIndex: Int, ignoreCase: Boolean, last: Boolean = false): Int {\n    val indices = if (!last)\n        startIndex.coerceAtLeast(0)..endIndex.coerceAtMost(length)\n    else\n        startIndex.coerceAtMost(lastIndex) downTo endIndex.coerceAtLeast(0)\n\n    if (this is String && other is String) { // smart cast\n        for (index in indices) {\n            if (other.regionMatches(0, this, index, other.length, ignoreCase))\n                return index\n        }\n    } else {\n        for (index in indices) {\n            if (other.regionMatchesImpl(0, this, index, other.length, ignoreCase))\n                return index\n        }\n    }\n    return -1\n}\n\nprivate fun CharSequence.findAnyOf(strings: Collection<String>, startIndex: Int, ignoreCase: Boolean, last: Boolean): Pair<Int, String>? {\n    if (!ignoreCase && strings.size == 1) {\n        val string = strings.single()\n        val index = if (!last) indexOf(string, startIndex) else lastIndexOf(string, startIndex)\n        return if (index < 0) null else index to string\n    }\n\n    val indices = if (!last) startIndex.coerceAtLeast(0)..length else startIndex.coerceAtMost(lastIndex) downTo 0\n\n    if (this is String) {\n        for (index in indices) {\n            val matchingString = strings.firstOrNull { it.regionMatches(0, this, index, it.length, ignoreCase) }\n            if (matchingString != null)\n                return index to matchingString\n        }\n    } else {\n        for (index in indices) {\n            val matchingString = strings.firstOrNull { it.regionMatchesImpl(0, this, index, it.length, ignoreCase) }\n            if (matchingString != null)\n                return index to matchingString\n        }\n    }\n\n    return null\n}\n\n/**\n * Finds the first occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return A pair of an index of the first occurrence of matched string from [strings] and the string matched\n * or `null` if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.findAnyOf(strings: Collection<String>, startIndex: Int = 0, ignoreCase: Boolean = false): Pair<Int, String>? =\n    findAnyOf(strings, startIndex, ignoreCase, last = false)\n\n/**\n * Finds the last occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return A pair of an index of the last occurrence of matched string from [strings] and the string matched or `null` if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the end toward the beginning of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.findLastAnyOf(strings: Collection<String>, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Pair<Int, String>? =\n    findAnyOf(strings, startIndex, ignoreCase, last = true)\n\n/**\n * Finds the index of the first occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the first occurrence of matched string from [strings] or -1 if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.indexOfAny(strings: Collection<String>, startIndex: Int = 0, ignoreCase: Boolean = false): Int =\n    findAnyOf(strings, startIndex, ignoreCase, last = false)?.first ?: -1\n\n/**\n * Finds the index of the last occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the last occurrence of matched string from [strings] or -1 if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the end toward the beginning of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.lastIndexOfAny(strings: Collection<String>, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int =\n    findAnyOf(strings, startIndex, ignoreCase, last = true)?.first ?: -1\n\n\n// indexOf\n\n/**\n * Returns the index within this string of the first occurrence of the specified character, starting from the specified [startIndex].\n *\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the first occurrence of [char] or -1 if none is found.\n */\npublic fun CharSequence.indexOf(char: Char, startIndex: Int = 0, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        indexOfAny(charArrayOf(char), startIndex, ignoreCase)\n    else\n        nativeIndexOf(char, startIndex)\n}\n\n/**\n * Returns the index within this char sequence of the first occurrence of the specified [string],\n * starting from the specified [startIndex].\n *\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the first occurrence of [string] or `-1` if none is found.\n * @sample samples.text.Strings.indexOf\n */\npublic fun CharSequence.indexOf(string: String, startIndex: Int = 0, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        indexOf(string, startIndex, length, ignoreCase)\n    else\n        nativeIndexOf(string, startIndex)\n}\n\n/**\n * Returns the index within this char sequence of the last occurrence of the specified character,\n * starting from the specified [startIndex].\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the last occurrence of [char] or -1 if none is found.\n */\npublic fun CharSequence.lastIndexOf(char: Char, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        lastIndexOfAny(charArrayOf(char), startIndex, ignoreCase)\n    else\n        nativeLastIndexOf(char, startIndex)\n}\n\n/**\n * Returns the index within this char sequence of the last occurrence of the specified [string],\n * starting from the specified [startIndex].\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the last occurrence of [string] or -1 if none is found.\n */\npublic fun CharSequence.lastIndexOf(string: String, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        indexOf(string, startIndex, 0, ignoreCase, last = true)\n    else\n        nativeLastIndexOf(string, startIndex)\n}\n\n/**\n * Returns `true` if this char sequence contains the specified [other] sequence of characters as a substring.\n *\n * @param ignoreCase `true` to ignore character case when comparing strings. By default `false`.\n */\n@Suppress(\"INAPPLICABLE_OPERATOR_MODIFIER\")\npublic operator fun CharSequence.contains(other: CharSequence, ignoreCase: Boolean = false): Boolean =\n    if (other is String)\n        indexOf(other, ignoreCase = ignoreCase) >= 0\n    else\n        indexOf(other, 0, length, ignoreCase) >= 0\n\n\n\n/**\n * Returns `true` if this char sequence contains the specified character [char].\n *\n * @param ignoreCase `true` to ignore character case when comparing characters. By default `false`.\n */\n@Suppress(\"INAPPLICABLE_OPERATOR_MODIFIER\")\npublic operator fun CharSequence.contains(char: Char, ignoreCase: Boolean = false): Boolean =\n    indexOf(char, ignoreCase = ignoreCase) >= 0\n\n/**\n * Returns `true` if this char sequence contains at least one match of the specified regular expression [regex].\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharSequence.contains(regex: Regex): Boolean = regex.containsMatchIn(this)\n\n\n// rangesDelimitedBy\n\n\nprivate class DelimitedRangesSequence(\n    private val input: CharSequence,\n    private val startIndex: Int,\n    private val limit: Int,\n    private val getNextMatch: CharSequence.(currentIndex: Int) -> Pair<Int, Int>?\n) : Sequence<IntRange> {\n\n    override fun iterator(): Iterator<IntRange> = object : Iterator<IntRange> {\n        var nextState: Int = -1 // -1 for unknown, 0 for done, 1 for continue\n        var currentStartIndex: Int = startIndex.coerceIn(0, input.length)\n        var nextSearchIndex: Int = currentStartIndex\n        var nextItem: IntRange? = null\n        var counter: Int = 0\n\n        private fun calcNext() {\n            if (nextSearchIndex < 0) {\n                nextState = 0\n                nextItem = null\n            } else {\n                if (limit > 0 && ++counter >= limit || nextSearchIndex > input.length) {\n                    nextItem = currentStartIndex..input.lastIndex\n                    nextSearchIndex = -1\n                } else {\n                    val match = input.getNextMatch(nextSearchIndex)\n                    if (match == null) {\n                        nextItem = currentStartIndex..input.lastIndex\n                        nextSearchIndex = -1\n                    } else {\n                        val (index, length) = match\n                        nextItem = currentStartIndex until index\n                        currentStartIndex = index + length\n                        nextSearchIndex = currentStartIndex + if (length == 0) 1 else 0\n                    }\n                }\n                nextState = 1\n            }\n        }\n\n        override fun next(): IntRange {\n            if (nextState == -1)\n                calcNext()\n            if (nextState == 0)\n                throw NoSuchElementException()\n            val result = nextItem as IntRange\n            // Clean next to avoid keeping reference on yielded instance\n            nextItem = null\n            nextState = -1\n            return result\n        }\n\n        override fun hasNext(): Boolean {\n            if (nextState == -1)\n                calcNext()\n            return nextState == 1\n        }\n    }\n}\n\n/**\n * Returns a sequence of index ranges of substrings in this char sequence around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more characters to be used as delimiters.\n * @param startIndex The index to start searching delimiters from.\n *  No range having its start value less than [startIndex] is returned.\n *  [startIndex] is coerced to be non-negative and not greater than length of this string.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n */\nprivate fun CharSequence.rangesDelimitedBy(delimiters: CharArray, startIndex: Int = 0, ignoreCase: Boolean = false, limit: Int = 0): Sequence<IntRange> {\n    require(limit >= 0, { \"Limit must be non-negative, but was $limit.\" })\n\n    return DelimitedRangesSequence(this, startIndex, limit, { currentIndex ->\n        indexOfAny(delimiters, currentIndex, ignoreCase = ignoreCase).let { if (it < 0) null else it to 1 }\n    })\n}\n\n\n/**\n * Returns a sequence of index ranges of substrings in this char sequence around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more strings to be used as delimiters.\n * @param startIndex The index to start searching delimiters from.\n *  No range having its start value less than [startIndex] is returned.\n *  [startIndex] is coerced to be non-negative and not greater than length of this string.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n *\n * To avoid ambiguous results when strings in [delimiters] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [delimiters]\n * that matches this string at that position.\n */\nprivate fun CharSequence.rangesDelimitedBy(delimiters: Array<out String>, startIndex: Int = 0, ignoreCase: Boolean = false, limit: Int = 0): Sequence<IntRange> {\n    require(limit >= 0, { \"Limit must be non-negative, but was $limit.\" } )\n    val delimitersList = delimiters.asList()\n\n    return DelimitedRangesSequence(this, startIndex, limit, { currentIndex -> findAnyOf(delimitersList, currentIndex, ignoreCase = ignoreCase, last = false)?.let { it.first to it.second.length } })\n\n}\n\n\n// split\n\n/**\n * Splits this char sequence to a sequence of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more strings to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n *\n * To avoid ambiguous results when strings in [delimiters] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [delimiters]\n * that matches this string at that position.\n */\npublic fun CharSequence.splitToSequence(vararg delimiters: String, ignoreCase: Boolean = false, limit: Int = 0): Sequence<String> =\n    rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).map { substring(it) }\n\n/**\n * Splits this char sequence to a list of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more strings to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n *\n * To avoid ambiguous results when strings in [delimiters] have characters in common, this method proceeds from\n * the beginning to the end of this string, and matches at each position the first element in [delimiters]\n * that is equal to a delimiter in this instance at that position.\n */\npublic fun CharSequence.split(vararg delimiters: String, ignoreCase: Boolean = false, limit: Int = 0): List<String> {\n    if (delimiters.size == 1) {\n        val delimiter = delimiters[0]\n        if (!delimiter.isEmpty()) {\n            return split(delimiter, ignoreCase, limit)\n        }\n    }\n\n    return rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).asIterable().map { substring(it) }\n}\n\n/**\n * Splits this char sequence to a sequence of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more characters to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return.\n */\npublic fun CharSequence.splitToSequence(vararg delimiters: Char, ignoreCase: Boolean = false, limit: Int = 0): Sequence<String> =\n    rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).map { substring(it) }\n\n/**\n * Splits this char sequence to a list of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more characters to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return.\n */\npublic fun CharSequence.split(vararg delimiters: Char, ignoreCase: Boolean = false, limit: Int = 0): List<String> {\n    if (delimiters.size == 1) {\n        return split(delimiters[0].toString(), ignoreCase, limit)\n    }\n\n    return rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).asIterable().map { substring(it) }\n}\n\n/**\n * Splits this char sequence to a list of strings around occurrences of the specified [delimiter].\n * This is specialized version of split which receives single non-empty delimiter and offers better performance\n *\n * @param delimiter String used as delimiter\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return.\n */\nprivate fun CharSequence.split(delimiter: String, ignoreCase: Boolean, limit: Int): List<String> {\n    require(limit >= 0, { \"Limit must be non-negative, but was $limit.\" })\n\n    var currentOffset = 0\n    var nextIndex = indexOf(delimiter, currentOffset, ignoreCase)\n    if (nextIndex == -1 || limit == 1) {\n        return listOf(this.toString())\n    }\n\n    val isLimited = limit > 0\n    val result = ArrayList<String>(if (isLimited) limit.coerceAtMost(10) else 10)\n    do {\n        result.add(substring(currentOffset, nextIndex))\n        currentOffset = nextIndex + delimiter.length\n        // Do not search for next occurrence if we're reaching limit\n        if (isLimited && result.size == limit - 1) break\n        nextIndex = indexOf(delimiter, currentOffset, ignoreCase)\n    } while (nextIndex != -1)\n\n    result.add(substring(currentOffset, length))\n    return result\n}\n\n/**\n * Splits this char sequence around matches of the given regular expression.\n *\n * @param limit Non-negative value specifying the maximum number of substrings to return.\n * Zero by default means no limit is set.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.split(regex: Regex, limit: Int = 0): List<String> = regex.split(this, limit)\n\n/**\n * Splits this char sequence to a sequence of lines delimited by any of the following character sequences: CRLF, LF or CR.\n *\n * The lines returned do not include terminating line separators.\n */\npublic fun CharSequence.lineSequence(): Sequence<String> = splitToSequence(\"\\r\\n\", \"\\n\", \"\\r\")\n\n/**\n * Splits this char sequence to a list of lines delimited by any of the following character sequences: CRLF, LF or CR.\n *\n * The lines returned do not include terminating line separators.\n */\npublic fun CharSequence.lines(): List<String> = lineSequence().toList()\n\n/**\n * Returns `true` if the contents of this char sequence are equal to the contents of the specified [other],\n * i.e. both char sequences contain the same number of the same characters in the same order.\n *\n * @sample samples.text.Strings.contentEquals\n */\n@SinceKotlin(\"1.5\")\npublic expect infix fun CharSequence?.contentEquals(other: CharSequence?): Boolean\n\n/**\n * Returns `true` if the contents of this char sequence are equal to the contents of the specified [other], optionally ignoring case difference.\n *\n * @param ignoreCase `true` to ignore character case when comparing contents.\n *\n * @sample samples.text.Strings.contentEquals\n */\n@SinceKotlin(\"1.5\")\npublic expect fun CharSequence?.contentEquals(other: CharSequence?, ignoreCase: Boolean): Boolean\n\ninternal fun CharSequence?.contentEqualsIgnoreCaseImpl(other: CharSequence?): Boolean {\n    if (this is String && other is String) {\n        return this.equals(other, ignoreCase = true)\n    }\n\n    if (this === other) return true\n    if (this == null || other == null || this.length != other.length) return false\n\n    for (i in 0 until length) {\n        if (!this[i].equals(other[i], ignoreCase = true)) {\n            return false\n        }\n    }\n\n    return true\n}\n\ninternal fun CharSequence?.contentEqualsImpl(other: CharSequence?): Boolean {\n    if (this is String && other is String) {\n        return this == other\n    }\n\n    if (this === other) return true\n    if (this == null || other == null || this.length != other.length) return false\n\n    for (i in 0 until length) {\n        if (this[i] != other[i]) {\n            return false\n        }\n    }\n\n    return true\n}\n\n/**\n * Returns `true` if the content of this string is equal to the word \"true\", `false` if it is equal to \"false\",\n * and throws an exception otherwise.\n *\n * There is also a lenient version of the function available on nullable String, [String?.toBoolean].\n * Note that this function is case-sensitive.\n *\n * @sample samples.text.Strings.toBooleanStrict\n */\n@SinceKotlin(\"1.5\")\npublic fun String.toBooleanStrict(): Boolean = when (this) {\n    \"true\" -> true\n    \"false\" -> false\n    else -> throw IllegalArgumentException(\"The string doesn't represent a boolean value: $this\")\n}\n\n/**\n * Returns `true` if the content of this string is equal to the word \"true\", `false` if it is equal to \"false\",\n * and `null` otherwise.\n *\n * There is also a lenient version of the function available on nullable String, [String?.toBoolean].\n * Note that this function is case-sensitive.\n *\n * @sample samples.text.Strings.toBooleanStrictOrNull\n */\n@SinceKotlin(\"1.5\")\npublic fun String.toBooleanStrictOrNull(): Boolean? = when (this) {\n    \"true\" -> true\n    \"false\" -> false\n    else -> null\n}","package kotlinx.html\n\nimport kotlinx.html.*\nimport kotlinx.html.impl.*\nimport kotlinx.html.attributes.*\n\n/*******************************************************************************\n    DO NOT EDIT\n    This file was generated by module generate\n*******************************************************************************/\n\ninterface FlowOrHeadingContent : Tag {\n}\n\ninterface FlowOrMetaDataContent : FlowOrPhrasingOrMetaDataContent, Tag {\n}\n\ninterface FlowOrInteractiveContent : FlowOrInteractiveOrPhrasingContent, Tag {\n}\n\ninterface FlowOrPhrasingContent : FlowOrInteractiveOrPhrasingContent, FlowOrPhrasingOrMetaDataContent, Tag {\n}\n\ninterface FlowOrPhrasingOrMetaDataContent : Tag {\n}\n\ninterface SectioningOrFlowContent : Tag {\n}\n\ninterface FlowOrInteractiveOrPhrasingContent : Tag {\n}\n\n\n\n/**\n * Heading\n */\n@HtmlTagMarker\ninline fun FlowOrHeadingContent.h1(classes : String? = null, crossinline block : H1.() -> Unit = {}) : Unit = H1(attributesMapOf(\"class\", classes), consumer).visit(block)\n\n/**\n * Heading\n */\n@HtmlTagMarker\ninline fun FlowOrHeadingContent.h2(classes : String? = null, crossinline block : H2.() -> Unit = {}) : Unit = H2(attributesMapOf(\"class\", classes), consumer).visit(block)\n\n/**\n * Heading\n */\n@HtmlTagMarker\ninline fun FlowOrHeadingContent.h3(classes : String? = null, crossinline block : H3.() -> Unit = {}) : Unit = H3(attributesMapOf(\"class\", classes), consumer).visit(block)\n\n/**\n * Heading\n */\n@HtmlTagMarker\ninline fun FlowOrHeadingContent.h4(classes : String? = null, crossinline block : H4.() -> Unit = {}) : Unit = H4(attributesMapOf(\"class\", classes), consumer).visit(block)\n\n/**\n * Heading\n */\n@HtmlTagMarker\ninline fun FlowOrHeadingContent.h5(classes : String? = null, crossinline block : H5.() -> Unit = {}) : Unit = H5(attributesMapOf(\"class\", classes), consumer).visit(block)\n\n/**\n * Heading\n */\n@HtmlTagMarker\ninline fun FlowOrHeadingContent.h6(classes : String? = null, crossinline block : H6.() -> Unit = {}) : Unit = H6(attributesMapOf(\"class\", classes), consumer).visit(block)\n\n@HtmlTagMarker\ninline fun FlowOrHeadingContent.hGroup(classes : String? = null, crossinline block : HGROUP.() -> Unit = {}) : Unit = HGROUP(attributesMapOf(\"class\", classes), consumer).visit(block)\n\n\n/**\n * Style info\n */\n@HtmlTagMarker\ninline fun FlowOrMetaDataContent.style(type : String? = null, crossinline block : STYLE.() -> Unit = {}) : Unit = STYLE(attributesMapOf(\"type\", type), consumer).visit(block)\n@Deprecated(\"This tag doesn't support content or requires unsafe (try unsafe {})\")\n@Suppress(\"DEPRECATION\")\n/**\n * Style info\n */\n@HtmlTagMarker\nfun FlowOrMetaDataContent.style(type : String? = null, content : String = \"\") : Unit = STYLE(attributesMapOf(\"type\", type), consumer).visit({+content})\n\n\n/**\n * Disclosure control for hiding details\n */\n@HtmlTagMarker\ninline fun FlowOrInteractiveContent.details(classes : String? = null, crossinline block : DETAILS.() -> Unit = {}) : Unit = DETAILS(attributesMapOf(\"class\", classes), consumer).visit(block)\n\n\n/**\n * Abbreviated form (e.g., WWW, HTTP,etc.)\n */\n@HtmlTagMarker\ninline fun FlowOrPhrasingContent.abbr(classes : String? = null, crossinline block : ABBR.() -> Unit = {}) : Unit = ABBR(attributesMapOf(\"class\", classes), consumer).visit(block)\n\n/**\n * Client-side image map area\n */\n@HtmlTagMarker\ninline fun FlowOrPhrasingContent.area(shape : AreaShape? = null, alt : String? = null, classes : String? = null, crossinline block : AREA.() -> Unit = {}) : Unit = AREA(attributesMapOf(\"Shape\", shape?.enumEncode(),\"alt\", alt,\"class\", classes), consumer).visit(block)\n@HtmlTagMarker\ninline fun FlowOrPhrasingContent.rectArea(alt : String? = null, classes : String? = null, crossinline block : AREA.() -> Unit = {}) : Unit = AREA(attributesMapOf(\"Shape\", AreaShape.rect.realValue,\"alt\", alt,\"class\", classes), consumer).visit(block)\n@HtmlTagMarker\ninline fun FlowOrPhrasingContent.circleArea(alt : String? = null, classes : String? = null, crossinline block : AREA.() -> Unit = {}) : Unit = AREA(attributesMapOf(\"Shape\", AreaShape.circle.realValue,\"alt\", alt,\"class\", classes), consumer).visit(block)\n@HtmlTagMarker\ninline fun FlowOrPhrasingContent.polyArea(alt : String? = null, classes : String? = null, crossinline block : AREA.() -> Unit = {}) : Unit = AREA(attributesMapOf(\"Shape\", AreaShape.poly.realValue,\"alt\", alt,\"class\", classes), consumer).visit(block)\n@HtmlTagMarker\ninline fun FlowOrPhrasingContent.defaultArea(alt : String? = null, classes : String? = null, crossinline block : AREA.() -> Unit = {}) : Unit = AREA(attributesMapOf(\"Shape\", AreaShape.default.realValue,\"alt\", alt,\"class\", classes), consumer).visit(block)\n\n/**\n * Bold text style\n */\n@HtmlTagMarker\ninline fun FlowOrPhrasingContent.b(classes : String? = null, crossinline block : B.() -> Unit = {}) : Unit = B(attributesMapOf(\"class\", classes), consumer).visit(block)\n\n/**\n * Text directionality isolation\n */\n@HtmlTagMarker\ninline fun FlowOrPhrasingContent.bdi(classes : String? = null, crossinline block : BDI.() -> Unit = {}) : Unit = BDI(attributesMapOf(\"class\", classes), consumer).visit(block)\n\n/**\n * I18N BiDi over-ride\n */\n@HtmlTagMarker\ninline fun FlowOrPhrasingContent.bdo(classes : String? = null, crossinline block : BDO.() -> Unit = {}) : Unit = BDO(attributesMapOf(\"class\", classes), consumer).visit(block)\n\n/**\n * Forced line break\n */\n@HtmlTagMarker\ninline fun FlowOrPhrasingContent.br(classes : String? = null, crossinline block : BR.() -> Unit = {}) : Unit = BR(attributesMapOf(\"class\", classes), consumer).visit(block)\n\n/**\n * Scriptable bitmap canvas\n */\n@HtmlTagMarker\ninline fun FlowOrPhrasingContent.canvas(classes : String? = null, crossinline block : CANVAS.() -> Unit = {}) : Unit = CANVAS(attributesMapOf(\"class\", classes), consumer).visit(block)\n/**\n * Scriptable bitmap canvas\n */\n@HtmlTagMarker\nfun FlowOrPhrasingContent.canvas(classes : String? = null, content : String = \"\") : Unit = CANVAS(attributesMapOf(\"class\", classes), consumer).visit({+content})\n\n/**\n * Citation\n */\n@HtmlTagMarker\ninline fun FlowOrPhrasingContent.cite(classes : String? = null, crossinline block : CITE.() -> Unit = {}) : Unit = CITE(attributesMapOf(\"class\", classes), consumer).visit(block)\n\n/**\n * Computer code fragment\n */\n@HtmlTagMarker\ninline fun FlowOrPhrasingContent.code(classes : String? = null, crossinline block : CODE.() -> Unit = {}) : Unit = CODE(attributesMapOf(\"class\", classes), consumer).visit(block)\n\n/**\n * Container for options for \n */\n@HtmlTagMarker\ninline fun FlowOrPhrasingContent.dataList(classes : String? = null, crossinline block : DATALIST.() -> Unit = {}) : Unit = DATALIST(attributesMapOf(\"class\", classes), consumer).visit(block)\n\n/**\n * Deleted text\n */\n@HtmlTagMarker\ninline fun FlowOrPhrasingContent.del(classes : String? = null, crossinline block : DEL.() -> Unit = {}) : Unit = DEL(attributesMapOf(\"class\", classes), consumer).visit(block)\n\n/**\n * Instance definition\n */\n@HtmlTagMarker\ninline fun FlowOrPhrasingContent.dfn(classes : String? = null, crossinline block : DFN.() -> Unit = {}) : Unit = DFN(attributesMapOf(\"class\", classes), consumer).visit(block)\n\n/**\n * Emphasis\n */\n@HtmlTagMarker\ninline fun FlowOrPhrasingContent.em(classes : String? = null, crossinline block : EM.() -> Unit = {}) : Unit = EM(attributesMapOf(\"class\", classes), consumer).visit(block)\n\n/**\n * Italic text style\n */\n@HtmlTagMarker\ninline fun FlowOrPhrasingContent.i(classes : String? = null, crossinline block : I.() -> Unit = {}) : Unit = I(attributesMapOf(\"class\", classes), consumer).visit(block)\n\n/**\n * Inserted text\n */\n@HtmlTagMarker\ninline fun FlowOrPhrasingContent.ins(classes : String? = null, crossinline block : INS.() -> Unit = {}) : Unit = INS(attributesMapOf(\"class\", classes), consumer).visit(block)\n\n/**\n * Text to be entered by the user\n */\n@HtmlTagMarker\ninline fun FlowOrPhrasingContent.kbd(classes : String? = null, crossinline block : KBD.() -> Unit = {}) : Unit = KBD(attributesMapOf(\"class\", classes), consumer).visit(block)\n\n/**\n * Client-side image map\n */\n@HtmlTagMarker\ninline fun FlowOrPhrasingContent.map(name : String? = null, classes : String? = null, crossinline block : MAP.() -> Unit = {}) : Unit = MAP(attributesMapOf(\"name\", name,\"class\", classes), consumer).visit(block)\n\n/**\n * Highlight\n */\n@HtmlTagMarker\ninline fun FlowOrPhrasingContent.mark(classes : String? = null, crossinline block : MARK.() -> Unit = {}) : Unit = MARK(attributesMapOf(\"class\", classes), consumer).visit(block)\n\n@HtmlTagMarker\ninline fun FlowOrPhrasingContent.math(classes : String? = null, crossinline block : MATH.() -> Unit = {}) : Unit = MATH(attributesMapOf(\"class\", classes), consumer).visit(block)\n\n/**\n * Gauge\n */\n@HtmlTagMarker\ninline fun FlowOrPhrasingContent.meter(classes : String? = null, crossinline block : METER.() -> Unit = {}) : Unit = METER(attributesMapOf(\"class\", classes), consumer).visit(block)\n\n/**\n * Calculated output value\n */\n@HtmlTagMarker\ninline fun FlowOrPhrasingContent.output(classes : String? = null, crossinline block : OUTPUT.() -> Unit = {}) : Unit = OUTPUT(attributesMapOf(\"class\", classes), consumer).visit(block)\n\n/**\n * Progress bar\n */\n@HtmlTagMarker\ninline fun FlowOrPhrasingContent.progress(classes : String? = null, crossinline block : PROGRESS.() -> Unit = {}) : Unit = PROGRESS(attributesMapOf(\"class\", classes), consumer).visit(block)\n\n/**\n * Short inline quotation\n */\n@HtmlTagMarker\ninline fun FlowOrPhrasingContent.q(classes : String? = null, crossinline block : Q.() -> Unit = {}) : Unit = Q(attributesMapOf(\"class\", classes), consumer).visit(block)\n\n/**\n * Ruby annotation(s)\n */\n@HtmlTagMarker\ninline fun FlowOrPhrasingContent.ruby(classes : String? = null, crossinline block : RUBY.() -> Unit = {}) : Unit = RUBY(attributesMapOf(\"class\", classes), consumer).visit(block)\n\n/**\n * Strike-through text style\n */\n@HtmlTagMarker\ninline fun FlowOrPhrasingContent.samp(classes : String? = null, crossinline block : SAMP.() -> Unit = {}) : Unit = SAMP(attributesMapOf(\"class\", classes), consumer).visit(block)\n\n/**\n * Small text style\n */\n@HtmlTagMarker\ninline fun FlowOrPhrasingContent.small(classes : String? = null, crossinline block : SMALL.() -> Unit = {}) : Unit = SMALL(attributesMapOf(\"class\", classes), consumer).visit(block)\n\n/**\n * Generic language/style container\n */\n@HtmlTagMarker\ninline fun FlowOrPhrasingContent.span(classes : String? = null, crossinline block : SPAN.() -> Unit = {}) : Unit = SPAN(attributesMapOf(\"class\", classes), consumer).visit(block)\n\n/**\n * Strong emphasis\n */\n@HtmlTagMarker\ninline fun FlowOrPhrasingContent.strong(classes : String? = null, crossinline block : STRONG.() -> Unit = {}) : Unit = STRONG(attributesMapOf(\"class\", classes), consumer).visit(block)\n\n/**\n * Subscript\n */\n@HtmlTagMarker\ninline fun FlowOrPhrasingContent.sub(classes : String? = null, crossinline block : SUB.() -> Unit = {}) : Unit = SUB(attributesMapOf(\"class\", classes), consumer).visit(block)\n\n/**\n * Superscript\n */\n@HtmlTagMarker\ninline fun FlowOrPhrasingContent.sup(classes : String? = null, crossinline block : SUP.() -> Unit = {}) : Unit = SUP(attributesMapOf(\"class\", classes), consumer).visit(block)\n\n@HtmlTagMarker\ninline fun FlowOrPhrasingContent.svg(classes : String? = null, crossinline block : SVG.() -> Unit = {}) : Unit = SVG(attributesMapOf(\"class\", classes), consumer).visit(block)\n@HtmlTagMarker\nfun FlowOrPhrasingContent.svg(classes : String? = null, content : String = \"\") : Unit = SVG(attributesMapOf(\"class\", classes), consumer).visit({+content})\n\n/**\n * Machine-readable equivalent of date- or time-related data\n */\n@HtmlTagMarker\ninline fun FlowOrPhrasingContent.time(classes : String? = null, crossinline block : TIME.() -> Unit = {}) : Unit = TIME(attributesMapOf(\"class\", classes), consumer).visit(block)\n\n/**\n * Unordered list\n */\n@HtmlTagMarker\ninline fun FlowOrPhrasingContent.htmlVar(classes : String? = null, crossinline block : VAR.() -> Unit = {}) : Unit = VAR(attributesMapOf(\"class\", classes), consumer).visit(block)\n\n\n@HtmlTagMarker\ninline fun FlowOrPhrasingOrMetaDataContent.command(type : CommandType? = null, classes : String? = null, crossinline block : COMMAND.() -> Unit = {}) : Unit = COMMAND(attributesMapOf(\"type\", type?.enumEncode(),\"class\", classes), consumer).visit(block)\n@HtmlTagMarker\ninline fun FlowOrPhrasingOrMetaDataContent.commandCommand(classes : String? = null, crossinline block : COMMAND.() -> Unit = {}) : Unit = COMMAND(attributesMapOf(\"type\", CommandType.command.realValue,\"class\", classes), consumer).visit(block)\n@HtmlTagMarker\ninline fun FlowOrPhrasingOrMetaDataContent.checkBoxCommand(classes : String? = null, crossinline block : COMMAND.() -> Unit = {}) : Unit = COMMAND(attributesMapOf(\"type\", CommandType.checkBox.realValue,\"class\", classes), consumer).visit(block)\n@HtmlTagMarker\ninline fun FlowOrPhrasingOrMetaDataContent.radioCommand(classes : String? = null, crossinline block : COMMAND.() -> Unit = {}) : Unit = COMMAND(attributesMapOf(\"type\", CommandType.radio.realValue,\"class\", classes), consumer).visit(block)\n\n/**\n * A media-independent link\n */\n@HtmlTagMarker\ninline fun FlowOrPhrasingOrMetaDataContent.link(href : String? = null, rel : String? = null, type : String? = null, crossinline block : LINK.() -> Unit = {}) : Unit = LINK(attributesMapOf(\"href\", href,\"rel\", rel,\"type\", type), consumer).visit(block)\n\n/**\n * Generic metainformation\n */\n@HtmlTagMarker\ninline fun FlowOrPhrasingOrMetaDataContent.meta(name : String? = null, content : String? = null, charset : String? = null, crossinline block : META.() -> Unit = {}) : Unit = META(attributesMapOf(\"name\", name,\"content\", content,\"charset\", charset), consumer).visit(block)\n\n/**\n * Generic metainformation\n */\n@HtmlTagMarker\ninline fun FlowOrPhrasingOrMetaDataContent.noScript(classes : String? = null, crossinline block : NOSCRIPT.() -> Unit = {}) : Unit = NOSCRIPT(attributesMapOf(\"class\", classes), consumer).visit(block)\n\n/**\n * Script statements\n */\n@HtmlTagMarker\ninline fun FlowOrPhrasingOrMetaDataContent.script(type : String? = null, src : String? = null, crossinline block : SCRIPT.() -> Unit = {}) : Unit = SCRIPT(attributesMapOf(\"type\", type,\"src\", src), consumer).visit(block)\n@Deprecated(\"This tag doesn't support content or requires unsafe (try unsafe {})\")\n@Suppress(\"DEPRECATION\")\n/**\n * Script statements\n */\n@HtmlTagMarker\nfun FlowOrPhrasingOrMetaDataContent.script(type : String? = null, src : String? = null, content : String = \"\") : Unit = SCRIPT(attributesMapOf(\"type\", type,\"src\", src), consumer).visit({+content})\n\n\n/**\n * Self-contained syndicatable or reusable composition\n */\n@HtmlTagMarker\ninline fun SectioningOrFlowContent.article(classes : String? = null, crossinline block : ARTICLE.() -> Unit = {}) : Unit = ARTICLE(attributesMapOf(\"class\", classes), consumer).visit(block)\n\n/**\n * Sidebar for tangentially related content\n */\n@HtmlTagMarker\ninline fun SectioningOrFlowContent.aside(classes : String? = null, crossinline block : ASIDE.() -> Unit = {}) : Unit = ASIDE(attributesMapOf(\"class\", classes), consumer).visit(block)\n\n/**\n * Container for the dominant contents of another element\n */\n@HtmlTagMarker\ninline fun SectioningOrFlowContent.main(classes : String? = null, crossinline block : MAIN.() -> Unit = {}) : Unit = MAIN(attributesMapOf(\"class\", classes), consumer).visit(block)\n\n/**\n * Section with navigational links\n */\n@HtmlTagMarker\ninline fun SectioningOrFlowContent.nav(classes : String? = null, crossinline block : NAV.() -> Unit = {}) : Unit = NAV(attributesMapOf(\"class\", classes), consumer).visit(block)\n\n/**\n * Generic document or application section\n */\n@HtmlTagMarker\ninline fun SectioningOrFlowContent.section(classes : String? = null, crossinline block : SECTION.() -> Unit = {}) : Unit = SECTION(attributesMapOf(\"class\", classes), consumer).visit(block)\n\n\n/**\n * Anchor\n */\n@HtmlTagMarker\ninline fun FlowOrInteractiveOrPhrasingContent.a(href : String? = null, target : String? = null, classes : String? = null, crossinline block : A.() -> Unit = {}) : Unit = A(attributesMapOf(\"href\", href,\"target\", target,\"class\", classes), consumer).visit(block)\n\n/**\n * Audio player\n */\n@HtmlTagMarker\ninline fun FlowOrInteractiveOrPhrasingContent.audio(classes : String? = null, crossinline block : AUDIO.() -> Unit = {}) : Unit = AUDIO(attributesMapOf(\"class\", classes), consumer).visit(block)\n\n/**\n * Push button\n */\n@HtmlTagMarker\ninline fun FlowOrInteractiveOrPhrasingContent.button(formEncType : ButtonFormEncType? = null, formMethod : ButtonFormMethod? = null, name : String? = null, type : ButtonType? = null, classes : String? = null, crossinline block : BUTTON.() -> Unit = {}) : Unit = BUTTON(attributesMapOf(\"formenctype\", formEncType?.enumEncode(),\"formmethod\", formMethod?.enumEncode(),\"name\", name,\"type\", type?.enumEncode(),\"class\", classes), consumer).visit(block)\n@HtmlTagMarker\ninline fun FlowOrInteractiveOrPhrasingContent.getButton(formEncType : ButtonFormEncType? = null, name : String? = null, type : ButtonType? = null, classes : String? = null, crossinline block : BUTTON.() -> Unit = {}) : Unit = BUTTON(attributesMapOf(\"formenctype\", formEncType?.enumEncode(),\"formmethod\", ButtonFormMethod.get.realValue,\"name\", name,\"type\", type?.enumEncode(),\"class\", classes), consumer).visit(block)\n@HtmlTagMarker\ninline fun FlowOrInteractiveOrPhrasingContent.postButton(formEncType : ButtonFormEncType? = null, name : String? = null, type : ButtonType? = null, classes : String? = null, crossinline block : BUTTON.() -> Unit = {}) : Unit = BUTTON(attributesMapOf(\"formenctype\", formEncType?.enumEncode(),\"formmethod\", ButtonFormMethod.post.realValue,\"name\", name,\"type\", type?.enumEncode(),\"class\", classes), consumer).visit(block)\n@Suppress(\"DEPRECATION\")\n@HtmlTagMarker\ninline fun FlowOrInteractiveOrPhrasingContent.putButton(formEncType : ButtonFormEncType? = null, name : String? = null, type : ButtonType? = null, classes : String? = null, crossinline block : BUTTON.() -> Unit = {}) : Unit = BUTTON(attributesMapOf(\"formenctype\", formEncType?.enumEncode(),\"formmethod\", ButtonFormMethod.put.realValue,\"name\", name,\"type\", type?.enumEncode(),\"class\", classes), consumer).visit(block)\n@Suppress(\"DEPRECATION\")\n@HtmlTagMarker\ninline fun FlowOrInteractiveOrPhrasingContent.deleteButton(formEncType : ButtonFormEncType? = null, name : String? = null, type : ButtonType? = null, classes : String? = null, crossinline block : BUTTON.() -> Unit = {}) : Unit = BUTTON(attributesMapOf(\"formenctype\", formEncType?.enumEncode(),\"formmethod\", ButtonFormMethod.delete.realValue,\"name\", name,\"type\", type?.enumEncode(),\"class\", classes), consumer).visit(block)\n@Suppress(\"DEPRECATION\")\n@HtmlTagMarker\ninline fun FlowOrInteractiveOrPhrasingContent.patchButton(formEncType : ButtonFormEncType? = null, name : String? = null, type : ButtonType? = null, classes : String? = null, crossinline block : BUTTON.() -> Unit = {}) : Unit = BUTTON(attributesMapOf(\"formenctype\", formEncType?.enumEncode(),\"formmethod\", ButtonFormMethod.patch.realValue,\"name\", name,\"type\", type?.enumEncode(),\"class\", classes), consumer).visit(block)\n\n/**\n * Plugin\n */\n@HtmlTagMarker\ninline fun FlowOrInteractiveOrPhrasingContent.embed(classes : String? = null, crossinline block : EMBED.() -> Unit = {}) : Unit = EMBED(attributesMapOf(\"class\", classes), consumer).visit(block)\n\n/**\n * Inline subwindow\n */\n@HtmlTagMarker\ninline fun FlowOrInteractiveOrPhrasingContent.iframe(sandbox : IframeSandbox? = null, classes : String? = null, crossinline block : IFRAME.() -> Unit = {}) : Unit = IFRAME(attributesMapOf(\"sandbox\", sandbox?.enumEncode(),\"class\", classes), consumer).visit(block)\n/**\n * Inline subwindow\n */\n@HtmlTagMarker\nfun FlowOrInteractiveOrPhrasingContent.iframe(sandbox : IframeSandbox? = null, classes : String? = null, content : String = \"\") : Unit = IFRAME(attributesMapOf(\"sandbox\", sandbox?.enumEncode(),\"class\", classes), consumer).visit({+content})\n@HtmlTagMarker\ninline fun FlowOrInteractiveOrPhrasingContent.allowSameOriginIframe(classes : String? = null, crossinline block : IFRAME.() -> Unit = {}) : Unit = IFRAME(attributesMapOf(\"sandbox\", IframeSandbox.allowSameOrigin.realValue,\"class\", classes), consumer).visit(block)\n@HtmlTagMarker\ninline fun FlowOrInteractiveOrPhrasingContent.allowFormSIframe(classes : String? = null, crossinline block : IFRAME.() -> Unit = {}) : Unit = IFRAME(attributesMapOf(\"sandbox\", IframeSandbox.allowFormS.realValue,\"class\", classes), consumer).visit(block)\n@HtmlTagMarker\ninline fun FlowOrInteractiveOrPhrasingContent.allowScriptsIframe(classes : String? = null, crossinline block : IFRAME.() -> Unit = {}) : Unit = IFRAME(attributesMapOf(\"sandbox\", IframeSandbox.allowScripts.realValue,\"class\", classes), consumer).visit(block)\n@HtmlTagMarker\nfun FlowOrInteractiveOrPhrasingContent.allowSameOriginIframe(classes : String? = null, content : String = \"\") : Unit = IFRAME(attributesMapOf(\"sandbox\", IframeSandbox.allowSameOrigin.realValue,\"class\", classes), consumer).visit({+content})\n@HtmlTagMarker\nfun FlowOrInteractiveOrPhrasingContent.allowFormSIframe(classes : String? = null, content : String = \"\") : Unit = IFRAME(attributesMapOf(\"sandbox\", IframeSandbox.allowFormS.realValue,\"class\", classes), consumer).visit({+content})\n@HtmlTagMarker\nfun FlowOrInteractiveOrPhrasingContent.allowScriptsIframe(classes : String? = null, content : String = \"\") : Unit = IFRAME(attributesMapOf(\"sandbox\", IframeSandbox.allowScripts.realValue,\"class\", classes), consumer).visit({+content})\n\n/**\n * Embedded image\n */\n@HtmlTagMarker\ninline fun FlowOrInteractiveOrPhrasingContent.img(alt : String? = null, src : String? = null, classes : String? = null, crossinline block : IMG.() -> Unit = {}) : Unit = IMG(attributesMapOf(\"alt\", alt,\"src\", src,\"class\", classes), consumer).visit(block)\n\n/**\n * Form control\n */\n@HtmlTagMarker\ninline fun FlowOrInteractiveOrPhrasingContent.input(type : InputType? = null, formEncType : InputFormEncType? = null, formMethod : InputFormMethod? = null, name : String? = null, classes : String? = null, crossinline block : INPUT.() -> Unit = {}) : Unit = INPUT(attributesMapOf(\"type\", type?.enumEncode(),\"formenctype\", formEncType?.enumEncode(),\"formmethod\", formMethod?.enumEncode(),\"name\", name,\"class\", classes), consumer).visit(block)\n@HtmlTagMarker\ninline fun FlowOrInteractiveOrPhrasingContent.buttonInput(formEncType : InputFormEncType? = null, formMethod : InputFormMethod? = null, name : String? = null, classes : String? = null, crossinline block : INPUT.() -> Unit = {}) : Unit = INPUT(attributesMapOf(\"type\", InputType.button.realValue,\"formenctype\", formEncType?.enumEncode(),\"formmethod\", formMethod?.enumEncode(),\"name\", name,\"class\", classes), consumer).visit(block)\n@HtmlTagMarker\ninline fun FlowOrInteractiveOrPhrasingContent.checkBoxInput(formEncType : InputFormEncType? = null, formMethod : InputFormMethod? = null, name : String? = null, classes : String? = null, crossinline block : INPUT.() -> Unit = {}) : Unit = INPUT(attributesMapOf(\"type\", InputType.checkBox.realValue,\"formenctype\", formEncType?.enumEncode(),\"formmethod\", formMethod?.enumEncode(),\"name\", name,\"class\", classes), consumer).visit(block)\n@HtmlTagMarker\ninline fun FlowOrInteractiveOrPhrasingContent.colorInput(formEncType : InputFormEncType? = null, formMethod : InputFormMethod? = null, name : String? = null, classes : String? = null, crossinline block : INPUT.() -> Unit = {}) : Unit = INPUT(attributesMapOf(\"type\", InputType.color.realValue,\"formenctype\", formEncType?.enumEncode(),\"formmethod\", formMethod?.enumEncode(),\"name\", name,\"class\", classes), consumer).visit(block)\n@HtmlTagMarker\ninline fun FlowOrInteractiveOrPhrasingContent.dateInput(formEncType : InputFormEncType? = null, formMethod : InputFormMethod? = null, name : String? = null, classes : String? = null, crossinline block : INPUT.() -> Unit = {}) : Unit = INPUT(attributesMapOf(\"type\", InputType.date.realValue,\"formenctype\", formEncType?.enumEncode(),\"formmethod\", formMethod?.enumEncode(),\"name\", name,\"class\", classes), consumer).visit(block)\n@HtmlTagMarker\ninline fun FlowOrInteractiveOrPhrasingContent.dateTimeInput(formEncType : InputFormEncType? = null, formMethod : InputFormMethod? = null, name : String? = null, classes : String? = null, crossinline block : INPUT.() -> Unit = {}) : Unit = INPUT(attributesMapOf(\"type\", InputType.dateTime.realValue,\"formenctype\", formEncType?.enumEncode(),\"formmethod\", formMethod?.enumEncode(),\"name\", name,\"class\", classes), consumer).visit(block)\n@HtmlTagMarker\ninline fun FlowOrInteractiveOrPhrasingContent.dateTimeLocalInput(formEncType : InputFormEncType? = null, formMethod : InputFormMethod? = null, name : String? = null, classes : String? = null, crossinline block : INPUT.() -> Unit = {}) : Unit = INPUT(attributesMapOf(\"type\", InputType.dateTimeLocal.realValue,\"formenctype\", formEncType?.enumEncode(),\"formmethod\", formMethod?.enumEncode(),\"name\", name,\"class\", classes), consumer).visit(block)\n@HtmlTagMarker\ninline fun FlowOrInteractiveOrPhrasingContent.emailInput(formEncType : InputFormEncType? = null, formMethod : InputFormMethod? = null, name : String? = null, classes : String? = null, crossinline block : INPUT.() -> Unit = {}) : Unit = INPUT(attributesMapOf(\"type\", InputType.email.realValue,\"formenctype\", formEncType?.enumEncode(),\"formmethod\", formMethod?.enumEncode(),\"name\", name,\"class\", classes), consumer).visit(block)\n@HtmlTagMarker\ninline fun FlowOrInteractiveOrPhrasingContent.fileInput(formEncType : InputFormEncType? = null, formMethod : InputFormMethod? = null, name : String? = null, classes : String? = null, crossinline block : INPUT.() -> Unit = {}) : Unit = INPUT(attributesMapOf(\"type\", InputType.file.realValue,\"formenctype\", formEncType?.enumEncode(),\"formmethod\", formMethod?.enumEncode(),\"name\", name,\"class\", classes), consumer).visit(block)\n@HtmlTagMarker\ninline fun FlowOrInteractiveOrPhrasingContent.hiddenInput(formEncType : InputFormEncType? = null, formMethod : InputFormMethod? = null, name : String? = null, classes : String? = null, crossinline block : INPUT.() -> Unit = {}) : Unit = INPUT(attributesMapOf(\"type\", InputType.hidden.realValue,\"formenctype\", formEncType?.enumEncode(),\"formmethod\", formMethod?.enumEncode(),\"name\", name,\"class\", classes), consumer).visit(block)\n@HtmlTagMarker\ninline fun FlowOrInteractiveOrPhrasingContent.imageInput(formEncType : InputFormEncType? = null, formMethod : InputFormMethod? = null, name : String? = null, classes : String? = null, crossinline block : INPUT.() -> Unit = {}) : Unit = INPUT(attributesMapOf(\"type\", InputType.image.realValue,\"formenctype\", formEncType?.enumEncode(),\"formmethod\", formMethod?.enumEncode(),\"name\", name,\"class\", classes), consumer).visit(block)\n@HtmlTagMarker\ninline fun FlowOrInteractiveOrPhrasingContent.monthInput(formEncType : InputFormEncType? = null, formMethod : InputFormMethod? = null, name : String? = null, classes : String? = null, crossinline block : INPUT.() -> Unit = {}) : Unit = INPUT(attributesMapOf(\"type\", InputType.month.realValue,\"formenctype\", formEncType?.enumEncode(),\"formmethod\", formMethod?.enumEncode(),\"name\", name,\"class\", classes), consumer).visit(block)\n@HtmlTagMarker\ninline fun FlowOrInteractiveOrPhrasingContent.numberInput(formEncType : InputFormEncType? = null, formMethod : InputFormMethod? = null, name : String? = null, classes : String? = null, crossinline block : INPUT.() -> Unit = {}) : Unit = INPUT(attributesMapOf(\"type\", InputType.number.realValue,\"formenctype\", formEncType?.enumEncode(),\"formmethod\", formMethod?.enumEncode(),\"name\", name,\"class\", classes), consumer).visit(block)\n@HtmlTagMarker\ninline fun FlowOrInteractiveOrPhrasingContent.passwordInput(formEncType : InputFormEncType? = null, formMethod : InputFormMethod? = null, name : String? = null, classes : String? = null, crossinline block : INPUT.() -> Unit = {}) : Unit = INPUT(attributesMapOf(\"type\", InputType.password.realValue,\"formenctype\", formEncType?.enumEncode(),\"formmethod\", formMethod?.enumEncode(),\"name\", name,\"class\", classes), consumer).visit(block)\n@HtmlTagMarker\ninline fun FlowOrInteractiveOrPhrasingContent.radioInput(formEncType : InputFormEncType? = null, formMethod : InputFormMethod? = null, name : String? = null, classes : String? = null, crossinline block : INPUT.() -> Unit = {}) : Unit = INPUT(attributesMapOf(\"type\", InputType.radio.realValue,\"formenctype\", formEncType?.enumEncode(),\"formmethod\", formMethod?.enumEncode(),\"name\", name,\"class\", classes), consumer).visit(block)\n@HtmlTagMarker\ninline fun FlowOrInteractiveOrPhrasingContent.rangeInput(formEncType : InputFormEncType? = null, formMethod : InputFormMethod? = null, name : String? = null, classes : String? = null, crossinline block : INPUT.() -> Unit = {}) : Unit = INPUT(attributesMapOf(\"type\", InputType.range.realValue,\"formenctype\", formEncType?.enumEncode(),\"formmethod\", formMethod?.enumEncode(),\"name\", name,\"class\", classes), consumer).visit(block)\n@HtmlTagMarker\ninline fun FlowOrInteractiveOrPhrasingContent.resetInput(formEncType : InputFormEncType? = null, formMethod : InputFormMethod? = null, name : String? = null, classes : String? = null, crossinline block : INPUT.() -> Unit = {}) : Unit = INPUT(attributesMapOf(\"type\", InputType.reset.realValue,\"formenctype\", formEncType?.enumEncode(),\"formmethod\", formMethod?.enumEncode(),\"name\", name,\"class\", classes), consumer).visit(block)\n@HtmlTagMarker\ninline fun FlowOrInteractiveOrPhrasingContent.searchInput(formEncType : InputFormEncType? = null, formMethod : InputFormMethod? = null, name : String? = null, classes : String? = null, crossinline block : INPUT.() -> Unit = {}) : Unit = INPUT(attributesMapOf(\"type\", InputType.search.realValue,\"formenctype\", formEncType?.enumEncode(),\"formmethod\", formMethod?.enumEncode(),\"name\", name,\"class\", classes), consumer).visit(block)\n@HtmlTagMarker\ninline fun FlowOrInteractiveOrPhrasingContent.submitInput(formEncType : InputFormEncType? = null, formMethod : InputFormMethod? = null, name : String? = null, classes : String? = null, crossinline block : INPUT.() -> Unit = {}) : Unit = INPUT(attributesMapOf(\"type\", InputType.submit.realValue,\"formenctype\", formEncType?.enumEncode(),\"formmethod\", formMethod?.enumEncode(),\"name\", name,\"class\", classes), consumer).visit(block)\n@HtmlTagMarker\ninline fun FlowOrInteractiveOrPhrasingContent.textInput(formEncType : InputFormEncType? = null, formMethod : InputFormMethod? = null, name : String? = null, classes : String? = null, crossinline block : INPUT.() -> Unit = {}) : Unit = INPUT(attributesMapOf(\"type\", InputType.text.realValue,\"formenctype\", formEncType?.enumEncode(),\"formmethod\", formMethod?.enumEncode(),\"name\", name,\"class\", classes), consumer).visit(block)\n@HtmlTagMarker\ninline fun FlowOrInteractiveOrPhrasingContent.telInput(formEncType : InputFormEncType? = null, formMethod : InputFormMethod? = null, name : String? = null, classes : String? = null, crossinline block : INPUT.() -> Unit = {}) : Unit = INPUT(attributesMapOf(\"type\", InputType.tel.realValue,\"formenctype\", formEncType?.enumEncode(),\"formmethod\", formMethod?.enumEncode(),\"name\", name,\"class\", classes), consumer).visit(block)\n@HtmlTagMarker\ninline fun FlowOrInteractiveOrPhrasingContent.timeInput(formEncType : InputFormEncType? = null, formMethod : InputFormMethod? = null, name : String? = null, classes : String? = null, crossinline block : INPUT.() -> Unit = {}) : Unit = INPUT(attributesMapOf(\"type\", InputType.time.realValue,\"formenctype\", formEncType?.enumEncode(),\"formmethod\", formMethod?.enumEncode(),\"name\", name,\"class\", classes), consumer).visit(block)\n@HtmlTagMarker\ninline fun FlowOrInteractiveOrPhrasingContent.urlInput(formEncType : InputFormEncType? = null, formMethod : InputFormMethod? = null, name : String? = null, classes : String? = null, crossinline block : INPUT.() -> Unit = {}) : Unit = INPUT(attributesMapOf(\"type\", InputType.url.realValue,\"formenctype\", formEncType?.enumEncode(),\"formmethod\", formMethod?.enumEncode(),\"name\", name,\"class\", classes), consumer).visit(block)\n@HtmlTagMarker\ninline fun FlowOrInteractiveOrPhrasingContent.weekInput(formEncType : InputFormEncType? = null, formMethod : InputFormMethod? = null, name : String? = null, classes : String? = null, crossinline block : INPUT.() -> Unit = {}) : Unit = INPUT(attributesMapOf(\"type\", InputType.week.realValue,\"formenctype\", formEncType?.enumEncode(),\"formmethod\", formMethod?.enumEncode(),\"name\", name,\"class\", classes), consumer).visit(block)\n\n/**\n * Cryptographic key-pair generator form control\n */\n@HtmlTagMarker\ninline fun FlowOrInteractiveOrPhrasingContent.keyGen(keyType : KeyGenKeyType? = null, classes : String? = null, crossinline block : KEYGEN.() -> Unit = {}) : Unit = KEYGEN(attributesMapOf(\"keytype\", keyType?.enumEncode(),\"class\", classes), consumer).visit(block)\n@HtmlTagMarker\ninline fun FlowOrInteractiveOrPhrasingContent.rsaKeyGen(classes : String? = null, crossinline block : KEYGEN.() -> Unit = {}) : Unit = KEYGEN(attributesMapOf(\"keytype\", KeyGenKeyType.rsa.realValue,\"class\", classes), consumer).visit(block)\n\n/**\n * Form field label text\n */\n@HtmlTagMarker\ninline fun FlowOrInteractiveOrPhrasingContent.label(classes : String? = null, crossinline block : LABEL.() -> Unit = {}) : Unit = LABEL(attributesMapOf(\"class\", classes), consumer).visit(block)\n\n/**\n * Generic embedded object\n */\n@HtmlTagMarker\ninline fun FlowOrInteractiveOrPhrasingContent.htmlObject(classes : String? = null, crossinline block : OBJECT.() -> Unit = {}) : Unit = OBJECT(attributesMapOf(\"class\", classes), consumer).visit(block)\n\n/**\n * Option selector\n */\n@HtmlTagMarker\ninline fun FlowOrInteractiveOrPhrasingContent.select(classes : String? = null, crossinline block : SELECT.() -> Unit = {}) : Unit = SELECT(attributesMapOf(\"class\", classes), consumer).visit(block)\n\n/**\n * Multi-line text field\n */\n@HtmlTagMarker\ninline fun FlowOrInteractiveOrPhrasingContent.textArea(rows : String? = null, cols : String? = null, wrap : TextAreaWrap? = null, classes : String? = null, crossinline block : TEXTAREA.() -> Unit = {}) : Unit = TEXTAREA(attributesMapOf(\"rows\", rows,\"cols\", cols,\"wrap\", wrap?.enumEncode(),\"class\", classes), consumer).visit(block)\n/**\n * Multi-line text field\n */\n@HtmlTagMarker\nfun FlowOrInteractiveOrPhrasingContent.textArea(rows : String? = null, cols : String? = null, wrap : TextAreaWrap? = null, classes : String? = null, content : String = \"\") : Unit = TEXTAREA(attributesMapOf(\"rows\", rows,\"cols\", cols,\"wrap\", wrap?.enumEncode(),\"class\", classes), consumer).visit({+content})\n@HtmlTagMarker\ninline fun FlowOrInteractiveOrPhrasingContent.hardTextArea(rows : String? = null, cols : String? = null, classes : String? = null, crossinline block : TEXTAREA.() -> Unit = {}) : Unit = TEXTAREA(attributesMapOf(\"rows\", rows,\"cols\", cols,\"wrap\", TextAreaWrap.hard.realValue,\"class\", classes), consumer).visit(block)\n@HtmlTagMarker\ninline fun FlowOrInteractiveOrPhrasingContent.softTextArea(rows : String? = null, cols : String? = null, classes : String? = null, crossinline block : TEXTAREA.() -> Unit = {}) : Unit = TEXTAREA(attributesMapOf(\"rows\", rows,\"cols\", cols,\"wrap\", TextAreaWrap.soft.realValue,\"class\", classes), consumer).visit(block)\n@HtmlTagMarker\nfun FlowOrInteractiveOrPhrasingContent.hardTextArea(rows : String? = null, cols : String? = null, classes : String? = null, content : String = \"\") : Unit = TEXTAREA(attributesMapOf(\"rows\", rows,\"cols\", cols,\"wrap\", TextAreaWrap.hard.realValue,\"class\", classes), consumer).visit({+content})\n@HtmlTagMarker\nfun FlowOrInteractiveOrPhrasingContent.softTextArea(rows : String? = null, cols : String? = null, classes : String? = null, content : String = \"\") : Unit = TEXTAREA(attributesMapOf(\"rows\", rows,\"cols\", cols,\"wrap\", TextAreaWrap.soft.realValue,\"class\", classes), consumer).visit({+content})\n\n/**\n * Video player\n */\n@HtmlTagMarker\ninline fun FlowOrInteractiveOrPhrasingContent.video(classes : String? = null, crossinline block : VIDEO.() -> Unit = {}) : Unit = VIDEO(attributesMapOf(\"class\", classes), consumer).visit(block)\n\n\n",null,null,null,"/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StandardKt\")\npackage kotlin\n\nimport kotlin.contracts.*\n\n/**\n * An exception is thrown to indicate that a method body remains to be implemented.\n */\npublic class NotImplementedError(message: String = \"An operation is not implemented.\") : Error(message)\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n */\n\n@kotlin.internal.InlineOnly\npublic inline fun TODO(): Nothing = throw NotImplementedError()\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n *\n * @param reason a string explaining why the implementation is missing.\n */\n@kotlin.internal.InlineOnly\npublic inline fun TODO(reason: String): Nothing = throw NotImplementedError(\"An operation is not implemented: $reason\")\n\n\n\n/**\n * Calls the specified function [block] and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#run).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <R> run(block: () -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#run).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.run(block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with the given [receiver] as its receiver and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#with).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> with(receiver: T, block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return receiver.block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns `this` value.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#apply).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> T.apply(block: T.() -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block()\n    return this\n}\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns `this` value.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#also).\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.also(block: (T) -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block(this)\n    return this\n}\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#let).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.let(block: (T) -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block(this)\n}\n\n/**\n * Returns `this` value if it satisfies the given [predicate] or `null`, if it doesn't.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#takeif-and-takeunless).\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeIf(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (predicate(this)) this else null\n}\n\n/**\n * Returns `this` value if it _does not_ satisfy the given [predicate] or `null`, if it does.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#takeif-and-takeunless).\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeUnless(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (!predicate(this)) this else null\n}\n\n/**\n * Executes the given function [action] specified number of [times].\n *\n * A zero-based index of current iteration is passed as a parameter to [action].\n *\n * @sample samples.misc.ControlFlow.repeat\n */\n@kotlin.internal.InlineOnly\npublic inline fun repeat(times: Int, action: (Int) -> Unit) {\n    contract { callsInPlace(action) }\n\n    for (index in 0 until times) {\n        action(index)\n    }\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// NOTE: THIS FILE IS AUTO-GENERATED, DO NOT EDIT!\n// See github.com/kotlin/dukat for details\n\npackage org.w3c.dom\n\nimport kotlin.js.*\nimport org.khronos.webgl.*\nimport org.w3c.css.masking.*\nimport org.w3c.dom.clipboard.*\nimport org.w3c.dom.css.*\nimport org.w3c.dom.encryptedmedia.*\nimport org.w3c.dom.events.*\nimport org.w3c.dom.mediacapture.*\nimport org.w3c.dom.mediasource.*\nimport org.w3c.dom.parsing.*\nimport org.w3c.dom.pointerevents.*\nimport org.w3c.dom.svg.*\nimport org.w3c.dom.url.*\nimport org.w3c.fetch.*\nimport org.w3c.files.*\nimport org.w3c.notifications.*\nimport org.w3c.performance.*\nimport org.w3c.workers.*\nimport org.w3c.xhr.*\n\npublic external abstract class HTMLAllCollection {\n    open val length: Int\n    fun item(nameOrIndex: String = definedExternally): UnionElementOrHTMLCollection?\n    fun namedItem(name: String): UnionElementOrHTMLCollection?\n}\n\n@kotlin.internal.InlineOnly\npublic inline operator fun HTMLAllCollection.get(index: Int): Element? = asDynamic()[index]\n\n@kotlin.internal.InlineOnly\npublic inline operator fun HTMLAllCollection.get(name: String): UnionElementOrHTMLCollection? = asDynamic()[name]\n\n/**\n * Exposes the JavaScript [HTMLFormControlsCollection](https://developer.mozilla.org/en/docs/Web/API/HTMLFormControlsCollection) to Kotlin\n */\npublic external abstract class HTMLFormControlsCollection : HTMLCollection\n\n/**\n * Exposes the JavaScript [RadioNodeList](https://developer.mozilla.org/en/docs/Web/API/RadioNodeList) to Kotlin\n */\npublic external abstract class RadioNodeList : NodeList, UnionElementOrRadioNodeList {\n    open var value: String\n}\n\n/**\n * Exposes the JavaScript [HTMLOptionsCollection](https://developer.mozilla.org/en/docs/Web/API/HTMLOptionsCollection) to Kotlin\n */\npublic external abstract class HTMLOptionsCollection : HTMLCollection {\n    override var length: Int\n    open var selectedIndex: Int\n    fun add(element: UnionHTMLOptGroupElementOrHTMLOptionElement, before: dynamic = definedExternally)\n    fun remove(index: Int)\n}\n\n@kotlin.internal.InlineOnly\npublic inline operator fun HTMLOptionsCollection.set(index: Int, option: HTMLOptionElement?) { asDynamic()[index] = option }\n\n/**\n * Exposes the JavaScript [HTMLElement](https://developer.mozilla.org/en/docs/Web/API/HTMLElement) to Kotlin\n */\npublic external abstract class HTMLElement : Element, GlobalEventHandlers, DocumentAndElementEventHandlers, ElementContentEditable, ElementCSSInlineStyle {\n    open var title: String\n    open var lang: String\n    open var translate: Boolean\n    open var dir: String\n    open val dataset: DOMStringMap\n    open var hidden: Boolean\n    open var tabIndex: Int\n    open var accessKey: String\n    open val accessKeyLabel: String\n    open var draggable: Boolean\n    open val dropzone: DOMTokenList\n    open var contextMenu: HTMLMenuElement?\n    open var spellcheck: Boolean\n    open var innerText: String\n    open val offsetParent: Element?\n    open val offsetTop: Int\n    open val offsetLeft: Int\n    open val offsetWidth: Int\n    open val offsetHeight: Int\n    fun click()\n    fun focus()\n    fun blur()\n    fun forceSpellCheck()\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLUnknownElement](https://developer.mozilla.org/en/docs/Web/API/HTMLUnknownElement) to Kotlin\n */\npublic external abstract class HTMLUnknownElement : HTMLElement {\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [DOMStringMap](https://developer.mozilla.org/en/docs/Web/API/DOMStringMap) to Kotlin\n */\npublic external abstract class DOMStringMap\n\n@kotlin.internal.InlineOnly\npublic inline operator fun DOMStringMap.get(name: String): String? = asDynamic()[name]\n\n@kotlin.internal.InlineOnly\npublic inline operator fun DOMStringMap.set(name: String, value: String) { asDynamic()[name] = value }\n\n/**\n * Exposes the JavaScript [HTMLHtmlElement](https://developer.mozilla.org/en/docs/Web/API/HTMLHtmlElement) to Kotlin\n */\npublic external abstract class HTMLHtmlElement : HTMLElement {\n    open var version: String\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLHeadElement](https://developer.mozilla.org/en/docs/Web/API/HTMLHeadElement) to Kotlin\n */\npublic external abstract class HTMLHeadElement : HTMLElement {\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLTitleElement](https://developer.mozilla.org/en/docs/Web/API/HTMLTitleElement) to Kotlin\n */\npublic external abstract class HTMLTitleElement : HTMLElement {\n    open var text: String\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLBaseElement](https://developer.mozilla.org/en/docs/Web/API/HTMLBaseElement) to Kotlin\n */\npublic external abstract class HTMLBaseElement : HTMLElement {\n    open var href: String\n    open var target: String\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLLinkElement](https://developer.mozilla.org/en/docs/Web/API/HTMLLinkElement) to Kotlin\n */\npublic external abstract class HTMLLinkElement : HTMLElement, LinkStyle {\n    open var href: String\n    open var crossOrigin: String?\n    open var rel: String\n    open var `as`: RequestDestination\n    open val relList: DOMTokenList\n    open var media: String\n    open var nonce: String\n    open var hreflang: String\n    open var type: String\n    open val sizes: DOMTokenList\n    open var referrerPolicy: String\n    open var charset: String\n    open var rev: String\n    open var target: String\n    open var scope: String\n    open var workerType: WorkerType\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLMetaElement](https://developer.mozilla.org/en/docs/Web/API/HTMLMetaElement) to Kotlin\n */\npublic external abstract class HTMLMetaElement : HTMLElement {\n    open var name: String\n    open var httpEquiv: String\n    open var content: String\n    open var scheme: String\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLStyleElement](https://developer.mozilla.org/en/docs/Web/API/HTMLStyleElement) to Kotlin\n */\npublic external abstract class HTMLStyleElement : HTMLElement, LinkStyle {\n    open var media: String\n    open var nonce: String\n    open var type: String\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLBodyElement](https://developer.mozilla.org/en/docs/Web/API/HTMLBodyElement) to Kotlin\n */\npublic external abstract class HTMLBodyElement : HTMLElement, WindowEventHandlers {\n    open var text: String\n    open var link: String\n    open var vLink: String\n    open var aLink: String\n    open var bgColor: String\n    open var background: String\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLHeadingElement](https://developer.mozilla.org/en/docs/Web/API/HTMLHeadingElement) to Kotlin\n */\npublic external abstract class HTMLHeadingElement : HTMLElement {\n    open var align: String\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLParagraphElement](https://developer.mozilla.org/en/docs/Web/API/HTMLParagraphElement) to Kotlin\n */\npublic external abstract class HTMLParagraphElement : HTMLElement {\n    open var align: String\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLHRElement](https://developer.mozilla.org/en/docs/Web/API/HTMLHRElement) to Kotlin\n */\npublic external abstract class HTMLHRElement : HTMLElement {\n    open var align: String\n    open var color: String\n    open var noShade: Boolean\n    open var size: String\n    open var width: String\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLPreElement](https://developer.mozilla.org/en/docs/Web/API/HTMLPreElement) to Kotlin\n */\npublic external abstract class HTMLPreElement : HTMLElement {\n    open var width: Int\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLQuoteElement](https://developer.mozilla.org/en/docs/Web/API/HTMLQuoteElement) to Kotlin\n */\npublic external abstract class HTMLQuoteElement : HTMLElement {\n    open var cite: String\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLOListElement](https://developer.mozilla.org/en/docs/Web/API/HTMLOListElement) to Kotlin\n */\npublic external abstract class HTMLOListElement : HTMLElement {\n    open var reversed: Boolean\n    open var start: Int\n    open var type: String\n    open var compact: Boolean\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLUListElement](https://developer.mozilla.org/en/docs/Web/API/HTMLUListElement) to Kotlin\n */\npublic external abstract class HTMLUListElement : HTMLElement {\n    open var compact: Boolean\n    open var type: String\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLLIElement](https://developer.mozilla.org/en/docs/Web/API/HTMLLIElement) to Kotlin\n */\npublic external abstract class HTMLLIElement : HTMLElement {\n    open var value: Int\n    open var type: String\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLDListElement](https://developer.mozilla.org/en/docs/Web/API/HTMLDListElement) to Kotlin\n */\npublic external abstract class HTMLDListElement : HTMLElement {\n    open var compact: Boolean\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLDivElement](https://developer.mozilla.org/en/docs/Web/API/HTMLDivElement) to Kotlin\n */\npublic external abstract class HTMLDivElement : HTMLElement {\n    open var align: String\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLAnchorElement](https://developer.mozilla.org/en/docs/Web/API/HTMLAnchorElement) to Kotlin\n */\npublic external abstract class HTMLAnchorElement : HTMLElement, HTMLHyperlinkElementUtils {\n    open var target: String\n    open var download: String\n    open var ping: String\n    open var rel: String\n    open val relList: DOMTokenList\n    open var hreflang: String\n    open var type: String\n    open var text: String\n    open var referrerPolicy: String\n    open var coords: String\n    open var charset: String\n    open var name: String\n    open var rev: String\n    open var shape: String\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLDataElement](https://developer.mozilla.org/en/docs/Web/API/HTMLDataElement) to Kotlin\n */\npublic external abstract class HTMLDataElement : HTMLElement {\n    open var value: String\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLTimeElement](https://developer.mozilla.org/en/docs/Web/API/HTMLTimeElement) to Kotlin\n */\npublic external abstract class HTMLTimeElement : HTMLElement {\n    open var dateTime: String\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLSpanElement](https://developer.mozilla.org/en/docs/Web/API/HTMLSpanElement) to Kotlin\n */\npublic external abstract class HTMLSpanElement : HTMLElement {\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLBRElement](https://developer.mozilla.org/en/docs/Web/API/HTMLBRElement) to Kotlin\n */\npublic external abstract class HTMLBRElement : HTMLElement {\n    open var clear: String\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLHyperlinkElementUtils](https://developer.mozilla.org/en/docs/Web/API/HTMLHyperlinkElementUtils) to Kotlin\n */\npublic external interface HTMLHyperlinkElementUtils {\n    var href: String\n    val origin: String\n    var protocol: String\n    var username: String\n    var password: String\n    var host: String\n    var hostname: String\n    var port: String\n    var pathname: String\n    var search: String\n    var hash: String\n}\n\n/**\n * Exposes the JavaScript [HTMLModElement](https://developer.mozilla.org/en/docs/Web/API/HTMLModElement) to Kotlin\n */\npublic external abstract class HTMLModElement : HTMLElement {\n    open var cite: String\n    open var dateTime: String\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLPictureElement](https://developer.mozilla.org/en/docs/Web/API/HTMLPictureElement) to Kotlin\n */\npublic external abstract class HTMLPictureElement : HTMLElement {\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLSourceElement](https://developer.mozilla.org/en/docs/Web/API/HTMLSourceElement) to Kotlin\n */\npublic external abstract class HTMLSourceElement : HTMLElement {\n    open var src: String\n    open var type: String\n    open var srcset: String\n    open var sizes: String\n    open var media: String\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLImageElement](https://developer.mozilla.org/en/docs/Web/API/HTMLImageElement) to Kotlin\n */\npublic external abstract class HTMLImageElement : HTMLElement, HTMLOrSVGImageElement, TexImageSource {\n    open var alt: String\n    open var src: String\n    open var srcset: String\n    open var sizes: String\n    open var crossOrigin: String?\n    open var useMap: String\n    open var isMap: Boolean\n    open var width: Int\n    open var height: Int\n    open val naturalWidth: Int\n    open val naturalHeight: Int\n    open val complete: Boolean\n    open val currentSrc: String\n    open var referrerPolicy: String\n    open var name: String\n    open var lowsrc: String\n    open var align: String\n    open var hspace: Int\n    open var vspace: Int\n    open var longDesc: String\n    open var border: String\n    open val x: Int\n    open val y: Int\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLIFrameElement](https://developer.mozilla.org/en/docs/Web/API/HTMLIFrameElement) to Kotlin\n */\npublic external abstract class HTMLIFrameElement : HTMLElement {\n    open var src: String\n    open var srcdoc: String\n    open var name: String\n    open val sandbox: DOMTokenList\n    open var allowFullscreen: Boolean\n    open var allowUserMedia: Boolean\n    open var width: String\n    open var height: String\n    open var referrerPolicy: String\n    open val contentDocument: Document?\n    open val contentWindow: Window?\n    open var align: String\n    open var scrolling: String\n    open var frameBorder: String\n    open var longDesc: String\n    open var marginHeight: String\n    open var marginWidth: String\n    fun getSVGDocument(): Document?\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLEmbedElement](https://developer.mozilla.org/en/docs/Web/API/HTMLEmbedElement) to Kotlin\n */\npublic external abstract class HTMLEmbedElement : HTMLElement {\n    open var src: String\n    open var type: String\n    open var width: String\n    open var height: String\n    open var align: String\n    open var name: String\n    fun getSVGDocument(): Document?\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLObjectElement](https://developer.mozilla.org/en/docs/Web/API/HTMLObjectElement) to Kotlin\n */\npublic external abstract class HTMLObjectElement : HTMLElement {\n    open var data: String\n    open var type: String\n    open var typeMustMatch: Boolean\n    open var name: String\n    open var useMap: String\n    open val form: HTMLFormElement?\n    open var width: String\n    open var height: String\n    open val contentDocument: Document?\n    open val contentWindow: Window?\n    open val willValidate: Boolean\n    open val validity: ValidityState\n    open val validationMessage: String\n    open var align: String\n    open var archive: String\n    open var code: String\n    open var declare: Boolean\n    open var hspace: Int\n    open var standby: String\n    open var vspace: Int\n    open var codeBase: String\n    open var codeType: String\n    open var border: String\n    fun getSVGDocument(): Document?\n    fun checkValidity(): Boolean\n    fun reportValidity(): Boolean\n    fun setCustomValidity(error: String)\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLParamElement](https://developer.mozilla.org/en/docs/Web/API/HTMLParamElement) to Kotlin\n */\npublic external abstract class HTMLParamElement : HTMLElement {\n    open var name: String\n    open var value: String\n    open var type: String\n    open var valueType: String\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLVideoElement](https://developer.mozilla.org/en/docs/Web/API/HTMLVideoElement) to Kotlin\n */\npublic external abstract class HTMLVideoElement : HTMLMediaElement, CanvasImageSource, TexImageSource {\n    open var width: Int\n    open var height: Int\n    open val videoWidth: Int\n    open val videoHeight: Int\n    open var poster: String\n    open var playsInline: Boolean\n\n    companion object {\n        val NETWORK_EMPTY: Short\n        val NETWORK_IDLE: Short\n        val NETWORK_LOADING: Short\n        val NETWORK_NO_SOURCE: Short\n        val HAVE_NOTHING: Short\n        val HAVE_METADATA: Short\n        val HAVE_CURRENT_DATA: Short\n        val HAVE_FUTURE_DATA: Short\n        val HAVE_ENOUGH_DATA: Short\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLAudioElement](https://developer.mozilla.org/en/docs/Web/API/HTMLAudioElement) to Kotlin\n */\npublic external abstract class HTMLAudioElement : HTMLMediaElement {\n    companion object {\n        val NETWORK_EMPTY: Short\n        val NETWORK_IDLE: Short\n        val NETWORK_LOADING: Short\n        val NETWORK_NO_SOURCE: Short\n        val HAVE_NOTHING: Short\n        val HAVE_METADATA: Short\n        val HAVE_CURRENT_DATA: Short\n        val HAVE_FUTURE_DATA: Short\n        val HAVE_ENOUGH_DATA: Short\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLTrackElement](https://developer.mozilla.org/en/docs/Web/API/HTMLTrackElement) to Kotlin\n */\npublic external abstract class HTMLTrackElement : HTMLElement {\n    open var kind: String\n    open var src: String\n    open var srclang: String\n    open var label: String\n    open var default: Boolean\n    open val readyState: Short\n    open val track: TextTrack\n\n    companion object {\n        val NONE: Short\n        val LOADING: Short\n        val LOADED: Short\n        val ERROR: Short\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLMediaElement](https://developer.mozilla.org/en/docs/Web/API/HTMLMediaElement) to Kotlin\n */\npublic external abstract class HTMLMediaElement : HTMLElement {\n    open val error: MediaError?\n    open var src: String\n    open var srcObject: MediaProvider?\n    open val currentSrc: String\n    open var crossOrigin: String?\n    open val networkState: Short\n    open var preload: String\n    open val buffered: TimeRanges\n    open val readyState: Short\n    open val seeking: Boolean\n    open var currentTime: Double\n    open val duration: Double\n    open val paused: Boolean\n    open var defaultPlaybackRate: Double\n    open var playbackRate: Double\n    open val played: TimeRanges\n    open val seekable: TimeRanges\n    open val ended: Boolean\n    open var autoplay: Boolean\n    open var loop: Boolean\n    open var controls: Boolean\n    open var volume: Double\n    open var muted: Boolean\n    open var defaultMuted: Boolean\n    open val audioTracks: AudioTrackList\n    open val videoTracks: VideoTrackList\n    open val textTracks: TextTrackList\n    open val mediaKeys: MediaKeys?\n    open var onencrypted: ((Event) -> dynamic)?\n    open var onwaitingforkey: ((Event) -> dynamic)?\n    fun load()\n    fun canPlayType(type: String): CanPlayTypeResult\n    fun fastSeek(time: Double)\n    fun getStartDate(): dynamic\n    fun play(): Promise<Unit>\n    fun pause()\n    fun addTextTrack(kind: TextTrackKind, label: String = definedExternally, language: String = definedExternally): TextTrack\n    fun setMediaKeys(mediaKeys: MediaKeys?): Promise<Unit>\n\n    companion object {\n        val NETWORK_EMPTY: Short\n        val NETWORK_IDLE: Short\n        val NETWORK_LOADING: Short\n        val NETWORK_NO_SOURCE: Short\n        val HAVE_NOTHING: Short\n        val HAVE_METADATA: Short\n        val HAVE_CURRENT_DATA: Short\n        val HAVE_FUTURE_DATA: Short\n        val HAVE_ENOUGH_DATA: Short\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [MediaError](https://developer.mozilla.org/en/docs/Web/API/MediaError) to Kotlin\n */\npublic external abstract class MediaError {\n    open val code: Short\n\n    companion object {\n        val MEDIA_ERR_ABORTED: Short\n        val MEDIA_ERR_NETWORK: Short\n        val MEDIA_ERR_DECODE: Short\n        val MEDIA_ERR_SRC_NOT_SUPPORTED: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [AudioTrackList](https://developer.mozilla.org/en/docs/Web/API/AudioTrackList) to Kotlin\n */\npublic external abstract class AudioTrackList : EventTarget {\n    open val length: Int\n    open var onchange: ((Event) -> dynamic)?\n    open var onaddtrack: ((TrackEvent) -> dynamic)?\n    open var onremovetrack: ((TrackEvent) -> dynamic)?\n    fun getTrackById(id: String): AudioTrack?\n}\n\n@kotlin.internal.InlineOnly\npublic inline operator fun AudioTrackList.get(index: Int): AudioTrack? = asDynamic()[index]\n\n/**\n * Exposes the JavaScript [AudioTrack](https://developer.mozilla.org/en/docs/Web/API/AudioTrack) to Kotlin\n */\npublic external abstract class AudioTrack : UnionAudioTrackOrTextTrackOrVideoTrack {\n    open val id: String\n    open val kind: String\n    open val label: String\n    open val language: String\n    open var enabled: Boolean\n    open val sourceBuffer: SourceBuffer?\n}\n\n/**\n * Exposes the JavaScript [VideoTrackList](https://developer.mozilla.org/en/docs/Web/API/VideoTrackList) to Kotlin\n */\npublic external abstract class VideoTrackList : EventTarget {\n    open val length: Int\n    open val selectedIndex: Int\n    open var onchange: ((Event) -> dynamic)?\n    open var onaddtrack: ((TrackEvent) -> dynamic)?\n    open var onremovetrack: ((TrackEvent) -> dynamic)?\n    fun getTrackById(id: String): VideoTrack?\n}\n\n@kotlin.internal.InlineOnly\npublic inline operator fun VideoTrackList.get(index: Int): VideoTrack? = asDynamic()[index]\n\n/**\n * Exposes the JavaScript [VideoTrack](https://developer.mozilla.org/en/docs/Web/API/VideoTrack) to Kotlin\n */\npublic external abstract class VideoTrack : UnionAudioTrackOrTextTrackOrVideoTrack {\n    open val id: String\n    open val kind: String\n    open val label: String\n    open val language: String\n    open var selected: Boolean\n    open val sourceBuffer: SourceBuffer?\n}\n\npublic external abstract class TextTrackList : EventTarget {\n    open val length: Int\n    open var onchange: ((Event) -> dynamic)?\n    open var onaddtrack: ((TrackEvent) -> dynamic)?\n    open var onremovetrack: ((TrackEvent) -> dynamic)?\n    fun getTrackById(id: String): TextTrack?\n}\n\n@kotlin.internal.InlineOnly\npublic inline operator fun TextTrackList.get(index: Int): TextTrack? = asDynamic()[index]\n\n/**\n * Exposes the JavaScript [TextTrack](https://developer.mozilla.org/en/docs/Web/API/TextTrack) to Kotlin\n */\npublic external abstract class TextTrack : EventTarget, UnionAudioTrackOrTextTrackOrVideoTrack {\n    open val kind: TextTrackKind\n    open val label: String\n    open val language: String\n    open val id: String\n    open val inBandMetadataTrackDispatchType: String\n    open var mode: TextTrackMode\n    open val cues: TextTrackCueList?\n    open val activeCues: TextTrackCueList?\n    open var oncuechange: ((Event) -> dynamic)?\n    open val sourceBuffer: SourceBuffer?\n    fun addCue(cue: TextTrackCue)\n    fun removeCue(cue: TextTrackCue)\n}\n\npublic external abstract class TextTrackCueList {\n    open val length: Int\n    fun getCueById(id: String): TextTrackCue?\n}\n\n@kotlin.internal.InlineOnly\npublic inline operator fun TextTrackCueList.get(index: Int): TextTrackCue? = asDynamic()[index]\n\n/**\n * Exposes the JavaScript [TextTrackCue](https://developer.mozilla.org/en/docs/Web/API/TextTrackCue) to Kotlin\n */\npublic external abstract class TextTrackCue : EventTarget {\n    open val track: TextTrack?\n    open var id: String\n    open var startTime: Double\n    open var endTime: Double\n    open var pauseOnExit: Boolean\n    open var onenter: ((Event) -> dynamic)?\n    open var onexit: ((Event) -> dynamic)?\n}\n\n/**\n * Exposes the JavaScript [TimeRanges](https://developer.mozilla.org/en/docs/Web/API/TimeRanges) to Kotlin\n */\npublic external abstract class TimeRanges {\n    open val length: Int\n    fun start(index: Int): Double\n    fun end(index: Int): Double\n}\n\n/**\n * Exposes the JavaScript [TrackEvent](https://developer.mozilla.org/en/docs/Web/API/TrackEvent) to Kotlin\n */\npublic external open class TrackEvent(type: String, eventInitDict: TrackEventInit = definedExternally) : Event {\n    open val track: UnionAudioTrackOrTextTrackOrVideoTrack?\n\n    companion object {\n        val NONE: Short\n        val CAPTURING_PHASE: Short\n        val AT_TARGET: Short\n        val BUBBLING_PHASE: Short\n    }\n}\n\npublic external interface TrackEventInit : EventInit {\n    var track: UnionAudioTrackOrTextTrackOrVideoTrack? /* = null */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun TrackEventInit(track: UnionAudioTrackOrTextTrackOrVideoTrack? = null, bubbles: Boolean? = false, cancelable: Boolean? = false, composed: Boolean? = false): TrackEventInit {\n    val o = js(\"({})\")\n    o[\"track\"] = track\n    o[\"bubbles\"] = bubbles\n    o[\"cancelable\"] = cancelable\n    o[\"composed\"] = composed\n    return o\n}\n\n/**\n * Exposes the JavaScript [HTMLMapElement](https://developer.mozilla.org/en/docs/Web/API/HTMLMapElement) to Kotlin\n */\npublic external abstract class HTMLMapElement : HTMLElement {\n    open var name: String\n    open val areas: HTMLCollection\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLAreaElement](https://developer.mozilla.org/en/docs/Web/API/HTMLAreaElement) to Kotlin\n */\npublic external abstract class HTMLAreaElement : HTMLElement, HTMLHyperlinkElementUtils {\n    open var alt: String\n    open var coords: String\n    open var shape: String\n    open var target: String\n    open var download: String\n    open var ping: String\n    open var rel: String\n    open val relList: DOMTokenList\n    open var referrerPolicy: String\n    open var noHref: Boolean\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLTableElement](https://developer.mozilla.org/en/docs/Web/API/HTMLTableElement) to Kotlin\n */\npublic external abstract class HTMLTableElement : HTMLElement {\n    open var caption: HTMLTableCaptionElement?\n    open var tHead: HTMLTableSectionElement?\n    open var tFoot: HTMLTableSectionElement?\n    open val tBodies: HTMLCollection\n    open val rows: HTMLCollection\n    open var align: String\n    open var border: String\n    open var frame: String\n    open var rules: String\n    open var summary: String\n    open var width: String\n    open var bgColor: String\n    open var cellPadding: String\n    open var cellSpacing: String\n    fun createCaption(): HTMLTableCaptionElement\n    fun deleteCaption()\n    fun createTHead(): HTMLTableSectionElement\n    fun deleteTHead()\n    fun createTFoot(): HTMLTableSectionElement\n    fun deleteTFoot()\n    fun createTBody(): HTMLTableSectionElement\n    fun insertRow(index: Int = definedExternally): HTMLTableRowElement\n    fun deleteRow(index: Int)\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLTableCaptionElement](https://developer.mozilla.org/en/docs/Web/API/HTMLTableCaptionElement) to Kotlin\n */\npublic external abstract class HTMLTableCaptionElement : HTMLElement {\n    open var align: String\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLTableColElement](https://developer.mozilla.org/en/docs/Web/API/HTMLTableColElement) to Kotlin\n */\npublic external abstract class HTMLTableColElement : HTMLElement {\n    open var span: Int\n    open var align: String\n    open var ch: String\n    open var chOff: String\n    open var vAlign: String\n    open var width: String\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLTableSectionElement](https://developer.mozilla.org/en/docs/Web/API/HTMLTableSectionElement) to Kotlin\n */\npublic external abstract class HTMLTableSectionElement : HTMLElement {\n    open val rows: HTMLCollection\n    open var align: String\n    open var ch: String\n    open var chOff: String\n    open var vAlign: String\n    fun insertRow(index: Int = definedExternally): HTMLElement\n    fun deleteRow(index: Int)\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLTableRowElement](https://developer.mozilla.org/en/docs/Web/API/HTMLTableRowElement) to Kotlin\n */\npublic external abstract class HTMLTableRowElement : HTMLElement {\n    open val rowIndex: Int\n    open val sectionRowIndex: Int\n    open val cells: HTMLCollection\n    open var align: String\n    open var ch: String\n    open var chOff: String\n    open var vAlign: String\n    open var bgColor: String\n    fun insertCell(index: Int = definedExternally): HTMLElement\n    fun deleteCell(index: Int)\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLTableCellElement](https://developer.mozilla.org/en/docs/Web/API/HTMLTableCellElement) to Kotlin\n */\npublic external abstract class HTMLTableCellElement : HTMLElement {\n    open var colSpan: Int\n    open var rowSpan: Int\n    open var headers: String\n    open val cellIndex: Int\n    open var scope: String\n    open var abbr: String\n    open var align: String\n    open var axis: String\n    open var height: String\n    open var width: String\n    open var ch: String\n    open var chOff: String\n    open var noWrap: Boolean\n    open var vAlign: String\n    open var bgColor: String\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLFormElement](https://developer.mozilla.org/en/docs/Web/API/HTMLFormElement) to Kotlin\n */\npublic external abstract class HTMLFormElement : HTMLElement {\n    open var acceptCharset: String\n    open var action: String\n    open var autocomplete: String\n    open var enctype: String\n    open var encoding: String\n    open var method: String\n    open var name: String\n    open var noValidate: Boolean\n    open var target: String\n    open val elements: HTMLFormControlsCollection\n    open val length: Int\n    fun submit()\n    fun reset()\n    fun checkValidity(): Boolean\n    fun reportValidity(): Boolean\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n@kotlin.internal.InlineOnly\npublic inline operator fun HTMLFormElement.get(index: Int): Element? = asDynamic()[index]\n\n@kotlin.internal.InlineOnly\npublic inline operator fun HTMLFormElement.get(name: String): UnionElementOrRadioNodeList? = asDynamic()[name]\n\n/**\n * Exposes the JavaScript [HTMLLabelElement](https://developer.mozilla.org/en/docs/Web/API/HTMLLabelElement) to Kotlin\n */\npublic external abstract class HTMLLabelElement : HTMLElement {\n    open val form: HTMLFormElement?\n    open var htmlFor: String\n    open val control: HTMLElement?\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLInputElement](https://developer.mozilla.org/en/docs/Web/API/HTMLInputElement) to Kotlin\n */\npublic external abstract class HTMLInputElement : HTMLElement {\n    open var accept: String\n    open var alt: String\n    open var autocomplete: String\n    open var autofocus: Boolean\n    open var defaultChecked: Boolean\n    open var checked: Boolean\n    open var dirName: String\n    open var disabled: Boolean\n    open val form: HTMLFormElement?\n    open val files: FileList?\n    open var formAction: String\n    open var formEnctype: String\n    open var formMethod: String\n    open var formNoValidate: Boolean\n    open var formTarget: String\n    open var height: Int\n    open var indeterminate: Boolean\n    open var inputMode: String\n    open val list: HTMLElement?\n    open var max: String\n    open var maxLength: Int\n    open var min: String\n    open var minLength: Int\n    open var multiple: Boolean\n    open var name: String\n    open var pattern: String\n    open var placeholder: String\n    open var readOnly: Boolean\n    open var required: Boolean\n    open var size: Int\n    open var src: String\n    open var step: String\n    open var type: String\n    open var defaultValue: String\n    open var value: String\n    open var valueAsDate: dynamic\n    open var valueAsNumber: Double\n    open var width: Int\n    open val willValidate: Boolean\n    open val validity: ValidityState\n    open val validationMessage: String\n    open val labels: NodeList\n    open var selectionStart: Int?\n    open var selectionEnd: Int?\n    open var selectionDirection: String?\n    open var align: String\n    open var useMap: String\n    fun stepUp(n: Int = definedExternally)\n    fun stepDown(n: Int = definedExternally)\n    fun checkValidity(): Boolean\n    fun reportValidity(): Boolean\n    fun setCustomValidity(error: String)\n    fun select()\n    fun setRangeText(replacement: String)\n    fun setRangeText(replacement: String, start: Int, end: Int, selectionMode: SelectionMode = definedExternally)\n    fun setSelectionRange(start: Int, end: Int, direction: String = definedExternally)\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLButtonElement](https://developer.mozilla.org/en/docs/Web/API/HTMLButtonElement) to Kotlin\n */\npublic external abstract class HTMLButtonElement : HTMLElement {\n    open var autofocus: Boolean\n    open var disabled: Boolean\n    open val form: HTMLFormElement?\n    open var formAction: String\n    open var formEnctype: String\n    open var formMethod: String\n    open var formNoValidate: Boolean\n    open var formTarget: String\n    open var name: String\n    open var type: String\n    open var value: String\n    open var menu: HTMLMenuElement?\n    open val willValidate: Boolean\n    open val validity: ValidityState\n    open val validationMessage: String\n    open val labels: NodeList\n    fun checkValidity(): Boolean\n    fun reportValidity(): Boolean\n    fun setCustomValidity(error: String)\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLSelectElement](https://developer.mozilla.org/en/docs/Web/API/HTMLSelectElement) to Kotlin\n */\npublic external abstract class HTMLSelectElement : HTMLElement, ItemArrayLike<Element> {\n    open var autocomplete: String\n    open var autofocus: Boolean\n    open var disabled: Boolean\n    open val form: HTMLFormElement?\n    open var multiple: Boolean\n    open var name: String\n    open var required: Boolean\n    open var size: Int\n    open val type: String\n    open val options: HTMLOptionsCollection\n    override var length: Int\n    open val selectedOptions: HTMLCollection\n    open var selectedIndex: Int\n    open var value: String\n    open val willValidate: Boolean\n    open val validity: ValidityState\n    open val validationMessage: String\n    open val labels: NodeList\n    fun namedItem(name: String): HTMLOptionElement?\n    fun add(element: UnionHTMLOptGroupElementOrHTMLOptionElement, before: dynamic = definedExternally)\n    fun remove(index: Int)\n    fun checkValidity(): Boolean\n    fun reportValidity(): Boolean\n    fun setCustomValidity(error: String)\n    override fun item(index: Int): Element?\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n@kotlin.internal.InlineOnly\npublic inline operator fun HTMLSelectElement.get(index: Int): Element? = asDynamic()[index]\n\n@kotlin.internal.InlineOnly\npublic inline operator fun HTMLSelectElement.set(index: Int, option: HTMLOptionElement?) { asDynamic()[index] = option }\n\n/**\n * Exposes the JavaScript [HTMLDataListElement](https://developer.mozilla.org/en/docs/Web/API/HTMLDataListElement) to Kotlin\n */\npublic external abstract class HTMLDataListElement : HTMLElement {\n    open val options: HTMLCollection\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLOptGroupElement](https://developer.mozilla.org/en/docs/Web/API/HTMLOptGroupElement) to Kotlin\n */\npublic external abstract class HTMLOptGroupElement : HTMLElement, UnionHTMLOptGroupElementOrHTMLOptionElement {\n    open var disabled: Boolean\n    open var label: String\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLOptionElement](https://developer.mozilla.org/en/docs/Web/API/HTMLOptionElement) to Kotlin\n */\npublic external abstract class HTMLOptionElement : HTMLElement, UnionHTMLOptGroupElementOrHTMLOptionElement {\n    open var disabled: Boolean\n    open val form: HTMLFormElement?\n    open var label: String\n    open var defaultSelected: Boolean\n    open var selected: Boolean\n    open var value: String\n    open var text: String\n    open val index: Int\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLTextAreaElement](https://developer.mozilla.org/en/docs/Web/API/HTMLTextAreaElement) to Kotlin\n */\npublic external abstract class HTMLTextAreaElement : HTMLElement {\n    open var autocomplete: String\n    open var autofocus: Boolean\n    open var cols: Int\n    open var dirName: String\n    open var disabled: Boolean\n    open val form: HTMLFormElement?\n    open var inputMode: String\n    open var maxLength: Int\n    open var minLength: Int\n    open var name: String\n    open var placeholder: String\n    open var readOnly: Boolean\n    open var required: Boolean\n    open var rows: Int\n    open var wrap: String\n    open val type: String\n    open var defaultValue: String\n    open var value: String\n    open val textLength: Int\n    open val willValidate: Boolean\n    open val validity: ValidityState\n    open val validationMessage: String\n    open val labels: NodeList\n    open var selectionStart: Int?\n    open var selectionEnd: Int?\n    open var selectionDirection: String?\n    fun checkValidity(): Boolean\n    fun reportValidity(): Boolean\n    fun setCustomValidity(error: String)\n    fun select()\n    fun setRangeText(replacement: String)\n    fun setRangeText(replacement: String, start: Int, end: Int, selectionMode: SelectionMode = definedExternally)\n    fun setSelectionRange(start: Int, end: Int, direction: String = definedExternally)\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLKeygenElement](https://developer.mozilla.org/en/docs/Web/API/HTMLKeygenElement) to Kotlin\n */\npublic external abstract class HTMLKeygenElement : HTMLElement {\n    open var autofocus: Boolean\n    open var challenge: String\n    open var disabled: Boolean\n    open val form: HTMLFormElement?\n    open var keytype: String\n    open var name: String\n    open val type: String\n    open val willValidate: Boolean\n    open val validity: ValidityState\n    open val validationMessage: String\n    open val labels: NodeList\n    fun checkValidity(): Boolean\n    fun reportValidity(): Boolean\n    fun setCustomValidity(error: String)\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLOutputElement](https://developer.mozilla.org/en/docs/Web/API/HTMLOutputElement) to Kotlin\n */\npublic external abstract class HTMLOutputElement : HTMLElement {\n    open val htmlFor: DOMTokenList\n    open val form: HTMLFormElement?\n    open var name: String\n    open val type: String\n    open var defaultValue: String\n    open var value: String\n    open val willValidate: Boolean\n    open val validity: ValidityState\n    open val validationMessage: String\n    open val labels: NodeList\n    fun checkValidity(): Boolean\n    fun reportValidity(): Boolean\n    fun setCustomValidity(error: String)\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLProgressElement](https://developer.mozilla.org/en/docs/Web/API/HTMLProgressElement) to Kotlin\n */\npublic external abstract class HTMLProgressElement : HTMLElement {\n    open var value: Double\n    open var max: Double\n    open val position: Double\n    open val labels: NodeList\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLMeterElement](https://developer.mozilla.org/en/docs/Web/API/HTMLMeterElement) to Kotlin\n */\npublic external abstract class HTMLMeterElement : HTMLElement {\n    open var value: Double\n    open var min: Double\n    open var max: Double\n    open var low: Double\n    open var high: Double\n    open var optimum: Double\n    open val labels: NodeList\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLFieldSetElement](https://developer.mozilla.org/en/docs/Web/API/HTMLFieldSetElement) to Kotlin\n */\npublic external abstract class HTMLFieldSetElement : HTMLElement {\n    open var disabled: Boolean\n    open val form: HTMLFormElement?\n    open var name: String\n    open val type: String\n    open val elements: HTMLCollection\n    open val willValidate: Boolean\n    open val validity: ValidityState\n    open val validationMessage: String\n    fun checkValidity(): Boolean\n    fun reportValidity(): Boolean\n    fun setCustomValidity(error: String)\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLLegendElement](https://developer.mozilla.org/en/docs/Web/API/HTMLLegendElement) to Kotlin\n */\npublic external abstract class HTMLLegendElement : HTMLElement {\n    open val form: HTMLFormElement?\n    open var align: String\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [ValidityState](https://developer.mozilla.org/en/docs/Web/API/ValidityState) to Kotlin\n */\npublic external abstract class ValidityState {\n    open val valueMissing: Boolean\n    open val typeMismatch: Boolean\n    open val patternMismatch: Boolean\n    open val tooLong: Boolean\n    open val tooShort: Boolean\n    open val rangeUnderflow: Boolean\n    open val rangeOverflow: Boolean\n    open val stepMismatch: Boolean\n    open val badInput: Boolean\n    open val customError: Boolean\n    open val valid: Boolean\n}\n\n/**\n * Exposes the JavaScript [HTMLDetailsElement](https://developer.mozilla.org/en/docs/Web/API/HTMLDetailsElement) to Kotlin\n */\npublic external abstract class HTMLDetailsElement : HTMLElement {\n    open var open: Boolean\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\npublic external abstract class HTMLMenuElement : HTMLElement {\n    open var type: String\n    open var label: String\n    open var compact: Boolean\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\npublic external abstract class HTMLMenuItemElement : HTMLElement {\n    open var type: String\n    open var label: String\n    open var icon: String\n    open var disabled: Boolean\n    open var checked: Boolean\n    open var radiogroup: String\n    open var default: Boolean\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\npublic external open class RelatedEvent(type: String, eventInitDict: RelatedEventInit = definedExternally) : Event {\n    open val relatedTarget: EventTarget?\n\n    companion object {\n        val NONE: Short\n        val CAPTURING_PHASE: Short\n        val AT_TARGET: Short\n        val BUBBLING_PHASE: Short\n    }\n}\n\npublic external interface RelatedEventInit : EventInit {\n    var relatedTarget: EventTarget? /* = null */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun RelatedEventInit(relatedTarget: EventTarget? = null, bubbles: Boolean? = false, cancelable: Boolean? = false, composed: Boolean? = false): RelatedEventInit {\n    val o = js(\"({})\")\n    o[\"relatedTarget\"] = relatedTarget\n    o[\"bubbles\"] = bubbles\n    o[\"cancelable\"] = cancelable\n    o[\"composed\"] = composed\n    return o\n}\n\n/**\n * Exposes the JavaScript [HTMLDialogElement](https://developer.mozilla.org/en/docs/Web/API/HTMLDialogElement) to Kotlin\n */\npublic external abstract class HTMLDialogElement : HTMLElement {\n    open var open: Boolean\n    open var returnValue: String\n    fun show(anchor: UnionElementOrMouseEvent = definedExternally)\n    fun showModal(anchor: UnionElementOrMouseEvent = definedExternally)\n    fun close(returnValue: String = definedExternally)\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLScriptElement](https://developer.mozilla.org/en/docs/Web/API/HTMLScriptElement) to Kotlin\n */\npublic external abstract class HTMLScriptElement : HTMLElement, HTMLOrSVGScriptElement {\n    open var src: String\n    open var type: String\n    open var charset: String\n    open var async: Boolean\n    open var defer: Boolean\n    open var crossOrigin: String?\n    open var text: String\n    open var nonce: String\n    open var event: String\n    open var htmlFor: String\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLTemplateElement](https://developer.mozilla.org/en/docs/Web/API/HTMLTemplateElement) to Kotlin\n */\npublic external abstract class HTMLTemplateElement : HTMLElement {\n    open val content: DocumentFragment\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLSlotElement](https://developer.mozilla.org/en/docs/Web/API/HTMLSlotElement) to Kotlin\n */\npublic external abstract class HTMLSlotElement : HTMLElement {\n    open var name: String\n    fun assignedNodes(options: AssignedNodesOptions = definedExternally): Array<Node>\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\npublic external interface AssignedNodesOptions {\n    var flatten: Boolean? /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun AssignedNodesOptions(flatten: Boolean? = false): AssignedNodesOptions {\n    val o = js(\"({})\")\n    o[\"flatten\"] = flatten\n    return o\n}\n\n/**\n * Exposes the JavaScript [HTMLCanvasElement](https://developer.mozilla.org/en/docs/Web/API/HTMLCanvasElement) to Kotlin\n */\npublic external abstract class HTMLCanvasElement : HTMLElement, CanvasImageSource, TexImageSource {\n    open var width: Int\n    open var height: Int\n    fun getContext(contextId: String, vararg arguments: Any?): RenderingContext?\n    fun toDataURL(type: String = definedExternally, quality: Any? = definedExternally): String\n    fun toBlob(_callback: (Blob?) -> Unit, type: String = definedExternally, quality: Any? = definedExternally)\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\npublic external interface CanvasRenderingContext2DSettings {\n    var alpha: Boolean? /* = true */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun CanvasRenderingContext2DSettings(alpha: Boolean? = true): CanvasRenderingContext2DSettings {\n    val o = js(\"({})\")\n    o[\"alpha\"] = alpha\n    return o\n}\n\n/**\n * Exposes the JavaScript [CanvasRenderingContext2D](https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D) to Kotlin\n */\npublic external abstract class CanvasRenderingContext2D : CanvasState, CanvasTransform, CanvasCompositing, CanvasImageSmoothing, CanvasFillStrokeStyles, CanvasShadowStyles, CanvasFilters, CanvasRect, CanvasDrawPath, CanvasUserInterface, CanvasText, CanvasDrawImage, CanvasHitRegion, CanvasImageData, CanvasPathDrawingStyles, CanvasTextDrawingStyles, CanvasPath, RenderingContext {\n    open val canvas: HTMLCanvasElement\n}\n\npublic external interface CanvasState {\n    fun save()\n    fun restore()\n}\n\npublic external interface CanvasTransform {\n    fun scale(x: Double, y: Double)\n    fun rotate(angle: Double)\n    fun translate(x: Double, y: Double)\n    fun transform(a: Double, b: Double, c: Double, d: Double, e: Double, f: Double)\n    fun getTransform(): DOMMatrix\n    fun setTransform(a: Double, b: Double, c: Double, d: Double, e: Double, f: Double)\n    fun setTransform(transform: dynamic = definedExternally)\n    fun resetTransform()\n}\n\npublic external interface CanvasCompositing {\n    var globalAlpha: Double\n    var globalCompositeOperation: String\n}\n\npublic external interface CanvasImageSmoothing {\n    var imageSmoothingEnabled: Boolean\n    var imageSmoothingQuality: ImageSmoothingQuality\n}\n\npublic external interface CanvasFillStrokeStyles {\n    var strokeStyle: dynamic\n        get() = definedExternally\n        set(value) = definedExternally\n    var fillStyle: dynamic\n        get() = definedExternally\n        set(value) = definedExternally\n    fun createLinearGradient(x0: Double, y0: Double, x1: Double, y1: Double): CanvasGradient\n    fun createRadialGradient(x0: Double, y0: Double, r0: Double, x1: Double, y1: Double, r1: Double): CanvasGradient\n    fun createPattern(image: CanvasImageSource, repetition: String): CanvasPattern?\n}\n\npublic external interface CanvasShadowStyles {\n    var shadowOffsetX: Double\n    var shadowOffsetY: Double\n    var shadowBlur: Double\n    var shadowColor: String\n}\n\npublic external interface CanvasFilters {\n    var filter: String\n}\n\npublic external interface CanvasRect {\n    fun clearRect(x: Double, y: Double, w: Double, h: Double)\n    fun fillRect(x: Double, y: Double, w: Double, h: Double)\n    fun strokeRect(x: Double, y: Double, w: Double, h: Double)\n}\n\npublic external interface CanvasDrawPath {\n    fun beginPath()\n    fun fill(fillRule: CanvasFillRule = definedExternally)\n    fun fill(path: Path2D, fillRule: CanvasFillRule = definedExternally)\n    fun stroke()\n    fun stroke(path: Path2D)\n    fun clip(fillRule: CanvasFillRule = definedExternally)\n    fun clip(path: Path2D, fillRule: CanvasFillRule = definedExternally)\n    fun resetClip()\n    fun isPointInPath(x: Double, y: Double, fillRule: CanvasFillRule = definedExternally): Boolean\n    fun isPointInPath(path: Path2D, x: Double, y: Double, fillRule: CanvasFillRule = definedExternally): Boolean\n    fun isPointInStroke(x: Double, y: Double): Boolean\n    fun isPointInStroke(path: Path2D, x: Double, y: Double): Boolean\n}\n\npublic external interface CanvasUserInterface {\n    fun drawFocusIfNeeded(element: Element)\n    fun drawFocusIfNeeded(path: Path2D, element: Element)\n    fun scrollPathIntoView()\n    fun scrollPathIntoView(path: Path2D)\n}\n\npublic external interface CanvasText {\n    fun fillText(text: String, x: Double, y: Double, maxWidth: Double = definedExternally)\n    fun strokeText(text: String, x: Double, y: Double, maxWidth: Double = definedExternally)\n    fun measureText(text: String): TextMetrics\n}\n\npublic external interface CanvasDrawImage {\n    fun drawImage(image: CanvasImageSource, dx: Double, dy: Double)\n    fun drawImage(image: CanvasImageSource, dx: Double, dy: Double, dw: Double, dh: Double)\n    fun drawImage(image: CanvasImageSource, sx: Double, sy: Double, sw: Double, sh: Double, dx: Double, dy: Double, dw: Double, dh: Double)\n}\n\npublic external interface CanvasHitRegion {\n    fun addHitRegion(options: HitRegionOptions = definedExternally)\n    fun removeHitRegion(id: String)\n    fun clearHitRegions()\n}\n\npublic external interface CanvasImageData {\n    fun createImageData(sw: Double, sh: Double): ImageData\n    fun createImageData(imagedata: ImageData): ImageData\n    fun getImageData(sx: Double, sy: Double, sw: Double, sh: Double): ImageData\n    fun putImageData(imagedata: ImageData, dx: Double, dy: Double)\n    fun putImageData(imagedata: ImageData, dx: Double, dy: Double, dirtyX: Double, dirtyY: Double, dirtyWidth: Double, dirtyHeight: Double)\n}\n\npublic external interface CanvasPathDrawingStyles {\n    var lineWidth: Double\n    var lineCap: CanvasLineCap\n    var lineJoin: CanvasLineJoin\n    var miterLimit: Double\n    var lineDashOffset: Double\n    fun setLineDash(segments: Array<Double>)\n    fun getLineDash(): Array<Double>\n}\n\npublic external interface CanvasTextDrawingStyles {\n    var font: String\n    var textAlign: CanvasTextAlign\n    var textBaseline: CanvasTextBaseline\n    var direction: CanvasDirection\n}\n\npublic external interface CanvasPath {\n    fun closePath()\n    fun moveTo(x: Double, y: Double)\n    fun lineTo(x: Double, y: Double)\n    fun quadraticCurveTo(cpx: Double, cpy: Double, x: Double, y: Double)\n    fun bezierCurveTo(cp1x: Double, cp1y: Double, cp2x: Double, cp2y: Double, x: Double, y: Double)\n    fun arcTo(x1: Double, y1: Double, x2: Double, y2: Double, radius: Double)\n    fun arcTo(x1: Double, y1: Double, x2: Double, y2: Double, radiusX: Double, radiusY: Double, rotation: Double)\n    fun rect(x: Double, y: Double, w: Double, h: Double)\n    fun arc(x: Double, y: Double, radius: Double, startAngle: Double, endAngle: Double, anticlockwise: Boolean = definedExternally)\n    fun ellipse(x: Double, y: Double, radiusX: Double, radiusY: Double, rotation: Double, startAngle: Double, endAngle: Double, anticlockwise: Boolean = definedExternally)\n}\n\n/**\n * Exposes the JavaScript [CanvasGradient](https://developer.mozilla.org/en/docs/Web/API/CanvasGradient) to Kotlin\n */\npublic external abstract class CanvasGradient {\n    fun addColorStop(offset: Double, color: String)\n}\n\n/**\n * Exposes the JavaScript [CanvasPattern](https://developer.mozilla.org/en/docs/Web/API/CanvasPattern) to Kotlin\n */\npublic external abstract class CanvasPattern {\n    fun setTransform(transform: dynamic = definedExternally)\n}\n\n/**\n * Exposes the JavaScript [TextMetrics](https://developer.mozilla.org/en/docs/Web/API/TextMetrics) to Kotlin\n */\npublic external abstract class TextMetrics {\n    open val width: Double\n    open val actualBoundingBoxLeft: Double\n    open val actualBoundingBoxRight: Double\n    open val fontBoundingBoxAscent: Double\n    open val fontBoundingBoxDescent: Double\n    open val actualBoundingBoxAscent: Double\n    open val actualBoundingBoxDescent: Double\n    open val emHeightAscent: Double\n    open val emHeightDescent: Double\n    open val hangingBaseline: Double\n    open val alphabeticBaseline: Double\n    open val ideographicBaseline: Double\n}\n\npublic external interface HitRegionOptions {\n    var path: Path2D? /* = null */\n        get() = definedExternally\n        set(value) = definedExternally\n    var fillRule: CanvasFillRule? /* = CanvasFillRule.NONZERO */\n        get() = definedExternally\n        set(value) = definedExternally\n    var id: String? /* = \"\" */\n        get() = definedExternally\n        set(value) = definedExternally\n    var parentID: String? /* = null */\n        get() = definedExternally\n        set(value) = definedExternally\n    var cursor: String? /* = \"inherit\" */\n        get() = definedExternally\n        set(value) = definedExternally\n    var control: Element? /* = null */\n        get() = definedExternally\n        set(value) = definedExternally\n    var label: String? /* = null */\n        get() = definedExternally\n        set(value) = definedExternally\n    var role: String? /* = null */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun HitRegionOptions(path: Path2D? = null, fillRule: CanvasFillRule? = CanvasFillRule.NONZERO, id: String? = \"\", parentID: String? = null, cursor: String? = \"inherit\", control: Element? = null, label: String? = null, role: String? = null): HitRegionOptions {\n    val o = js(\"({})\")\n    o[\"path\"] = path\n    o[\"fillRule\"] = fillRule\n    o[\"id\"] = id\n    o[\"parentID\"] = parentID\n    o[\"cursor\"] = cursor\n    o[\"control\"] = control\n    o[\"label\"] = label\n    o[\"role\"] = role\n    return o\n}\n\n/**\n * Exposes the JavaScript [ImageData](https://developer.mozilla.org/en/docs/Web/API/ImageData) to Kotlin\n */\npublic external open class ImageData : ImageBitmapSource, TexImageSource {\n    constructor(sw: Int, sh: Int)\n    constructor(data: Uint8ClampedArray, sw: Int, sh: Int = definedExternally)\n    open val width: Int\n    open val height: Int\n    open val data: Uint8ClampedArray\n}\n\n/**\n * Exposes the JavaScript [Path2D](https://developer.mozilla.org/en/docs/Web/API/Path2D) to Kotlin\n */\npublic external open class Path2D() : CanvasPath {\n    constructor(path: Path2D)\n    constructor(paths: Array<Path2D>, fillRule: CanvasFillRule = definedExternally)\n    constructor(d: String)\n    fun addPath(path: Path2D, transform: dynamic = definedExternally)\n    override fun closePath()\n    override fun moveTo(x: Double, y: Double)\n    override fun lineTo(x: Double, y: Double)\n    override fun quadraticCurveTo(cpx: Double, cpy: Double, x: Double, y: Double)\n    override fun bezierCurveTo(cp1x: Double, cp1y: Double, cp2x: Double, cp2y: Double, x: Double, y: Double)\n    override fun arcTo(x1: Double, y1: Double, x2: Double, y2: Double, radius: Double)\n    override fun arcTo(x1: Double, y1: Double, x2: Double, y2: Double, radiusX: Double, radiusY: Double, rotation: Double)\n    override fun rect(x: Double, y: Double, w: Double, h: Double)\n    override fun arc(x: Double, y: Double, radius: Double, startAngle: Double, endAngle: Double, anticlockwise: Boolean /* = definedExternally */)\n    override fun ellipse(x: Double, y: Double, radiusX: Double, radiusY: Double, rotation: Double, startAngle: Double, endAngle: Double, anticlockwise: Boolean /* = definedExternally */)\n}\n\n/**\n * Exposes the JavaScript [ImageBitmapRenderingContext](https://developer.mozilla.org/en/docs/Web/API/ImageBitmapRenderingContext) to Kotlin\n */\npublic external abstract class ImageBitmapRenderingContext {\n    open val canvas: HTMLCanvasElement\n    fun transferFromImageBitmap(bitmap: ImageBitmap?)\n}\n\npublic external interface ImageBitmapRenderingContextSettings {\n    var alpha: Boolean? /* = true */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun ImageBitmapRenderingContextSettings(alpha: Boolean? = true): ImageBitmapRenderingContextSettings {\n    val o = js(\"({})\")\n    o[\"alpha\"] = alpha\n    return o\n}\n\n/**\n * Exposes the JavaScript [CustomElementRegistry](https://developer.mozilla.org/en/docs/Web/API/CustomElementRegistry) to Kotlin\n */\npublic external abstract class CustomElementRegistry {\n    fun define(name: String, constructor: () -> dynamic, options: ElementDefinitionOptions = definedExternally)\n    fun get(name: String): Any?\n    fun whenDefined(name: String): Promise<Unit>\n}\n\npublic external interface ElementDefinitionOptions {\n    var extends: String?\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun ElementDefinitionOptions(extends: String? = undefined): ElementDefinitionOptions {\n    val o = js(\"({})\")\n    o[\"extends\"] = extends\n    return o\n}\n\npublic external interface ElementContentEditable {\n    var contentEditable: String\n    val isContentEditable: Boolean\n}\n\n/**\n * Exposes the JavaScript [DataTransfer](https://developer.mozilla.org/en/docs/Web/API/DataTransfer) to Kotlin\n */\npublic external abstract class DataTransfer {\n    open var dropEffect: String\n    open var effectAllowed: String\n    open val items: DataTransferItemList\n    open val types: Array<out String>\n    open val files: FileList\n    fun setDragImage(image: Element, x: Int, y: Int)\n    fun getData(format: String): String\n    fun setData(format: String, data: String)\n    fun clearData(format: String = definedExternally)\n}\n\n/**\n * Exposes the JavaScript [DataTransferItemList](https://developer.mozilla.org/en/docs/Web/API/DataTransferItemList) to Kotlin\n */\npublic external abstract class DataTransferItemList {\n    open val length: Int\n    fun add(data: String, type: String): DataTransferItem?\n    fun add(data: File): DataTransferItem?\n    fun remove(index: Int)\n    fun clear()\n}\n\n@kotlin.internal.InlineOnly\npublic inline operator fun DataTransferItemList.get(index: Int): DataTransferItem? = asDynamic()[index]\n\n/**\n * Exposes the JavaScript [DataTransferItem](https://developer.mozilla.org/en/docs/Web/API/DataTransferItem) to Kotlin\n */\npublic external abstract class DataTransferItem {\n    open val kind: String\n    open val type: String\n    fun getAsString(_callback: ((String) -> Unit)?)\n    fun getAsFile(): File?\n}\n\n/**\n * Exposes the JavaScript [DragEvent](https://developer.mozilla.org/en/docs/Web/API/DragEvent) to Kotlin\n */\npublic external open class DragEvent(type: String, eventInitDict: DragEventInit = definedExternally) : MouseEvent {\n    open val dataTransfer: DataTransfer?\n\n    companion object {\n        val NONE: Short\n        val CAPTURING_PHASE: Short\n        val AT_TARGET: Short\n        val BUBBLING_PHASE: Short\n    }\n}\n\npublic external interface DragEventInit : MouseEventInit {\n    var dataTransfer: DataTransfer? /* = null */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun DragEventInit(dataTransfer: DataTransfer? = null, screenX: Int? = 0, screenY: Int? = 0, clientX: Int? = 0, clientY: Int? = 0, button: Short? = 0, buttons: Short? = 0, relatedTarget: EventTarget? = null, region: String? = null, ctrlKey: Boolean? = false, shiftKey: Boolean? = false, altKey: Boolean? = false, metaKey: Boolean? = false, modifierAltGraph: Boolean? = false, modifierCapsLock: Boolean? = false, modifierFn: Boolean? = false, modifierFnLock: Boolean? = false, modifierHyper: Boolean? = false, modifierNumLock: Boolean? = false, modifierScrollLock: Boolean? = false, modifierSuper: Boolean? = false, modifierSymbol: Boolean? = false, modifierSymbolLock: Boolean? = false, view: Window? = null, detail: Int? = 0, bubbles: Boolean? = false, cancelable: Boolean? = false, composed: Boolean? = false): DragEventInit {\n    val o = js(\"({})\")\n    o[\"dataTransfer\"] = dataTransfer\n    o[\"screenX\"] = screenX\n    o[\"screenY\"] = screenY\n    o[\"clientX\"] = clientX\n    o[\"clientY\"] = clientY\n    o[\"button\"] = button\n    o[\"buttons\"] = buttons\n    o[\"relatedTarget\"] = relatedTarget\n    o[\"region\"] = region\n    o[\"ctrlKey\"] = ctrlKey\n    o[\"shiftKey\"] = shiftKey\n    o[\"altKey\"] = altKey\n    o[\"metaKey\"] = metaKey\n    o[\"modifierAltGraph\"] = modifierAltGraph\n    o[\"modifierCapsLock\"] = modifierCapsLock\n    o[\"modifierFn\"] = modifierFn\n    o[\"modifierFnLock\"] = modifierFnLock\n    o[\"modifierHyper\"] = modifierHyper\n    o[\"modifierNumLock\"] = modifierNumLock\n    o[\"modifierScrollLock\"] = modifierScrollLock\n    o[\"modifierSuper\"] = modifierSuper\n    o[\"modifierSymbol\"] = modifierSymbol\n    o[\"modifierSymbolLock\"] = modifierSymbolLock\n    o[\"view\"] = view\n    o[\"detail\"] = detail\n    o[\"bubbles\"] = bubbles\n    o[\"cancelable\"] = cancelable\n    o[\"composed\"] = composed\n    return o\n}\n\n/**\n * Exposes the JavaScript [Window](https://developer.mozilla.org/en/docs/Web/API/Window) to Kotlin\n */\npublic external abstract class Window : EventTarget, GlobalEventHandlers, WindowEventHandlers, WindowOrWorkerGlobalScope, WindowSessionStorage, WindowLocalStorage, GlobalPerformance, UnionMessagePortOrWindowProxy {\n    open val window: Window\n    open val self: Window\n    open val document: Document\n    open var name: String\n    open val location: Location\n    open val history: History\n    open val customElements: CustomElementRegistry\n    open val locationbar: BarProp\n    open val menubar: BarProp\n    open val personalbar: BarProp\n    open val scrollbars: BarProp\n    open val statusbar: BarProp\n    open val toolbar: BarProp\n    open var status: String\n    open val closed: Boolean\n    open val frames: Window\n    open val length: Int\n    open val top: Window\n    open var opener: Any?\n    open val parent: Window\n    open val frameElement: Element?\n    open val navigator: Navigator\n    open val applicationCache: ApplicationCache\n    open val external: External\n    open val screen: Screen\n    open val innerWidth: Int\n    open val innerHeight: Int\n    open val scrollX: Double\n    open val pageXOffset: Double\n    open val scrollY: Double\n    open val pageYOffset: Double\n    open val screenX: Int\n    open val screenY: Int\n    open val outerWidth: Int\n    open val outerHeight: Int\n    open val devicePixelRatio: Double\n    fun close()\n    fun stop()\n    fun focus()\n    fun blur()\n    fun open(url: String = definedExternally, target: String = definedExternally, features: String = definedExternally): Window?\n    fun alert()\n    fun alert(message: String)\n    fun confirm(message: String = definedExternally): Boolean\n    fun prompt(message: String = definedExternally, default: String = definedExternally): String?\n    fun print()\n    fun requestAnimationFrame(callback: (Double) -> Unit): Int\n    fun cancelAnimationFrame(handle: Int)\n    fun postMessage(message: Any?, targetOrigin: String, transfer: Array<dynamic> = definedExternally)\n    fun captureEvents()\n    fun releaseEvents()\n    fun matchMedia(query: String): MediaQueryList\n    fun moveTo(x: Int, y: Int)\n    fun moveBy(x: Int, y: Int)\n    fun resizeTo(x: Int, y: Int)\n    fun resizeBy(x: Int, y: Int)\n    fun scroll(options: ScrollToOptions = definedExternally)\n    fun scroll(x: Double, y: Double)\n    fun scrollTo(options: ScrollToOptions = definedExternally)\n    fun scrollTo(x: Double, y: Double)\n    fun scrollBy(options: ScrollToOptions = definedExternally)\n    fun scrollBy(x: Double, y: Double)\n    fun getComputedStyle(elt: Element, pseudoElt: String? = definedExternally): CSSStyleDeclaration\n}\n\n@kotlin.internal.InlineOnly\npublic inline operator fun Window.get(name: String): dynamic = asDynamic()[name]\n\npublic external abstract class BarProp {\n    open val visible: Boolean\n}\n\n/**\n * Exposes the JavaScript [History](https://developer.mozilla.org/en/docs/Web/API/History) to Kotlin\n */\npublic external abstract class History {\n    open val length: Int\n    open var scrollRestoration: ScrollRestoration\n    open val state: Any?\n    fun go(delta: Int = definedExternally)\n    fun back()\n    fun forward()\n    fun pushState(data: Any?, title: String, url: String? = definedExternally)\n    fun replaceState(data: Any?, title: String, url: String? = definedExternally)\n}\n\n/**\n * Exposes the JavaScript [Location](https://developer.mozilla.org/en/docs/Web/API/Location) to Kotlin\n */\npublic external abstract class Location {\n    open var href: String\n    open val origin: String\n    open var protocol: String\n    open var host: String\n    open var hostname: String\n    open var port: String\n    open var pathname: String\n    open var search: String\n    open var hash: String\n    open val ancestorOrigins: Array<out String>\n    fun assign(url: String)\n    fun replace(url: String)\n    fun reload()\n}\n\n/**\n * Exposes the JavaScript [PopStateEvent](https://developer.mozilla.org/en/docs/Web/API/PopStateEvent) to Kotlin\n */\npublic external open class PopStateEvent(type: String, eventInitDict: PopStateEventInit = definedExternally) : Event {\n    open val state: Any?\n\n    companion object {\n        val NONE: Short\n        val CAPTURING_PHASE: Short\n        val AT_TARGET: Short\n        val BUBBLING_PHASE: Short\n    }\n}\n\npublic external interface PopStateEventInit : EventInit {\n    var state: Any? /* = null */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun PopStateEventInit(state: Any? = null, bubbles: Boolean? = false, cancelable: Boolean? = false, composed: Boolean? = false): PopStateEventInit {\n    val o = js(\"({})\")\n    o[\"state\"] = state\n    o[\"bubbles\"] = bubbles\n    o[\"cancelable\"] = cancelable\n    o[\"composed\"] = composed\n    return o\n}\n\n/**\n * Exposes the JavaScript [HashChangeEvent](https://developer.mozilla.org/en/docs/Web/API/HashChangeEvent) to Kotlin\n */\npublic external open class HashChangeEvent(type: String, eventInitDict: HashChangeEventInit = definedExternally) : Event {\n    open val oldURL: String\n    open val newURL: String\n\n    companion object {\n        val NONE: Short\n        val CAPTURING_PHASE: Short\n        val AT_TARGET: Short\n        val BUBBLING_PHASE: Short\n    }\n}\n\npublic external interface HashChangeEventInit : EventInit {\n    var oldURL: String? /* = \"\" */\n        get() = definedExternally\n        set(value) = definedExternally\n    var newURL: String? /* = \"\" */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun HashChangeEventInit(oldURL: String? = \"\", newURL: String? = \"\", bubbles: Boolean? = false, cancelable: Boolean? = false, composed: Boolean? = false): HashChangeEventInit {\n    val o = js(\"({})\")\n    o[\"oldURL\"] = oldURL\n    o[\"newURL\"] = newURL\n    o[\"bubbles\"] = bubbles\n    o[\"cancelable\"] = cancelable\n    o[\"composed\"] = composed\n    return o\n}\n\n/**\n * Exposes the JavaScript [PageTransitionEvent](https://developer.mozilla.org/en/docs/Web/API/PageTransitionEvent) to Kotlin\n */\npublic external open class PageTransitionEvent(type: String, eventInitDict: PageTransitionEventInit = definedExternally) : Event {\n    open val persisted: Boolean\n\n    companion object {\n        val NONE: Short\n        val CAPTURING_PHASE: Short\n        val AT_TARGET: Short\n        val BUBBLING_PHASE: Short\n    }\n}\n\npublic external interface PageTransitionEventInit : EventInit {\n    var persisted: Boolean? /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun PageTransitionEventInit(persisted: Boolean? = false, bubbles: Boolean? = false, cancelable: Boolean? = false, composed: Boolean? = false): PageTransitionEventInit {\n    val o = js(\"({})\")\n    o[\"persisted\"] = persisted\n    o[\"bubbles\"] = bubbles\n    o[\"cancelable\"] = cancelable\n    o[\"composed\"] = composed\n    return o\n}\n\n/**\n * Exposes the JavaScript [BeforeUnloadEvent](https://developer.mozilla.org/en/docs/Web/API/BeforeUnloadEvent) to Kotlin\n */\npublic external open class BeforeUnloadEvent : Event {\n    var returnValue: String\n\n    companion object {\n        val NONE: Short\n        val CAPTURING_PHASE: Short\n        val AT_TARGET: Short\n        val BUBBLING_PHASE: Short\n    }\n}\n\npublic external abstract class ApplicationCache : EventTarget {\n    open val status: Short\n    open var onchecking: ((Event) -> dynamic)?\n    open var onerror: ((Event) -> dynamic)?\n    open var onnoupdate: ((Event) -> dynamic)?\n    open var ondownloading: ((Event) -> dynamic)?\n    open var onprogress: ((ProgressEvent) -> dynamic)?\n    open var onupdateready: ((Event) -> dynamic)?\n    open var oncached: ((Event) -> dynamic)?\n    open var onobsolete: ((Event) -> dynamic)?\n    fun update()\n    fun abort()\n    fun swapCache()\n\n    companion object {\n        val UNCACHED: Short\n        val IDLE: Short\n        val CHECKING: Short\n        val DOWNLOADING: Short\n        val UPDATEREADY: Short\n        val OBSOLETE: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [NavigatorOnLine](https://developer.mozilla.org/en/docs/Web/API/NavigatorOnLine) to Kotlin\n */\npublic external interface NavigatorOnLine {\n    val onLine: Boolean\n}\n\n/**\n * Exposes the JavaScript [ErrorEvent](https://developer.mozilla.org/en/docs/Web/API/ErrorEvent) to Kotlin\n */\npublic external open class ErrorEvent(type: String, eventInitDict: ErrorEventInit = definedExternally) : Event {\n    open val message: String\n    open val filename: String\n    open val lineno: Int\n    open val colno: Int\n    open val error: Any?\n\n    companion object {\n        val NONE: Short\n        val CAPTURING_PHASE: Short\n        val AT_TARGET: Short\n        val BUBBLING_PHASE: Short\n    }\n}\n\npublic external interface ErrorEventInit : EventInit {\n    var message: String? /* = \"\" */\n        get() = definedExternally\n        set(value) = definedExternally\n    var filename: String? /* = \"\" */\n        get() = definedExternally\n        set(value) = definedExternally\n    var lineno: Int? /* = 0 */\n        get() = definedExternally\n        set(value) = definedExternally\n    var colno: Int? /* = 0 */\n        get() = definedExternally\n        set(value) = definedExternally\n    var error: Any? /* = null */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun ErrorEventInit(message: String? = \"\", filename: String? = \"\", lineno: Int? = 0, colno: Int? = 0, error: Any? = null, bubbles: Boolean? = false, cancelable: Boolean? = false, composed: Boolean? = false): ErrorEventInit {\n    val o = js(\"({})\")\n    o[\"message\"] = message\n    o[\"filename\"] = filename\n    o[\"lineno\"] = lineno\n    o[\"colno\"] = colno\n    o[\"error\"] = error\n    o[\"bubbles\"] = bubbles\n    o[\"cancelable\"] = cancelable\n    o[\"composed\"] = composed\n    return o\n}\n\n/**\n * Exposes the JavaScript [PromiseRejectionEvent](https://developer.mozilla.org/en/docs/Web/API/PromiseRejectionEvent) to Kotlin\n */\npublic external open class PromiseRejectionEvent(type: String, eventInitDict: PromiseRejectionEventInit) : Event {\n    open val promise: Promise<Any?>\n    open val reason: Any?\n\n    companion object {\n        val NONE: Short\n        val CAPTURING_PHASE: Short\n        val AT_TARGET: Short\n        val BUBBLING_PHASE: Short\n    }\n}\n\npublic external interface PromiseRejectionEventInit : EventInit {\n    var promise: Promise<Any?>?\n        get() = definedExternally\n        set(value) = definedExternally\n    var reason: Any?\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun PromiseRejectionEventInit(promise: Promise<Any?>?, reason: Any? = undefined, bubbles: Boolean? = false, cancelable: Boolean? = false, composed: Boolean? = false): PromiseRejectionEventInit {\n    val o = js(\"({})\")\n    o[\"promise\"] = promise\n    o[\"reason\"] = reason\n    o[\"bubbles\"] = bubbles\n    o[\"cancelable\"] = cancelable\n    o[\"composed\"] = composed\n    return o\n}\n\n/**\n * Exposes the JavaScript [GlobalEventHandlers](https://developer.mozilla.org/en/docs/Web/API/GlobalEventHandlers) to Kotlin\n */\npublic external interface GlobalEventHandlers {\n    var onabort: ((Event) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onblur: ((FocusEvent) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var oncancel: ((Event) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var oncanplay: ((Event) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var oncanplaythrough: ((Event) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onchange: ((Event) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onclick: ((MouseEvent) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onclose: ((Event) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var oncontextmenu: ((MouseEvent) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var oncuechange: ((Event) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var ondblclick: ((MouseEvent) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var ondrag: ((DragEvent) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var ondragend: ((DragEvent) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var ondragenter: ((DragEvent) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var ondragexit: ((DragEvent) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var ondragleave: ((DragEvent) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var ondragover: ((DragEvent) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var ondragstart: ((DragEvent) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var ondrop: ((DragEvent) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var ondurationchange: ((Event) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onemptied: ((Event) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onended: ((Event) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onerror: ((dynamic, String, Int, Int, Any?) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onfocus: ((FocusEvent) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var oninput: ((InputEvent) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var oninvalid: ((Event) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onkeydown: ((KeyboardEvent) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onkeypress: ((KeyboardEvent) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onkeyup: ((KeyboardEvent) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onload: ((Event) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onloadeddata: ((Event) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onloadedmetadata: ((Event) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onloadend: ((Event) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onloadstart: ((ProgressEvent) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onmousedown: ((MouseEvent) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onmouseenter: ((MouseEvent) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onmouseleave: ((MouseEvent) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onmousemove: ((MouseEvent) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onmouseout: ((MouseEvent) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onmouseover: ((MouseEvent) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onmouseup: ((MouseEvent) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onwheel: ((WheelEvent) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onpause: ((Event) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onplay: ((Event) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onplaying: ((Event) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onprogress: ((ProgressEvent) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onratechange: ((Event) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onreset: ((Event) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onresize: ((Event) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onscroll: ((Event) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onseeked: ((Event) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onseeking: ((Event) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onselect: ((Event) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onshow: ((Event) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onstalled: ((Event) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onsubmit: ((Event) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onsuspend: ((Event) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var ontimeupdate: ((Event) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var ontoggle: ((Event) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onvolumechange: ((Event) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onwaiting: ((Event) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var ongotpointercapture: ((PointerEvent) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onlostpointercapture: ((PointerEvent) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onpointerdown: ((PointerEvent) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onpointermove: ((PointerEvent) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onpointerup: ((PointerEvent) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onpointercancel: ((PointerEvent) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onpointerover: ((PointerEvent) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onpointerout: ((PointerEvent) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onpointerenter: ((PointerEvent) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onpointerleave: ((PointerEvent) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n/**\n * Exposes the JavaScript [WindowEventHandlers](https://developer.mozilla.org/en/docs/Web/API/WindowEventHandlers) to Kotlin\n */\npublic external interface WindowEventHandlers {\n    var onafterprint: ((Event) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onbeforeprint: ((Event) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onbeforeunload: ((BeforeUnloadEvent) -> String?)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onhashchange: ((HashChangeEvent) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onlanguagechange: ((Event) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onmessage: ((MessageEvent) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onoffline: ((Event) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var ononline: ((Event) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onpagehide: ((PageTransitionEvent) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onpageshow: ((PageTransitionEvent) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onpopstate: ((PopStateEvent) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onrejectionhandled: ((Event) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onstorage: ((StorageEvent) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onunhandledrejection: ((PromiseRejectionEvent) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onunload: ((Event) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\npublic external interface DocumentAndElementEventHandlers {\n    var oncopy: ((ClipboardEvent) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var oncut: ((ClipboardEvent) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onpaste: ((ClipboardEvent) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n/**\n * Exposes the JavaScript [WindowOrWorkerGlobalScope](https://developer.mozilla.org/en/docs/Web/API/WindowOrWorkerGlobalScope) to Kotlin\n */\npublic external interface WindowOrWorkerGlobalScope {\n    val origin: String\n    val caches: CacheStorage\n    fun btoa(data: String): String\n    fun atob(data: String): String\n    fun setTimeout(handler: dynamic, timeout: Int = definedExternally, vararg arguments: Any?): Int\n    fun clearTimeout(handle: Int = definedExternally)\n    fun setInterval(handler: dynamic, timeout: Int = definedExternally, vararg arguments: Any?): Int\n    fun clearInterval(handle: Int = definedExternally)\n    fun createImageBitmap(image: ImageBitmapSource, options: ImageBitmapOptions = definedExternally): Promise<ImageBitmap>\n    fun createImageBitmap(image: ImageBitmapSource, sx: Int, sy: Int, sw: Int, sh: Int, options: ImageBitmapOptions = definedExternally): Promise<ImageBitmap>\n    fun fetch(input: dynamic, init: RequestInit = definedExternally): Promise<Response>\n}\n\n/**\n * Exposes the JavaScript [Navigator](https://developer.mozilla.org/en/docs/Web/API/Navigator) to Kotlin\n */\npublic external abstract class Navigator : NavigatorID, NavigatorLanguage, NavigatorOnLine, NavigatorContentUtils, NavigatorCookies, NavigatorPlugins, NavigatorConcurrentHardware {\n    open val clipboard: Clipboard\n    open val mediaDevices: MediaDevices\n    open val maxTouchPoints: Int\n    open val serviceWorker: ServiceWorkerContainer\n    fun requestMediaKeySystemAccess(keySystem: String, supportedConfigurations: Array<MediaKeySystemConfiguration>): Promise<MediaKeySystemAccess>\n    fun getUserMedia(constraints: MediaStreamConstraints, successCallback: (MediaStream) -> Unit, errorCallback: (dynamic) -> Unit)\n    fun vibrate(pattern: dynamic): Boolean\n}\n\n/**\n * Exposes the JavaScript [NavigatorID](https://developer.mozilla.org/en/docs/Web/API/NavigatorID) to Kotlin\n */\npublic external interface NavigatorID {\n    val appCodeName: String\n    val appName: String\n    val appVersion: String\n    val platform: String\n    val product: String\n    val productSub: String\n    val userAgent: String\n    val vendor: String\n    val vendorSub: String\n    val oscpu: String\n    fun taintEnabled(): Boolean\n}\n\n/**\n * Exposes the JavaScript [NavigatorLanguage](https://developer.mozilla.org/en/docs/Web/API/NavigatorLanguage) to Kotlin\n */\npublic external interface NavigatorLanguage {\n    val language: String\n    val languages: Array<out String>\n}\n\npublic external interface NavigatorContentUtils {\n    fun registerProtocolHandler(scheme: String, url: String, title: String)\n    fun registerContentHandler(mimeType: String, url: String, title: String)\n    fun isProtocolHandlerRegistered(scheme: String, url: String): String\n    fun isContentHandlerRegistered(mimeType: String, url: String): String\n    fun unregisterProtocolHandler(scheme: String, url: String)\n    fun unregisterContentHandler(mimeType: String, url: String)\n}\n\npublic external interface NavigatorCookies {\n    val cookieEnabled: Boolean\n}\n\n/**\n * Exposes the JavaScript [NavigatorPlugins](https://developer.mozilla.org/en/docs/Web/API/NavigatorPlugins) to Kotlin\n */\npublic external interface NavigatorPlugins {\n    val plugins: PluginArray\n    val mimeTypes: MimeTypeArray\n    fun javaEnabled(): Boolean\n}\n\n/**\n * Exposes the JavaScript [PluginArray](https://developer.mozilla.org/en/docs/Web/API/PluginArray) to Kotlin\n */\npublic external abstract class PluginArray : ItemArrayLike<Plugin> {\n    fun refresh(reload: Boolean = definedExternally)\n    override fun item(index: Int): Plugin?\n    fun namedItem(name: String): Plugin?\n}\n\n@kotlin.internal.InlineOnly\npublic inline operator fun PluginArray.get(index: Int): Plugin? = asDynamic()[index]\n\n@kotlin.internal.InlineOnly\npublic inline operator fun PluginArray.get(name: String): Plugin? = asDynamic()[name]\n\n/**\n * Exposes the JavaScript [MimeTypeArray](https://developer.mozilla.org/en/docs/Web/API/MimeTypeArray) to Kotlin\n */\npublic external abstract class MimeTypeArray : ItemArrayLike<MimeType> {\n    override fun item(index: Int): MimeType?\n    fun namedItem(name: String): MimeType?\n}\n\n@kotlin.internal.InlineOnly\npublic inline operator fun MimeTypeArray.get(index: Int): MimeType? = asDynamic()[index]\n\n@kotlin.internal.InlineOnly\npublic inline operator fun MimeTypeArray.get(name: String): MimeType? = asDynamic()[name]\n\n/**\n * Exposes the JavaScript [Plugin](https://developer.mozilla.org/en/docs/Web/API/Plugin) to Kotlin\n */\npublic external abstract class Plugin : ItemArrayLike<MimeType> {\n    open val name: String\n    open val description: String\n    open val filename: String\n    override fun item(index: Int): MimeType?\n    fun namedItem(name: String): MimeType?\n}\n\n@kotlin.internal.InlineOnly\npublic inline operator fun Plugin.get(index: Int): MimeType? = asDynamic()[index]\n\n@kotlin.internal.InlineOnly\npublic inline operator fun Plugin.get(name: String): MimeType? = asDynamic()[name]\n\n/**\n * Exposes the JavaScript [MimeType](https://developer.mozilla.org/en/docs/Web/API/MimeType) to Kotlin\n */\npublic external abstract class MimeType {\n    open val type: String\n    open val description: String\n    open val suffixes: String\n    open val enabledPlugin: Plugin\n}\n\n/**\n * Exposes the JavaScript [ImageBitmap](https://developer.mozilla.org/en/docs/Web/API/ImageBitmap) to Kotlin\n */\npublic external abstract class ImageBitmap : CanvasImageSource, TexImageSource {\n    open val width: Int\n    open val height: Int\n    fun close()\n}\n\npublic external interface ImageBitmapOptions {\n    var imageOrientation: ImageOrientation? /* = ImageOrientation.NONE */\n        get() = definedExternally\n        set(value) = definedExternally\n    var premultiplyAlpha: PremultiplyAlpha? /* = PremultiplyAlpha.DEFAULT */\n        get() = definedExternally\n        set(value) = definedExternally\n    var colorSpaceConversion: ColorSpaceConversion? /* = ColorSpaceConversion.DEFAULT */\n        get() = definedExternally\n        set(value) = definedExternally\n    var resizeWidth: Int?\n        get() = definedExternally\n        set(value) = definedExternally\n    var resizeHeight: Int?\n        get() = definedExternally\n        set(value) = definedExternally\n    var resizeQuality: ResizeQuality? /* = ResizeQuality.LOW */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun ImageBitmapOptions(imageOrientation: ImageOrientation? = ImageOrientation.NONE, premultiplyAlpha: PremultiplyAlpha? = PremultiplyAlpha.DEFAULT, colorSpaceConversion: ColorSpaceConversion? = ColorSpaceConversion.DEFAULT, resizeWidth: Int? = undefined, resizeHeight: Int? = undefined, resizeQuality: ResizeQuality? = ResizeQuality.LOW): ImageBitmapOptions {\n    val o = js(\"({})\")\n    o[\"imageOrientation\"] = imageOrientation\n    o[\"premultiplyAlpha\"] = premultiplyAlpha\n    o[\"colorSpaceConversion\"] = colorSpaceConversion\n    o[\"resizeWidth\"] = resizeWidth\n    o[\"resizeHeight\"] = resizeHeight\n    o[\"resizeQuality\"] = resizeQuality\n    return o\n}\n\n/**\n * Exposes the JavaScript [MessageEvent](https://developer.mozilla.org/en/docs/Web/API/MessageEvent) to Kotlin\n */\npublic external open class MessageEvent(type: String, eventInitDict: MessageEventInit = definedExternally) : Event {\n    open val data: Any?\n    open val origin: String\n    open val lastEventId: String\n    open val source: UnionMessagePortOrWindowProxy?\n    open val ports: Array<out MessagePort>\n    fun initMessageEvent(type: String, bubbles: Boolean, cancelable: Boolean, data: Any?, origin: String, lastEventId: String, source: UnionMessagePortOrWindowProxy?, ports: Array<MessagePort>)\n\n    companion object {\n        val NONE: Short\n        val CAPTURING_PHASE: Short\n        val AT_TARGET: Short\n        val BUBBLING_PHASE: Short\n    }\n}\n\npublic external interface MessageEventInit : EventInit {\n    var data: Any? /* = null */\n        get() = definedExternally\n        set(value) = definedExternally\n    var origin: String? /* = \"\" */\n        get() = definedExternally\n        set(value) = definedExternally\n    var lastEventId: String? /* = \"\" */\n        get() = definedExternally\n        set(value) = definedExternally\n    var source: UnionMessagePortOrWindowProxy? /* = null */\n        get() = definedExternally\n        set(value) = definedExternally\n    var ports: Array<MessagePort>? /* = arrayOf() */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun MessageEventInit(data: Any? = null, origin: String? = \"\", lastEventId: String? = \"\", source: UnionMessagePortOrWindowProxy? = null, ports: Array<MessagePort>? = arrayOf(), bubbles: Boolean? = false, cancelable: Boolean? = false, composed: Boolean? = false): MessageEventInit {\n    val o = js(\"({})\")\n    o[\"data\"] = data\n    o[\"origin\"] = origin\n    o[\"lastEventId\"] = lastEventId\n    o[\"source\"] = source\n    o[\"ports\"] = ports\n    o[\"bubbles\"] = bubbles\n    o[\"cancelable\"] = cancelable\n    o[\"composed\"] = composed\n    return o\n}\n\n/**\n * Exposes the JavaScript [EventSource](https://developer.mozilla.org/en/docs/Web/API/EventSource) to Kotlin\n */\npublic external open class EventSource(url: String, eventSourceInitDict: EventSourceInit = definedExternally) : EventTarget {\n    open val url: String\n    open val withCredentials: Boolean\n    open val readyState: Short\n    var onopen: ((Event) -> dynamic)?\n    var onmessage: ((MessageEvent) -> dynamic)?\n    var onerror: ((Event) -> dynamic)?\n    fun close()\n\n    companion object {\n        val CONNECTING: Short\n        val OPEN: Short\n        val CLOSED: Short\n    }\n}\n\npublic external interface EventSourceInit {\n    var withCredentials: Boolean? /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun EventSourceInit(withCredentials: Boolean? = false): EventSourceInit {\n    val o = js(\"({})\")\n    o[\"withCredentials\"] = withCredentials\n    return o\n}\n\n/**\n * Exposes the JavaScript [WebSocket](https://developer.mozilla.org/en/docs/Web/API/WebSocket) to Kotlin\n */\npublic external open class WebSocket(url: String, protocols: dynamic = definedExternally) : EventTarget {\n    open val url: String\n    open val readyState: Short\n    open val bufferedAmount: Number\n    var onopen: ((Event) -> dynamic)?\n    var onerror: ((Event) -> dynamic)?\n    var onclose: ((Event) -> dynamic)?\n    open val extensions: String\n    open val protocol: String\n    var onmessage: ((MessageEvent) -> dynamic)?\n    var binaryType: BinaryType\n    fun close(code: Short = definedExternally, reason: String = definedExternally)\n    fun send(data: String)\n    fun send(data: Blob)\n    fun send(data: ArrayBuffer)\n    fun send(data: ArrayBufferView)\n\n    companion object {\n        val CONNECTING: Short\n        val OPEN: Short\n        val CLOSING: Short\n        val CLOSED: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [CloseEvent](https://developer.mozilla.org/en/docs/Web/API/CloseEvent) to Kotlin\n */\npublic external open class CloseEvent(type: String, eventInitDict: CloseEventInit = definedExternally) : Event {\n    open val wasClean: Boolean\n    open val code: Short\n    open val reason: String\n\n    companion object {\n        val NONE: Short\n        val CAPTURING_PHASE: Short\n        val AT_TARGET: Short\n        val BUBBLING_PHASE: Short\n    }\n}\n\npublic external interface CloseEventInit : EventInit {\n    var wasClean: Boolean? /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n    var code: Short? /* = 0 */\n        get() = definedExternally\n        set(value) = definedExternally\n    var reason: String? /* = \"\" */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun CloseEventInit(wasClean: Boolean? = false, code: Short? = 0, reason: String? = \"\", bubbles: Boolean? = false, cancelable: Boolean? = false, composed: Boolean? = false): CloseEventInit {\n    val o = js(\"({})\")\n    o[\"wasClean\"] = wasClean\n    o[\"code\"] = code\n    o[\"reason\"] = reason\n    o[\"bubbles\"] = bubbles\n    o[\"cancelable\"] = cancelable\n    o[\"composed\"] = composed\n    return o\n}\n\n/**\n * Exposes the JavaScript [MessageChannel](https://developer.mozilla.org/en/docs/Web/API/MessageChannel) to Kotlin\n */\npublic external open class MessageChannel {\n    open val port1: MessagePort\n    open val port2: MessagePort\n}\n\n/**\n * Exposes the JavaScript [MessagePort](https://developer.mozilla.org/en/docs/Web/API/MessagePort) to Kotlin\n */\npublic external abstract class MessagePort : EventTarget, UnionMessagePortOrWindowProxy, UnionMessagePortOrServiceWorker, UnionClientOrMessagePortOrServiceWorker {\n    open var onmessage: ((MessageEvent) -> dynamic)?\n    fun postMessage(message: Any?, transfer: Array<dynamic> = definedExternally)\n    fun start()\n    fun close()\n}\n\n/**\n * Exposes the JavaScript [BroadcastChannel](https://developer.mozilla.org/en/docs/Web/API/BroadcastChannel) to Kotlin\n */\npublic external open class BroadcastChannel(name: String) : EventTarget {\n    open val name: String\n    var onmessage: ((MessageEvent) -> dynamic)?\n    fun postMessage(message: Any?)\n    fun close()\n}\n\n/**\n * Exposes the JavaScript [WorkerGlobalScope](https://developer.mozilla.org/en/docs/Web/API/WorkerGlobalScope) to Kotlin\n */\npublic external abstract class WorkerGlobalScope : EventTarget, WindowOrWorkerGlobalScope, GlobalPerformance {\n    open val self: WorkerGlobalScope\n    open val location: WorkerLocation\n    open val navigator: WorkerNavigator\n    open var onerror: ((dynamic, String, Int, Int, Any?) -> dynamic)?\n    open var onlanguagechange: ((Event) -> dynamic)?\n    open var onoffline: ((Event) -> dynamic)?\n    open var ononline: ((Event) -> dynamic)?\n    open var onrejectionhandled: ((Event) -> dynamic)?\n    open var onunhandledrejection: ((PromiseRejectionEvent) -> dynamic)?\n    fun importScripts(vararg urls: String)\n}\n\n/**\n * Exposes the JavaScript [DedicatedWorkerGlobalScope](https://developer.mozilla.org/en/docs/Web/API/DedicatedWorkerGlobalScope) to Kotlin\n */\npublic external abstract class DedicatedWorkerGlobalScope : WorkerGlobalScope {\n    open var onmessage: ((MessageEvent) -> dynamic)?\n    fun postMessage(message: Any?, transfer: Array<dynamic> = definedExternally)\n    fun close()\n}\n\n/**\n * Exposes the JavaScript [SharedWorkerGlobalScope](https://developer.mozilla.org/en/docs/Web/API/SharedWorkerGlobalScope) to Kotlin\n */\npublic external abstract class SharedWorkerGlobalScope : WorkerGlobalScope {\n    open val name: String\n    open val applicationCache: ApplicationCache\n    open var onconnect: ((Event) -> dynamic)?\n    fun close()\n}\n\n/**\n * Exposes the JavaScript [AbstractWorker](https://developer.mozilla.org/en/docs/Web/API/AbstractWorker) to Kotlin\n */\npublic external interface AbstractWorker {\n    var onerror: ((Event) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n/**\n * Exposes the JavaScript [Worker](https://developer.mozilla.org/en/docs/Web/API/Worker) to Kotlin\n */\npublic external open class Worker(scriptURL: String, options: WorkerOptions = definedExternally) : EventTarget, AbstractWorker {\n    var onmessage: ((MessageEvent) -> dynamic)?\n    override var onerror: ((Event) -> dynamic)?\n    fun terminate()\n    fun postMessage(message: Any?, transfer: Array<dynamic> = definedExternally)\n}\n\npublic external interface WorkerOptions {\n    var type: WorkerType? /* = WorkerType.CLASSIC */\n        get() = definedExternally\n        set(value) = definedExternally\n    var credentials: RequestCredentials? /* = RequestCredentials.OMIT */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun WorkerOptions(type: WorkerType? = WorkerType.CLASSIC, credentials: RequestCredentials? = RequestCredentials.OMIT): WorkerOptions {\n    val o = js(\"({})\")\n    o[\"type\"] = type\n    o[\"credentials\"] = credentials\n    return o\n}\n\n/**\n * Exposes the JavaScript [SharedWorker](https://developer.mozilla.org/en/docs/Web/API/SharedWorker) to Kotlin\n */\npublic external open class SharedWorker(scriptURL: String, name: String = definedExternally, options: WorkerOptions = definedExternally) : EventTarget, AbstractWorker {\n    open val port: MessagePort\n    override var onerror: ((Event) -> dynamic)?\n}\n\n/**\n * Exposes the JavaScript [NavigatorConcurrentHardware](https://developer.mozilla.org/en/docs/Web/API/NavigatorConcurrentHardware) to Kotlin\n */\npublic external interface NavigatorConcurrentHardware {\n    val hardwareConcurrency: Number\n}\n\n/**\n * Exposes the JavaScript [WorkerNavigator](https://developer.mozilla.org/en/docs/Web/API/WorkerNavigator) to Kotlin\n */\npublic external abstract class WorkerNavigator : NavigatorID, NavigatorLanguage, NavigatorOnLine, NavigatorConcurrentHardware {\n    open val serviceWorker: ServiceWorkerContainer\n}\n\n/**\n * Exposes the JavaScript [WorkerLocation](https://developer.mozilla.org/en/docs/Web/API/WorkerLocation) to Kotlin\n */\npublic external abstract class WorkerLocation {\n    open val href: String\n    open val origin: String\n    open val protocol: String\n    open val host: String\n    open val hostname: String\n    open val port: String\n    open val pathname: String\n    open val search: String\n    open val hash: String\n}\n\n/**\n * Exposes the JavaScript [Storage](https://developer.mozilla.org/en/docs/Web/API/Storage) to Kotlin\n */\npublic external abstract class Storage {\n    open val length: Int\n    fun key(index: Int): String?\n    fun removeItem(key: String)\n    fun clear()\n    fun getItem(key: String): String?\n    fun setItem(key: String, value: String)\n}\n\n@kotlin.internal.InlineOnly\npublic inline operator fun Storage.get(key: String): String? = asDynamic()[key]\n\n@kotlin.internal.InlineOnly\npublic inline operator fun Storage.set(key: String, value: String) { asDynamic()[key] = value }\n\n/**\n * Exposes the JavaScript [WindowSessionStorage](https://developer.mozilla.org/en/docs/Web/API/WindowSessionStorage) to Kotlin\n */\npublic external interface WindowSessionStorage {\n    val sessionStorage: Storage\n}\n\n/**\n * Exposes the JavaScript [WindowLocalStorage](https://developer.mozilla.org/en/docs/Web/API/WindowLocalStorage) to Kotlin\n */\npublic external interface WindowLocalStorage {\n    val localStorage: Storage\n}\n\n/**\n * Exposes the JavaScript [StorageEvent](https://developer.mozilla.org/en/docs/Web/API/StorageEvent) to Kotlin\n */\npublic external open class StorageEvent(type: String, eventInitDict: StorageEventInit = definedExternally) : Event {\n    open val key: String?\n    open val oldValue: String?\n    open val newValue: String?\n    open val url: String\n    open val storageArea: Storage?\n\n    companion object {\n        val NONE: Short\n        val CAPTURING_PHASE: Short\n        val AT_TARGET: Short\n        val BUBBLING_PHASE: Short\n    }\n}\n\npublic external interface StorageEventInit : EventInit {\n    var key: String? /* = null */\n        get() = definedExternally\n        set(value) = definedExternally\n    var oldValue: String? /* = null */\n        get() = definedExternally\n        set(value) = definedExternally\n    var newValue: String? /* = null */\n        get() = definedExternally\n        set(value) = definedExternally\n    var url: String? /* = \"\" */\n        get() = definedExternally\n        set(value) = definedExternally\n    var storageArea: Storage? /* = null */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun StorageEventInit(key: String? = null, oldValue: String? = null, newValue: String? = null, url: String? = \"\", storageArea: Storage? = null, bubbles: Boolean? = false, cancelable: Boolean? = false, composed: Boolean? = false): StorageEventInit {\n    val o = js(\"({})\")\n    o[\"key\"] = key\n    o[\"oldValue\"] = oldValue\n    o[\"newValue\"] = newValue\n    o[\"url\"] = url\n    o[\"storageArea\"] = storageArea\n    o[\"bubbles\"] = bubbles\n    o[\"cancelable\"] = cancelable\n    o[\"composed\"] = composed\n    return o\n}\n\npublic external abstract class HTMLAppletElement : HTMLElement {\n    open var align: String\n    open var alt: String\n    open var archive: String\n    open var code: String\n    open var codeBase: String\n    open var height: String\n    open var hspace: Int\n    open var name: String\n    open var _object: String\n    open var vspace: Int\n    open var width: String\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLMarqueeElement](https://developer.mozilla.org/en/docs/Web/API/HTMLMarqueeElement) to Kotlin\n */\npublic external abstract class HTMLMarqueeElement : HTMLElement {\n    open var behavior: String\n    open var bgColor: String\n    open var direction: String\n    open var height: String\n    open var hspace: Int\n    open var loop: Int\n    open var scrollAmount: Int\n    open var scrollDelay: Int\n    open var trueSpeed: Boolean\n    open var vspace: Int\n    open var width: String\n    open var onbounce: ((Event) -> dynamic)?\n    open var onfinish: ((Event) -> dynamic)?\n    open var onstart: ((Event) -> dynamic)?\n    fun start()\n    fun stop()\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLFrameSetElement](https://developer.mozilla.org/en/docs/Web/API/HTMLFrameSetElement) to Kotlin\n */\npublic external abstract class HTMLFrameSetElement : HTMLElement, WindowEventHandlers {\n    open var cols: String\n    open var rows: String\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\npublic external abstract class HTMLFrameElement : HTMLElement {\n    open var name: String\n    open var scrolling: String\n    open var src: String\n    open var frameBorder: String\n    open var longDesc: String\n    open var noResize: Boolean\n    open val contentDocument: Document?\n    open val contentWindow: Window?\n    open var marginHeight: String\n    open var marginWidth: String\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\npublic external abstract class HTMLDirectoryElement : HTMLElement {\n    open var compact: Boolean\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLFontElement](https://developer.mozilla.org/en/docs/Web/API/HTMLFontElement) to Kotlin\n */\npublic external abstract class HTMLFontElement : HTMLElement {\n    open var color: String\n    open var face: String\n    open var size: String\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\npublic external interface External {\n    fun AddSearchProvider()\n    fun IsSearchProviderInstalled()\n}\n\npublic external interface EventInit {\n    var bubbles: Boolean? /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n    var cancelable: Boolean? /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n    var composed: Boolean? /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun EventInit(bubbles: Boolean? = false, cancelable: Boolean? = false, composed: Boolean? = false): EventInit {\n    val o = js(\"({})\")\n    o[\"bubbles\"] = bubbles\n    o[\"cancelable\"] = cancelable\n    o[\"composed\"] = composed\n    return o\n}\n\n/**\n * Exposes the JavaScript [CustomEvent](https://developer.mozilla.org/en/docs/Web/API/CustomEvent) to Kotlin\n */\npublic external open class CustomEvent(type: String, eventInitDict: CustomEventInit = definedExternally) : Event {\n    open val detail: Any?\n    fun initCustomEvent(type: String, bubbles: Boolean, cancelable: Boolean, detail: Any?)\n\n    companion object {\n        val NONE: Short\n        val CAPTURING_PHASE: Short\n        val AT_TARGET: Short\n        val BUBBLING_PHASE: Short\n    }\n}\n\npublic external interface CustomEventInit : EventInit {\n    var detail: Any? /* = null */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun CustomEventInit(detail: Any? = null, bubbles: Boolean? = false, cancelable: Boolean? = false, composed: Boolean? = false): CustomEventInit {\n    val o = js(\"({})\")\n    o[\"detail\"] = detail\n    o[\"bubbles\"] = bubbles\n    o[\"cancelable\"] = cancelable\n    o[\"composed\"] = composed\n    return o\n}\n\npublic external interface EventListenerOptions {\n    var capture: Boolean? /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun EventListenerOptions(capture: Boolean? = false): EventListenerOptions {\n    val o = js(\"({})\")\n    o[\"capture\"] = capture\n    return o\n}\n\npublic external interface AddEventListenerOptions : EventListenerOptions {\n    var passive: Boolean? /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n    var once: Boolean? /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun AddEventListenerOptions(passive: Boolean? = false, once: Boolean? = false, capture: Boolean? = false): AddEventListenerOptions {\n    val o = js(\"({})\")\n    o[\"passive\"] = passive\n    o[\"once\"] = once\n    o[\"capture\"] = capture\n    return o\n}\n\npublic external interface NonElementParentNode {\n    fun getElementById(elementId: String): Element?\n}\n\n/**\n * Exposes the JavaScript [DocumentOrShadowRoot](https://developer.mozilla.org/en/docs/Web/API/DocumentOrShadowRoot) to Kotlin\n */\npublic external interface DocumentOrShadowRoot {\n    val fullscreenElement: Element?\n        get() = definedExternally\n}\n\n/**\n * Exposes the JavaScript [ParentNode](https://developer.mozilla.org/en/docs/Web/API/ParentNode) to Kotlin\n */\npublic external interface ParentNode {\n    val children: HTMLCollection\n    val firstElementChild: Element?\n        get() = definedExternally\n    val lastElementChild: Element?\n        get() = definedExternally\n    val childElementCount: Int\n    fun prepend(vararg nodes: dynamic)\n    fun append(vararg nodes: dynamic)\n    fun querySelector(selectors: String): Element?\n    fun querySelectorAll(selectors: String): NodeList\n}\n\n/**\n * Exposes the JavaScript [NonDocumentTypeChildNode](https://developer.mozilla.org/en/docs/Web/API/NonDocumentTypeChildNode) to Kotlin\n */\npublic external interface NonDocumentTypeChildNode {\n    val previousElementSibling: Element?\n        get() = definedExternally\n    val nextElementSibling: Element?\n        get() = definedExternally\n}\n\n/**\n * Exposes the JavaScript [ChildNode](https://developer.mozilla.org/en/docs/Web/API/ChildNode) to Kotlin\n */\npublic external interface ChildNode {\n    fun before(vararg nodes: dynamic)\n    fun after(vararg nodes: dynamic)\n    fun replaceWith(vararg nodes: dynamic)\n    fun remove()\n}\n\n/**\n * Exposes the JavaScript [Slotable](https://developer.mozilla.org/en/docs/Web/API/Slotable) to Kotlin\n */\npublic external interface Slotable {\n    val assignedSlot: HTMLSlotElement?\n        get() = definedExternally\n}\n\n/**\n * Exposes the JavaScript [NodeList](https://developer.mozilla.org/en/docs/Web/API/NodeList) to Kotlin\n */\npublic external abstract class NodeList : ItemArrayLike<Node> {\n    override fun item(index: Int): Node?\n}\n\n@kotlin.internal.InlineOnly\npublic inline operator fun NodeList.get(index: Int): Node? = asDynamic()[index]\n\n/**\n * Exposes the JavaScript [HTMLCollection](https://developer.mozilla.org/en/docs/Web/API/HTMLCollection) to Kotlin\n */\npublic external abstract class HTMLCollection : ItemArrayLike<Element>, UnionElementOrHTMLCollection {\n    override fun item(index: Int): Element?\n    fun namedItem(name: String): Element?\n}\n\n@kotlin.internal.InlineOnly\npublic inline operator fun HTMLCollection.get(index: Int): Element? = asDynamic()[index]\n\n@kotlin.internal.InlineOnly\npublic inline operator fun HTMLCollection.get(name: String): Element? = asDynamic()[name]\n\n/**\n * Exposes the JavaScript [MutationObserver](https://developer.mozilla.org/en/docs/Web/API/MutationObserver) to Kotlin\n */\npublic external open class MutationObserver(callback: (Array<MutationRecord>, MutationObserver) -> Unit) {\n    fun observe(target: Node, options: MutationObserverInit = definedExternally)\n    fun disconnect()\n    fun takeRecords(): Array<MutationRecord>\n}\n\n/**\n * Exposes the JavaScript [MutationObserverInit](https://developer.mozilla.org/en/docs/Web/API/MutationObserverInit) to Kotlin\n */\npublic external interface MutationObserverInit {\n    var childList: Boolean? /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n    var attributes: Boolean?\n        get() = definedExternally\n        set(value) = definedExternally\n    var characterData: Boolean?\n        get() = definedExternally\n        set(value) = definedExternally\n    var subtree: Boolean? /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n    var attributeOldValue: Boolean?\n        get() = definedExternally\n        set(value) = definedExternally\n    var characterDataOldValue: Boolean?\n        get() = definedExternally\n        set(value) = definedExternally\n    var attributeFilter: Array<String>?\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun MutationObserverInit(childList: Boolean? = false, attributes: Boolean? = undefined, characterData: Boolean? = undefined, subtree: Boolean? = false, attributeOldValue: Boolean? = undefined, characterDataOldValue: Boolean? = undefined, attributeFilter: Array<String>? = undefined): MutationObserverInit {\n    val o = js(\"({})\")\n    o[\"childList\"] = childList\n    o[\"attributes\"] = attributes\n    o[\"characterData\"] = characterData\n    o[\"subtree\"] = subtree\n    o[\"attributeOldValue\"] = attributeOldValue\n    o[\"characterDataOldValue\"] = characterDataOldValue\n    o[\"attributeFilter\"] = attributeFilter\n    return o\n}\n\n/**\n * Exposes the JavaScript [MutationRecord](https://developer.mozilla.org/en/docs/Web/API/MutationRecord) to Kotlin\n */\npublic external abstract class MutationRecord {\n    open val type: String\n    open val target: Node\n    open val addedNodes: NodeList\n    open val removedNodes: NodeList\n    open val previousSibling: Node?\n    open val nextSibling: Node?\n    open val attributeName: String?\n    open val attributeNamespace: String?\n    open val oldValue: String?\n}\n\n/**\n * Exposes the JavaScript [Node](https://developer.mozilla.org/en/docs/Web/API/Node) to Kotlin\n */\npublic external abstract class Node : EventTarget {\n    open val nodeType: Short\n    open val nodeName: String\n    open val baseURI: String\n    open val isConnected: Boolean\n    open val ownerDocument: Document?\n    open val parentNode: Node?\n    open val parentElement: Element?\n    open val childNodes: NodeList\n    open val firstChild: Node?\n    open val lastChild: Node?\n    open val previousSibling: Node?\n    open val nextSibling: Node?\n    open var nodeValue: String?\n    open var textContent: String?\n    fun getRootNode(options: GetRootNodeOptions = definedExternally): Node\n    fun hasChildNodes(): Boolean\n    fun normalize()\n    fun cloneNode(deep: Boolean = definedExternally): Node\n    fun isEqualNode(otherNode: Node?): Boolean\n    fun isSameNode(otherNode: Node?): Boolean\n    fun compareDocumentPosition(other: Node): Short\n    fun contains(other: Node?): Boolean\n    fun lookupPrefix(namespace: String?): String?\n    fun lookupNamespaceURI(prefix: String?): String?\n    fun isDefaultNamespace(namespace: String?): Boolean\n    fun insertBefore(node: Node, child: Node?): Node\n    fun appendChild(node: Node): Node\n    fun replaceChild(node: Node, child: Node): Node\n    fun removeChild(child: Node): Node\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\npublic external interface GetRootNodeOptions {\n    var composed: Boolean? /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun GetRootNodeOptions(composed: Boolean? = false): GetRootNodeOptions {\n    val o = js(\"({})\")\n    o[\"composed\"] = composed\n    return o\n}\n\n/**\n * Exposes the JavaScript [Document](https://developer.mozilla.org/en/docs/Web/API/Document) to Kotlin\n */\npublic external open class Document : Node, GlobalEventHandlers, DocumentAndElementEventHandlers, NonElementParentNode, DocumentOrShadowRoot, ParentNode, GeometryUtils {\n    open val implementation: DOMImplementation\n    open val URL: String\n    open val documentURI: String\n    open val origin: String\n    open val compatMode: String\n    open val characterSet: String\n    open val charset: String\n    open val inputEncoding: String\n    open val contentType: String\n    open val doctype: DocumentType?\n    open val documentElement: Element?\n    open val location: Location?\n    var domain: String\n    open val referrer: String\n    var cookie: String\n    open val lastModified: String\n    open val readyState: DocumentReadyState\n    var title: String\n    var dir: String\n    var body: HTMLElement?\n    open val head: HTMLHeadElement?\n    open val images: HTMLCollection\n    open val embeds: HTMLCollection\n    open val plugins: HTMLCollection\n    open val links: HTMLCollection\n    open val forms: HTMLCollection\n    open val scripts: HTMLCollection\n    open val currentScript: HTMLOrSVGScriptElement?\n    open val defaultView: Window?\n    open val activeElement: Element?\n    var designMode: String\n    var onreadystatechange: ((Event) -> dynamic)?\n    var fgColor: String\n    var linkColor: String\n    var vlinkColor: String\n    var alinkColor: String\n    var bgColor: String\n    open val anchors: HTMLCollection\n    open val applets: HTMLCollection\n    open val all: HTMLAllCollection\n    open val scrollingElement: Element?\n    open val styleSheets: StyleSheetList\n    open val rootElement: SVGSVGElement?\n    open val fullscreenEnabled: Boolean\n    open val fullscreen: Boolean\n    var onfullscreenchange: ((Event) -> dynamic)?\n    var onfullscreenerror: ((Event) -> dynamic)?\n    override var onabort: ((Event) -> dynamic)?\n    override var onblur: ((FocusEvent) -> dynamic)?\n    override var oncancel: ((Event) -> dynamic)?\n    override var oncanplay: ((Event) -> dynamic)?\n    override var oncanplaythrough: ((Event) -> dynamic)?\n    override var onchange: ((Event) -> dynamic)?\n    override var onclick: ((MouseEvent) -> dynamic)?\n    override var onclose: ((Event) -> dynamic)?\n    override var oncontextmenu: ((MouseEvent) -> dynamic)?\n    override var oncuechange: ((Event) -> dynamic)?\n    override var ondblclick: ((MouseEvent) -> dynamic)?\n    override var ondrag: ((DragEvent) -> dynamic)?\n    override var ondragend: ((DragEvent) -> dynamic)?\n    override var ondragenter: ((DragEvent) -> dynamic)?\n    override var ondragexit: ((DragEvent) -> dynamic)?\n    override var ondragleave: ((DragEvent) -> dynamic)?\n    override var ondragover: ((DragEvent) -> dynamic)?\n    override var ondragstart: ((DragEvent) -> dynamic)?\n    override var ondrop: ((DragEvent) -> dynamic)?\n    override var ondurationchange: ((Event) -> dynamic)?\n    override var onemptied: ((Event) -> dynamic)?\n    override var onended: ((Event) -> dynamic)?\n    override var onerror: ((dynamic, String, Int, Int, Any?) -> dynamic)?\n    override var onfocus: ((FocusEvent) -> dynamic)?\n    override var oninput: ((InputEvent) -> dynamic)?\n    override var oninvalid: ((Event) -> dynamic)?\n    override var onkeydown: ((KeyboardEvent) -> dynamic)?\n    override var onkeypress: ((KeyboardEvent) -> dynamic)?\n    override var onkeyup: ((KeyboardEvent) -> dynamic)?\n    override var onload: ((Event) -> dynamic)?\n    override var onloadeddata: ((Event) -> dynamic)?\n    override var onloadedmetadata: ((Event) -> dynamic)?\n    override var onloadend: ((Event) -> dynamic)?\n    override var onloadstart: ((ProgressEvent) -> dynamic)?\n    override var onmousedown: ((MouseEvent) -> dynamic)?\n    override var onmouseenter: ((MouseEvent) -> dynamic)?\n    override var onmouseleave: ((MouseEvent) -> dynamic)?\n    override var onmousemove: ((MouseEvent) -> dynamic)?\n    override var onmouseout: ((MouseEvent) -> dynamic)?\n    override var onmouseover: ((MouseEvent) -> dynamic)?\n    override var onmouseup: ((MouseEvent) -> dynamic)?\n    override var onwheel: ((WheelEvent) -> dynamic)?\n    override var onpause: ((Event) -> dynamic)?\n    override var onplay: ((Event) -> dynamic)?\n    override var onplaying: ((Event) -> dynamic)?\n    override var onprogress: ((ProgressEvent) -> dynamic)?\n    override var onratechange: ((Event) -> dynamic)?\n    override var onreset: ((Event) -> dynamic)?\n    override var onresize: ((Event) -> dynamic)?\n    override var onscroll: ((Event) -> dynamic)?\n    override var onseeked: ((Event) -> dynamic)?\n    override var onseeking: ((Event) -> dynamic)?\n    override var onselect: ((Event) -> dynamic)?\n    override var onshow: ((Event) -> dynamic)?\n    override var onstalled: ((Event) -> dynamic)?\n    override var onsubmit: ((Event) -> dynamic)?\n    override var onsuspend: ((Event) -> dynamic)?\n    override var ontimeupdate: ((Event) -> dynamic)?\n    override var ontoggle: ((Event) -> dynamic)?\n    override var onvolumechange: ((Event) -> dynamic)?\n    override var onwaiting: ((Event) -> dynamic)?\n    override var ongotpointercapture: ((PointerEvent) -> dynamic)?\n    override var onlostpointercapture: ((PointerEvent) -> dynamic)?\n    override var onpointerdown: ((PointerEvent) -> dynamic)?\n    override var onpointermove: ((PointerEvent) -> dynamic)?\n    override var onpointerup: ((PointerEvent) -> dynamic)?\n    override var onpointercancel: ((PointerEvent) -> dynamic)?\n    override var onpointerover: ((PointerEvent) -> dynamic)?\n    override var onpointerout: ((PointerEvent) -> dynamic)?\n    override var onpointerenter: ((PointerEvent) -> dynamic)?\n    override var onpointerleave: ((PointerEvent) -> dynamic)?\n    override var oncopy: ((ClipboardEvent) -> dynamic)?\n    override var oncut: ((ClipboardEvent) -> dynamic)?\n    override var onpaste: ((ClipboardEvent) -> dynamic)?\n    override val fullscreenElement: Element?\n    override val children: HTMLCollection\n    override val firstElementChild: Element?\n    override val lastElementChild: Element?\n    override val childElementCount: Int\n    fun getElementsByTagName(qualifiedName: String): HTMLCollection\n    fun getElementsByTagNameNS(namespace: String?, localName: String): HTMLCollection\n    fun getElementsByClassName(classNames: String): HTMLCollection\n    fun createElement(localName: String, options: ElementCreationOptions = definedExternally): Element\n    fun createElementNS(namespace: String?, qualifiedName: String, options: ElementCreationOptions = definedExternally): Element\n    fun createDocumentFragment(): DocumentFragment\n    fun createTextNode(data: String): Text\n    fun createCDATASection(data: String): CDATASection\n    fun createComment(data: String): Comment\n    fun createProcessingInstruction(target: String, data: String): ProcessingInstruction\n    fun importNode(node: Node, deep: Boolean = definedExternally): Node\n    fun adoptNode(node: Node): Node\n    fun createAttribute(localName: String): Attr\n    fun createAttributeNS(namespace: String?, qualifiedName: String): Attr\n    fun createEvent(`interface`: String): Event\n    fun createRange(): Range\n    fun createNodeIterator(root: Node, whatToShow: Int = definedExternally, filter: NodeFilter? = definedExternally): NodeIterator\n    fun createNodeIterator(root: Node, whatToShow: Int = definedExternally, filter: ((Node) -> Short)? = definedExternally): NodeIterator\n    fun createTreeWalker(root: Node, whatToShow: Int = definedExternally, filter: NodeFilter? = definedExternally): TreeWalker\n    fun createTreeWalker(root: Node, whatToShow: Int = definedExternally, filter: ((Node) -> Short)? = definedExternally): TreeWalker\n    fun getElementsByName(elementName: String): NodeList\n    fun open(type: String = definedExternally, replace: String = definedExternally): Document\n    fun open(url: String, name: String, features: String): Window\n    fun close()\n    fun write(vararg text: String)\n    fun writeln(vararg text: String)\n    fun hasFocus(): Boolean\n    fun execCommand(commandId: String, showUI: Boolean = definedExternally, value: String = definedExternally): Boolean\n    fun queryCommandEnabled(commandId: String): Boolean\n    fun queryCommandIndeterm(commandId: String): Boolean\n    fun queryCommandState(commandId: String): Boolean\n    fun queryCommandSupported(commandId: String): Boolean\n    fun queryCommandValue(commandId: String): String\n    fun clear()\n    fun captureEvents()\n    fun releaseEvents()\n    fun elementFromPoint(x: Double, y: Double): Element?\n    fun elementsFromPoint(x: Double, y: Double): Array<Element>\n    fun caretPositionFromPoint(x: Double, y: Double): CaretPosition?\n    fun createTouch(view: Window, target: EventTarget, identifier: Int, pageX: Int, pageY: Int, screenX: Int, screenY: Int): Touch\n    fun createTouchList(vararg touches: Touch): TouchList\n    fun exitFullscreen(): Promise<Unit>\n    override fun getElementById(elementId: String): Element?\n    override fun prepend(vararg nodes: dynamic)\n    override fun append(vararg nodes: dynamic)\n    override fun querySelector(selectors: String): Element?\n    override fun querySelectorAll(selectors: String): NodeList\n    override fun getBoxQuads(options: BoxQuadOptions /* = definedExternally */): Array<DOMQuad>\n    override fun convertQuadFromNode(quad: dynamic, from: dynamic, options: ConvertCoordinateOptions /* = definedExternally */): DOMQuad\n    override fun convertRectFromNode(rect: DOMRectReadOnly, from: dynamic, options: ConvertCoordinateOptions /* = definedExternally */): DOMQuad\n    override fun convertPointFromNode(point: DOMPointInit, from: dynamic, options: ConvertCoordinateOptions /* = definedExternally */): DOMPoint\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n@kotlin.internal.InlineOnly\npublic inline operator fun Document.get(name: String): dynamic = asDynamic()[name]\n\n/**\n * Exposes the JavaScript [XMLDocument](https://developer.mozilla.org/en/docs/Web/API/XMLDocument) to Kotlin\n */\npublic external open class XMLDocument : Document {\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\npublic external interface ElementCreationOptions {\n    var `is`: String?\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun ElementCreationOptions(`is`: String? = undefined): ElementCreationOptions {\n    val o = js(\"({})\")\n    o[\"is\"] = `is`\n    return o\n}\n\n/**\n * Exposes the JavaScript [DOMImplementation](https://developer.mozilla.org/en/docs/Web/API/DOMImplementation) to Kotlin\n */\npublic external abstract class DOMImplementation {\n    fun createDocumentType(qualifiedName: String, publicId: String, systemId: String): DocumentType\n    fun createDocument(namespace: String?, qualifiedName: String, doctype: DocumentType? = definedExternally): XMLDocument\n    fun createHTMLDocument(title: String = definedExternally): Document\n    fun hasFeature(): Boolean\n}\n\n/**\n * Exposes the JavaScript [DocumentType](https://developer.mozilla.org/en/docs/Web/API/DocumentType) to Kotlin\n */\npublic external abstract class DocumentType : Node, ChildNode {\n    open val name: String\n    open val publicId: String\n    open val systemId: String\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [DocumentFragment](https://developer.mozilla.org/en/docs/Web/API/DocumentFragment) to Kotlin\n */\npublic external open class DocumentFragment : Node, NonElementParentNode, ParentNode {\n    override val children: HTMLCollection\n    override val firstElementChild: Element?\n    override val lastElementChild: Element?\n    override val childElementCount: Int\n    override fun getElementById(elementId: String): Element?\n    override fun prepend(vararg nodes: dynamic)\n    override fun append(vararg nodes: dynamic)\n    override fun querySelector(selectors: String): Element?\n    override fun querySelectorAll(selectors: String): NodeList\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [ShadowRoot](https://developer.mozilla.org/en/docs/Web/API/ShadowRoot) to Kotlin\n */\npublic external open class ShadowRoot : DocumentFragment, DocumentOrShadowRoot {\n    open val mode: ShadowRootMode\n    open val host: Element\n    override val fullscreenElement: Element?\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [Element](https://developer.mozilla.org/en/docs/Web/API/Element) to Kotlin\n */\npublic external abstract class Element : Node, ParentNode, NonDocumentTypeChildNode, ChildNode, Slotable, GeometryUtils, UnionElementOrHTMLCollection, UnionElementOrRadioNodeList, UnionElementOrMouseEvent, UnionElementOrProcessingInstruction {\n    open val namespaceURI: String?\n    open val prefix: String?\n    open val localName: String\n    open val tagName: String\n    open var id: String\n    open var className: String\n    open val classList: DOMTokenList\n    open var slot: String\n    open val attributes: NamedNodeMap\n    open val shadowRoot: ShadowRoot?\n    open var scrollTop: Double\n    open var scrollLeft: Double\n    open val scrollWidth: Int\n    open val scrollHeight: Int\n    open val clientTop: Int\n    open val clientLeft: Int\n    open val clientWidth: Int\n    open val clientHeight: Int\n    open var innerHTML: String\n    open var outerHTML: String\n    fun hasAttributes(): Boolean\n    fun getAttributeNames(): Array<String>\n    fun getAttribute(qualifiedName: String): String?\n    fun getAttributeNS(namespace: String?, localName: String): String?\n    fun setAttribute(qualifiedName: String, value: String)\n    fun setAttributeNS(namespace: String?, qualifiedName: String, value: String)\n    fun removeAttribute(qualifiedName: String)\n    fun removeAttributeNS(namespace: String?, localName: String)\n    fun hasAttribute(qualifiedName: String): Boolean\n    fun hasAttributeNS(namespace: String?, localName: String): Boolean\n    fun getAttributeNode(qualifiedName: String): Attr?\n    fun getAttributeNodeNS(namespace: String?, localName: String): Attr?\n    fun setAttributeNode(attr: Attr): Attr?\n    fun setAttributeNodeNS(attr: Attr): Attr?\n    fun removeAttributeNode(attr: Attr): Attr\n    fun attachShadow(init: ShadowRootInit): ShadowRoot\n    fun closest(selectors: String): Element?\n    fun matches(selectors: String): Boolean\n    fun webkitMatchesSelector(selectors: String): Boolean\n    fun getElementsByTagName(qualifiedName: String): HTMLCollection\n    fun getElementsByTagNameNS(namespace: String?, localName: String): HTMLCollection\n    fun getElementsByClassName(classNames: String): HTMLCollection\n    fun insertAdjacentElement(where: String, element: Element): Element?\n    fun insertAdjacentText(where: String, data: String)\n    fun getClientRects(): Array<DOMRect>\n    fun getBoundingClientRect(): DOMRect\n    fun scrollIntoView()\n    fun scrollIntoView(arg: dynamic)\n    fun scroll(options: ScrollToOptions = definedExternally)\n    fun scroll(x: Double, y: Double)\n    fun scrollTo(options: ScrollToOptions = definedExternally)\n    fun scrollTo(x: Double, y: Double)\n    fun scrollBy(options: ScrollToOptions = definedExternally)\n    fun scrollBy(x: Double, y: Double)\n    fun insertAdjacentHTML(position: String, text: String)\n    fun setPointerCapture(pointerId: Int)\n    fun releasePointerCapture(pointerId: Int)\n    fun hasPointerCapture(pointerId: Int): Boolean\n    fun requestFullscreen(): Promise<Unit>\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\npublic external interface ShadowRootInit {\n    var mode: ShadowRootMode?\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun ShadowRootInit(mode: ShadowRootMode?): ShadowRootInit {\n    val o = js(\"({})\")\n    o[\"mode\"] = mode\n    return o\n}\n\n/**\n * Exposes the JavaScript [NamedNodeMap](https://developer.mozilla.org/en/docs/Web/API/NamedNodeMap) to Kotlin\n */\npublic external abstract class NamedNodeMap : ItemArrayLike<Attr> {\n    fun getNamedItemNS(namespace: String?, localName: String): Attr?\n    fun setNamedItem(attr: Attr): Attr?\n    fun setNamedItemNS(attr: Attr): Attr?\n    fun removeNamedItem(qualifiedName: String): Attr\n    fun removeNamedItemNS(namespace: String?, localName: String): Attr\n    override fun item(index: Int): Attr?\n    fun getNamedItem(qualifiedName: String): Attr?\n}\n\n@kotlin.internal.InlineOnly\npublic inline operator fun NamedNodeMap.get(index: Int): Attr? = asDynamic()[index]\n\n@kotlin.internal.InlineOnly\npublic inline operator fun NamedNodeMap.get(qualifiedName: String): Attr? = asDynamic()[qualifiedName]\n\n/**\n * Exposes the JavaScript [Attr](https://developer.mozilla.org/en/docs/Web/API/Attr) to Kotlin\n */\npublic external abstract class Attr : Node {\n    open val namespaceURI: String?\n    open val prefix: String?\n    open val localName: String\n    open val name: String\n    open var value: String\n    open val ownerElement: Element?\n    open val specified: Boolean\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [CharacterData](https://developer.mozilla.org/en/docs/Web/API/CharacterData) to Kotlin\n */\npublic external abstract class CharacterData : Node, NonDocumentTypeChildNode, ChildNode {\n    open var data: String\n    open val length: Int\n    fun substringData(offset: Int, count: Int): String\n    fun appendData(data: String)\n    fun insertData(offset: Int, data: String)\n    fun deleteData(offset: Int, count: Int)\n    fun replaceData(offset: Int, count: Int, data: String)\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [Text](https://developer.mozilla.org/en/docs/Web/API/Text) to Kotlin\n */\npublic external open class Text(data: String = definedExternally) : CharacterData, Slotable, GeometryUtils {\n    open val wholeText: String\n    override val assignedSlot: HTMLSlotElement?\n    override val previousElementSibling: Element?\n    override val nextElementSibling: Element?\n    fun splitText(offset: Int): Text\n    override fun getBoxQuads(options: BoxQuadOptions /* = definedExternally */): Array<DOMQuad>\n    override fun convertQuadFromNode(quad: dynamic, from: dynamic, options: ConvertCoordinateOptions /* = definedExternally */): DOMQuad\n    override fun convertRectFromNode(rect: DOMRectReadOnly, from: dynamic, options: ConvertCoordinateOptions /* = definedExternally */): DOMQuad\n    override fun convertPointFromNode(point: DOMPointInit, from: dynamic, options: ConvertCoordinateOptions /* = definedExternally */): DOMPoint\n    override fun before(vararg nodes: dynamic)\n    override fun after(vararg nodes: dynamic)\n    override fun replaceWith(vararg nodes: dynamic)\n    override fun remove()\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [CDATASection](https://developer.mozilla.org/en/docs/Web/API/CDATASection) to Kotlin\n */\npublic external open class CDATASection : Text {\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [ProcessingInstruction](https://developer.mozilla.org/en/docs/Web/API/ProcessingInstruction) to Kotlin\n */\npublic external abstract class ProcessingInstruction : CharacterData, LinkStyle, UnionElementOrProcessingInstruction {\n    open val target: String\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [Comment](https://developer.mozilla.org/en/docs/Web/API/Comment) to Kotlin\n */\npublic external open class Comment(data: String = definedExternally) : CharacterData {\n    override val previousElementSibling: Element?\n    override val nextElementSibling: Element?\n    override fun before(vararg nodes: dynamic)\n    override fun after(vararg nodes: dynamic)\n    override fun replaceWith(vararg nodes: dynamic)\n    override fun remove()\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [Range](https://developer.mozilla.org/en/docs/Web/API/Range) to Kotlin\n */\npublic external open class Range {\n    open val startContainer: Node\n    open val startOffset: Int\n    open val endContainer: Node\n    open val endOffset: Int\n    open val collapsed: Boolean\n    open val commonAncestorContainer: Node\n    fun setStart(node: Node, offset: Int)\n    fun setEnd(node: Node, offset: Int)\n    fun setStartBefore(node: Node)\n    fun setStartAfter(node: Node)\n    fun setEndBefore(node: Node)\n    fun setEndAfter(node: Node)\n    fun collapse(toStart: Boolean = definedExternally)\n    fun selectNode(node: Node)\n    fun selectNodeContents(node: Node)\n    fun compareBoundaryPoints(how: Short, sourceRange: Range): Short\n    fun deleteContents()\n    fun extractContents(): DocumentFragment\n    fun cloneContents(): DocumentFragment\n    fun insertNode(node: Node)\n    fun surroundContents(newParent: Node)\n    fun cloneRange(): Range\n    fun detach()\n    fun isPointInRange(node: Node, offset: Int): Boolean\n    fun comparePoint(node: Node, offset: Int): Short\n    fun intersectsNode(node: Node): Boolean\n    fun getClientRects(): Array<DOMRect>\n    fun getBoundingClientRect(): DOMRect\n    fun createContextualFragment(fragment: String): DocumentFragment\n\n    companion object {\n        val START_TO_START: Short\n        val START_TO_END: Short\n        val END_TO_END: Short\n        val END_TO_START: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [NodeIterator](https://developer.mozilla.org/en/docs/Web/API/NodeIterator) to Kotlin\n */\npublic external abstract class NodeIterator {\n    open val root: Node\n    open val referenceNode: Node\n    open val pointerBeforeReferenceNode: Boolean\n    open val whatToShow: Int\n    open val filter: NodeFilter?\n    fun nextNode(): Node?\n    fun previousNode(): Node?\n    fun detach()\n}\n\n/**\n * Exposes the JavaScript [TreeWalker](https://developer.mozilla.org/en/docs/Web/API/TreeWalker) to Kotlin\n */\npublic external abstract class TreeWalker {\n    open val root: Node\n    open val whatToShow: Int\n    open val filter: NodeFilter?\n    open var currentNode: Node\n    fun parentNode(): Node?\n    fun firstChild(): Node?\n    fun lastChild(): Node?\n    fun previousSibling(): Node?\n    fun nextSibling(): Node?\n    fun previousNode(): Node?\n    fun nextNode(): Node?\n}\n\n/**\n * Exposes the JavaScript [NodeFilter](https://developer.mozilla.org/en/docs/Web/API/NodeFilter) to Kotlin\n */\n@Suppress(\"NESTED_CLASS_IN_EXTERNAL_INTERFACE\")\npublic external interface NodeFilter {\n    fun acceptNode(node: Node): Short\n\n    companion object {\n        val FILTER_ACCEPT: Short\n        val FILTER_REJECT: Short\n        val FILTER_SKIP: Short\n        val SHOW_ALL: Int\n        val SHOW_ELEMENT: Int\n        val SHOW_ATTRIBUTE: Int\n        val SHOW_TEXT: Int\n        val SHOW_CDATA_SECTION: Int\n        val SHOW_ENTITY_REFERENCE: Int\n        val SHOW_ENTITY: Int\n        val SHOW_PROCESSING_INSTRUCTION: Int\n        val SHOW_COMMENT: Int\n        val SHOW_DOCUMENT: Int\n        val SHOW_DOCUMENT_TYPE: Int\n        val SHOW_DOCUMENT_FRAGMENT: Int\n        val SHOW_NOTATION: Int\n    }\n}\n\n/**\n * Exposes the JavaScript [DOMTokenList](https://developer.mozilla.org/en/docs/Web/API/DOMTokenList) to Kotlin\n */\npublic external abstract class DOMTokenList : ItemArrayLike<String> {\n    open var value: String\n    fun contains(token: String): Boolean\n    fun add(vararg tokens: String)\n    fun remove(vararg tokens: String)\n    fun toggle(token: String, force: Boolean = definedExternally): Boolean\n    fun replace(token: String, newToken: String)\n    fun supports(token: String): Boolean\n    override fun item(index: Int): String?\n}\n\n@kotlin.internal.InlineOnly\npublic inline operator fun DOMTokenList.get(index: Int): String? = asDynamic()[index]\n\n/**\n * Exposes the JavaScript [DOMPointReadOnly](https://developer.mozilla.org/en/docs/Web/API/DOMPointReadOnly) to Kotlin\n */\npublic external open class DOMPointReadOnly(x: Double, y: Double, z: Double, w: Double) {\n    open val x: Double\n    open val y: Double\n    open val z: Double\n    open val w: Double\n    fun matrixTransform(matrix: DOMMatrixReadOnly): DOMPoint\n}\n\n/**\n * Exposes the JavaScript [DOMPoint](https://developer.mozilla.org/en/docs/Web/API/DOMPoint) to Kotlin\n */\npublic external open class DOMPoint : DOMPointReadOnly {\n    constructor(point: DOMPointInit)\n    constructor(x: Double = definedExternally, y: Double = definedExternally, z: Double = definedExternally, w: Double = definedExternally)\n    override var x: Double\n    override var y: Double\n    override var z: Double\n    override var w: Double\n}\n\n/**\n * Exposes the JavaScript [DOMPointInit](https://developer.mozilla.org/en/docs/Web/API/DOMPointInit) to Kotlin\n */\npublic external interface DOMPointInit {\n    var x: Double? /* = 0.0 */\n        get() = definedExternally\n        set(value) = definedExternally\n    var y: Double? /* = 0.0 */\n        get() = definedExternally\n        set(value) = definedExternally\n    var z: Double? /* = 0.0 */\n        get() = definedExternally\n        set(value) = definedExternally\n    var w: Double? /* = 1.0 */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun DOMPointInit(x: Double? = 0.0, y: Double? = 0.0, z: Double? = 0.0, w: Double? = 1.0): DOMPointInit {\n    val o = js(\"({})\")\n    o[\"x\"] = x\n    o[\"y\"] = y\n    o[\"z\"] = z\n    o[\"w\"] = w\n    return o\n}\n\n/**\n * Exposes the JavaScript [DOMRect](https://developer.mozilla.org/en/docs/Web/API/DOMRect) to Kotlin\n */\npublic external open class DOMRect(x: Double = definedExternally, y: Double = definedExternally, width: Double = definedExternally, height: Double = definedExternally) : DOMRectReadOnly {\n    override var x: Double\n    override var y: Double\n    override var width: Double\n    override var height: Double\n}\n\n/**\n * Exposes the JavaScript [DOMRectReadOnly](https://developer.mozilla.org/en/docs/Web/API/DOMRectReadOnly) to Kotlin\n */\npublic external open class DOMRectReadOnly(x: Double, y: Double, width: Double, height: Double) {\n    open val x: Double\n    open val y: Double\n    open val width: Double\n    open val height: Double\n    open val top: Double\n    open val right: Double\n    open val bottom: Double\n    open val left: Double\n}\n\npublic external interface DOMRectInit {\n    var x: Double? /* = 0.0 */\n        get() = definedExternally\n        set(value) = definedExternally\n    var y: Double? /* = 0.0 */\n        get() = definedExternally\n        set(value) = definedExternally\n    var width: Double? /* = 0.0 */\n        get() = definedExternally\n        set(value) = definedExternally\n    var height: Double? /* = 0.0 */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun DOMRectInit(x: Double? = 0.0, y: Double? = 0.0, width: Double? = 0.0, height: Double? = 0.0): DOMRectInit {\n    val o = js(\"({})\")\n    o[\"x\"] = x\n    o[\"y\"] = y\n    o[\"width\"] = width\n    o[\"height\"] = height\n    return o\n}\n\npublic external interface DOMRectList : ItemArrayLike<DOMRect> {\n    override fun item(index: Int): DOMRect?\n}\n\n@kotlin.internal.InlineOnly\npublic inline operator fun DOMRectList.get(index: Int): DOMRect? = asDynamic()[index]\n\n/**\n * Exposes the JavaScript [DOMQuad](https://developer.mozilla.org/en/docs/Web/API/DOMQuad) to Kotlin\n */\npublic external open class DOMQuad {\n    constructor(p1: DOMPointInit = definedExternally, p2: DOMPointInit = definedExternally, p3: DOMPointInit = definedExternally, p4: DOMPointInit = definedExternally)\n    constructor(rect: DOMRectInit)\n    open val p1: DOMPoint\n    open val p2: DOMPoint\n    open val p3: DOMPoint\n    open val p4: DOMPoint\n    open val bounds: DOMRectReadOnly\n}\n\n/**\n * Exposes the JavaScript [DOMMatrixReadOnly](https://developer.mozilla.org/en/docs/Web/API/DOMMatrixReadOnly) to Kotlin\n */\npublic external open class DOMMatrixReadOnly(numberSequence: Array<Double>) {\n    open val a: Double\n    open val b: Double\n    open val c: Double\n    open val d: Double\n    open val e: Double\n    open val f: Double\n    open val m11: Double\n    open val m12: Double\n    open val m13: Double\n    open val m14: Double\n    open val m21: Double\n    open val m22: Double\n    open val m23: Double\n    open val m24: Double\n    open val m31: Double\n    open val m32: Double\n    open val m33: Double\n    open val m34: Double\n    open val m41: Double\n    open val m42: Double\n    open val m43: Double\n    open val m44: Double\n    open val is2D: Boolean\n    open val isIdentity: Boolean\n    fun translate(tx: Double, ty: Double, tz: Double = definedExternally): DOMMatrix\n    fun scale(scale: Double, originX: Double = definedExternally, originY: Double = definedExternally): DOMMatrix\n    fun scale3d(scale: Double, originX: Double = definedExternally, originY: Double = definedExternally, originZ: Double = definedExternally): DOMMatrix\n    fun scaleNonUniform(scaleX: Double, scaleY: Double = definedExternally, scaleZ: Double = definedExternally, originX: Double = definedExternally, originY: Double = definedExternally, originZ: Double = definedExternally): DOMMatrix\n    fun rotate(angle: Double, originX: Double = definedExternally, originY: Double = definedExternally): DOMMatrix\n    fun rotateFromVector(x: Double, y: Double): DOMMatrix\n    fun rotateAxisAngle(x: Double, y: Double, z: Double, angle: Double): DOMMatrix\n    fun skewX(sx: Double): DOMMatrix\n    fun skewY(sy: Double): DOMMatrix\n    fun multiply(other: DOMMatrix): DOMMatrix\n    fun flipX(): DOMMatrix\n    fun flipY(): DOMMatrix\n    fun inverse(): DOMMatrix\n    fun transformPoint(point: DOMPointInit = definedExternally): DOMPoint\n    fun toFloat32Array(): Float32Array\n    fun toFloat64Array(): Float64Array\n}\n\n/**\n * Exposes the JavaScript [DOMMatrix](https://developer.mozilla.org/en/docs/Web/API/DOMMatrix) to Kotlin\n */\npublic external open class DOMMatrix() : DOMMatrixReadOnly {\n    constructor(transformList: String)\n    constructor(other: DOMMatrixReadOnly)\n    constructor(array32: Float32Array)\n    constructor(array64: Float64Array)\n    constructor(numberSequence: Array<Double>)\n    override var a: Double\n    override var b: Double\n    override var c: Double\n    override var d: Double\n    override var e: Double\n    override var f: Double\n    override var m11: Double\n    override var m12: Double\n    override var m13: Double\n    override var m14: Double\n    override var m21: Double\n    override var m22: Double\n    override var m23: Double\n    override var m24: Double\n    override var m31: Double\n    override var m32: Double\n    override var m33: Double\n    override var m34: Double\n    override var m41: Double\n    override var m42: Double\n    override var m43: Double\n    override var m44: Double\n    fun multiplySelf(other: DOMMatrix): DOMMatrix\n    fun preMultiplySelf(other: DOMMatrix): DOMMatrix\n    fun translateSelf(tx: Double, ty: Double, tz: Double = definedExternally): DOMMatrix\n    fun scaleSelf(scale: Double, originX: Double = definedExternally, originY: Double = definedExternally): DOMMatrix\n    fun scale3dSelf(scale: Double, originX: Double = definedExternally, originY: Double = definedExternally, originZ: Double = definedExternally): DOMMatrix\n    fun scaleNonUniformSelf(scaleX: Double, scaleY: Double = definedExternally, scaleZ: Double = definedExternally, originX: Double = definedExternally, originY: Double = definedExternally, originZ: Double = definedExternally): DOMMatrix\n    fun rotateSelf(angle: Double, originX: Double = definedExternally, originY: Double = definedExternally): DOMMatrix\n    fun rotateFromVectorSelf(x: Double, y: Double): DOMMatrix\n    fun rotateAxisAngleSelf(x: Double, y: Double, z: Double, angle: Double): DOMMatrix\n    fun skewXSelf(sx: Double): DOMMatrix\n    fun skewYSelf(sy: Double): DOMMatrix\n    fun invertSelf(): DOMMatrix\n    fun setMatrixValue(transformList: String): DOMMatrix\n}\n\npublic external interface ScrollOptions {\n    var behavior: ScrollBehavior? /* = ScrollBehavior.AUTO */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun ScrollOptions(behavior: ScrollBehavior? = ScrollBehavior.AUTO): ScrollOptions {\n    val o = js(\"({})\")\n    o[\"behavior\"] = behavior\n    return o\n}\n\n/**\n * Exposes the JavaScript [ScrollToOptions](https://developer.mozilla.org/en/docs/Web/API/ScrollToOptions) to Kotlin\n */\npublic external interface ScrollToOptions : ScrollOptions {\n    var left: Double?\n        get() = definedExternally\n        set(value) = definedExternally\n    var top: Double?\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun ScrollToOptions(left: Double? = undefined, top: Double? = undefined, behavior: ScrollBehavior? = ScrollBehavior.AUTO): ScrollToOptions {\n    val o = js(\"({})\")\n    o[\"left\"] = left\n    o[\"top\"] = top\n    o[\"behavior\"] = behavior\n    return o\n}\n\n/**\n * Exposes the JavaScript [MediaQueryList](https://developer.mozilla.org/en/docs/Web/API/MediaQueryList) to Kotlin\n */\npublic external abstract class MediaQueryList : EventTarget {\n    open val media: String\n    open val matches: Boolean\n    open var onchange: ((Event) -> dynamic)?\n    fun addListener(listener: EventListener?)\n    fun addListener(listener: ((Event) -> Unit)?)\n    fun removeListener(listener: EventListener?)\n    fun removeListener(listener: ((Event) -> Unit)?)\n}\n\n/**\n * Exposes the JavaScript [MediaQueryListEvent](https://developer.mozilla.org/en/docs/Web/API/MediaQueryListEvent) to Kotlin\n */\npublic external open class MediaQueryListEvent(type: String, eventInitDict: MediaQueryListEventInit = definedExternally) : Event {\n    open val media: String\n    open val matches: Boolean\n\n    companion object {\n        val NONE: Short\n        val CAPTURING_PHASE: Short\n        val AT_TARGET: Short\n        val BUBBLING_PHASE: Short\n    }\n}\n\npublic external interface MediaQueryListEventInit : EventInit {\n    var media: String? /* = \"\" */\n        get() = definedExternally\n        set(value) = definedExternally\n    var matches: Boolean? /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun MediaQueryListEventInit(media: String? = \"\", matches: Boolean? = false, bubbles: Boolean? = false, cancelable: Boolean? = false, composed: Boolean? = false): MediaQueryListEventInit {\n    val o = js(\"({})\")\n    o[\"media\"] = media\n    o[\"matches\"] = matches\n    o[\"bubbles\"] = bubbles\n    o[\"cancelable\"] = cancelable\n    o[\"composed\"] = composed\n    return o\n}\n\n/**\n * Exposes the JavaScript [Screen](https://developer.mozilla.org/en/docs/Web/API/Screen) to Kotlin\n */\npublic external abstract class Screen {\n    open val availWidth: Int\n    open val availHeight: Int\n    open val width: Int\n    open val height: Int\n    open val colorDepth: Int\n    open val pixelDepth: Int\n}\n\n/**\n * Exposes the JavaScript [CaretPosition](https://developer.mozilla.org/en/docs/Web/API/CaretPosition) to Kotlin\n */\npublic external abstract class CaretPosition {\n    open val offsetNode: Node\n    open val offset: Int\n    fun getClientRect(): DOMRect?\n}\n\npublic external interface ScrollIntoViewOptions : ScrollOptions {\n    var block: ScrollLogicalPosition? /* = ScrollLogicalPosition.CENTER */\n        get() = definedExternally\n        set(value) = definedExternally\n    var inline: ScrollLogicalPosition? /* = ScrollLogicalPosition.CENTER */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun ScrollIntoViewOptions(block: ScrollLogicalPosition? = ScrollLogicalPosition.CENTER, inline: ScrollLogicalPosition? = ScrollLogicalPosition.CENTER, behavior: ScrollBehavior? = ScrollBehavior.AUTO): ScrollIntoViewOptions {\n    val o = js(\"({})\")\n    o[\"block\"] = block\n    o[\"inline\"] = inline\n    o[\"behavior\"] = behavior\n    return o\n}\n\npublic external interface BoxQuadOptions {\n    var box: CSSBoxType? /* = CSSBoxType.BORDER */\n        get() = definedExternally\n        set(value) = definedExternally\n    var relativeTo: dynamic\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun BoxQuadOptions(box: CSSBoxType? = CSSBoxType.BORDER, relativeTo: dynamic = undefined): BoxQuadOptions {\n    val o = js(\"({})\")\n    o[\"box\"] = box\n    o[\"relativeTo\"] = relativeTo\n    return o\n}\n\npublic external interface ConvertCoordinateOptions {\n    var fromBox: CSSBoxType? /* = CSSBoxType.BORDER */\n        get() = definedExternally\n        set(value) = definedExternally\n    var toBox: CSSBoxType? /* = CSSBoxType.BORDER */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun ConvertCoordinateOptions(fromBox: CSSBoxType? = CSSBoxType.BORDER, toBox: CSSBoxType? = CSSBoxType.BORDER): ConvertCoordinateOptions {\n    val o = js(\"({})\")\n    o[\"fromBox\"] = fromBox\n    o[\"toBox\"] = toBox\n    return o\n}\n\n/**\n * Exposes the JavaScript [GeometryUtils](https://developer.mozilla.org/en/docs/Web/API/GeometryUtils) to Kotlin\n */\npublic external interface GeometryUtils {\n    fun getBoxQuads(options: BoxQuadOptions = definedExternally): Array<DOMQuad>\n    fun convertQuadFromNode(quad: dynamic, from: dynamic, options: ConvertCoordinateOptions = definedExternally): DOMQuad\n    fun convertRectFromNode(rect: DOMRectReadOnly, from: dynamic, options: ConvertCoordinateOptions = definedExternally): DOMQuad\n    fun convertPointFromNode(point: DOMPointInit, from: dynamic, options: ConvertCoordinateOptions = definedExternally): DOMPoint\n}\n\n/**\n * Exposes the JavaScript [Touch](https://developer.mozilla.org/en/docs/Web/API/Touch) to Kotlin\n */\npublic external abstract class Touch {\n    open val identifier: Int\n    open val target: EventTarget\n    open val screenX: Int\n    open val screenY: Int\n    open val clientX: Int\n    open val clientY: Int\n    open val pageX: Int\n    open val pageY: Int\n    open val region: String?\n}\n\npublic external abstract class TouchList : ItemArrayLike<Touch> {\n    override fun item(index: Int): Touch?\n}\n\n@kotlin.internal.InlineOnly\npublic inline operator fun TouchList.get(index: Int): Touch? = asDynamic()[index]\n\npublic external open class TouchEvent : UIEvent {\n    open val touches: TouchList\n    open val targetTouches: TouchList\n    open val changedTouches: TouchList\n    open val altKey: Boolean\n    open val metaKey: Boolean\n    open val ctrlKey: Boolean\n    open val shiftKey: Boolean\n\n    companion object {\n        val NONE: Short\n        val CAPTURING_PHASE: Short\n        val AT_TARGET: Short\n        val BUBBLING_PHASE: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [Image](https://developer.mozilla.org/en/docs/Web/API/Image) to Kotlin\n */\npublic external open class Image(width: Int = definedExternally, height: Int = definedExternally) : HTMLImageElement {\n    override var onabort: ((Event) -> dynamic)?\n    override var onblur: ((FocusEvent) -> dynamic)?\n    override var oncancel: ((Event) -> dynamic)?\n    override var oncanplay: ((Event) -> dynamic)?\n    override var oncanplaythrough: ((Event) -> dynamic)?\n    override var onchange: ((Event) -> dynamic)?\n    override var onclick: ((MouseEvent) -> dynamic)?\n    override var onclose: ((Event) -> dynamic)?\n    override var oncontextmenu: ((MouseEvent) -> dynamic)?\n    override var oncuechange: ((Event) -> dynamic)?\n    override var ondblclick: ((MouseEvent) -> dynamic)?\n    override var ondrag: ((DragEvent) -> dynamic)?\n    override var ondragend: ((DragEvent) -> dynamic)?\n    override var ondragenter: ((DragEvent) -> dynamic)?\n    override var ondragexit: ((DragEvent) -> dynamic)?\n    override var ondragleave: ((DragEvent) -> dynamic)?\n    override var ondragover: ((DragEvent) -> dynamic)?\n    override var ondragstart: ((DragEvent) -> dynamic)?\n    override var ondrop: ((DragEvent) -> dynamic)?\n    override var ondurationchange: ((Event) -> dynamic)?\n    override var onemptied: ((Event) -> dynamic)?\n    override var onended: ((Event) -> dynamic)?\n    override var onerror: ((dynamic, String, Int, Int, Any?) -> dynamic)?\n    override var onfocus: ((FocusEvent) -> dynamic)?\n    override var oninput: ((InputEvent) -> dynamic)?\n    override var oninvalid: ((Event) -> dynamic)?\n    override var onkeydown: ((KeyboardEvent) -> dynamic)?\n    override var onkeypress: ((KeyboardEvent) -> dynamic)?\n    override var onkeyup: ((KeyboardEvent) -> dynamic)?\n    override var onload: ((Event) -> dynamic)?\n    override var onloadeddata: ((Event) -> dynamic)?\n    override var onloadedmetadata: ((Event) -> dynamic)?\n    override var onloadend: ((Event) -> dynamic)?\n    override var onloadstart: ((ProgressEvent) -> dynamic)?\n    override var onmousedown: ((MouseEvent) -> dynamic)?\n    override var onmouseenter: ((MouseEvent) -> dynamic)?\n    override var onmouseleave: ((MouseEvent) -> dynamic)?\n    override var onmousemove: ((MouseEvent) -> dynamic)?\n    override var onmouseout: ((MouseEvent) -> dynamic)?\n    override var onmouseover: ((MouseEvent) -> dynamic)?\n    override var onmouseup: ((MouseEvent) -> dynamic)?\n    override var onwheel: ((WheelEvent) -> dynamic)?\n    override var onpause: ((Event) -> dynamic)?\n    override var onplay: ((Event) -> dynamic)?\n    override var onplaying: ((Event) -> dynamic)?\n    override var onprogress: ((ProgressEvent) -> dynamic)?\n    override var onratechange: ((Event) -> dynamic)?\n    override var onreset: ((Event) -> dynamic)?\n    override var onresize: ((Event) -> dynamic)?\n    override var onscroll: ((Event) -> dynamic)?\n    override var onseeked: ((Event) -> dynamic)?\n    override var onseeking: ((Event) -> dynamic)?\n    override var onselect: ((Event) -> dynamic)?\n    override var onshow: ((Event) -> dynamic)?\n    override var onstalled: ((Event) -> dynamic)?\n    override var onsubmit: ((Event) -> dynamic)?\n    override var onsuspend: ((Event) -> dynamic)?\n    override var ontimeupdate: ((Event) -> dynamic)?\n    override var ontoggle: ((Event) -> dynamic)?\n    override var onvolumechange: ((Event) -> dynamic)?\n    override var onwaiting: ((Event) -> dynamic)?\n    override var ongotpointercapture: ((PointerEvent) -> dynamic)?\n    override var onlostpointercapture: ((PointerEvent) -> dynamic)?\n    override var onpointerdown: ((PointerEvent) -> dynamic)?\n    override var onpointermove: ((PointerEvent) -> dynamic)?\n    override var onpointerup: ((PointerEvent) -> dynamic)?\n    override var onpointercancel: ((PointerEvent) -> dynamic)?\n    override var onpointerover: ((PointerEvent) -> dynamic)?\n    override var onpointerout: ((PointerEvent) -> dynamic)?\n    override var onpointerenter: ((PointerEvent) -> dynamic)?\n    override var onpointerleave: ((PointerEvent) -> dynamic)?\n    override var oncopy: ((ClipboardEvent) -> dynamic)?\n    override var oncut: ((ClipboardEvent) -> dynamic)?\n    override var onpaste: ((ClipboardEvent) -> dynamic)?\n    override var contentEditable: String\n    override val isContentEditable: Boolean\n    override val style: CSSStyleDeclaration\n    override val children: HTMLCollection\n    override val firstElementChild: Element?\n    override val lastElementChild: Element?\n    override val childElementCount: Int\n    override val previousElementSibling: Element?\n    override val nextElementSibling: Element?\n    override val assignedSlot: HTMLSlotElement?\n    override fun prepend(vararg nodes: dynamic)\n    override fun append(vararg nodes: dynamic)\n    override fun querySelector(selectors: String): Element?\n    override fun querySelectorAll(selectors: String): NodeList\n    override fun before(vararg nodes: dynamic)\n    override fun after(vararg nodes: dynamic)\n    override fun replaceWith(vararg nodes: dynamic)\n    override fun remove()\n    override fun getBoxQuads(options: BoxQuadOptions /* = definedExternally */): Array<DOMQuad>\n    override fun convertQuadFromNode(quad: dynamic, from: dynamic, options: ConvertCoordinateOptions /* = definedExternally */): DOMQuad\n    override fun convertRectFromNode(rect: DOMRectReadOnly, from: dynamic, options: ConvertCoordinateOptions /* = definedExternally */): DOMQuad\n    override fun convertPointFromNode(point: DOMPointInit, from: dynamic, options: ConvertCoordinateOptions /* = definedExternally */): DOMPoint\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\npublic external open class Audio(src: String = definedExternally) : HTMLAudioElement {\n    override var onabort: ((Event) -> dynamic)?\n    override var onblur: ((FocusEvent) -> dynamic)?\n    override var oncancel: ((Event) -> dynamic)?\n    override var oncanplay: ((Event) -> dynamic)?\n    override var oncanplaythrough: ((Event) -> dynamic)?\n    override var onchange: ((Event) -> dynamic)?\n    override var onclick: ((MouseEvent) -> dynamic)?\n    override var onclose: ((Event) -> dynamic)?\n    override var oncontextmenu: ((MouseEvent) -> dynamic)?\n    override var oncuechange: ((Event) -> dynamic)?\n    override var ondblclick: ((MouseEvent) -> dynamic)?\n    override var ondrag: ((DragEvent) -> dynamic)?\n    override var ondragend: ((DragEvent) -> dynamic)?\n    override var ondragenter: ((DragEvent) -> dynamic)?\n    override var ondragexit: ((DragEvent) -> dynamic)?\n    override var ondragleave: ((DragEvent) -> dynamic)?\n    override var ondragover: ((DragEvent) -> dynamic)?\n    override var ondragstart: ((DragEvent) -> dynamic)?\n    override var ondrop: ((DragEvent) -> dynamic)?\n    override var ondurationchange: ((Event) -> dynamic)?\n    override var onemptied: ((Event) -> dynamic)?\n    override var onended: ((Event) -> dynamic)?\n    override var onerror: ((dynamic, String, Int, Int, Any?) -> dynamic)?\n    override var onfocus: ((FocusEvent) -> dynamic)?\n    override var oninput: ((InputEvent) -> dynamic)?\n    override var oninvalid: ((Event) -> dynamic)?\n    override var onkeydown: ((KeyboardEvent) -> dynamic)?\n    override var onkeypress: ((KeyboardEvent) -> dynamic)?\n    override var onkeyup: ((KeyboardEvent) -> dynamic)?\n    override var onload: ((Event) -> dynamic)?\n    override var onloadeddata: ((Event) -> dynamic)?\n    override var onloadedmetadata: ((Event) -> dynamic)?\n    override var onloadend: ((Event) -> dynamic)?\n    override var onloadstart: ((ProgressEvent) -> dynamic)?\n    override var onmousedown: ((MouseEvent) -> dynamic)?\n    override var onmouseenter: ((MouseEvent) -> dynamic)?\n    override var onmouseleave: ((MouseEvent) -> dynamic)?\n    override var onmousemove: ((MouseEvent) -> dynamic)?\n    override var onmouseout: ((MouseEvent) -> dynamic)?\n    override var onmouseover: ((MouseEvent) -> dynamic)?\n    override var onmouseup: ((MouseEvent) -> dynamic)?\n    override var onwheel: ((WheelEvent) -> dynamic)?\n    override var onpause: ((Event) -> dynamic)?\n    override var onplay: ((Event) -> dynamic)?\n    override var onplaying: ((Event) -> dynamic)?\n    override var onprogress: ((ProgressEvent) -> dynamic)?\n    override var onratechange: ((Event) -> dynamic)?\n    override var onreset: ((Event) -> dynamic)?\n    override var onresize: ((Event) -> dynamic)?\n    override var onscroll: ((Event) -> dynamic)?\n    override var onseeked: ((Event) -> dynamic)?\n    override var onseeking: ((Event) -> dynamic)?\n    override var onselect: ((Event) -> dynamic)?\n    override var onshow: ((Event) -> dynamic)?\n    override var onstalled: ((Event) -> dynamic)?\n    override var onsubmit: ((Event) -> dynamic)?\n    override var onsuspend: ((Event) -> dynamic)?\n    override var ontimeupdate: ((Event) -> dynamic)?\n    override var ontoggle: ((Event) -> dynamic)?\n    override var onvolumechange: ((Event) -> dynamic)?\n    override var onwaiting: ((Event) -> dynamic)?\n    override var ongotpointercapture: ((PointerEvent) -> dynamic)?\n    override var onlostpointercapture: ((PointerEvent) -> dynamic)?\n    override var onpointerdown: ((PointerEvent) -> dynamic)?\n    override var onpointermove: ((PointerEvent) -> dynamic)?\n    override var onpointerup: ((PointerEvent) -> dynamic)?\n    override var onpointercancel: ((PointerEvent) -> dynamic)?\n    override var onpointerover: ((PointerEvent) -> dynamic)?\n    override var onpointerout: ((PointerEvent) -> dynamic)?\n    override var onpointerenter: ((PointerEvent) -> dynamic)?\n    override var onpointerleave: ((PointerEvent) -> dynamic)?\n    override var oncopy: ((ClipboardEvent) -> dynamic)?\n    override var oncut: ((ClipboardEvent) -> dynamic)?\n    override var onpaste: ((ClipboardEvent) -> dynamic)?\n    override var contentEditable: String\n    override val isContentEditable: Boolean\n    override val style: CSSStyleDeclaration\n    override val children: HTMLCollection\n    override val firstElementChild: Element?\n    override val lastElementChild: Element?\n    override val childElementCount: Int\n    override val previousElementSibling: Element?\n    override val nextElementSibling: Element?\n    override val assignedSlot: HTMLSlotElement?\n    override fun prepend(vararg nodes: dynamic)\n    override fun append(vararg nodes: dynamic)\n    override fun querySelector(selectors: String): Element?\n    override fun querySelectorAll(selectors: String): NodeList\n    override fun before(vararg nodes: dynamic)\n    override fun after(vararg nodes: dynamic)\n    override fun replaceWith(vararg nodes: dynamic)\n    override fun remove()\n    override fun getBoxQuads(options: BoxQuadOptions /* = definedExternally */): Array<DOMQuad>\n    override fun convertQuadFromNode(quad: dynamic, from: dynamic, options: ConvertCoordinateOptions /* = definedExternally */): DOMQuad\n    override fun convertRectFromNode(rect: DOMRectReadOnly, from: dynamic, options: ConvertCoordinateOptions /* = definedExternally */): DOMQuad\n    override fun convertPointFromNode(point: DOMPointInit, from: dynamic, options: ConvertCoordinateOptions /* = definedExternally */): DOMPoint\n\n    companion object {\n        val NETWORK_EMPTY: Short\n        val NETWORK_IDLE: Short\n        val NETWORK_LOADING: Short\n        val NETWORK_NO_SOURCE: Short\n        val HAVE_NOTHING: Short\n        val HAVE_METADATA: Short\n        val HAVE_CURRENT_DATA: Short\n        val HAVE_FUTURE_DATA: Short\n        val HAVE_ENOUGH_DATA: Short\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [Option](https://developer.mozilla.org/en/docs/Web/API/Option) to Kotlin\n */\npublic external open class Option(text: String = definedExternally, value: String = definedExternally, defaultSelected: Boolean = definedExternally, selected: Boolean = definedExternally) : HTMLOptionElement {\n    override var onabort: ((Event) -> dynamic)?\n    override var onblur: ((FocusEvent) -> dynamic)?\n    override var oncancel: ((Event) -> dynamic)?\n    override var oncanplay: ((Event) -> dynamic)?\n    override var oncanplaythrough: ((Event) -> dynamic)?\n    override var onchange: ((Event) -> dynamic)?\n    override var onclick: ((MouseEvent) -> dynamic)?\n    override var onclose: ((Event) -> dynamic)?\n    override var oncontextmenu: ((MouseEvent) -> dynamic)?\n    override var oncuechange: ((Event) -> dynamic)?\n    override var ondblclick: ((MouseEvent) -> dynamic)?\n    override var ondrag: ((DragEvent) -> dynamic)?\n    override var ondragend: ((DragEvent) -> dynamic)?\n    override var ondragenter: ((DragEvent) -> dynamic)?\n    override var ondragexit: ((DragEvent) -> dynamic)?\n    override var ondragleave: ((DragEvent) -> dynamic)?\n    override var ondragover: ((DragEvent) -> dynamic)?\n    override var ondragstart: ((DragEvent) -> dynamic)?\n    override var ondrop: ((DragEvent) -> dynamic)?\n    override var ondurationchange: ((Event) -> dynamic)?\n    override var onemptied: ((Event) -> dynamic)?\n    override var onended: ((Event) -> dynamic)?\n    override var onerror: ((dynamic, String, Int, Int, Any?) -> dynamic)?\n    override var onfocus: ((FocusEvent) -> dynamic)?\n    override var oninput: ((InputEvent) -> dynamic)?\n    override var oninvalid: ((Event) -> dynamic)?\n    override var onkeydown: ((KeyboardEvent) -> dynamic)?\n    override var onkeypress: ((KeyboardEvent) -> dynamic)?\n    override var onkeyup: ((KeyboardEvent) -> dynamic)?\n    override var onload: ((Event) -> dynamic)?\n    override var onloadeddata: ((Event) -> dynamic)?\n    override var onloadedmetadata: ((Event) -> dynamic)?\n    override var onloadend: ((Event) -> dynamic)?\n    override var onloadstart: ((ProgressEvent) -> dynamic)?\n    override var onmousedown: ((MouseEvent) -> dynamic)?\n    override var onmouseenter: ((MouseEvent) -> dynamic)?\n    override var onmouseleave: ((MouseEvent) -> dynamic)?\n    override var onmousemove: ((MouseEvent) -> dynamic)?\n    override var onmouseout: ((MouseEvent) -> dynamic)?\n    override var onmouseover: ((MouseEvent) -> dynamic)?\n    override var onmouseup: ((MouseEvent) -> dynamic)?\n    override var onwheel: ((WheelEvent) -> dynamic)?\n    override var onpause: ((Event) -> dynamic)?\n    override var onplay: ((Event) -> dynamic)?\n    override var onplaying: ((Event) -> dynamic)?\n    override var onprogress: ((ProgressEvent) -> dynamic)?\n    override var onratechange: ((Event) -> dynamic)?\n    override var onreset: ((Event) -> dynamic)?\n    override var onresize: ((Event) -> dynamic)?\n    override var onscroll: ((Event) -> dynamic)?\n    override var onseeked: ((Event) -> dynamic)?\n    override var onseeking: ((Event) -> dynamic)?\n    override var onselect: ((Event) -> dynamic)?\n    override var onshow: ((Event) -> dynamic)?\n    override var onstalled: ((Event) -> dynamic)?\n    override var onsubmit: ((Event) -> dynamic)?\n    override var onsuspend: ((Event) -> dynamic)?\n    override var ontimeupdate: ((Event) -> dynamic)?\n    override var ontoggle: ((Event) -> dynamic)?\n    override var onvolumechange: ((Event) -> dynamic)?\n    override var onwaiting: ((Event) -> dynamic)?\n    override var ongotpointercapture: ((PointerEvent) -> dynamic)?\n    override var onlostpointercapture: ((PointerEvent) -> dynamic)?\n    override var onpointerdown: ((PointerEvent) -> dynamic)?\n    override var onpointermove: ((PointerEvent) -> dynamic)?\n    override var onpointerup: ((PointerEvent) -> dynamic)?\n    override var onpointercancel: ((PointerEvent) -> dynamic)?\n    override var onpointerover: ((PointerEvent) -> dynamic)?\n    override var onpointerout: ((PointerEvent) -> dynamic)?\n    override var onpointerenter: ((PointerEvent) -> dynamic)?\n    override var onpointerleave: ((PointerEvent) -> dynamic)?\n    override var oncopy: ((ClipboardEvent) -> dynamic)?\n    override var oncut: ((ClipboardEvent) -> dynamic)?\n    override var onpaste: ((ClipboardEvent) -> dynamic)?\n    override var contentEditable: String\n    override val isContentEditable: Boolean\n    override val style: CSSStyleDeclaration\n    override val children: HTMLCollection\n    override val firstElementChild: Element?\n    override val lastElementChild: Element?\n    override val childElementCount: Int\n    override val previousElementSibling: Element?\n    override val nextElementSibling: Element?\n    override val assignedSlot: HTMLSlotElement?\n    override fun prepend(vararg nodes: dynamic)\n    override fun append(vararg nodes: dynamic)\n    override fun querySelector(selectors: String): Element?\n    override fun querySelectorAll(selectors: String): NodeList\n    override fun before(vararg nodes: dynamic)\n    override fun after(vararg nodes: dynamic)\n    override fun replaceWith(vararg nodes: dynamic)\n    override fun remove()\n    override fun getBoxQuads(options: BoxQuadOptions /* = definedExternally */): Array<DOMQuad>\n    override fun convertQuadFromNode(quad: dynamic, from: dynamic, options: ConvertCoordinateOptions /* = definedExternally */): DOMQuad\n    override fun convertRectFromNode(rect: DOMRectReadOnly, from: dynamic, options: ConvertCoordinateOptions /* = definedExternally */): DOMQuad\n    override fun convertPointFromNode(point: DOMPointInit, from: dynamic, options: ConvertCoordinateOptions /* = definedExternally */): DOMPoint\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\npublic external interface UnionElementOrHTMLCollection\n\npublic external interface UnionElementOrRadioNodeList\n\npublic external interface UnionHTMLOptGroupElementOrHTMLOptionElement\n\npublic external interface MediaProvider\n\npublic external interface UnionAudioTrackOrTextTrackOrVideoTrack\n\npublic external interface UnionElementOrMouseEvent\n\npublic external interface RenderingContext\n\npublic external interface HTMLOrSVGImageElement : CanvasImageSource\n\npublic external interface CanvasImageSource : ImageBitmapSource\n\npublic external interface ImageBitmapSource\n\npublic external interface UnionMessagePortOrWindowProxy\n\npublic external interface HTMLOrSVGScriptElement\n\n/* please, don't implement this interface! */\n@Suppress(\"NESTED_CLASS_IN_EXTERNAL_INTERFACE\")\npublic external interface DocumentReadyState {\n    companion object\n}\n\npublic inline val DocumentReadyState.Companion.LOADING: DocumentReadyState get() = \"loading\".asDynamic().unsafeCast<DocumentReadyState>()\n\npublic inline val DocumentReadyState.Companion.INTERACTIVE: DocumentReadyState get() = \"interactive\".asDynamic().unsafeCast<DocumentReadyState>()\n\npublic inline val DocumentReadyState.Companion.COMPLETE: DocumentReadyState get() = \"complete\".asDynamic().unsafeCast<DocumentReadyState>()\n\n/* please, don't implement this interface! */\n@Suppress(\"NESTED_CLASS_IN_EXTERNAL_INTERFACE\")\npublic external interface CanPlayTypeResult {\n    companion object\n}\n\npublic inline val CanPlayTypeResult.Companion.EMPTY: CanPlayTypeResult get() = \"\".asDynamic().unsafeCast<CanPlayTypeResult>()\n\npublic inline val CanPlayTypeResult.Companion.MAYBE: CanPlayTypeResult get() = \"maybe\".asDynamic().unsafeCast<CanPlayTypeResult>()\n\npublic inline val CanPlayTypeResult.Companion.PROBABLY: CanPlayTypeResult get() = \"probably\".asDynamic().unsafeCast<CanPlayTypeResult>()\n\n/* please, don't implement this interface! */\n@Suppress(\"NESTED_CLASS_IN_EXTERNAL_INTERFACE\")\npublic external interface TextTrackMode {\n    companion object\n}\n\npublic inline val TextTrackMode.Companion.DISABLED: TextTrackMode get() = \"disabled\".asDynamic().unsafeCast<TextTrackMode>()\n\npublic inline val TextTrackMode.Companion.HIDDEN: TextTrackMode get() = \"hidden\".asDynamic().unsafeCast<TextTrackMode>()\n\npublic inline val TextTrackMode.Companion.SHOWING: TextTrackMode get() = \"showing\".asDynamic().unsafeCast<TextTrackMode>()\n\n/* please, don't implement this interface! */\n@Suppress(\"NESTED_CLASS_IN_EXTERNAL_INTERFACE\")\npublic external interface TextTrackKind {\n    companion object\n}\n\npublic inline val TextTrackKind.Companion.SUBTITLES: TextTrackKind get() = \"subtitles\".asDynamic().unsafeCast<TextTrackKind>()\n\npublic inline val TextTrackKind.Companion.CAPTIONS: TextTrackKind get() = \"captions\".asDynamic().unsafeCast<TextTrackKind>()\n\npublic inline val TextTrackKind.Companion.DESCRIPTIONS: TextTrackKind get() = \"descriptions\".asDynamic().unsafeCast<TextTrackKind>()\n\npublic inline val TextTrackKind.Companion.CHAPTERS: TextTrackKind get() = \"chapters\".asDynamic().unsafeCast<TextTrackKind>()\n\npublic inline val TextTrackKind.Companion.METADATA: TextTrackKind get() = \"metadata\".asDynamic().unsafeCast<TextTrackKind>()\n\n/* please, don't implement this interface! */\n@Suppress(\"NESTED_CLASS_IN_EXTERNAL_INTERFACE\")\npublic external interface SelectionMode {\n    companion object\n}\n\npublic inline val SelectionMode.Companion.SELECT: SelectionMode get() = \"select\".asDynamic().unsafeCast<SelectionMode>()\n\npublic inline val SelectionMode.Companion.START: SelectionMode get() = \"start\".asDynamic().unsafeCast<SelectionMode>()\n\npublic inline val SelectionMode.Companion.END: SelectionMode get() = \"end\".asDynamic().unsafeCast<SelectionMode>()\n\npublic inline val SelectionMode.Companion.PRESERVE: SelectionMode get() = \"preserve\".asDynamic().unsafeCast<SelectionMode>()\n\n/* please, don't implement this interface! */\n@Suppress(\"NESTED_CLASS_IN_EXTERNAL_INTERFACE\")\npublic external interface CanvasFillRule {\n    companion object\n}\n\npublic inline val CanvasFillRule.Companion.NONZERO: CanvasFillRule get() = \"nonzero\".asDynamic().unsafeCast<CanvasFillRule>()\n\npublic inline val CanvasFillRule.Companion.EVENODD: CanvasFillRule get() = \"evenodd\".asDynamic().unsafeCast<CanvasFillRule>()\n\n/* please, don't implement this interface! */\n@Suppress(\"NESTED_CLASS_IN_EXTERNAL_INTERFACE\")\npublic external interface ImageSmoothingQuality {\n    companion object\n}\n\npublic inline val ImageSmoothingQuality.Companion.LOW: ImageSmoothingQuality get() = \"low\".asDynamic().unsafeCast<ImageSmoothingQuality>()\n\npublic inline val ImageSmoothingQuality.Companion.MEDIUM: ImageSmoothingQuality get() = \"medium\".asDynamic().unsafeCast<ImageSmoothingQuality>()\n\npublic inline val ImageSmoothingQuality.Companion.HIGH: ImageSmoothingQuality get() = \"high\".asDynamic().unsafeCast<ImageSmoothingQuality>()\n\n/* please, don't implement this interface! */\n@Suppress(\"NESTED_CLASS_IN_EXTERNAL_INTERFACE\")\npublic external interface CanvasLineCap {\n    companion object\n}\n\npublic inline val CanvasLineCap.Companion.BUTT: CanvasLineCap get() = \"butt\".asDynamic().unsafeCast<CanvasLineCap>()\n\npublic inline val CanvasLineCap.Companion.ROUND: CanvasLineCap get() = \"round\".asDynamic().unsafeCast<CanvasLineCap>()\n\npublic inline val CanvasLineCap.Companion.SQUARE: CanvasLineCap get() = \"square\".asDynamic().unsafeCast<CanvasLineCap>()\n\n/* please, don't implement this interface! */\n@Suppress(\"NESTED_CLASS_IN_EXTERNAL_INTERFACE\")\npublic external interface CanvasLineJoin {\n    companion object\n}\n\npublic inline val CanvasLineJoin.Companion.ROUND: CanvasLineJoin get() = \"round\".asDynamic().unsafeCast<CanvasLineJoin>()\n\npublic inline val CanvasLineJoin.Companion.BEVEL: CanvasLineJoin get() = \"bevel\".asDynamic().unsafeCast<CanvasLineJoin>()\n\npublic inline val CanvasLineJoin.Companion.MITER: CanvasLineJoin get() = \"miter\".asDynamic().unsafeCast<CanvasLineJoin>()\n\n/* please, don't implement this interface! */\n@Suppress(\"NESTED_CLASS_IN_EXTERNAL_INTERFACE\")\npublic external interface CanvasTextAlign {\n    companion object\n}\n\npublic inline val CanvasTextAlign.Companion.START: CanvasTextAlign get() = \"start\".asDynamic().unsafeCast<CanvasTextAlign>()\n\npublic inline val CanvasTextAlign.Companion.END: CanvasTextAlign get() = \"end\".asDynamic().unsafeCast<CanvasTextAlign>()\n\npublic inline val CanvasTextAlign.Companion.LEFT: CanvasTextAlign get() = \"left\".asDynamic().unsafeCast<CanvasTextAlign>()\n\npublic inline val CanvasTextAlign.Companion.RIGHT: CanvasTextAlign get() = \"right\".asDynamic().unsafeCast<CanvasTextAlign>()\n\npublic inline val CanvasTextAlign.Companion.CENTER: CanvasTextAlign get() = \"center\".asDynamic().unsafeCast<CanvasTextAlign>()\n\n/* please, don't implement this interface! */\n@Suppress(\"NESTED_CLASS_IN_EXTERNAL_INTERFACE\")\npublic external interface CanvasTextBaseline {\n    companion object\n}\n\npublic inline val CanvasTextBaseline.Companion.TOP: CanvasTextBaseline get() = \"top\".asDynamic().unsafeCast<CanvasTextBaseline>()\n\npublic inline val CanvasTextBaseline.Companion.HANGING: CanvasTextBaseline get() = \"hanging\".asDynamic().unsafeCast<CanvasTextBaseline>()\n\npublic inline val CanvasTextBaseline.Companion.MIDDLE: CanvasTextBaseline get() = \"middle\".asDynamic().unsafeCast<CanvasTextBaseline>()\n\npublic inline val CanvasTextBaseline.Companion.ALPHABETIC: CanvasTextBaseline get() = \"alphabetic\".asDynamic().unsafeCast<CanvasTextBaseline>()\n\npublic inline val CanvasTextBaseline.Companion.IDEOGRAPHIC: CanvasTextBaseline get() = \"ideographic\".asDynamic().unsafeCast<CanvasTextBaseline>()\n\npublic inline val CanvasTextBaseline.Companion.BOTTOM: CanvasTextBaseline get() = \"bottom\".asDynamic().unsafeCast<CanvasTextBaseline>()\n\n/* please, don't implement this interface! */\n@Suppress(\"NESTED_CLASS_IN_EXTERNAL_INTERFACE\")\npublic external interface CanvasDirection {\n    companion object\n}\n\npublic inline val CanvasDirection.Companion.LTR: CanvasDirection get() = \"ltr\".asDynamic().unsafeCast<CanvasDirection>()\n\npublic inline val CanvasDirection.Companion.RTL: CanvasDirection get() = \"rtl\".asDynamic().unsafeCast<CanvasDirection>()\n\npublic inline val CanvasDirection.Companion.INHERIT: CanvasDirection get() = \"inherit\".asDynamic().unsafeCast<CanvasDirection>()\n\n/* please, don't implement this interface! */\n@Suppress(\"NESTED_CLASS_IN_EXTERNAL_INTERFACE\")\npublic external interface ScrollRestoration {\n    companion object\n}\n\npublic inline val ScrollRestoration.Companion.AUTO: ScrollRestoration get() = \"auto\".asDynamic().unsafeCast<ScrollRestoration>()\n\npublic inline val ScrollRestoration.Companion.MANUAL: ScrollRestoration get() = \"manual\".asDynamic().unsafeCast<ScrollRestoration>()\n\n/* please, don't implement this interface! */\n@Suppress(\"NESTED_CLASS_IN_EXTERNAL_INTERFACE\")\npublic external interface ImageOrientation {\n    companion object\n}\n\npublic inline val ImageOrientation.Companion.NONE: ImageOrientation get() = \"none\".asDynamic().unsafeCast<ImageOrientation>()\n\npublic inline val ImageOrientation.Companion.FLIPY: ImageOrientation get() = \"flipY\".asDynamic().unsafeCast<ImageOrientation>()\n\n/* please, don't implement this interface! */\n@Suppress(\"NESTED_CLASS_IN_EXTERNAL_INTERFACE\")\npublic external interface PremultiplyAlpha {\n    companion object\n}\n\npublic inline val PremultiplyAlpha.Companion.NONE: PremultiplyAlpha get() = \"none\".asDynamic().unsafeCast<PremultiplyAlpha>()\n\npublic inline val PremultiplyAlpha.Companion.PREMULTIPLY: PremultiplyAlpha get() = \"premultiply\".asDynamic().unsafeCast<PremultiplyAlpha>()\n\npublic inline val PremultiplyAlpha.Companion.DEFAULT: PremultiplyAlpha get() = \"default\".asDynamic().unsafeCast<PremultiplyAlpha>()\n\n/* please, don't implement this interface! */\n@Suppress(\"NESTED_CLASS_IN_EXTERNAL_INTERFACE\")\npublic external interface ColorSpaceConversion {\n    companion object\n}\n\npublic inline val ColorSpaceConversion.Companion.NONE: ColorSpaceConversion get() = \"none\".asDynamic().unsafeCast<ColorSpaceConversion>()\n\npublic inline val ColorSpaceConversion.Companion.DEFAULT: ColorSpaceConversion get() = \"default\".asDynamic().unsafeCast<ColorSpaceConversion>()\n\n/* please, don't implement this interface! */\n@Suppress(\"NESTED_CLASS_IN_EXTERNAL_INTERFACE\")\npublic external interface ResizeQuality {\n    companion object\n}\n\npublic inline val ResizeQuality.Companion.PIXELATED: ResizeQuality get() = \"pixelated\".asDynamic().unsafeCast<ResizeQuality>()\n\npublic inline val ResizeQuality.Companion.LOW: ResizeQuality get() = \"low\".asDynamic().unsafeCast<ResizeQuality>()\n\npublic inline val ResizeQuality.Companion.MEDIUM: ResizeQuality get() = \"medium\".asDynamic().unsafeCast<ResizeQuality>()\n\npublic inline val ResizeQuality.Companion.HIGH: ResizeQuality get() = \"high\".asDynamic().unsafeCast<ResizeQuality>()\n\n/* please, don't implement this interface! */\n@Suppress(\"NESTED_CLASS_IN_EXTERNAL_INTERFACE\")\npublic external interface BinaryType {\n    companion object\n}\n\npublic inline val BinaryType.Companion.BLOB: BinaryType get() = \"blob\".asDynamic().unsafeCast<BinaryType>()\n\npublic inline val BinaryType.Companion.ARRAYBUFFER: BinaryType get() = \"arraybuffer\".asDynamic().unsafeCast<BinaryType>()\n\n/* please, don't implement this interface! */\n@Suppress(\"NESTED_CLASS_IN_EXTERNAL_INTERFACE\")\npublic external interface WorkerType {\n    companion object\n}\n\npublic inline val WorkerType.Companion.CLASSIC: WorkerType get() = \"classic\".asDynamic().unsafeCast<WorkerType>()\n\npublic inline val WorkerType.Companion.MODULE: WorkerType get() = \"module\".asDynamic().unsafeCast<WorkerType>()\n\n/* please, don't implement this interface! */\n@Suppress(\"NESTED_CLASS_IN_EXTERNAL_INTERFACE\")\npublic external interface ShadowRootMode {\n    companion object\n}\n\npublic inline val ShadowRootMode.Companion.OPEN: ShadowRootMode get() = \"open\".asDynamic().unsafeCast<ShadowRootMode>()\n\npublic inline val ShadowRootMode.Companion.CLOSED: ShadowRootMode get() = \"closed\".asDynamic().unsafeCast<ShadowRootMode>()\n\n/* please, don't implement this interface! */\n@Suppress(\"NESTED_CLASS_IN_EXTERNAL_INTERFACE\")\npublic external interface ScrollBehavior {\n    companion object\n}\n\npublic inline val ScrollBehavior.Companion.AUTO: ScrollBehavior get() = \"auto\".asDynamic().unsafeCast<ScrollBehavior>()\n\npublic inline val ScrollBehavior.Companion.INSTANT: ScrollBehavior get() = \"instant\".asDynamic().unsafeCast<ScrollBehavior>()\n\npublic inline val ScrollBehavior.Companion.SMOOTH: ScrollBehavior get() = \"smooth\".asDynamic().unsafeCast<ScrollBehavior>()\n\n/* please, don't implement this interface! */\n@Suppress(\"NESTED_CLASS_IN_EXTERNAL_INTERFACE\")\npublic external interface ScrollLogicalPosition {\n    companion object\n}\n\npublic inline val ScrollLogicalPosition.Companion.START: ScrollLogicalPosition get() = \"start\".asDynamic().unsafeCast<ScrollLogicalPosition>()\n\npublic inline val ScrollLogicalPosition.Companion.CENTER: ScrollLogicalPosition get() = \"center\".asDynamic().unsafeCast<ScrollLogicalPosition>()\n\npublic inline val ScrollLogicalPosition.Companion.END: ScrollLogicalPosition get() = \"end\".asDynamic().unsafeCast<ScrollLogicalPosition>()\n\npublic inline val ScrollLogicalPosition.Companion.NEAREST: ScrollLogicalPosition get() = \"nearest\".asDynamic().unsafeCast<ScrollLogicalPosition>()\n\n/* please, don't implement this interface! */\n@Suppress(\"NESTED_CLASS_IN_EXTERNAL_INTERFACE\")\npublic external interface CSSBoxType {\n    companion object\n}\n\npublic inline val CSSBoxType.Companion.MARGIN: CSSBoxType get() = \"margin\".asDynamic().unsafeCast<CSSBoxType>()\n\npublic inline val CSSBoxType.Companion.BORDER: CSSBoxType get() = \"border\".asDynamic().unsafeCast<CSSBoxType>()\n\npublic inline val CSSBoxType.Companion.PADDING: CSSBoxType get() = \"padding\".asDynamic().unsafeCast<CSSBoxType>()\n\npublic inline val CSSBoxType.Companion.CONTENT: CSSBoxType get() = \"content\".asDynamic().unsafeCast<CSSBoxType>()","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\nimport kotlin.js.RegExp\n\n/**\n * Converts the characters in the specified array to a string.\n */\n@SinceKotlin(\"1.2\")\n@Deprecated(\"Use CharArray.concatToString() instead\", ReplaceWith(\"chars.concatToString()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic actual fun String(chars: CharArray): String {\n    var result = \"\"\n    for (char in chars) {\n        result += char\n    }\n    return result\n}\n\n/**\n * Converts the characters from a portion of the specified array to a string.\n *\n * @throws IndexOutOfBoundsException if either [offset] or [length] are less than zero\n * or `offset + length` is out of [chars] array bounds.\n */\n@SinceKotlin(\"1.2\")\n@Deprecated(\"Use CharArray.concatToString(startIndex, endIndex) instead\", ReplaceWith(\"chars.concatToString(offset, offset + length)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic actual fun String(chars: CharArray, offset: Int, length: Int): String {\n    if (offset < 0 || length < 0 || chars.size - offset < length)\n        throw IndexOutOfBoundsException(\"size: ${chars.size}; offset: $offset; length: $length\")\n    var result = \"\"\n    for (index in offset until offset + length) {\n        result += chars[index]\n    }\n    return result\n}\n\n/**\n * Concatenates characters in this [CharArray] into a String.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun CharArray.concatToString(): String {\n    var result = \"\"\n    for (char in this) {\n        result += char\n    }\n    return result\n}\n\n/**\n * Concatenates characters in this [CharArray] or its subrange into a String.\n *\n * @param startIndex the beginning (inclusive) of the subrange of characters, 0 by default.\n * @param endIndex the end (exclusive) of the subrange of characters, size of this array by default.\n *\n * @throws IndexOutOfBoundsException if [startIndex] is less than zero or [endIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [startIndex] is greater than [endIndex].\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun CharArray.concatToString(startIndex: Int = 0, endIndex: Int = this.size): String {\n    AbstractList.checkBoundsIndexes(startIndex, endIndex, this.size)\n    var result = \"\"\n    for (index in startIndex until endIndex) {\n        result += this[index]\n    }\n    return result\n}\n\n/**\n * Returns a [CharArray] containing characters of this string.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun String.toCharArray(): CharArray {\n    return CharArray(length) { get(it) }\n}\n\n/**\n * Returns a [CharArray] containing characters of this string or its substring.\n *\n * @param startIndex the beginning (inclusive) of the substring, 0 by default.\n * @param endIndex the end (exclusive) of the substring, length of this string by default.\n *\n * @throws IndexOutOfBoundsException if [startIndex] is less than zero or [endIndex] is greater than the length of this string.\n * @throws IllegalArgumentException if [startIndex] is greater than [endIndex].\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.toCharArray(startIndex: Int = 0, endIndex: Int = this.length): CharArray {\n    AbstractList.checkBoundsIndexes(startIndex, endIndex, length)\n    return CharArray(endIndex - startIndex) { get(startIndex + it) }\n}\n\n/**\n * Decodes a string from the bytes in UTF-8 encoding in this array.\n *\n * Malformed byte sequences are replaced by the replacement char `\\uFFFD`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun ByteArray.decodeToString(): String {\n    return decodeUtf8(this, 0, size, false)\n}\n\n/**\n * Decodes a string from the bytes in UTF-8 encoding in this array or its subrange.\n *\n * @param startIndex the beginning (inclusive) of the subrange to decode, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to decode, size of this array by default.\n * @param throwOnInvalidSequence specifies whether to throw an exception on malformed byte sequence or replace it by the replacement char `\\uFFFD`.\n *\n * @throws IndexOutOfBoundsException if [startIndex] is less than zero or [endIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [startIndex] is greater than [endIndex].\n * @throws CharacterCodingException if the byte array contains malformed UTF-8 byte sequence and [throwOnInvalidSequence] is true.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun ByteArray.decodeToString(\n    startIndex: Int = 0,\n    endIndex: Int = this.size,\n    throwOnInvalidSequence: Boolean = false\n): String {\n    AbstractList.checkBoundsIndexes(startIndex, endIndex, this.size)\n    return decodeUtf8(this, startIndex, endIndex, throwOnInvalidSequence)\n}\n\n/**\n * Encodes this string to an array of bytes in UTF-8 encoding.\n *\n * Any malformed char sequence is replaced by the replacement byte sequence.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun String.encodeToByteArray(): ByteArray {\n    return encodeUtf8(this, 0, length, false)\n}\n\n/**\n * Encodes this string or its substring to an array of bytes in UTF-8 encoding.\n *\n * @param startIndex the beginning (inclusive) of the substring to encode, 0 by default.\n * @param endIndex the end (exclusive) of the substring to encode, length of this string by default.\n * @param throwOnInvalidSequence specifies whether to throw an exception on malformed char sequence or replace.\n *\n * @throws IndexOutOfBoundsException if [startIndex] is less than zero or [endIndex] is greater than the length of this string.\n * @throws IllegalArgumentException if [startIndex] is greater than [endIndex].\n * @throws CharacterCodingException if this string contains malformed char sequence and [throwOnInvalidSequence] is true.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.encodeToByteArray(\n    startIndex: Int = 0,\n    endIndex: Int = this.length,\n    throwOnInvalidSequence: Boolean = false\n): ByteArray {\n    AbstractList.checkBoundsIndexes(startIndex, endIndex, length)\n    return encodeUtf8(this, startIndex, endIndex, throwOnInvalidSequence)\n}\n\n/**\n * Returns a copy of this string converted to upper case using the rules of the default locale.\n */\n@Deprecated(\"Use uppercase() instead.\", ReplaceWith(\"uppercase()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\n@kotlin.internal.InlineOnly\npublic actual inline fun String.toUpperCase(): String = asDynamic().toUpperCase()\n\n/**\n * Returns a copy of this string converted to upper case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many and many-to-one character mapping,\n * thus the length of the returned string can be different from the length of the original string.\n *\n * @sample samples.text.Strings.uppercase\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic actual inline fun String.uppercase(): String = asDynamic().toUpperCase()\n\n/**\n * Returns a copy of this string converted to lower case using the rules of the default locale.\n */\n@Deprecated(\"Use lowercase() instead.\", ReplaceWith(\"lowercase()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\n@kotlin.internal.InlineOnly\npublic actual inline fun String.toLowerCase(): String = asDynamic().toLowerCase()\n\n/**\n * Returns a copy of this string converted to lower case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many and many-to-one character mapping,\n * thus the length of the returned string can be different from the length of the original string.\n *\n * @sample samples.text.Strings.lowercase\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic actual inline fun String.lowercase(): String = asDynamic().toLowerCase()\n\n@kotlin.internal.InlineOnly\ninternal actual inline fun String.nativeIndexOf(str: String, fromIndex: Int): Int = asDynamic().indexOf(str, fromIndex)\n\n@kotlin.internal.InlineOnly\ninternal actual inline fun String.nativeLastIndexOf(str: String, fromIndex: Int): Int = asDynamic().lastIndexOf(str, fromIndex)\n\n@kotlin.internal.InlineOnly\ninternal inline fun String.nativeStartsWith(s: String, position: Int): Boolean = asDynamic().startsWith(s, position)\n\n@kotlin.internal.InlineOnly\ninternal inline fun String.nativeEndsWith(s: String): Boolean = asDynamic().endsWith(s)\n\n@kotlin.internal.InlineOnly\npublic actual inline fun String.substring(startIndex: Int): String = asDynamic().substring(startIndex)\n\n@kotlin.internal.InlineOnly\npublic actual inline fun String.substring(startIndex: Int, endIndex: Int): String = asDynamic().substring(startIndex, endIndex)\n\n@kotlin.internal.InlineOnly\npublic inline fun String.concat(str: String): String = asDynamic().concat(str)\n\n@kotlin.internal.InlineOnly\npublic inline fun String.match(regex: String): Array<String>? = asDynamic().match(regex)\n\n//native public fun String.trim(): String\n//TODO: String.replace to implement effective trimLeading and trimTrailing\n\n@kotlin.internal.InlineOnly\ninternal inline fun String.nativeReplace(pattern: RegExp, replacement: String): String = asDynamic().replace(pattern, replacement)\n\n@OptIn(ExperimentalStdlibApi::class)\n@SinceKotlin(\"1.2\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.compareTo(other: String, ignoreCase: Boolean = false): Int {\n    if (ignoreCase) {\n        val n1 = this.length\n        val n2 = other.length\n        val min = minOf(n1, n2)\n        if (min == 0) return n1 - n2\n        var start = 0\n        while (true) {\n            val end = minOf(start + 16, min)\n            var s1 = this.substring(start, end)\n            var s2 = other.substring(start, end)\n            if (s1 != s2) {\n                s1 = s1.uppercase()\n                s2 = s2.uppercase()\n                if (s1 != s2) {\n                    s1 = s1.lowercase()\n                    s2 = s2.lowercase()\n                    if (s1 != s2) {\n                        return s1.compareTo(s2)\n                    }\n                }\n            }\n            if (end == min) break\n            start = end\n        }\n        return n1 - n2\n    } else {\n        return compareTo(other)\n    }\n}\n\n/**\n * Returns `true` if the contents of this char sequence are equal to the contents of the specified [other],\n * i.e. both char sequences contain the same number of the same characters in the same order.\n *\n * @sample samples.text.Strings.contentEquals\n */\n@SinceKotlin(\"1.5\")\npublic actual infix fun CharSequence?.contentEquals(other: CharSequence?): Boolean = contentEqualsImpl(other)\n\n/**\n * Returns `true` if the contents of this char sequence are equal to the contents of the specified [other], optionally ignoring case difference.\n *\n * @param ignoreCase `true` to ignore character case when comparing contents.\n *\n * @sample samples.text.Strings.contentEquals\n */\n@SinceKotlin(\"1.5\")\npublic actual fun CharSequence?.contentEquals(other: CharSequence?, ignoreCase: Boolean): Boolean {\n    return if (ignoreCase)\n        this.contentEqualsIgnoreCaseImpl(other)\n    else\n        this.contentEqualsImpl(other)\n}\n\n\nprivate val STRING_CASE_INSENSITIVE_ORDER = Comparator<String> { a, b -> a.compareTo(b, ignoreCase = true) }\n\n@SinceKotlin(\"1.2\")\npublic actual val String.Companion.CASE_INSENSITIVE_ORDER: Comparator<String>\n    get() = STRING_CASE_INSENSITIVE_ORDER\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(667);\n"],"sourceRoot":""}